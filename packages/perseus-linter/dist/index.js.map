{"version":3,"file":"index.js","sources":["../src/selector.ts","../src/rule.ts","../src/rules/lint-utils.ts","../src/rules/absolute-url.ts","../src/rules/blockquoted-math.ts","../src/rules/blockquoted-widget.ts","../src/rules/double-spacing-after-terminal.ts","../src/rules/extra-content-spacing.ts","../src/rules/heading-level-1.ts","../src/rules/heading-level-skip.ts","../src/rules/heading-sentence-case.ts","../src/rules/heading-title-case.ts","../src/rules/image-alt-text.ts","../src/rules/image-in-table.ts","../src/rules/image-spaces-around-urls.ts","../src/rules/image-widget.ts","../src/rules/link-click-here.ts","../src/rules/long-paragraph.ts","../src/rules/math-adjacent.ts","../src/rules/math-align-extra-break.ts","../src/rules/math-align-linebreaks.ts","../src/rules/math-empty.ts","../src/rules/math-font-size.ts","../src/rules/math-frac.ts","../src/rules/math-nested.ts","../src/rules/math-starts-with-space.ts","../src/rules/math-text-empty.ts","../src/rules/math-without-dollars.ts","../src/rules/nested-lists.ts","../src/rules/profanity.ts","../src/rules/table-missing-cells.ts","../src/rules/unbalanced-code-delimiters.ts","../src/rules/unescaped-dollar.ts","../src/rules/widget-in-table.ts","../src/rules/all-rules.ts","../src/tree-transformer.ts","../src/proptypes.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable no-useless-escape */\n/**\n * The Selector class implements a CSS-like system for matching nodes in a\n * parse tree based on the structure of the tree. Create a Selector object by\n * calling the static Selector.parse() method on a string that describes the\n * tree structure you want to match. For example, if you want to find text\n * nodes that are direct children of paragraph nodes that immediately follow\n * heading nodes, you could create an appropriate selector like this:\n *\n *   selector = Selector.parse(\"heading + paragraph > text\");\n *\n * Recall from the TreeTransformer class, that we consider any object with a\n * string-valued `type` property to be a tree node. The words \"heading\",\n * \"paragraph\" and \"text\" in the selector string above specify node types and\n * will match nodes in a parse tree that have `type` properties with those\n * values.\n *\n * Selectors are designed for use during tree traversals done with the\n * TreeTransformer traverse() method. To test whether the node currently being\n * traversed matches a selector, simply pass the TraversalState object to the\n * match() method of the Selector object. If the node does not match the\n * selector, match() returns null. If it does match, then match() returns an\n * array of nodes that match the selector. In the example above the first\n * element of the array would be the node the heading node, the second would\n * be the paragraph node that follows it, and the third would be the text node\n * that is a child of the paragraph.  The last element of a returned array of\n * nodes is always equal to the current node of the tree traversal.\n *\n * Code that uses a selector might look like this:\n *\n *   matchingNodes = selector.match(state);\n *   if (matchingNodes) {\n *       let heading = matchingNodes[0];\n *       let text = matchingNodes[2];\n *       // do something with those nodes\n *   }\n *\n * The Selector.parse() method recognizes a grammar that is similar to CSS\n * selectors:\n *\n * selector := treeSelector (, treeSelector)*\n *\n *    A selector is one or more comma-separated treeSelectors. A node matches\n *    the selector if it matches any of the treeSelectors.\n *\n * treeSelector := (treeSelector combinator)? nodeSelector\n *\n *    A treeSelector is a nodeSelector optionally preceeded by a combinator\n *    and another tree selector. The tree selector matches if the current node\n *    matches the node selector and a sibling or ancestor (depending on the\n *    combinator) of the current node matches the optional treeSelector.\n *\n * combinator := ' ' | '>' | '+' | '~'   // standard CSS3 combinators\n *\n *    A combinator is a space or punctuation character that specifies the\n *    relationship between two nodeSelectors. A space between two\n *    nodeSelectors means that the first selector much match an ancestor of\n *    the node that matches the second selector. A '>' character means that\n *    the first selector must match the parent of the node matched by the\n *    second. The '~' combinator means that the first selector must match a\n *    previous sibling of the node matched by the second. And the '+' selector\n *    means that first selector must match the immediate previous sibling of\n *    the node that matched the second.\n *\n * nodeSelector := <IDENTIFIER> | '*'\n *\n *    A nodeSelector is simply an identifier (a letter followed by any number\n *    of letters, digits, hypens, and underscores) or the wildcard asterisk\n *    character. A wildcard node selector matches any node. An identifier\n *    selector matches any node that has a `type` property whose value matches\n *    the identifier.\n *\n * If you call Selector.parse() on a string that does not match this grammar,\n * it will throw an exception\n *\n * TODO(davidflanagan): it might be useful to allow more sophsticated node\n * selector matching with attribute matches and pseudo-classes, like\n * \"heading[level=2]\" or \"paragraph:first-child\"\n *\n * Implementation Note: this file exports a very simple Selector class but all\n * the actual work is done in various internal classes. The Parser class\n * parses the string representation of a selector into a parse tree that\n * consists of instances of various subclasses of the Selector class. It is\n * these subclasses that implement the selector matching logic, often\n * depending on features of the TraversalState object from the TreeTransformer\n * traversal.\n */\n\nimport {Errors, PerseusError} from \"@khanacademy/perseus-error\";\n\nimport type {TreeNode, TraversalState} from \"./tree-transformer\";\n\n/**\n * This is the base class for all Selector types. The key method that all\n * selector subclasses must implement is match(). It takes a TraversalState\n * object (from a TreeTransformer traversal) and tests whether the selector\n * matches at the current node. See the comment at the start of this file for\n * more details on the match() method.\n */\nexport default class Selector {\n    static parse(selectorText: string): Selector {\n        return new Parser(selectorText).parse();\n    }\n\n    /**\n     * Return an array of the nodes that matched or null if no match.\n     * This is the base class so we just throw an exception. All Selector\n     * subclasses must provide an implementation of this method.\n     */\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        throw new PerseusError(\n            \"Selector subclasses must implement match()\",\n            Errors.NotAllowed,\n        );\n    }\n\n    /**\n     * Selector subclasses all define a toString() method primarily\n     * because it makes it easy to write parser tests.\n     */\n    toString(): string {\n        return \"Unknown selector class\";\n    }\n}\n\n/**\n * This class implements a parser for the selector grammar. Pass the source\n * text to the Parser() constructor, and then call the parse() method to\n * obtain a corresponding Selector object. parse() throws an exception\n * if there are syntax errors in the selector.\n *\n * This class is not exported, and you don't need to use it directly.\n * Instead call the static Selector.parse() method.\n */\nclass Parser {\n    static TOKENS: RegExp; // We do lexing with a simple regular expression\n    tokens: ReadonlyArray<string>; // The array of tokens\n    tokenIndex: number; // Which token in the array we're looking at now\n\n    constructor(s: string) {\n        // Normalize whitespace:\n        // - remove leading and trailing whitespace\n        // - replace runs of whitespace with single space characters\n        s = s.trim().replace(/\\s+/g, \" \");\n        // Convert the string to an array of tokens. Note that the TOKENS\n        // pattern ignores spaces that do not appear before identifiers\n        // or the * wildcard.\n        this.tokens = s.match(Parser.TOKENS) || [];\n        this.tokenIndex = 0;\n    }\n\n    // Return the next token or the empty string if there are no more\n    nextToken(): string {\n        return this.tokens[this.tokenIndex] || \"\";\n    }\n\n    // Increment the token index to \"consume\" the token we were looking at\n    // and move on to the next one.\n    consume(): void {\n        this.tokenIndex++;\n    }\n\n    // Return true if the current token is an identifier or false otherwise\n    isIdentifier(): boolean {\n        // The Parser.TOKENS regexp ensures that we only have to check\n        // the first character of a token to know what kind of token it is.\n        const c = this.tokens[this.tokenIndex][0];\n        return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n    }\n\n    // Consume space tokens until the next token is not a space.\n    skipSpace(): void {\n        while (this.nextToken() === \" \") {\n            this.consume();\n        }\n    }\n\n    // Parse a comma-separated sequence of tree selectors. This is the\n    // entry point for the Parser class and the only method that clients\n    // ever need to call.\n    parse(): Selector {\n        // We expect at least one tree selector\n        const ts = this.parseTreeSelector();\n\n        // Now see what's next\n        let token = this.nextToken();\n\n        // If there is no next token then we're done parsing and can return\n        // the tree selector object we got above\n        if (!token) {\n            return ts;\n        }\n\n        // Otherwise, there is more go come and we're going to need a\n        // list of tree selectors\n        const treeSelectors = [ts];\n        while (token) {\n            // The only character we allow after a tree selector is a comma\n            if (token === \",\") {\n                this.consume();\n            } else {\n                throw new ParseError(\"Expected comma\");\n            }\n\n            // And if we saw a comma, then it must be followed by another\n            // tree selector\n            treeSelectors.push(this.parseTreeSelector());\n            token = this.nextToken();\n        }\n\n        // If we parsed more than one tree selector, return them in a\n        // SelectorList object.\n        return new SelectorList(treeSelectors);\n    }\n\n    // Parse a sequence of node selectors linked together with\n    // hierarchy combinators: space, >, + and ~.\n    parseTreeSelector(): Selector {\n        this.skipSpace(); // Ignore space after a comma, for example\n\n        // A tree selector must begin with a node selector\n        let ns: Selector = this.parseNodeSelector();\n\n        for (;;) {\n            // Now check the next token. If there is none, or if it is a\n            // comma, then we're done with the treeSelector. Otherwise\n            // we expect a combinator followed by another node selector.\n            // If we don't see a combinator, we throw an error. If we\n            // do see a combinator and another node selector then we\n            // combine the current node selector with the new node selector\n            // using a Selector subclass that depends on the combinator.\n            const token = this.nextToken();\n\n            if (!token || token === \",\") {\n                break;\n            } else if (token === \" \") {\n                this.consume();\n                ns = new AncestorCombinator(ns, this.parseNodeSelector());\n            } else if (token === \">\") {\n                this.consume();\n                ns = new ParentCombinator(ns, this.parseNodeSelector());\n            } else if (token === \"+\") {\n                this.consume();\n                ns = new PreviousCombinator(ns, this.parseNodeSelector());\n            } else if (token === \"~\") {\n                this.consume();\n                ns = new SiblingCombinator(ns, this.parseNodeSelector());\n            } else {\n                throw new ParseError(\"Unexpected token: \" + token);\n            }\n        }\n\n        return ns;\n    }\n\n    // Parse a single node selector.\n    // For now, this is just a node type or a wildcard.\n    //\n    // TODO(davidflanagan): we may need to extend this with attribute\n    // selectors like 'heading[level=3]', or with pseudo-classes like\n    // paragraph:first-child\n    parseNodeSelector(): Selector {\n        // First, skip any whitespace\n        this.skipSpace();\n\n        const t = this.nextToken();\n        if (t === \"*\") {\n            this.consume();\n            return new AnyNode();\n        }\n        if (this.isIdentifier()) {\n            this.consume();\n            return new TypeSelector(t);\n        }\n\n        throw new ParseError(\"Expected node type\");\n    }\n}\n\n// We break the input string into tokens with this regexp. Token types\n// are identifiers, integers, punctuation and spaces. Note that spaces\n// tokens are only returned when they appear before an identifier or\n// wildcard token and are otherwise omitted.\nParser.TOKENS = /([a-zA-Z][\\w-]*)|(\\d+)|[^\\s]|(\\s(?=[a-zA-Z\\*]))/g;\n\n/**\n * This is a trivial Error subclass that the Parser uses to signal parse errors\n */\nclass ParseError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\n/**\n * This Selector subclass is a list of selectors. It matches a node if any of\n * the selectors on the list matches the node. It considers the selectors in\n * order, and returns the array of nodes returned by whichever one matches\n * first.\n */\nclass SelectorList extends Selector {\n    selectors: ReadonlyArray<Selector>;\n\n    constructor(selectors: ReadonlyArray<Selector>) {\n        super();\n        this.selectors = selectors;\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        for (let i = 0; i < this.selectors.length; i++) {\n            const s = this.selectors[i];\n            const result = s.match(state);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    toString(): string {\n        let result = \"\";\n        for (let i = 0; i < this.selectors.length; i++) {\n            result += i > 0 ? \", \" : \"\";\n            result += this.selectors[i].toString();\n        }\n        return result;\n    }\n}\n\n/**\n * This trivial Selector subclass implements the '*' wildcard and\n * matches any node.\n */\nclass AnyNode extends Selector {\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        return [state.currentNode()];\n    }\n\n    toString(): string {\n        return \"*\";\n    }\n}\n\n/**\n * This selector subclass implements the <IDENTIFIER> part of the grammar.\n * it matches any node whose `type` property is a specified string\n */\nclass TypeSelector extends Selector {\n    type: string;\n\n    constructor(type: string) {\n        super();\n        this.type = type;\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        const node = state.currentNode();\n        if (node.type === this.type) {\n            return [node];\n        }\n        return null;\n    }\n\n    toString(): string {\n        return this.type;\n    }\n}\n\n/**\n * This selector subclass is the superclass of the classes that implement\n * matching for the four combinators. It defines left and right properties for\n * the two selectors that are to be combined, but does not define a match\n * method.\n */\nclass SelectorCombinator extends Selector {\n    left: Selector;\n    right: Selector;\n\n    constructor(left: Selector, right: Selector) {\n        super();\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * This Selector subclass implements the space combinator. It matches if the\n * right selector matches the current node and the left selector matches some\n * ancestor of the current node.\n */\nclass AncestorCombinator extends SelectorCombinator {\n    constructor(left: Selector, right: Selector) {\n        super(left, right);\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        const rightResult = this.right.match(state);\n        if (rightResult) {\n            state = state.clone();\n            while (state.hasParent()) {\n                state.goToParent();\n                const leftResult = this.left.match(state);\n                if (leftResult) {\n                    return leftResult.concat(rightResult);\n                }\n            }\n        }\n        return null;\n    }\n\n    toString(): string {\n        return this.left.toString() + \" \" + this.right.toString();\n    }\n}\n\n/**\n * This Selector subclass implements the > combinator. It matches if the\n * right selector matches the current node and the left selector matches\n * the parent of the current node.\n */\nclass ParentCombinator extends SelectorCombinator {\n    constructor(left: Selector, right: Selector) {\n        super(left, right);\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        const rightResult = this.right.match(state);\n        if (rightResult) {\n            if (state.hasParent()) {\n                state = state.clone();\n                state.goToParent();\n                const leftResult = this.left.match(state);\n                if (leftResult) {\n                    return leftResult.concat(rightResult);\n                }\n            }\n        }\n        return null;\n    }\n\n    toString(): string {\n        return this.left.toString() + \" > \" + this.right.toString();\n    }\n}\n\n/**\n * This Selector subclass implements the + combinator. It matches if the\n * right selector matches the current node and the left selector matches\n * the immediate previous sibling of the current node.\n */\nclass PreviousCombinator extends SelectorCombinator {\n    constructor(left: Selector, right: Selector) {\n        super(left, right);\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        const rightResult = this.right.match(state);\n        if (rightResult) {\n            if (state.hasPreviousSibling()) {\n                state = state.clone();\n                state.goToPreviousSibling();\n                const leftResult = this.left.match(state);\n                if (leftResult) {\n                    return leftResult.concat(rightResult);\n                }\n            }\n        }\n        return null;\n    }\n\n    toString(): string {\n        return this.left.toString() + \" + \" + this.right.toString();\n    }\n}\n\n/**\n * This Selector subclass implements the ~ combinator. It matches if the\n * right selector matches the current node and the left selector matches\n * any previous sibling of the current node.\n */\nclass SiblingCombinator extends SelectorCombinator {\n    constructor(left: Selector, right: Selector) {\n        super(left, right);\n    }\n\n    match(state: TraversalState): ReadonlyArray<TreeNode> | null | undefined {\n        const rightResult = this.right.match(state);\n        if (rightResult) {\n            state = state.clone();\n            while (state.hasPreviousSibling()) {\n                state.goToPreviousSibling();\n                const leftResult = this.left.match(state);\n                if (leftResult) {\n                    return leftResult.concat(rightResult);\n                }\n            }\n        }\n        return null;\n    }\n\n    toString(): string {\n        return this.left.toString() + \" ~ \" + this.right.toString();\n    }\n}\n","/**\n * The Rule class represents a Perseus lint rule. A Rule instance has a check()\n * method that takes the same (node, state, content) arguments that a\n * TreeTransformer traversal callback function does. Call the check() method\n * during a tree traversal to determine whether the current node of the tree\n * violates the rule. If there is no violation, then check() returns\n * null. Otherwise, it returns an object that includes the name of the rule,\n * an error message, and the start and end positions within the node's content\n * string of the lint.\n *\n * A Perseus lint rule consists of a name, a severity, a selector, a pattern\n * (RegExp) and two functions. The check() method uses the selector, pattern,\n * and functions as follows:\n *\n * - First, when determining which rules to apply to a particular piece of\n *   content, each rule can specify an optional function provided in the fifth\n *   parameter to evaluate whether or not we should be applying this rule.\n *   If the function returns false, we don't use the rule on this content.\n *\n * - Next, check() tests whether the node currently being traversed matches\n *   the selector. If it does not, then the rule does not apply at this node\n *   and there is no lint and check() returns null.\n *\n * - If the selector matched, then check() tests the text content of the node\n *   (and its children) against the pattern. If the pattern does not match,\n *   then there is no lint, and check() returns null.\n *\n * - If both the selector and pattern match, then check() calls the function\n *   passing the TraversalState object, the content string for the node, the\n *   array of nodes returned by the selector match, and the array of strings\n *   returned by the pattern match. This function can use these arguments to\n *   implement any kind of lint detection logic it wants. If it determines\n *   that there is no lint, then it should return null. Otherwise, it should\n *   return an error message as a string, or an object with `message`, `start`\n *   and `end` properties. The start and end properties are numbers that mark\n *   the beginning and end of the problematic content. Note that these numbers\n *   are relative to the content string passed to the traversal callback, not\n *   to the entire string that was used to generate the parse tree in the\n *   first place. TODO(davidflanagan): modify the simple-markdown library to\n *   have an option to add the text offset of each node to the parse\n *   tree. This will allows us to pinpoint lint errors within a long string\n *   of markdown text.\n *\n * - If the function returns null, then check() returns null. Otherwise,\n *   check() returns an object with `rule`, `message`, `start` and `end`\n *   properties. The value of the `rule` property is the name of the rule,\n *   which is useful for error reporting purposes.\n *\n * The name, severity, selector, pattern and function arguments to the Rule()\n * constructor are optional, but you may not omit both the selector and the\n * pattern. If you do not specify a selector, a default selector that matches\n * any node of type \"text\" will be used. If you do not specify a pattern, then\n * any node that matches the selector will be assumed to match the pattern as\n * well. If you don't pass a function as the fourth argument to the Rule()\n * constructor, then you must pass an error message string instead. If you do\n * this, you'll get a default function that unconditionally returns an object\n * that includes the error message and the start and end indexes of the\n * portion of the content string that matched the pattern. If you don't pass a\n * function in the fifth parameter, the rule will be applied in any context.\n *\n * One of the design goals of this Rule class is to allow simple lint rules to\n * be described in JSON files without any JavaScript code. So in addition to\n * the Rule() constructor, the class also defines a Rule.makeRule() factory\n * method. This method takes a single object as its argument and expects the\n * object to have four string properties. The `name` property is passed as the\n * first argument to the Rule() construtctor.  The optional `selector`\n * property, if specified, is passed to Selector.parse() and the resulting\n * Selector object is used as the second argument to Rule().  The optional\n * `pattern` property is converted to a RegExp before being passed as the\n * third argument to Rule(). (See Rule.makePattern() for details on the string\n * to RegExp conversion). Finally, the `message` property specifies an error\n * message that is passed as the final argument to Rule(). You can also use a\n * real RegExp as the value of the `pattern` property or define a custom lint\n * function on the `lint` property instead of setting the `message`\n * property. Doing either of these things means that your rule description can\n * no longer be saved in a JSON file, however.\n *\n * For example, here are two lint rules defined with Rule.makeRule():\n *\n *    let nestedLists = Rule.makeRule({\n *        name: \"nested-lists\",\n *        selector: \"list list\",\n *        message: `Nested lists:\n *    nested lists are hard to read on mobile devices;\n *    do not use additional indentation.`,\n *    });\n *\n *    let longParagraph = Rule.makeRule({\n *        name: \"long-paragraph\",\n *        selector: \"paragraph\",\n *        pattern: /^.{501,}/,\n *        lint: function(state, content, nodes, match) {\n *            return `Paragraph too long:\n *    This paragraph is ${content.length} characters long.\n *    Shorten it to 500 characters or fewer.`;\n *        },\n *    });\n *\n * Certain advanced lint rules need additional information about the content\n * being linted in order to detect lint. For example, a rule to check for\n * whitespace at the start and end of the URL for an image can't use the\n * information in the node or content arguments because the markdown parser\n * strips leading and trailing whitespace when parsing. (Nevertheless, these\n * spaces have been a practical problem for our content translation process so\n * in order to check for them, a lint rule needs access to the original\n * unparsed source text. Similarly, there are various lint rules that check\n * widget usage. For example, it is easy to write a lint rule to ensure that\n * images have alt text for images encoded in markdown. But when images are\n * added to our content via an image widget we also want to be able to check\n * for alt text. In order to do this, the lint rule needs to be able to look\n * widgets up by name in the widgets object associated with the parse tree.\n *\n * In order to support advanced linting rules like these, the check() method\n * takes a context object as its optional fourth argument, and passes this\n * object on to the lint function of each rule. Rules that require extra\n * context should not assume that they will always get it, and should verify\n * that the necessary context has been supplied before using it. Currently the\n * \"content\" property of the context object is the unparsed source text if\n * available, and the \"widgets\" property of the context object is the widget\n * object associated with that content string in the JSON object that defines\n * the Perseus article or exercise that is being linted.\n */\n\nimport {Errors, PerseusError} from \"@khanacademy/perseus-error\";\n\nimport Selector from \"./selector\";\n\nimport type {TraversalState, TreeNode} from \"./tree-transformer\";\n\n// This represents the type returned by String.match(). It is an\n// array of strings, but also has index:number and input:string properties.\n// TypeScript doesn't handle it well, so we punt and just use any.\nexport type PatternMatchType = any;\n\n// This is the return type of the check() method of a Rule object\nexport type RuleCheckReturnType =\n    | {\n          rule: string;\n          message: string;\n          start: number;\n          end: number;\n          severity?: number;\n      }\n    | null\n    | undefined;\n\n// This is the return type of the lint detection function passed as the 4th\n// argument to the Rule() constructor. It can return null or a string or an\n// object containing a string and two numbers.\n// prettier-ignore\n// (prettier formats this in a way that ka-lint does not like)\nexport type LintTesterReturnType = string | {\n    message: string,\n    start: number,\n    end: number\n} | null | undefined;\n\nexport type LintRuleContextObject = any | null | undefined;\n\n// This is the type of the lint detection function that the Rule() constructor\n// expects as its fourth argument. It is passed the TraversalState object and\n// content string that were passed to check(), and is also passed the array of\n// nodes returned by the selector match and the array of strings returned by\n// the pattern match. It should return null if no lint is detected or an\n// error message or an object contining an error message.\nexport type LintTester = (\n    state: TraversalState,\n    content: string,\n    selectorMatch: ReadonlyArray<TreeNode>,\n    patternMatch: PatternMatchType,\n    context: LintRuleContextObject,\n) => LintTesterReturnType;\n\n// An optional check to verify whether or not a particular rule should\n// be checked by context. For example, some rules only apply in exercises,\n// and should never be applied to articles. Defaults to true, so if we\n// omit the applies function in a rule, it'll be tested everywhere.\nexport type AppliesTester = (context: LintRuleContextObject) => boolean;\n\n/**\n * A Rule object describes a Perseus lint rule. See the comment at the top of\n * this file for detailed description.\n */\nexport default class Rule {\n    name: string; // The name of the rule\n    severity: number; // The severity of the rule\n    selector: Selector; // The specified selector or the DEFAULT_SELECTOR\n    pattern: RegExp | null | undefined; // A regular expression if one was specified\n    lint: LintTester; // The lint-testing function or a default\n    applies: AppliesTester; // Checks to see if we should apply a rule or not\n    message: string | null | undefined; // The error message for use with the default function\n    static DEFAULT_SELECTOR: Selector;\n\n    // The comment at the top of this file has detailed docs for\n    // this constructor and its arguments\n    constructor(\n        name: string | null | undefined,\n        severity: number | null | undefined,\n        selector: Selector | null | undefined,\n        pattern: RegExp | null | undefined,\n        lint: LintTester | string,\n        applies: AppliesTester,\n    ) {\n        if (!selector && !pattern) {\n            throw new PerseusError(\n                \"Lint rules must have a selector or pattern\",\n                Errors.InvalidInput,\n                {metadata: {name}},\n            );\n        }\n\n        this.name = name || \"unnamed rule\";\n        this.severity = severity || Rule.Severity.BULK_WARNING;\n        this.selector = selector || Rule.DEFAULT_SELECTOR;\n        this.pattern = pattern || null;\n\n        // If we're called with an error message instead of a function then\n        // use a default function that will return the message.\n        if (typeof lint === \"function\") {\n            this.lint = lint;\n            this.message = null;\n        } else {\n            this.lint = (...args) => this._defaultLintFunction(...args);\n            this.message = lint;\n        }\n\n        this.applies =\n            applies ||\n            function () {\n                return true;\n            };\n    }\n\n    // A factory method for use with rules described in JSON files\n    // See the documentation at the start of this file for details.\n    static makeRule(options: any): Rule {\n        return new Rule(\n            options.name,\n            options.severity,\n            options.selector ? Selector.parse(options.selector) : null,\n            Rule.makePattern(options.pattern),\n            options.lint || options.message,\n            options.applies,\n        );\n    }\n\n    // Check the node n to see if it violates this lint rule.  A return value\n    // of false means there is no lint.  A returned object indicates a lint\n    // error. See the documentation at the top of this file for details.\n    check(\n        node: TreeNode,\n        traversalState: TraversalState,\n        content: string,\n        context: LintRuleContextObject,\n    ): RuleCheckReturnType {\n        // First, see if we match the selector.\n        // If no selector was passed to the constructor, we use a\n        // default selector that matches text nodes.\n        const selectorMatch = this.selector.match(traversalState);\n\n        // If the selector did not match, then we're done\n        if (!selectorMatch) {\n            return null;\n        }\n\n        // If the selector matched, then see if the pattern matches\n        let patternMatch;\n        if (this.pattern) {\n            patternMatch = content.match(this.pattern);\n        } else {\n            // If there is no pattern, then just match all of the content.\n            // Use a fake RegExp match object to represent this default match.\n            patternMatch = Rule.FakePatternMatch(content, content, 0);\n        }\n\n        // If there was a pattern and it didn't match, then we're done\n        if (!patternMatch) {\n            return null;\n        }\n\n        try {\n            // If we get here, then the selector and pattern have matched\n            // so now we call the lint function to see if there is lint.\n            const error = this.lint(\n                traversalState,\n                content,\n                selectorMatch,\n                patternMatch,\n                context,\n            );\n\n            if (!error) {\n                return null; // No lint; we're done\n            }\n            if (typeof error === \"string\") {\n                // If the lint function returned a string we assume it\n                // applies to the entire content of the node and return it.\n                return {\n                    rule: this.name,\n                    severity: this.severity,\n                    message: error,\n                    start: 0,\n                    end: content.length,\n                };\n            }\n            // If the lint function returned an object, then we just\n            // add the rule name to the message, start and end.\n            return {\n                rule: this.name,\n                severity: this.severity,\n                message: error.message,\n                start: error.start,\n                end: error.end,\n            };\n        } catch (e: any) {\n            // If the lint function threw an exception we handle that as\n            // a special type of lint. We want the user to see the lint\n            // warning in this case (even though it is out of their control)\n            // so that the bug gets reported. Otherwise we'd never know that\n            // a rule was failing.\n            return {\n                rule: \"lint-rule-failure\",\n                message: `Exception in rule ${this.name}: ${e.message}\nStack trace:\n${e.stack}`,\n                start: 0,\n                end: content.length,\n            };\n        }\n    }\n\n    // This internal method is the default lint function that we use when a\n    // rule is defined without a function. This is useful for rules where the\n    // selector and/or pattern match are enough to indicate lint. This\n    // function unconditionally returns the error message that was passed in\n    // place of a function, but also adds start and end properties that\n    // specify which particular portion of the node content matched the\n    // pattern.\n    _defaultLintFunction(\n        state: TraversalState,\n        content: string,\n        selectorMatch: ReadonlyArray<TreeNode>,\n        patternMatch: PatternMatchType,\n        context: LintRuleContextObject,\n    ): {\n        end: number;\n        message: string;\n        start: number;\n    } {\n        return {\n            message: this.message || \"\",\n            start: patternMatch.index,\n            end: patternMatch.index + patternMatch[0].length,\n        };\n    }\n\n    // The makeRule() factory function uses this static method to turn its\n    // argument into a RegExp. If the argument is already a RegExp, we just\n    // return it. Otherwise, we compile it into a RegExp and return that.\n    // The reason this is necessary is that Rule.makeRule() is designed for\n    // use with data from JSON files and JSON files can't include RegExp\n    // literals. Strings passed to this function do not need to be delimited\n    // with / characters unless you want to include flags for the RegExp.\n    //\n    // Examples:\n    //\n    //   input \"\"        ==> output null\n    //   input /foo/     ==> output /foo/\n    //   input \"foo\"     ==> output /foo/\n    //   input \"/foo/i\"  ==> output /foo/i\n    //\n    static makePattern(\n        pattern?: RegExp | string | null,\n    ): RegExp | null | undefined {\n        if (!pattern) {\n            return null;\n        }\n        if (pattern instanceof RegExp) {\n            return pattern;\n        }\n        if (pattern[0] === \"/\") {\n            const lastSlash = pattern.lastIndexOf(\"/\");\n            const expression = pattern.substring(1, lastSlash);\n            const flags = pattern.substring(lastSlash + 1);\n            // @ts-expect-error [FEI-5003] - TS2713 - Cannot access 'RegExp.flags' because 'RegExp' is a type, but not a namespace. Did you mean to retrieve the type of the property 'flags' in 'RegExp' with 'RegExp[\"flags\"]'?\n            return new RegExp(expression, flags as RegExp.flags);\n        }\n        return new RegExp(pattern);\n    }\n\n    // This static method returns an string array with index and input\n    // properties added, in order to simulate the return value of the\n    // String.match() method. We use it when a Rule has no pattern and we\n    // want to simulate a match on the entire content string.\n    static FakePatternMatch(\n        input: string,\n        match: string | null | undefined,\n        index: number,\n    ): PatternMatchType {\n        const result: any = [match];\n        result.index = index;\n        result.input = input;\n        return result;\n    }\n\n    static Severity: {\n        BULK_WARNING: number;\n        ERROR: number;\n        GUIDELINE: number;\n        WARNING: number;\n    } = {\n        ERROR: 1,\n        WARNING: 2,\n        GUIDELINE: 3,\n        BULK_WARNING: 4,\n    };\n}\n\nRule.DEFAULT_SELECTOR = Selector.parse(\"text\");\n","/* eslint-disable no-useless-escape */\n// Return the portion of a URL between // and /. This is the authority\n// portion which is usually just the hostname, but may also include\n// a username, password or port. We don't strip those things out because\n// we typically want to reject any URL that includes them\nconst HOSTNAME = /\\/\\/([^\\/]+)/;\n\n// Return the hostname of the URL, with any \"www.\" prefix removed.\n// If this is a relative URL with no hostname, return an empty string.\nexport function getHostname(url: string): string {\n    if (!url) {\n        return \"\";\n    }\n    const match = url.match(HOSTNAME);\n    return match ? match[1] : \"\";\n}\n\n// This list of domains that count as internal domains is from\n// webapp/content/models.py and webapp/url_util.py\nconst internalDomains = {\n    \"khanacademy.org\": true,\n    \"www.khanacademy.org\": true,\n    \"kasandbox.org\": true,\n    \"fastly.kastatic.org\": true,\n    \"cdn.kastatic.org\": true, // This isn't a link to cdn.kastatic.org\n    \"ka-youtube-converted.storage.googleapis.com\": true,\n    \"KA-share.s3.amazonaws.com\": true,\n    \"ka-article-iframes.s3.amazonaws.com\": true,\n    \"ka-cs-algorithms.s3.amazonaws.com\": true,\n    \"ka-cs-challenge-images.s3.amazonaws.com\": true,\n    \"ka-cs-scratchpad-audio.s3.amazonaws.com\": true,\n    \"ka-exercise-screenshots.s3.amazonaws.com\": true,\n    \"ka-exercise-screenshots-2.s3.amazonaws.com\": true,\n    \"ka-exercise-screenshots-3.s3.amazonaws.com\": true,\n    \"ka-learnstorm.s3.amazonaws.com\": true,\n    \"ka-mobile.s3.amazonaws.com\": true,\n    \"ka-perseus-graphie.s3.amazonaws.com\": true,\n    \"ka-perseus-images.s3.amazonaws.com\": true,\n} as const;\n\n// Returns true if this URL is relative, or if it is an absolute\n// URL with one of the domains listed above as its hostname.\nexport function isInternalURL(url: string): boolean {\n    const hostname = getHostname(url);\n    // eslint-disable-next-line no-prototype-builtins\n    return hostname === \"\" || internalDomains.hasOwnProperty(hostname);\n}\n","import Rule from \"../rule\";\n\nimport {getHostname} from \"./lint-utils\";\n\nexport default Rule.makeRule({\n    name: \"absolute-url\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"link, image\",\n    lint: function (state, content, nodes, match) {\n        const url = nodes[0].target;\n        const hostname = getHostname(url);\n\n        if (\n            hostname === \"khanacademy.org\" ||\n            hostname.endsWith(\".khanacademy.org\")\n        ) {\n            return `Don't use absolute URLs:\nWhen linking to KA content or images, omit the\nhttps://www.khanacademy.org URL prefix.\nUse a relative URL beginning with / instead.`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"blockquoted-math\",\n    severity: Rule.Severity.WARNING,\n    selector: \"blockQuote math, blockQuote blockMath\",\n    message: `Blockquoted math:\nmath should not be indented.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"blockquoted-widget\",\n    severity: Rule.Severity.WARNING,\n    selector: \"blockQuote widget\",\n    message: `Blockquoted widget:\nwidgets should not be indented.`,\n}) as Rule;\n","/* eslint-disable no-useless-escape */\nimport Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"double-spacing-after-terminal\",\n    severity: Rule.Severity.BULK_WARNING,\n    selector: \"paragraph\",\n    pattern: /[.!\\?] {2}/i,\n    message: `Use a single space after a sentence-ending period, or\nany other kind of terminal punctuation.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"extra-content-spacing\",\n    selector: \"paragraph\",\n    pattern: /\\s+$/,\n    applies: function (context) {\n        return context.contentType === \"article\";\n    },\n    message: `No extra whitespace at the end of content blocks.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"heading-level-1\",\n    severity: Rule.Severity.WARNING,\n    selector: \"heading\",\n    lint: function (state, content, nodes, match) {\n        if (nodes[0].level === 1) {\n            return `Don't use level-1 headings:\nBegin headings with two or more # characters.`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"heading-level-skip\",\n    severity: Rule.Severity.WARNING,\n    selector: \"heading ~ heading\",\n    lint: function (state, content, nodes, match) {\n        const currentHeading = nodes[1];\n        const previousHeading = nodes[0];\n        // A heading can have a level less than, the same as\n        // or one more than the previous heading. But going up\n        // by 2 or more levels is not right\n        if (currentHeading.level > previousHeading.level + 1) {\n            return `Skipped heading level:\nthis heading is level ${currentHeading.level} but\nthe previous heading was level ${previousHeading.level}`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"heading-sentence-case\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"heading\",\n    pattern: /^\\W*[a-z]/, // first letter is lowercase\n    message: `First letter is lowercase:\nthe first letter of a heading should be capitalized.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\n// These are 3-letter and longer words that we would not expect to be\n// capitalized even in a title-case heading.  See\n// http://blog.apastyle.org/apastyle/2012/03/title-case-and-sentence-case-capitalization-in-apa-style.html\nconst littleWords = {\n    and: true,\n    nor: true,\n    but: true,\n    the: true,\n    for: true,\n} as const;\n\nfunction isCapitalized(word: any) {\n    const c = word[0];\n    return c === c.toUpperCase();\n}\n\nexport default Rule.makeRule({\n    name: \"heading-title-case\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"heading\",\n    pattern: /[^\\s:]\\s+[A-Z]+[a-z]/,\n    locale: \"en\",\n    lint: function (state, content, nodes, match) {\n        // We want to assert that heading text is in sentence case, not\n        // title case. The pattern above requires a capital letter at the\n        // start of the heading and allows them after a colon, or in\n        // acronyms that are all capitalized.\n        //\n        // But we can't warn just because the pattern matched because\n        // proper nouns are also allowed bo be capitalized. We're not\n        // going to do dictionary lookup to check for proper nouns, so\n        // we try a heuristic: if the title is more than 3 words long\n        // and if all the words are capitalized or are on the list of\n        // words that don't get capitalized, then we'll assume that\n        // the heading is incorrectly in title case and will warn.\n        // But if there is at least one non-capitalized long word then\n        // we're not in title case and we should not warn.\n        //\n        // TODO(davidflanagan): if this rule causes a lot of false\n        // positives, we should tweak it or remove it. Note that it will\n        // fail for headings like \"World War II in Russia\"\n        //\n        // TODO(davidflanagan): This rule is specific to English.\n        // It is marked with a locale property above, but that is NYI\n        //\n        // for APA style rules for title case\n\n        const heading = content.trim();\n        let words = heading.split(/\\s+/);\n\n        // Remove the first word and the little words\n        words.shift();\n        words = words.filter(\n            // eslint-disable-next-line no-prototype-builtins\n            (w) => w.length > 2 && !littleWords.hasOwnProperty(w),\n        );\n\n        // If there are at least 3 remaining words and all\n        // are capitalized, then the heading is in title case.\n        if (words.length >= 3 && words.every((w) => isCapitalized(w))) {\n            return `Title-case heading:\nThis heading appears to be in title-case, but should be sentence-case.\nOnly capitalize the first letter and proper nouns.`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"image-alt-text\",\n    severity: Rule.Severity.WARNING,\n    selector: \"image\",\n    lint: function (state, content, nodes, match) {\n        const image = nodes[0];\n        if (!image.alt || !image.alt.trim()) {\n            return `Images should have alt text:\nfor accessibility, all images should have alt text.\nSpecify alt text inside square brackets after the !.`;\n        }\n        if (image.alt.length < 8) {\n            return `Images should have alt text:\nfor accessibility, all images should have descriptive alt text.\nThis image's alt text is only ${image.alt.length} characters long.`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"image-in-table\",\n    severity: Rule.Severity.BULK_WARNING,\n    selector: \"table image\",\n    message: `Image in table:\ndo not put images inside of tables.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"image-spaces-around-urls\",\n    severity: Rule.Severity.ERROR,\n    selector: \"image\",\n    lint: function (state, content, nodes, match, context) {\n        const image = nodes[0];\n        const url = image.target;\n\n        // The markdown parser strips leading and trailing spaces for us,\n        // but they're still a problem for our translation process, so\n        // we need to go check for them in the unparsed source string\n        // if we have it.\n        if (context && context.content) {\n            // Find the url in the original content and make sure that the\n            // character before is '(' and the character after is ')'\n            const index = context.content.indexOf(url);\n            if (index === -1) {\n                // It is not an error if we didn't find it.\n                return;\n            }\n\n            if (\n                context.content[index - 1] !== \"(\" ||\n                context.content[index + url.length] !== \")\"\n            ) {\n                return `Whitespace before or after image url:\nFor images, don't include any space or newlines after '(' or before ')'.\nWhitespace in image URLs causes translation difficulties.`;\n            }\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\n// Normally we have one rule per file. But since our selector class\n// can't match specific widget types directly, this rule implements\n// a number of image widget related rules in one place. This should\n// slightly increase efficiency, but it means that if there is more\n// than one problem with an image widget, the user will only see one\n// problem at a time.\nexport default Rule.makeRule({\n    name: \"image-widget\",\n    severity: Rule.Severity.WARNING,\n    selector: \"widget\",\n    lint: function (state, content, nodes, match, context) {\n        // This rule only looks at image widgets\n        if (state.currentNode().widgetType !== \"image\") {\n            return;\n        }\n\n        // If it can't find a definition for the widget it does nothing\n        const widget =\n            context &&\n            context.widgets &&\n            context.widgets[state.currentNode().id];\n        if (!widget) {\n            return;\n        }\n\n        // Make sure there is alt text\n        const alt = widget.options.alt;\n        if (!alt) {\n            return `Images should have alt text:\nfor accessibility, all images should have a text description.\nAdd a description in the \"Alt Text\" box of the image widget.`;\n        }\n\n        // Make sure the alt text it is not trivial\n        if (alt.trim().length < 8) {\n            return `Images should have alt text:\nfor accessibility, all images should have descriptive alt text.\nThis image's alt text is only ${alt.trim().length} characters long.`;\n        }\n\n        // Make sure there is no math in the caption\n        if (widget.options.caption && widget.options.caption.match(/[^\\\\]\\$/)) {\n            return `No math in image captions:\nDon't include math expressions in image captions.`;\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"link-click-here\",\n    severity: Rule.Severity.WARNING,\n    selector: \"link\",\n    pattern: /click here/i,\n    message: `Inappropriate link text:\nDo not use the words \"click here\" in links.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"long-paragraph\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"paragraph\",\n    pattern: /^.{501,}/,\n    lint: function (state, content, nodes, match) {\n        return `Paragraph too long:\nThis paragraph is ${content.length} characters long.\nShorten it to 500 characters or fewer.`;\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-adjacent\",\n    severity: Rule.Severity.WARNING,\n    selector: \"blockMath+blockMath\",\n    message: `Adjacent math blocks:\ncombine the blocks between \\\\begin{align} and \\\\end{align}`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-align-extra-break\",\n    severity: Rule.Severity.WARNING,\n    selector: \"blockMath\",\n    pattern: /(\\\\{2,})\\s*\\\\end{align}/,\n    message: `Extra space at end of block:\nDon't end an align block with backslashes`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-align-linebreaks\",\n    severity: Rule.Severity.WARNING,\n    selector: \"blockMath\",\n    // Match any align block with double backslashes in it\n    // Use [\\s\\S]* instead of .* so we match newlines as well.\n    pattern: /\\\\begin{align}[\\s\\S]*\\\\\\\\[\\s\\S]+\\\\end{align}/,\n    // Look for double backslashes and ensure that they are\n    // followed by optional space and another pair of backslashes.\n    // Note that this rule can't know where line breaks belong so\n    // it can't tell whether backslashes are completely missing. It just\n    // enforces that you don't have the wrong number of pairs of backslashes.\n    lint: function (state, content, nodes, match) {\n        let text = match[0];\n        while (text.length) {\n            const index = text.indexOf(\"\\\\\\\\\");\n            if (index === -1) {\n                // No more backslash pairs, so we found no lint\n                return null;\n            }\n            text = text.substring(index + 2);\n\n            // Now we expect to find optional spaces, another pair of\n            // backslashes, and more optional spaces not followed immediately\n            // by another pair of backslashes.\n            const nextpair = text.match(/^\\s*\\\\\\\\\\s*(?!\\\\\\\\)/);\n\n            // If that does not match then we either have too few or too\n            // many pairs of backslashes.\n            if (!nextpair) {\n                return \"Use four backslashes between lines of an align block\";\n            }\n\n            // If it did match, then, shorten the string and continue looping\n            // (because a single align block may have multiple lines that\n            // all must be separated by two sets of double backslashes).\n            text = text.substring(nextpair[0].length);\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-empty\",\n    severity: Rule.Severity.WARNING,\n    selector: \"math, blockMath\",\n    pattern: /^$/,\n    message: \"Empty math: don't use $$ in your markdown.\",\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-font-size\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"math, blockMath\",\n    pattern:\n        /\\\\(tiny|Tiny|small|large|Large|LARGE|huge|Huge|scriptsize|normalsize)\\s*{/,\n    message: `Math font size:\nDon't change the default font size with \\\\Large{} or similar commands`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-frac\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"math, blockMath\",\n    pattern: /\\\\frac[ {]/,\n    message: \"Use \\\\dfrac instead of \\\\frac in your math expressions.\",\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-nested\",\n    severity: Rule.Severity.ERROR,\n    selector: \"math, blockMath\",\n    pattern: /\\\\text{[^$}]*\\$[^$}]*\\$[^}]*}/,\n    message: `Nested math:\nDon't nest math expressions inside \\\\text{} blocks`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-starts-with-space\",\n    severity: Rule.Severity.GUIDELINE,\n    selector: \"math, blockMath\",\n    pattern: /^\\s*(~|\\\\qquad|\\\\quad|\\\\,|\\\\;|\\\\:|\\\\ |\\\\!|\\\\enspace|\\\\phantom)/,\n    message: `Math starts with space:\nmath should not be indented. Do not begin math expressions with\nLaTeX space commands like ~, \\\\;, \\\\quad, or \\\\phantom`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"math-text-empty\",\n    severity: Rule.Severity.WARNING,\n    selector: \"math, blockMath\",\n    pattern: /\\\\text{\\s*}/,\n    message: \"Empty \\\\text{} block in math expression\",\n}) as Rule;\n","import Rule from \"../rule\";\n\n// Because no selector is specified, this rule only applies to text nodes.\n// Math and code hold their content directly and do not have text nodes\n// beneath them (unlike the HTML DOM) so this rule automatically does not\n// apply inside $$ or ``.\nexport default Rule.makeRule({\n    name: \"math-without-dollars\",\n    severity: Rule.Severity.GUIDELINE,\n    pattern: /\\\\\\w+{[^}]*}|{|}/,\n    message: `This looks like LaTeX:\ndid you mean to put it inside dollar signs?`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"nested-lists\",\n    severity: Rule.Severity.WARNING,\n    selector: \"list list\",\n    message: `Nested lists:\nnested lists are hard to read on mobile devices;\ndo not use additional indentation.`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"profanity\",\n    // This list could obviously be expanded a lot, but I figured we\n    // could start with https://en.wikipedia.org/wiki/Seven_dirty_words\n    pattern: /\\b(shit|piss|fuck|cunt|cocksucker|motherfucker|tits)\\b/i,\n    message: \"Avoid profanity\",\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"table-missing-cells\",\n    severity: Rule.Severity.WARNING,\n    selector: \"table\",\n    lint: function (state, content, nodes, match) {\n        const table = nodes[0];\n        const headerLength = table.header.length;\n        const rowLengths = table.cells.map((r) => r.length);\n        for (let r = 0; r < rowLengths.length; r++) {\n            if (rowLengths[r] !== headerLength) {\n                return `Table rows don't match header:\nThe table header has ${headerLength} cells, but\nRow ${r + 1} has ${rowLengths[r]} cells.`;\n            }\n        }\n    },\n}) as Rule;\n","import Rule from \"../rule\";\n\n// Because no selector is specified, this rule only applies to text nodes.\n// Math and code hold their content directly and do not have text nodes\n// beneath them (unlike the HTML DOM) so this rule automatically does not\n// apply inside $$ or ``.\nexport default Rule.makeRule({\n    name: \"unbalanced-code-delimiters\",\n    severity: Rule.Severity.ERROR,\n    pattern: /[`~]+/,\n    message: `Unbalanced code delimiters:\ncode blocks should begin and end with the same type and number of delimiters`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"unescaped-dollar\",\n    severity: Rule.Severity.ERROR,\n    selector: \"unescapedDollar\",\n    message: `Unescaped dollar sign:\nDollar signs must appear in pairs or be escaped as \\\\$`,\n}) as Rule;\n","import Rule from \"../rule\";\n\nexport default Rule.makeRule({\n    name: \"widget-in-table\",\n    severity: Rule.Severity.BULK_WARNING,\n    selector: \"table widget\",\n    message: `Widget in table:\ndo not put widgets inside of tables.`,\n}) as Rule;\n","// TODO(davidflanagan):\n// This should probably be converted to use import and to export\n// and object that maps rule names to rules. Also, maybe this should\n// be an auto-generated file with a script that updates it any time\n// we add a new rule?\n\nimport AbsoluteUrl from \"./absolute-url\";\nimport BlockquotedMath from \"./blockquoted-math\";\nimport BlockquotedWidget from \"./blockquoted-widget\";\nimport DoubleSpacingAfterTerminal from \"./double-spacing-after-terminal\";\nimport ExtraContentSpacing from \"./extra-content-spacing\";\nimport HeadingLevel1 from \"./heading-level-1\";\nimport HeadingLevelSkip from \"./heading-level-skip\";\nimport HeadingSentenceCase from \"./heading-sentence-case\";\nimport HeadingTitleCase from \"./heading-title-case\";\nimport ImageAltText from \"./image-alt-text\";\nimport ImageInTable from \"./image-in-table\";\nimport ImageSpacesAroundUrls from \"./image-spaces-around-urls\";\nimport ImageWidget from \"./image-widget\";\nimport LinkClickHere from \"./link-click-here\";\nimport LongParagraph from \"./long-paragraph\";\nimport MathAdjacent from \"./math-adjacent\";\nimport MathAlignExtraBreak from \"./math-align-extra-break\";\nimport MathAlignLinebreaks from \"./math-align-linebreaks\";\nimport MathEmpty from \"./math-empty\";\nimport MathFontSize from \"./math-font-size\";\nimport MathFrac from \"./math-frac\";\nimport MathNested from \"./math-nested\";\nimport MathStartsWithSpace from \"./math-starts-with-space\";\nimport MathTextEmpty from \"./math-text-empty\";\nimport MathWithoutDollars from \"./math-without-dollars\";\nimport NestedLists from \"./nested-lists\";\nimport Profanity from \"./profanity\";\nimport TableMissingCells from \"./table-missing-cells\";\nimport UnbalancedCodeDelimiters from \"./unbalanced-code-delimiters\";\nimport UnescapedDollar from \"./unescaped-dollar\";\nimport WidgetInTable from \"./widget-in-table\";\n\nexport default [\n    AbsoluteUrl,\n    BlockquotedMath,\n    BlockquotedWidget,\n    DoubleSpacingAfterTerminal,\n    ExtraContentSpacing,\n    HeadingLevel1,\n    HeadingLevelSkip,\n    HeadingSentenceCase,\n    HeadingTitleCase,\n    ImageAltText,\n    ImageInTable,\n    LinkClickHere,\n    LongParagraph,\n    MathAdjacent,\n    MathAlignExtraBreak,\n    MathAlignLinebreaks,\n    MathEmpty,\n    MathFontSize,\n    MathFrac,\n    MathNested,\n    MathStartsWithSpace,\n    MathTextEmpty,\n    NestedLists,\n    TableMissingCells,\n    UnescapedDollar,\n    WidgetInTable,\n    Profanity,\n    MathWithoutDollars,\n    UnbalancedCodeDelimiters,\n    ImageSpacesAroundUrls,\n    ImageWidget,\n];\n","/**\n * TreeTransformer is a class for traversing and transforming trees.  Create a\n * TreeTransformer by passing the root node of the tree to the\n * constructor. Then traverse that tree by calling the traverse() method. The\n * argument to traverse() is a callback function that will be called once for\n * each node in the tree. This is a post-order depth-first traversal: the\n * callback is not called on the a way down, but on the way back up. That is,\n * the children of a node are traversed before the node itself is.\n *\n * The traversal callback function is passed three arguments, the node being\n * traversed, a TraversalState object, and the concatentated text content of\n * the node and all of its descendants. The TraversalState object is the most\n * most interesting argument: it has methods for querying the ancestors and\n * siblings of the node, and for deleting or replacing the node. These\n * transformation methods are why this class is a tree transformer and not\n * just a tree traverser.\n *\n * A typical tree traversal looks like this:\n *\n *   new TreeTransformer(root).traverse((node, state, content) => {\n *       let parent = state.parent();\n *       let previous = state.previousSibling();\n *       // etc.\n *   });\n *\n * The traverse() method descends through nodes and arrays of nodes and calls\n * the traverse callback on each node on the way back up to the root of the\n * tree. (Note that it only calls the callback on the nodes themselves, not\n * any arrays that contain nodes.) A node is loosely defined as any object\n * with a string-valued `type` property. Objects that do not have a type\n * property are assumed to not be part of the tree and are not traversed. When\n * traversing an array, all elements of the array are examined, and any that\n * are nodes or arrays are recursively traversed. When traversing a node, all\n * properties of the object are examined and any node or array values are\n * recursively traversed.  In typical parse trees, the children of a node are\n * in a `children` or `content` array, but this class is designed to handle\n * more general trees.  The Perseus markdown parser, for example, produces\n * nodes of type \"table\" that have children in the `header` and `cells`\n * properties.\n *\n * CAUTION: the traverse() method does not make any attempt to detect\n * cycles. If you call it on a cyclic graph instead of a tree, it will cause\n * infinite recursion (or, more likely, a stack overflow).\n *\n * TODO(davidflanagan): it probably wouldn't be hard to detect cycles: when\n * pushing a new node onto the containers stack we could just check that it\n * isn't already there.\n *\n * If a node has a text-valued `content` property, it is taken to be the\n * plain-text content of the node. The traverse() method concatenates these\n * content strings and passes them to the traversal callback for each\n * node. This means that the callback has access the full text content of its\n * node and all of the nodes descendants.\n *\n * See the TraversalState class for more information on what information and\n * methods are available to the traversal callback.\n **/\n\nimport {Errors, PerseusError} from \"@khanacademy/perseus-error\";\n\n// TreeNode is the type of a node in a parse tree. The only real requirement is\n// that every node has a string-valued `type` property\nexport type TreeNode = {\n    type: string;\n};\n\n// TraversalCallback is the type of the callback function passed to the\n// traverse() method. It is invoked with node, state, and content arguments\n// and is expected to return nothing.\nexport type TraversalCallback = (\n    node: TreeNode,\n    state: TraversalState,\n    content: string,\n) => void;\n\n// This is the TreeTransformer class described in detail at the\n// top of this file.\nexport default class TreeTransformer {\n    root: TreeNode;\n\n    // To create a tree transformer, just pass the root node of the tree\n    constructor(root: TreeNode) {\n        this.root = root;\n    }\n\n    // A utility function for determing whether an arbitrary value is a node\n    static isNode(n: any): boolean {\n        return n && typeof n === \"object\" && typeof n.type === \"string\";\n    }\n\n    // Determines whether a value is a node with type \"text\" and has\n    // a text-valued `content` property.\n    static isTextNode(n: any): boolean {\n        return (\n            TreeTransformer.isNode(n) &&\n            n.type === \"text\" &&\n            typeof n.content === \"string\"\n        );\n    }\n\n    // This is the main entry point for the traverse() method. See the comment\n    // at the top of this file for a detailed description. Note that this\n    // method just creates a new TraversalState object to use for this\n    // traversal and then invokes the internal _traverse() method to begin the\n    // recursion.\n    traverse(f: TraversalCallback): void {\n        this._traverse(this.root, new TraversalState(this.root), f);\n    }\n\n    // Do a post-order traversal of node and its descendants, invoking the\n    // callback function f() once for each node and returning the concatenated\n    // text content of the node and its descendants. f() is passed three\n    // arguments: the current node, a TraversalState object representing the\n    // current state of the traversal, and a string that holds the\n    // concatenated text of the node and its descendants.\n    //\n    // This private method holds all the traversal logic and implementation\n    // details. Note that this method uses the TraversalState object to store\n    // information about the structure of the tree.\n    _traverse(\n        n: TreeNode | Array<TreeNode>,\n        state: TraversalState,\n        f: TraversalCallback,\n    ): string {\n        let content = \"\";\n        if (TreeTransformer.isNode(n)) {\n            // If we were called on a node object, then we handle it\n            // this way.\n            const node = n as TreeNode; // safe cast; we just tested\n\n            // Put the node on the stack before recursing on its children\n            state._containers.push(node);\n            state._ancestors.push(node);\n\n            // Record the node's text content if it has any.\n            // Usually this is for nodes with a type property of \"text\",\n            // but other nodes types like \"math\" may also have content.\n            // @ts-expect-error [FEI-5003] - TS2339 - Property 'content' does not exist on type 'TreeNode'.\n            if (typeof node.content === \"string\") {\n                // @ts-expect-error [FEI-5003] - TS2339 - Property 'content' does not exist on type 'TreeNode'.\n                content = node.content;\n            }\n\n            // Recurse on the node. If there was content above, then there\n            // probably won't be any children to recurse on, but we check\n            // anyway.\n            //\n            // If we wanted to make the traversal completely specific to the\n            // actual Perseus parse trees that we'll be dealing with we could\n            // put a switch statement here to dispatch on the node type\n            // property with specific recursion steps for each known type of\n            // node.\n            const keys = Object.keys(node);\n            keys.forEach((key) => {\n                // Never recurse on the type property\n                if (key === \"type\") {\n                    return;\n                }\n                // Ignore properties that are null or primitive and only\n                // recurse on objects and arrays. Note that we don't do a\n                // isNode() check here. That is done in the recursive call to\n                // _traverse(). Note that the recursive call on each child\n                // returns the text content of the child and we add that\n                // content to the content for this node. Also note that we\n                // push the name of the property we're recursing over onto a\n                // TraversalState stack.\n                const value = node[key];\n                if (value && typeof value === \"object\") {\n                    state._indexes.push(key);\n                    content += this._traverse(value, state, f);\n                    state._indexes.pop();\n                }\n            });\n\n            // Restore the stacks after recursing on the children\n            state._currentNode = state._ancestors.pop();\n            state._containers.pop();\n\n            // And finally call the traversal callback for this node.  Note\n            // that this is post-order traversal. We call the callback on the\n            // way back up the tree, not on the way down.  That way we already\n            // know all the content contained within the node.\n            f(node, state, content);\n        } else if (Array.isArray(n)) {\n            // If we were called on an array instead of a node, then\n            // this is the code we use to recurse.\n            const nodes = n;\n\n            // Push the array onto the stack. This will allow the\n            // TraversalState object to locate siblings of this node.\n            state._containers.push(nodes);\n\n            // Now loop through this array and recurse on each element in it.\n            // Before recursing on an element, we push its array index on a\n            // TraversalState stack so that the TraversalState sibling methods\n            // can work. Note that TraversalState methods can alter the length\n            // of the array, and change the index of the current node, so we\n            // are careful here to test the array length on each iteration and\n            // to reset the index when we pop the stack. Also note that we\n            // concatentate the text content of the children.\n            let index = 0;\n            while (index < nodes.length) {\n                state._indexes.push(index);\n                content += this._traverse(nodes[index], state, f);\n                // Casting to convince TypeScript that this is a number\n                index = (state._indexes.pop() as number) + 1;\n            }\n\n            // Pop the array off the stack. Note, however, that we do not call\n            // the traversal callback on the array. That function is only\n            // called for nodes, not arrays of nodes.\n            state._containers.pop();\n        }\n\n        // The _traverse() method always returns the text content of\n        // this node and its children. This is the one piece of state that\n        // is not tracked in the TraversalState object.\n        return content;\n    }\n}\n\n// An instance of this class is passed to the callback function for\n// each node traversed. The class itself is not exported, but its\n// methods define the API available to the traversal callback.\n\n/**\n * This class represents the state of a tree traversal. An instance is created\n * by the traverse() method of the TreeTransformer class to maintain the state\n * for that traversal, and the instance is passed to the traversal callback\n * function for each node that is traversed. This class is not intended to be\n * instantiated directly, but is exported so that its type can be used for\n * type annotaions.\n **/\nexport class TraversalState {\n    // The root node of the tree being traversed\n    root: TreeNode;\n\n    // These are internal state properties. Use the accessor methods defined\n    // below instead of using these properties directly. Note that the\n    // _containers and _indexes stacks can have two different types of\n    // elements, depending on whether we just recursed on an array or on a\n    // node. This is hard for TypeScript to deal with, so you'll see a number of\n    // type casts through the any type when working with these two properties.\n    _currentNode: TreeNode | null | undefined;\n    _containers: Stack<TreeNode | Array<TreeNode>>;\n    _indexes: Stack<string | number>;\n    _ancestors: Stack<TreeNode>;\n\n    // The constructor just stores the root node and creates empty stacks.\n    constructor(root: TreeNode) {\n        this.root = root;\n\n        // When the callback is called, this property will hold the\n        // node that is currently being traversed.\n        this._currentNode = null;\n\n        // This is a stack of the objects and arrays that we've\n        // traversed through before reaching the currentNode.\n        // It is different than the ancestors array.\n        this._containers = new Stack();\n\n        // This stack has the same number of elements as the _containers\n        // stack. The last element of this._indexes[] is the index of\n        // the current node in the object or array that is the last element\n        // of this._containers[]. If the last element of this._containers[] is\n        // an array, then the last element of this stack will be a number.\n        // Otherwise if the last container is an object, then the last index\n        // will be a string property name.\n        this._indexes = new Stack();\n\n        // This is a stack of the ancestor nodes of the current one.\n        // It is different than the containers[] stack because it only\n        // includes nodes, not arrays.\n        this._ancestors = new Stack();\n    }\n\n    /**\n     * Return the current node in the traversal. Any time the traversal\n     * callback is called, this method will return the name value as the\n     * first argument to the callback.\n     */\n    currentNode(): TreeNode {\n        return this._currentNode || this.root;\n    }\n\n    /**\n     * Return the parent of the current node, if there is one, or null.\n     */\n    parent(): TreeNode | null | undefined {\n        return this._ancestors.top();\n    }\n\n    /**\n     * Return an array of ancestor nodes. The first element of this array is\n     * the same as this.parent() and the last element is the root node. If we\n     * are currently at the root node, the the returned array will be empty.\n     * This method makes a copy of the internal state, so modifications to the\n     * returned array have no effect on the traversal.\n     */\n    ancestors(): ReadonlyArray<TreeNode> {\n        return this._ancestors.values();\n    }\n\n    /**\n     * Return the next sibling of this node, if it has one, or null otherwise.\n     */\n    nextSibling(): TreeNode | null | undefined {\n        const siblings = this._containers.top();\n\n        // If we're at the root of the tree or if the parent is an\n        // object instead of an array, then there are no siblings.\n        if (!siblings || !Array.isArray(siblings)) {\n            return null;\n        }\n\n        // The top index is a number because the top container is an array\n        const index = this._indexes.top() as number;\n        if (siblings.length > index + 1) {\n            return siblings[index + 1];\n        }\n        return null; // There is no next sibling\n    }\n\n    /**\n     * Return the previous sibling of this node, if it has one, or null\n     * otherwise.\n     */\n    previousSibling(): TreeNode | null | undefined {\n        const siblings = this._containers.top();\n\n        // If we're at the root of the tree or if the parent is an\n        // object instead of an array, then there are no siblings.\n        if (!siblings || !Array.isArray(siblings)) {\n            return null;\n        }\n\n        // The top index is a number because the top container is an array\n        const index = this._indexes.top() as number;\n        if (index > 0) {\n            return siblings[index - 1];\n        }\n        return null; // There is no previous sibling\n    }\n\n    /**\n     * Remove the next sibling node (if there is one) from the tree.  Returns\n     * the removed sibling or null. This method makes it easy to traverse a\n     * tree and concatenate adjacent text nodes into a single node.\n     */\n    removeNextSibling(): TreeNode | null | undefined {\n        const siblings = this._containers.top();\n        if (siblings && Array.isArray(siblings)) {\n            // top index is a number because top container is an array\n            const index = this._indexes.top() as number;\n            if (siblings.length > index + 1) {\n                return siblings.splice(index + 1, 1)[0];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Replace the current node in the tree with the specified nodes.  If no\n     * nodes are passed, this is a node deletion. If one node (or array) is\n     * passed, this is a 1-for-1 replacement. If more than one node is passed\n     * then this is a combination of deletion and insertion.  The new node or\n     * nodes will not be traversed, so this method can safely be used to\n     * reparent the current node node beneath a new parent.\n     *\n     * This method throws an error if you attempt to replace the root node of\n     * the tree.\n     */\n    replace(...replacements: ReadonlyArray<TreeNode>): void {\n        const parent = this._containers.top();\n        if (!parent) {\n            throw new PerseusError(\n                \"Can't replace the root of the tree\",\n                Errors.Internal,\n            );\n        }\n\n        // The top of the container stack is either an array or an object\n        // and the top of the indexes stack is a corresponding array index\n        // or object property. This is hard for TypeScript, so we have to do some\n        // unsafe casting and be careful when we use which cast version\n        if (Array.isArray(parent)) {\n            const index = this._indexes.top() as number;\n            // For an array parent we just splice the new nodes in\n            parent.splice(index, 1, ...replacements);\n            // Adjust the index to account for the changed array length.\n            // We don't want to traverse any of the newly inserted nodes.\n            this._indexes.pop();\n            this._indexes.push(index + replacements.length - 1);\n        } else {\n            const property = this._indexes.top() as string;\n            // For an object parent we care how many new nodes there are\n            if (replacements.length === 0) {\n                // Deletion\n                delete parent[property];\n            } else if (replacements.length === 1) {\n                // Replacement\n                parent[property] = replacements[0];\n            } else {\n                // Replace one node with an array of nodes\n                parent[property] = replacements;\n            }\n        }\n    }\n\n    /**\n     * Returns true if the current node has a previous sibling and false\n     * otherwise. If this method returns false, then previousSibling() will\n     * return null, and goToPreviousSibling() will throw an error.\n     */\n    hasPreviousSibling(): boolean {\n        return (\n            Array.isArray(this._containers.top()) &&\n            (this._indexes.top() as number) > 0\n        );\n    }\n\n    /**\n     * Modify this traversal state object to have the state it would have had\n     * when visiting the previous sibling. Note that you may want to use\n     * clone() to make a copy before modifying the state object like this.\n     * This mutator method is not typically used during ordinary tree\n     * traversals, but is used by the Selector class for matching multi-node\n     * selectors.\n     */\n    goToPreviousSibling(): void {\n        if (!this.hasPreviousSibling()) {\n            throw new PerseusError(\n                \"goToPreviousSibling(): node has no previous sibling\",\n                Errors.Internal,\n            );\n        }\n\n        this._currentNode = this.previousSibling();\n        // Since we know that we have a previous sibling, we know that\n        // the value on top of the stack is a number, but we have to do\n        // this unsafe cast because TypeScript doesn't know that.\n        const index = this._indexes.pop() as number;\n        this._indexes.push(index - 1);\n    }\n\n    /**\n     * Returns true if the current node has an ancestor and false otherwise.\n     * If this method returns false, then the parent() method will return\n     * null and goToParent() will throw an error\n     */\n    hasParent(): boolean {\n        return this._ancestors.size() !== 0;\n    }\n\n    /**\n     * Modify this object to look like it will look when we (later) visit the\n     * parent node of this node. You should not modify the instance passed to\n     * the tree traversal callback. Instead, make a copy with the clone()\n     * method and modify that.  This mutator method is not typically used\n     * during ordinary tree traversals, but is used by the Selector class for\n     * matching multi-node selectors that involve parent and ancestor\n     * selectors.\n     */\n    goToParent(): void {\n        if (!this.hasParent()) {\n            throw new PerseusError(\n                \"goToParent(): node has no ancestor\",\n                Errors.NotAllowed,\n            );\n        }\n\n        this._currentNode = this._ancestors.pop();\n\n        // We need to pop the containers and indexes stacks at least once\n        // and more as needed until we restore the invariant that\n        // this._containers.top()[this.indexes.top()] === this._currentNode\n        //\n        while (\n            this._containers.size() &&\n            this._containers.top()[this._indexes.top()] !== this._currentNode\n        ) {\n            this._containers.pop();\n            this._indexes.pop();\n        }\n    }\n\n    /**\n     * Return a new TraversalState object that is a copy of this one.\n     * This method is useful in conjunction with the mutating methods\n     * goToParent() and goToPreviousSibling().\n     */\n    clone(): TraversalState {\n        const clone = new TraversalState(this.root);\n        clone._currentNode = this._currentNode;\n        clone._containers = this._containers.clone();\n        clone._indexes = this._indexes.clone();\n        clone._ancestors = this._ancestors.clone();\n        return clone;\n    }\n\n    /**\n     * Returns true if this TraversalState object is equal to that\n     * TraversalState object, or false otherwise. This method exists\n     * primarily for use by our unit tests.\n     */\n    equals(that: TraversalState): boolean {\n        return (\n            this.root === that.root &&\n            this._currentNode === that._currentNode &&\n            this._containers.equals(that._containers) &&\n            this._indexes.equals(that._indexes) &&\n            this._ancestors.equals(that._ancestors)\n        );\n    }\n}\n\n/**\n * This class is an internal utility that just treats an array as a stack\n * and gives us a top() method so we don't have to write expressions like\n * `ancestors[ancestors.length-1]`. The values() method automatically\n * copies the internal array so we don't have to worry about client code\n * modifying our internal stacks. The use of this Stack abstraction makes\n * the TraversalState class simpler in a number of places.\n */\nclass Stack<T> {\n    stack: Array<T>;\n\n    constructor(array?: ReadonlyArray<T> | null) {\n        this.stack = array ? array.slice(0) : [];\n    }\n\n    /** Push a value onto the stack. */\n    push(v: T): void {\n        this.stack.push(v);\n    }\n\n    /** Pop a value off of the stack. */\n    pop(): T {\n        // @ts-expect-error [FEI-5003] - TS2322 - Type 'T | undefined' is not assignable to type 'T'.\n        return this.stack.pop();\n    }\n\n    /** Return the top value of the stack without popping it. */\n    top(): T {\n        return this.stack[this.stack.length - 1];\n    }\n\n    /** Return a copy of the stack as an array */\n    values(): ReadonlyArray<T> {\n        return this.stack.slice(0);\n    }\n\n    /** Return the number of elements in the stack */\n    size(): number {\n        return this.stack.length;\n    }\n\n    /** Return a string representation of the stack */\n    toString(): string {\n        return this.stack.toString();\n    }\n\n    /** Return a shallow copy of the stack */\n    clone(): Stack<T> {\n        return new Stack(this.stack);\n    }\n\n    /**\n     * Compare this stack to another and return true if the contents of\n     * the two arrays are the same.\n     */\n    equals(that: Stack<T>): boolean {\n        if (!that || !that.stack || that.stack.length !== this.stack.length) {\n            return false;\n        }\n        for (let i = 0; i < this.stack.length; i++) {\n            if (this.stack[i] !== that.stack[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","// Define the shape of the linter context object that is passed through the\n// tree with additional information about what we are checking.\nimport PropTypes from \"prop-types\";\n\nimport type {LinterContextProps} from \"./types\";\n\nexport const linterContextProps = PropTypes.shape({\n    contentType: PropTypes.string,\n    highlightLint: PropTypes.bool,\n    paths: PropTypes.arrayOf(PropTypes.string),\n    stack: PropTypes.arrayOf(PropTypes.string),\n});\n\nexport const linterContextDefault: LinterContextProps = {\n    contentType: \"\",\n    highlightLint: false,\n    paths: [] as ReadonlyArray<any>,\n    stack: [] as ReadonlyArray<any>,\n};\n","import Rule from \"./rule\";\nimport AllRules from \"./rules/all-rules\";\nimport TreeTransformer from \"./tree-transformer\";\n\nexport {linterContextProps, linterContextDefault} from \"./proptypes\";\nexport type {LinterContextProps} from \"./types\";\n\nconst allLintRules: ReadonlyArray<any> = AllRules.filter(\n    (r) => r.severity < Rule.Severity.BULK_WARNING,\n);\n\nexport {Rule, allLintRules as rules};\n\n//\n// Run the Perseus linter over the specified markdown parse tree,\n// with the specified context object, and\n// return a (possibly empty) array of lint warning objects.  If the\n// highlight argument is true, this function also modifies the parse\n// tree to add \"lint\" nodes that can be visually rendered,\n// highlighting the problems for the user. The optional rules argument\n// is an array of Rule objects specifying which lint rules should be\n// applied to this parse tree. When omitted, a default set of rules is used.\n//\n// The context object may have additional properties that some lint\n// rules require:\n//\n//   context.content is the source content string that was parsed to create\n//   the parse tree.\n//\n//   context.widgets is the widgets object associated\n//   with the content string\n//\n// TODO: to make this even more general, allow the first argument to be\n// a string and run the parser over it in that case? (but ignore highlight\n// in that case). This would allow the one function to be used for both\n// online linting and batch linting.\n//\nexport function runLinter(\n    tree: any,\n    context: any,\n    highlight: boolean,\n    rules: ReadonlyArray<any> = allLintRules,\n): ReadonlyArray<any> {\n    const warnings: Array<any> = [];\n    const tt = new TreeTransformer(tree);\n\n    // The markdown parser often outputs adjacent text nodes. We\n    // coalesce them before linting for efficiency and accuracy.\n    tt.traverse((node, state, content) => {\n        if (TreeTransformer.isTextNode(node)) {\n            let next = state.nextSibling();\n            while (TreeTransformer.isTextNode(next)) {\n                // @ts-expect-error [FEI-5003] - TS2339 - Property 'content' does not exist on type 'TreeNode'. | TS2533 - Object is possibly 'null' or 'undefined'. | TS2339 - Property 'content' does not exist on type 'TreeNode'.\n                node.content += next.content;\n                state.removeNextSibling();\n                next = state.nextSibling();\n            }\n        }\n    });\n\n    // HTML tables are complicated, and the CSS we use in\n    // ../components/lint.jsx to display lint does not work to\n    // correctly position the lint indicators in the margin when the\n    // lint is inside a table. So as a workaround we keep track of all\n    // the lint that appears within a table and move it up to the\n    // table element itself.\n    //\n    // It is not ideal to have to do this here,\n    // but it is cleaner here than fixing up the lint during rendering\n    // in perseus-markdown.jsx. If our lint display was simpler and\n    // did not require indicators in the margin, this wouldn't be a\n    // problem. Or, if we modified the lint display stuff so that\n    // indicator positioning and tooltip display were both handled\n    // with JavaScript (instead of pure CSS), then we could avoid this\n    // issue too. But using JavaScript has its own downsides: there is\n    // risk that the linter JavaScript would interfere with\n    // widget-related Javascript.\n    let tableWarnings: Array<never> = [];\n    let insideTable = false;\n\n    // Traverse through the nodes of the parse tree. At each node, loop\n    // through the array of lint rules and check whether there is a\n    // lint violation at that node.\n    tt.traverse((node, state, content) => {\n        const nodeWarnings: Array<any> = [];\n\n        // If our rule is only designed to be tested against a particular\n        // content type and we're not in that content type, we don't need to\n        // consider that rule.\n        const applicableRules = rules.filter((r) => r.applies(context));\n\n        // Generate a stack so we can identify our position in the tree in\n        // lint rules\n        const stack = [...context.stack];\n        stack.push(node.type);\n\n        const nodeContext = {\n            ...context,\n            stack: stack.join(\".\"),\n        } as const;\n\n        applicableRules.forEach((rule) => {\n            const warning = rule.check(node, state, content, nodeContext);\n            if (warning) {\n                // The start and end locations are relative to this\n                // particular node, and so are not generally very useful.\n                // TODO: When the markdown parser saves the node\n                // locations in the source string then we can add\n                // these numbers to that one and get and absolute\n                // character range that will be useful\n                if (warning.start || warning.end) {\n                    warning.target = content.substring(\n                        warning.start,\n                        warning.end,\n                    );\n                }\n\n                // Add the warning to the list of all lint we've found\n                warnings.push(warning);\n\n                // If we're going to be highlighting lint, then we also\n                // need to keep track of warnings specific to this node.\n                if (highlight) {\n                    nodeWarnings.push(warning);\n                }\n            }\n        });\n\n        // If we're not highlighting lint in the tree, then we're done\n        // traversing this node.\n        if (!highlight) {\n            return;\n        }\n\n        // If the node we are currently at is a table, and there was lint\n        // inside the table, then we want to add that lint here\n        if (node.type === \"table\") {\n            if (tableWarnings.length) {\n                nodeWarnings.push(...tableWarnings);\n            }\n\n            // We're not in a table anymore, and don't have to remember\n            // the warnings for the table\n            insideTable = false;\n            tableWarnings = [];\n        } else if (!insideTable) {\n            // Otherwise, if we are not already inside a table, check\n            // to see if we've entered one. Because this is a post-order\n            // traversal we'll see the table contents before the table itself.\n            // Note that once we're inside the table, we don't have to\n            // do this check each time... We can just wait until we ascend\n            // up to the table, then we'll know we're out of it.\n            insideTable = state.ancestors().some((n) => n.type === \"table\");\n        }\n\n        // If we are inside a table and there were any warnings on\n        // this node, then we need to save the warnings for display\n        // on the table itself\n        if (insideTable && nodeWarnings.length) {\n            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.\n            tableWarnings.push(...nodeWarnings);\n        }\n\n        // If there were any warnings on this node, and if we're highlighting\n        // lint, then reparent the node so we can highlight it. Note that\n        // a single node can have multiple warnings. If this happends we\n        // concatenate the warnings and newline separate them. (The lint.jsx\n        // component that displays the warnings may want to convert the\n        // newlines into <br> tags.) We also provide a lint rule name\n        // so that lint.jsx can link to a document that provides more details\n        // on that particular lint rule. If there is more than one warning\n        // we only link to the first rule, however.\n        //\n        // Note that even if we're inside a table, we still reparent the\n        // linty node so that it can be highlighted. We just make a note\n        // of whether this lint is inside a table or not.\n        if (nodeWarnings.length) {\n            nodeWarnings.sort((a, b) => {\n                return a.severity - b.severity;\n            });\n\n            if (node.type !== \"text\" || nodeWarnings.length > 1) {\n                // If the linty node is not a text node, or if there is more\n                // than one warning on a text node, then reparent the entire\n                // node under a new lint node and put the warnings there.\n                state.replace({\n                    type: \"lint\",\n                    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ type: string; content: TreeNode; message: string; ruleName: any; blockHighlight: any; insideTable: boolean; severity: any; }' is not assignable to parameter of type 'TreeNode'.\n                    content: node,\n                    message: nodeWarnings.map((w) => w.message).join(\"\\n\\n\"),\n                    ruleName: nodeWarnings[0].rule,\n                    blockHighlight: nodeContext.blockHighlight,\n                    insideTable: insideTable,\n                    severity: nodeWarnings[0].severity,\n                });\n            } else {\n                //\n                // Otherwise, it is a single warning on a text node, and we\n                // only want to highlight the actual linty part of that string\n                // of text. So we want to replace the text node with (in the\n                // general case) three nodes:\n                //\n                // 1) A new text node that holds the non-linty prefix\n                //\n                // 2) A lint node that is the parent of a new text node\n                // that holds the linty part\n                //\n                // 3) A new text node that holds the non-linty suffix\n                //\n                // If the lint begins and/or ends at the boundaries of the\n                // original text node, then nodes 1 and/or 3 won't exist, of\n                // course.\n                //\n                // Note that we could generalize this to work with multple\n                // warnings on a text node as long as the warnings are\n                // non-overlapping. Hopefully, though, multiple warnings in a\n                // single text node will be rare in practice. Also, we don't\n                // have a good way to display multiple lint indicators on a\n                // single line, so keeping them combined in that case might\n                // be the best thing, anyway.\n                //\n                // @ts-expect-error [FEI-5003] - TS2339 - Property 'content' does not exist on type 'TreeNode'.\n                const content = node.content; // Text nodes have content\n                const warning = nodeWarnings[0]; // There is only one warning.\n                // These are the lint boundaries within the content\n                const start = warning.start || 0;\n                const end = warning.end || content.length;\n                const prefix = content.substring(0, start);\n                const lint = content.substring(start, end);\n                const suffix = content.substring(end);\n                // TODO(FEI-5003): Give this a real type.\n                const replacements: any[] = []; // What we'll replace the node with\n\n                // The prefix text node, if there is one\n                if (prefix) {\n                    replacements.push({\n                        type: \"text\",\n                        content: prefix,\n                    });\n                }\n\n                // The lint node wrapped around the linty text\n                replacements.push({\n                    type: \"lint\",\n                    content: {\n                        type: \"text\",\n                        content: lint,\n                    },\n                    message: warning.message,\n                    ruleName: warning.rule,\n                    insideTable: insideTable,\n                    severity: warning.severity,\n                });\n\n                // The suffix node, if there is one\n                if (suffix) {\n                    replacements.push({\n                        type: \"text\",\n                        content: suffix,\n                    });\n                }\n\n                // Now replace the lint text node with the one to three\n                // nodes in the replacement array\n                state.replace(...replacements);\n            }\n        }\n    });\n\n    return warnings;\n}\n\nexport function pushContextStack(context: any, name: string): any {\n    const stack = context.stack || [];\n    return {\n        ...context,\n        stack: stack.concat(name),\n    };\n}\n"],"names":["Selector","parse","selectorText","Parser","match","state","PerseusError","Errors","NotAllowed","toString","constructor","s","_defineProperty","trim","replace","tokens","TOKENS","tokenIndex","nextToken","consume","isIdentifier","c","skipSpace","ts","parseTreeSelector","token","treeSelectors","ParseError","push","SelectorList","ns","parseNodeSelector","AncestorCombinator","ParentCombinator","PreviousCombinator","SiblingCombinator","t","AnyNode","TypeSelector","Error","message","selectors","i","length","result","currentNode","type","node","SelectorCombinator","left","right","rightResult","clone","hasParent","goToParent","leftResult","concat","hasPreviousSibling","goToPreviousSibling","Rule","name","severity","selector","pattern","lint","applies","_this","InvalidInput","metadata","Severity","BULK_WARNING","DEFAULT_SELECTOR","_defaultLintFunction","arguments","makeRule","options","makePattern","check","traversalState","content","context","selectorMatch","patternMatch","FakePatternMatch","error","rule","start","end","e","stack","index","RegExp","lastSlash","lastIndexOf","expression","substring","flags","input","ERROR","WARNING","GUIDELINE","HOSTNAME","getHostname","url","nodes","target","hostname","endsWith","contentType","level","currentHeading","previousHeading","littleWords","and","nor","but","the","for","isCapitalized","word","toUpperCase","locale","heading","words","split","shift","filter","w","hasOwnProperty","every","image","alt","indexOf","widgetType","widget","widgets","id","caption","text","nextpair","table","headerLength","header","rowLengths","cells","map","r","AbsoluteUrl","BlockquotedMath","BlockquotedWidget","DoubleSpacingAfterTerminal","ExtraContentSpacing","HeadingLevel1","HeadingLevelSkip","HeadingSentenceCase","HeadingTitleCase","ImageAltText","ImageInTable","LinkClickHere","LongParagraph","MathAdjacent","MathAlignExtraBreak","MathAlignLinebreaks","MathEmpty","MathFontSize","MathFrac","MathNested","MathStartsWithSpace","MathTextEmpty","NestedLists","TableMissingCells","UnescapedDollar","WidgetInTable","Profanity","MathWithoutDollars","UnbalancedCodeDelimiters","ImageSpacesAroundUrls","ImageWidget","TreeTransformer","root","isNode","n","isTextNode","traverse","f","_traverse","TraversalState","_containers","_ancestors","keys","Object","forEach","key","value","_indexes","pop","_currentNode","Array","isArray","Stack","parent","top","ancestors","values","nextSibling","siblings","previousSibling","removeNextSibling","splice","Internal","_len","replacements","_key","property","size","equals","that","array","slice","v","linterContextProps","PropTypes","shape","string","highlightLint","bool","paths","arrayOf","linterContextDefault","allLintRules","AllRules","runLinter","tree","highlight","rules","undefined","warnings","tt","next","tableWarnings","insideTable","nodeWarnings","applicableRules","nodeContext","join","warning","some","sort","a","b","ruleName","blockHighlight","prefix","suffix","pushContextStack"],"mappings":"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"}