{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Contains markdown related functions in pure javascript,\n * extracted from perseus-markdown.jsx\n * Note that this file may be used in stand alone nodejs, thus\n * do not import anything from Perseus\n */\nimport SimpleMarkdown from \"@khanacademy/simple-markdown\";\n\n/**\n * This match function matches math in `$`s, such as:\n *\n * $y = x + 1$\n *\n * It functions roughly like the following regex:\n * /\\$([^\\$]*)\\$/\n *\n * Unfortunately, math may have other `$`s inside it, as\n * long as they are inside `{` braces `}`, mostly for\n * `\\text{ $math$ }`.\n *\n * To parse this, we can't use a regex, since we\n * should support arbitrary nesting (even though\n * MathJax actually only supports two levels of nesting\n * here, which we *could* parse with a regex).\n *\n * Non-regex matchers like this are now a first-class\n * concept in simple-markdown. Yay!\n *\n * This can also match block-math, which is math alone in a paragraph.\n */\n\nconst rWidgetRule = /^\\[\\[\\u2603 (([a-z-]+) ([0-9]+))\\]\\]/;\n\nconst mathMatcher = (source: any, state: any, isBlock: boolean) => {\n    const length = source.length;\n    let index = 0;\n\n    // When looking for blocks, skip over leading spaces\n    if (isBlock) {\n        if (state.inline) {\n            return null;\n        }\n        while (index < length && source[index] === \" \") {\n            index++;\n        }\n    }\n\n    // Our source must start with a \"$\"\n    if (!(index < length && source[index] === \"$\")) {\n        return null;\n    }\n\n    index++;\n    const startIndex = index;\n    let braceLevel = 0;\n\n    // Loop through the source, looking for a closing '$'\n    // closing '$'s only count if they are not escaped with\n    // a `\\`, and we are not in nested `{}` braces.\n    while (index < length) {\n        const character = source[index];\n\n        if (character === \"\\\\\") {\n            // Consume both the `\\` and the escaped char as a single\n            // token.\n            // This is so that the second `$` in `$\\\\$` closes\n            // the math expression, since the first `\\` is escaping\n            // the second `\\`, but the second `\\` is not escaping\n            // the second `$`.\n            // This also handles the case of escaping `$`s or\n            // braces `\\{`\n            index++;\n        } else if (braceLevel <= 0 && character === \"$\") {\n            let endIndex = index + 1;\n            if (isBlock) {\n                // Look for two trailing newlines after the closing `$`\n                const match = /^(?: *\\n){2,}/.exec(source.slice(endIndex));\n                // @ts-expect-error [FEI-5003] - TS2322 - Type 'number | null' is not assignable to type 'number'.\n                endIndex = match ? endIndex + match[0].length : null;\n            }\n\n            // Return an array that looks like the results of a\n            // regex's .exec function:\n            // capture[0] is the whole string\n            // capture[1] is the first \"paren\" match, which is the\n            //   content of the math here, as if we wrote the regex\n            //   /\\$([^\\$]*)\\$/\n            if (endIndex) {\n                return [\n                    source.substring(0, endIndex),\n                    source.substring(startIndex, index),\n                ];\n            }\n            return null;\n        } else if (character === \"{\") {\n            braceLevel++;\n        } else if (character === \"}\") {\n            braceLevel--;\n        } else if (character === \"\\n\" && source[index - 1] === \"\\n\") {\n            // This is a weird case we supported in the old\n            // math implementation--double newlines break\n            // math. I'm preserving it for now because content\n            // creators might have questions with single '$'s\n            // in paragraphs...\n            return null;\n        }\n\n        index++;\n    }\n\n    // we didn't find a closing `$`\n    return null;\n};\nconst mathMatch = (source: any, state: any): any =>\n    mathMatcher(source, state, false);\nconst blockMathMatch = (source: any, state: any): any =>\n    mathMatcher(source, state, true);\n\nconst TITLED_TABLE_REGEX = new RegExp(\n    \"^\\\\|\\\\| +(.*) +\\\\|\\\\| *\\\\n\" +\n        \"(\" +\n        // The simple-markdown nptable regex, without\n        // the leading `^`\n        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.\n        SimpleMarkdown.defaultRules.nptable.match.regex.source.substring(1) +\n        \")\",\n);\n\nconst crowdinJiptMatcher = SimpleMarkdown.blockRegex(/^(crwdns.*)\\n\\s*\\n/);\n\nexport const pureMarkdownRules = {\n    ...SimpleMarkdown.defaultRules,\n\n    // NOTE: basically ignored by JIPT. wraps everything at the outer layer\n    columns: {\n        order: -2,\n        match: SimpleMarkdown.blockRegex(\n            /^([\\s\\S]*\\n\\n)={5,}\\n\\n([\\s\\S]*)/,\n        ) as any,\n        parse: (capture: any, parse: any, state: any): any => {\n            return {\n                col1: parse(capture[1], state),\n                col2: parse(capture[2], state),\n            };\n        },\n    },\n    crowdinId: {\n        order: -1,\n        match: (source: any, state: any, prevCapture: any): any => {\n            // Only match on the just-in-place translation site\n            if (state.isJipt) {\n                return crowdinJiptMatcher(source, state, prevCapture);\n            }\n            return null;\n        },\n        parse: (capture: any, parse: any, state: any): any => ({\n            id: capture[1],\n        }),\n    },\n    // This is pretty much horrible, but we have a regex here to capture an\n    // entire table + a title. capture[1] is the title. capture[2] of the\n    // regex is a copy of the simple-markdown nptable regex. Then we turn\n    // our capture[2] into tableCapture[0], and any further captures in\n    // our table regex into tableCapture[1..], and we pass tableCapture to\n    // our nptable regex\n    titledTable: {\n        // process immediately before nptables\n        order: SimpleMarkdown.defaultRules.nptable.order - 0.5,\n        match: SimpleMarkdown.blockRegex(TITLED_TABLE_REGEX) as any,\n        parse: (capture: any, parse: any, state: any): any => {\n            const title = SimpleMarkdown.parseInline(parse, capture[1], state);\n\n            // Remove our [0] and [1] captures, and pass the rest to\n            // the nptable parser\n            const tableCapture = capture.slice(2);\n            const table = SimpleMarkdown.defaultRules.nptable.parse(\n                tableCapture,\n                parse,\n                state,\n            );\n            return {\n                title: title,\n                table: table,\n            };\n        },\n    },\n    widget: {\n        order: SimpleMarkdown.defaultRules.link.order - 0.75,\n        match: SimpleMarkdown.inlineRegex(rWidgetRule) as any,\n        parse: (capture: any, parse: any, state: any): any => {\n            return {\n                id: capture[1],\n                widgetType: capture[2],\n            };\n        },\n    },\n    blockMath: {\n        order: (SimpleMarkdown.defaultRules.codeBlock.order + 0.5) as any,\n        match: blockMathMatch,\n        parse: (capture: any, parse: any, state: any): any => {\n            return {\n                content: capture[1],\n            };\n        },\n    },\n    math: {\n        order: SimpleMarkdown.defaultRules.link.order - 0.25,\n        match: mathMatch,\n        parse: (capture: any, parse: any, state: any): any => {\n            return {\n                content: capture[1],\n            };\n        },\n    },\n    unescapedDollar: {\n        order: SimpleMarkdown.defaultRules.link.order - 0.24,\n        match: SimpleMarkdown.inlineRegex(/^(?!\\\\)\\$/) as any,\n        parse: (capture: any, parse: any, state: any): any => {\n            return {};\n        },\n    },\n    fence: {\n        ...SimpleMarkdown.defaultRules.fence,\n        parse: (capture: any, parse: any, state: any): any => {\n            const node = SimpleMarkdown.defaultRules.fence.parse(\n                capture,\n                parse,\n                state,\n            );\n\n            // support screenreader-only text with ```alt\n            if (node.lang === \"alt\") {\n                return {\n                    type: \"codeBlock\",\n                    lang: \"alt\",\n                    // default codeBlock parsing doesn't parse the contents.\n                    // We need to parse the contents for things like table\n                    // support :).\n                    // The \\n\\n is because the inside of the codeblock might\n                    // not end in double newlines for block rules, because\n                    // ordinarily we don't parse this :).\n                    content: parse(node.content + \"\\n\\n\", state),\n                };\n            }\n            return node;\n        },\n    },\n    blockQuote: {\n        ...SimpleMarkdown.defaultRules.blockQuote,\n        // Replace the less restrictive blockquote regex from SimpleMarkdown\n        // with a more restrictive one. The only difference should be that\n        //\n        // > A blockquote\n        //\n        // > Another blockquote\n        //\n        // will now match as two different blockQuotes instead of a single\n        // blockquote with some paragraph breaks in it.\n        //\n        // The main motivation for doing this is to provide better support for\n        // translators translating blockquotes with multiple paragraphs in\n        // them. When translating articles, we split up paragraphs, translate\n        // them separately, and then recombine them. We do this so that\n        // translators don't have to translate an entire article at a time,\n        // they can instead translate paragraph-by-paragraph.That system\n        // doesn't understand blockquotes, so it will split up blockquotes into\n        // more than one paragraph. A way to solve this would be to make that\n        // system understand blockquotes, but then translators would have to\n        // translate an entire, multi-paragraph blockquote at a time. Instead,\n        // we choose to modify our blockquote matching to split up\n        // multi-paragraph blockquotes into multiple blockquotes.\n        //\n        // There is also precedence for doing this splitting up in other\n        // libraries, for instance CommonMark also splits up blockquotes with\n        // empty lines into multiple blockquotes:\n        // https://spec.commonmark.org/0.28/#example-205\n        match: SimpleMarkdown.blockRegex(\n            /^ *>[^\\n]+(\\n( *>)?[^\\n]+)*\\n{2,}/,\n        ) as any,\n    },\n    list: {\n        ...SimpleMarkdown.defaultRules.list,\n        match: (source: any, state: any, prevCapture: any): any => {\n            // Since lists can contain double newlines and we have special\n            // handling of double newlines while parsing jipt content, just\n            // disable the list parser.\n            if (state.isJipt) {\n                return null;\n            }\n            return SimpleMarkdown.defaultRules.list.match(\n                source,\n                state,\n                prevCapture,\n            );\n        },\n    },\n    // The lint rule never actually matches anything.\n    // We check for lint after parsing, and, if we find any, we\n    // transform the tree to add lint nodes. This rule is here\n    // just for the react() function\n    lint: {\n        order: 1000,\n        match: (s: any): any => null,\n        parse: (capture: any, parse: any, state: any): any => ({}),\n    },\n} as const;\n\n// @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ readonly columns: { readonly order: -2; readonly match: any; readonly parse: (capture: any, parse: any, state: any) => any; }; readonly crowdinId: { readonly order: -1; readonly match: (source: any, state: any, prevCapture: any) => any; readonly parse: (capture: any, parse: any, state: any) => any; }; ... 34 more ...' is not assignable to parameter of type 'ParserRules'.\nconst builtParser = SimpleMarkdown.parserFor(pureMarkdownRules);\n\nexport const parse = (source: string, state?: any): any => {\n    const paragraphedSource = source + \"\\n\\n\";\n\n    return builtParser(paragraphedSource, {\n        ...state,\n        inline: false,\n    });\n};\n"],"names":["rWidgetRule","mathMatcher","source","state","isBlock","length","index","inline","startIndex","braceLevel","character","endIndex","match","exec","slice","substring","mathMatch","blockMathMatch","TITLED_TABLE_REGEX","RegExp","SimpleMarkdown","defaultRules","nptable","regex","crowdinJiptMatcher","blockRegex","pureMarkdownRules","columns","order","parse","capture","col1","col2","crowdinId","prevCapture","isJipt","id","titledTable","title","parseInline","tableCapture","table","widget","link","inlineRegex","widgetType","blockMath","codeBlock","content","math","unescapedDollar","fence","node","lang","type","blockQuote","list","lint","s","builtParser","parserFor","paragraphedSource"],"mappings":"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"}