'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var KAS = require('@khanacademy/kas');
var mathInput = require('@khanacademy/math-input');
var PerseusLinter = require('@khanacademy/perseus-linter');
var i18n = require('@khanacademy/wonder-blocks-i18n');
var classNames = require('classnames');
var React = require('react');
var _ = require('underscore');
var $ = require('jquery');
var MathQuill = require('mathquill');
var ReactDOM = require('react-dom');
var PropTypes = require('prop-types');
var kmath = require('@khanacademy/kmath');
var Spacing = require('@khanacademy/wonder-blocks-spacing');
var aphrodite = require('aphrodite');
var wonderBlocksProgressSpinner = require('@khanacademy/wonder-blocks-progress-spinner');
var wonderBlocksCore = require('@khanacademy/wonder-blocks-core');
var SimpleMarkdown = require('@khanacademy/simple-markdown');
var pureMarkdown = require('@khanacademy/pure-markdown');
var wonderBlocksForm = require('@khanacademy/wonder-blocks-form');
var Button = require('@khanacademy/wonder-blocks-button');
var Clickable = require('@khanacademy/wonder-blocks-clickable');
var Color = require('@khanacademy/wonder-blocks-color');
var wonderBlocksLayout = require('@khanacademy/wonder-blocks-layout');
var wonderBlocksPopover = require('@khanacademy/wonder-blocks-popover');
var wonderBlocksDropdown = require('@khanacademy/wonder-blocks-dropdown');
var debounce = require('lodash.debounce');
var createReactClass = require('create-react-class');
var Tooltip$1 = require('@khanacademy/wonder-blocks-tooltip');
var Link = require('@khanacademy/wonder-blocks-link');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var KAS__namespace = /*#__PURE__*/_interopNamespace(KAS);
var PerseusLinter__namespace = /*#__PURE__*/_interopNamespace(PerseusLinter);
var i18n__namespace = /*#__PURE__*/_interopNamespace(i18n);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var $__default = /*#__PURE__*/_interopDefaultLegacy($);
var MathQuill__default = /*#__PURE__*/_interopDefaultLegacy(MathQuill);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var Spacing__default = /*#__PURE__*/_interopDefaultLegacy(Spacing);
var SimpleMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(SimpleMarkdown);
var Button__default = /*#__PURE__*/_interopDefaultLegacy(Button);
var Clickable__default = /*#__PURE__*/_interopDefaultLegacy(Clickable);
var Color__default = /*#__PURE__*/_interopDefaultLegacy(Color);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var createReactClass__default = /*#__PURE__*/_interopDefaultLegacy(createReactClass);
var Tooltip__default = /*#__PURE__*/_interopDefaultLegacy(Tooltip$1);
var Link__default = /*#__PURE__*/_interopDefaultLegacy(Link);

var version = {
  apiVersion: {
    major: 12,
    minor: 0
  },
  itemDataVersion: {
    major: 0,
    minor: 1
  }
};

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/**
 * A stripped version of Icon.jsx from webapp. Takes an SVG icon and renders it
 * inline like Font Awesome did.
 *
 * If you are looking for an icon that we've used before you should look in
 * webapp's `icon-paths.js` which is a reference file for all the SVG paths
 * that we've used. You'll need to copy the object from that file into
 * whichever file you're using the icon and explicitly pass it in to the
 * <InlineIcon/> React component.
 *
 * We assume that the viewBox is cropped and aligned to (0, 0), but icons can
 * be defined differently. At some point we might want to add these attributes
 * to `icon-paths.js`, but for now this is a fairly safe assumption.
 *
 * Sample usage:
 *
 *   const editIcon = {
 *      path: "M41.209 53.753l5.39 0l0 5.39l3.136 0l6.468-6.517-8.477-8.526-6.517 6.517l0 3.136zm33.173-34.937q-.882-.882-1.862.049l-19.6 19.6q-.931.98-.049 1.862t1.862-.049l19.6-19.6q.931-.98.049-1.862zm-38.563 45.668l0-16.121l37.632-37.632 16.17 16.121-37.632 37.632l-16.17 0zm43.022-12.397l0 10.633q-.049 6.713-4.753 11.417t-11.368 4.704l-46.599 0q-6.713 0-11.417-4.753t-4.704-11.368l0-46.599q0-6.664 4.753-11.417t11.368-4.704l46.599 0q3.528 0 6.566 1.372.833.392.98 1.323t-.49 1.617l-2.744 2.744q-.784.784-1.96.441t-2.352-.343l-46.599 0q-3.675 0-6.321 2.646t-2.646 6.321l0 46.599q0 3.675 2.646 6.321t6.321 2.646l46.599 0q3.675 0 6.321-2.646t2.646-6.321l0-7.056q0-.735.49-1.225l3.577-3.577q.833-.833 1.96-.392t1.127 1.617zm7.203-51.646q2.254 0 3.773 1.568l8.526 8.526q1.568 1.568 1.568 3.822t-1.568 3.773l-5.145 5.145-16.121-16.121 5.145-5.145q1.568-1.568 3.822-1.568z",
 *      width: 100,
 *      height: 78.912,
 *   };
 *   <InlineIcon {...editIcon} />
 *
 */
const InlineIcon = _ref => {
  let {
    path,
    width,
    height,
    style = {},
    title
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement("svg", {
    role: "img",
    "aria-hidden": !title,
    style: {
      verticalAlign: "middle",
      ...style
    },
    width: "".concat(width / height, "em"),
    height: "1em",
    viewBox: "0 0 ".concat(width, " ").concat(height)
  }, !!title && /*#__PURE__*/React__namespace.createElement("title", null, title), /*#__PURE__*/React__namespace.createElement("path", {
    d: path,
    fill: "currentColor"
  }));
};

let _dependencies = null;
const setDependencies = dependencies => {
  _dependencies = dependencies;
};
const getDependencies = () => {
  if (_dependencies) {
    return _dependencies;
  }
  throw new Error(["Perseus has not been provided required dependencies.", "setDependencies(dependencies) must be called first.", "Make sure Perseus is being imported from javascript/perseus/perseus.js."].join("\n"));
};

var dependencies = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setDependencies: setDependencies,
    getDependencies: getDependencies
});

const prettyBig = {
  fontSize: "150%"
};
const slightlyBig = {
  fontSize: "120%"
};
const symbStyle = {
  fontSize: "130%"
};
// These are functions because we want to generate a new component for each use
// on the page rather than reusing an instance (which will cause an error).
// Also, it's useful for things which might look different depending on the
// props.

const basic = [() => [/*#__PURE__*/React__namespace.createElement("span", {
  key: "plus",
  style: slightlyBig
}, "+"), "+"], () => [/*#__PURE__*/React__namespace.createElement("span", {
  key: "minus",
  style: prettyBig
}, "-"), "-"],
// TODO(joel) - display as \cdot when appropriate
props => {
  const {
    TeX
  } = getDependencies();
  if (props.convertDotToTimes) {
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "times",
      style: prettyBig
    }, i18n__namespace.doNotTranslate("\\times")), "\\times"];
  }
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "times",
    style: prettyBig
  }, i18n__namespace.doNotTranslate("\\cdot")), "\\cdot"];
}, () => {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "frac",
    style: prettyBig
  }, i18n__namespace.doNotTranslate("\\frac{x}{y}")),
  // If there's something in the input that can become part of a
  // fraction, typing "/" puts it in the numerator. If not, typing
  // "/" does nothing. In that case, enter a \frac.
  input => {
    const contents = input.latex();
    input.typedText("/");
    if (input.latex() === contents) {
      input.cmd("\\frac");
    }
  }];
}];
const buttonSets = {
  basic,
  "basic+div": basic.concat([() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "div"
    }, i18n__namespace.doNotTranslate("\\div")), "\\div"];
  }]),
  trig: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "sin"
    }, i18n__namespace.doNotTranslate("\\sin")), "\\sin"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "cos"
    }, i18n__namespace.doNotTranslate("\\cos")), "\\cos"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "tan"
    }, i18n__namespace.doNotTranslate("\\tan")), "\\tan"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "theta",
      style: symbStyle
    }, i18n__namespace.doNotTranslate("\\theta")), "\\theta"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement("span", {
      key: "phi"
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "perseus-sr-only"
    }, i18n__namespace.doNotTranslate("phi")), /*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pi",
      style: symbStyle
    }, i18n__namespace.doNotTranslate("\\phi"))), "\\phi"];
  }],
  prealgebra: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "sqrt"
    }, i18n__namespace.doNotTranslate("\\sqrt{x}")), "\\sqrt"];
  },
  // TODO(joel) - how does desmos do this?
  () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "nthroot"
    }, i18n__namespace.doNotTranslate("\\sqrt[3]{x}")), input => {
      input.typedText("nthroot3");
      input.keystroke("Right");
    }];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pow",
      style: slightlyBig
    }, i18n__namespace.doNotTranslate("a^b")), input => {
      const contents = input.latex();
      input.typedText("^");

      // If the input hasn't changed (for example, if we're
      // attempting to add an exponent on an empty input or an empty
      // denominator), insert our own "a^b"
      if (input.latex() === contents) {
        input.typedText("a^b");
      }
    }];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pi",
      style: slightlyBig
    }, i18n__namespace.doNotTranslate("\\pi")), "\\pi"];
  }],
  logarithms: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "log"
    }, i18n__namespace.doNotTranslate("\\log")), "\\log"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "ln"
    }, i18n__namespace.doNotTranslate("\\ln")), "\\ln"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "log_b"
    }, i18n__namespace.doNotTranslate("\\log_b")), input => {
      input.typedText("log_");
      input.keystroke("Right");
      input.typedText("(");
      input.keystroke("Left");
      input.keystroke("Left");
    }];
  }],
  "basic relations": [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "eq"
    }, "="), "="];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "lt"
    }, i18n__namespace.doNotTranslate("\\lt")), "\\lt"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "gt"
    }, i18n__namespace.doNotTranslate("\\gt")), "\\gt"];
  }],
  "advanced relations": [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "neq"
    }, i18n__namespace.doNotTranslate("\\neq")), "\\neq"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "leq"
    }, i18n__namespace.doNotTranslate("\\leq")), "\\leq"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "geq"
    }, i18n__namespace.doNotTranslate("\\geq")), "\\geq"];
  }]
};
const buttonSetsPropType = PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOf(___default["default"](buttonSets).keys()));
class TexButtons extends React__namespace.Component {
  render() {
    // Always show buttonSets in the same order. Note: Technically it's ok
    // for _.keys() to return the keys in an arbitrary order, but in
    // practice, they will be ordered as listed above.
    const sortedButtonSets = ___default["default"].sortBy(this.props.sets, setName =>
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | number' is not assignable to parameter of type 'string'.
    ___default["default"].keys(buttonSets).indexOf(setName));
    const buttons = ___default["default"](sortedButtonSets).map(setName => buttonSets[setName]);
    const buttonRows = ___default["default"](buttons).map(row => row.map(symbGen => {
      // create a (component, thing we should send to mathquill) pair
      const symbol = symbGen(this.props);
      return /*#__PURE__*/React__namespace.createElement("button", {
        onClick: () => this.props.onInsert(symbol[1]),
        className: "tex-button"
        // @ts-expect-error [FEI-5003] - TS2533 - Object is possibly 'null' or 'undefined'. | TS2339 - Property 'key' does not exist on type 'boolean | ReactChild | ReactFragment | ReactPortal'.
        ,
        key: symbol[0].key,
        type: "button"
      }, symbol[0]);
    }));
    const buttonPopup = ___default["default"](buttonRows).map((row, i) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "clearfix tex-button-row",
        key: this.props.sets[i]
      }, row);
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "".concat(this.props.className || "", " preview-measure")
    }, buttonPopup);
  }
}
_defineProperty(TexButtons, "buttonSets", buttonSets);
_defineProperty(TexButtons, "buttonSetsType", buttonSetsPropType);

// A WYSIWYG math input that calls `onChange(LaTeX-string)`
class MathInput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "mouseDown", void 0);
    _defineProperty(this, "state", {
      focused: false
    });
    _defineProperty(this, "handleFocus", () => {
      this.setState({
        focused: true
      });
      // TODO(joel) fix properly - we should probably allow onFocus handlers
      // to this property, but we need to work correctly with them.
      // if (this.props.onFocus) {
      //     this.props.onFocus();
      // }
    });
    _defineProperty(this, "handleMouseDown", event => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2345 - Argument of type 'EventTarget | null' is not assignable to parameter of type 'Node | null'.
      const focused = ReactDOM__default["default"].findDOMNode(this).contains(event.target);
      this.mouseDown = focused;
      if (!focused) {
        this.setState({
          focused: false
        });
      }
    });
    _defineProperty(this, "handleMouseUp", () => {
      // this mouse click started in the buttons div so we should focus the
      // input
      if (this.mouseDown) {
        this.focus();
      }
      this.mouseDown = false;
    });
    _defineProperty(this, "handleBlur", e => {
      // TODO(michaelpolyak): Consider trapping focus within the button group.
      // Focusing back on the input when TAB out of the last button in the
      // group. This will probably require ESCAPE key handling to enable to
      // close (blur) the button group in order to focus on next page element.
      if (!this.mouseDown &&
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
      !ReactDOM__default["default"].findDOMNode(this).contains(e.relatedTarget)) {
        this.setState({
          focused: false
        });
      }
    });
    _defineProperty(this, "_shouldShowButtons", () => {
      if (this.props.buttonsVisible === "always") {
        return true;
      }
      if (this.props.buttonsVisible === "never") {
        return false;
      }
      return this.state.focused;
    });
    _defineProperty(this, "insert", value => {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      const input = this.mathField();
      if (___default["default"](value).isFunction()) {
        value(input);
      } else if (value[0] === "\\") {
        input.cmd(value).focus();
      } else {
        input.write(value).focus();
      }
      input.focus();
    });
    _defineProperty(this, "mathField", options => {
      // The MathQuill API is now "versioned" through its own "InterVer"
      // system.
      // See: https://github.com/mathquill/mathquill/pull/459
      const MQ = MathQuill__default["default"].getInterface(2);

      // MathQuill.MathField takes a DOM node, MathQuill-ifies it if it's
      // seeing that node for the first time, then returns the associated
      // MathQuill object for that node. It is stable - will always return
      // the same object when called on the same DOM node.
      // eslint-disable-next-line react/no-string-refs
      return MQ.MathField(ReactDOM__default["default"].findDOMNode(this.refs.mathinput), options);
    });
    _defineProperty(this, "focus", () => {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      this.mathField().focus();
      this.setState({
        focused: true
      });
    });
    _defineProperty(this, "blur", () => {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      this.mathField().blur();
      this.setState({
        focused: false
      });
    });
  }
  componentDidMount() {
    window.addEventListener("mousedown", this.handleMouseDown);
    window.addEventListener("mouseup", this.handleMouseUp);
    let initialized = false;

    // Initialize MathQuill.MathField instance
    this.mathField({
      // LaTeX commands that, when typed, are immediately replaced by the
      // appropriate symbol. This does not include ln, log, or any of the
      // trig functions; those are always interpreted as commands.
      autoCommands: "pi theta phi sqrt nthroot",
      // Pop the cursor out of super/subscripts on arithmetic operators
      // or (in)equalities.
      charsThatBreakOutOfSupSub: "+-*/=<>≠≤≥",
      // Prevent excessive super/subscripts or fractions from being
      // created without operands, e.g. when somebody holds down a key
      supSubsRequireOperand: true,
      // The name of this option is somewhat misleading, as tabbing in
      // MathQuill breaks you out of a nested context (fraction/script)
      // if you're in one, but moves focus to the next input if you're
      // not. Spaces (with this option enabled) are just ignored in the
      // latter case.
      //
      // TODO(alex): In order to allow inputting mixed numbers, we will
      // have to accept spaces in certain cases. The desired behavior is
      // still to escape nested contexts if currently in one, but to
      // insert a space if not (we don't expect mixed numbers in nested
      // contexts). We should also limit to one consecutive space.
      spaceBehavesLikeTab: true,
      handlers: {
        edited: mathField => {
          // This handler is guaranteed to be called on change, but
          // unlike React it sometimes generates false positives.
          // One of these is on initialization (with an empty string
          // value), so we have to guard against that below.
          let value = mathField.latex();

          // Provide a MathQuill-compatible way to generate the
          // not-equals sign without pasting unicode or typing TeX
          value = value.replace(/<>/g, "\\ne");

          // Use the specified symbol to represent multiplication
          // TODO(alex): Add an option to disallow variables, in
          // which case 'x' should get converted to '\\times'
          if (this.props.convertDotToTimes) {
            value = value.replace(/\\cdot/g, "\\times");

            // Preserve cursor position in the common case:
            // typing '*' to insert a multiplication sign.
            // We do this by modifying internal MathQuill state
            // directly, instead of waiting for `.latex()` to be
            // called in `componentDidUpdate()`.
            const left = mathField.__controller.cursor[MathQuill__default["default"].L];
            if (left && left.ctrlSeq === "\\cdot ") {
              mathField.__controller.backspace();
              mathField.cmd("\\times");
            }
          } else {
            value = value.replace(/\\times/g, "\\cdot");
          }
          if (initialized && this.props.value !== value) {
            this.props.onChange(value);
          }
        },
        enter: () => {
          // NOTE(kevinb): This isn't how answers to exercises are
          // submitted.  The actual mechanism for this can be found
          // in exercise-problem-template.jsx, see `handleSubmit`.

          // This handler is called when the user presses the enter
          // key. Since this isn't an actual <input> element, we have
          // to manually trigger the usually automatic form submit.
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'submit' does not exist on type 'JQueryStatic'.
          $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.mathinput)).submit();
        },
        upOutOf: mathField => {
          // This handler is called when the user presses the up
          // arrow key, but there is nowhere in the expression to go
          // up to (no numerator or exponent). For ease of use,
          // interpret this as an attempt to create an exponent.
          mathField.typedText("^");
        }
      }
    });

    // Ideally, we would be able to pass an initial value directly into
    // the constructor above
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
    this.mathField().latex(this.props.value);
    initialized = true;
  }
  componentWillUnmount() {
    window.removeEventListener("mousedown", this.handleMouseDown);
    window.removeEventListener("mouseup", this.handleMouseUp);
  }

  // handlers:
  // keep track of two related bits of state:
  // * this.state.focused - whether the buttons are currently shown
  // * this.mouseDown - whether a mouse click is active that started in the
  //   buttons div

  render() {
    let className = classNames__default["default"]({
      "perseus-math-input": true,
      // mathquill usually adds these itself but react removes them when
      // updating the component.
      "mq-editable-field": true,
      "mq-math-mode": true
    });
    if (this.props.className) {
      className = className + " " + this.props.className;
    }
    let buttons = null;
    if (this._shouldShowButtons()) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Element' is not assignable to type 'null'.
      buttons = /*#__PURE__*/React__namespace.createElement(TexButtons, {
        sets: this.props.buttonSets,
        className: "math-input-buttons absolute",
        convertDotToTimes: this.props.convertDotToTimes,
        onInsert: this.insert
      });
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: className
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "mathinput",
      "aria-label": this.props.labelText,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    })), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative"
      },
      onBlur: this.handleBlur
    }, buttons));
  }
}
_defineProperty(MathInput, "defaultProps", {
  value: "",
  convertDotToTimes: false,
  buttonsVisible: "focused"
});

const zIndex = 10;
let HorizontalDirection = /*#__PURE__*/function (HorizontalDirection) {
  HorizontalDirection["Left"] = "left";
  HorizontalDirection["Right"] = "right";
  return HorizontalDirection;
}({});
let VerticalDirection = /*#__PURE__*/function (VerticalDirection) {
  VerticalDirection["Top"] = "top";
  VerticalDirection["Bottom"] = "bottom";
  return VerticalDirection;
}({});
const Triangle = props => {
  let borderLeft;
  let borderRight;
  let borderTop;
  let borderBottom;
  const hBorder = "".concat(props.width, "px solid transparent");
  if (props.horizontalDirection === "right") {
    borderLeft = hBorder;
  } else {
    borderRight = hBorder;
  }
  const vBorder = "".concat(props.height, "px solid ").concat(props.color);
  if (props.verticalDirection === "top") {
    borderTop = vBorder;
  } else {
    borderBottom = vBorder;
  }
  return /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      display: "block",
      height: 0,
      width: 0,
      position: "absolute",
      left: props.left,
      top: props["top"],
      borderLeft: borderLeft,
      borderRight: borderRight,
      borderTop: borderTop,
      borderBottom: borderBottom
    }
  });
};
const TooltipArrow = props => {
  // TODO(aria): Think about adding a box-shadow to the triangle here
  // See http://css-tricks.com/triangle-with-shadow/

  //const isRight = (this.props.horizontalDirection === "right");
  const isTop = props.verticalDirection === "top";
  const frontTopOffset = isTop ? 0 : 1;
  const borderTopOffset = isTop ? 0 : -1;
  return /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      display: "block",
      position: props.position,
      visibility: props.visibility,
      left: props.left,
      top: props["top"],
      width: props.width + 2,
      height: props.height + 1,
      marginTop: -1,
      marginBottom: -2,
      zIndex: zIndex
    }
  }, /*#__PURE__*/React__namespace.createElement(Triangle, {
    horizontalDirection: props.horizontalDirection,
    verticalDirection: props.verticalDirection,
    color: props.border,
    left: 0,
    top: borderTopOffset,
    width: props.width + 2 // one extra for the diagonal
    ,
    height: props.height + 2
  }), /*#__PURE__*/React__namespace.createElement(Triangle, {
    horizontalDirection: props.horizontalDirection,
    verticalDirection: props.verticalDirection,
    color: props.color,
    left: 1,
    top: frontTopOffset,
    width: props.width,
    height: props.height
  }));
};
TooltipArrow.defaultProps = {
  position: "relative",
  visibility: "visible",
  left: 0,
  top: 0
};
const VERTICAL_CORNERS = {
  top: {
    top: "-100%"
  },
  bottom: {
    top: 0
  }
};
const HORIZONTAL_CORNERS = {
  left: {
    targetLeft: 0
  },
  right: {
    targetLeft: "100%"
  }
};
const HORIZONTAL_ALIGNMNENTS = {
  left: {
    tooltipLeft: 0,
    arrowLeft: arrowSize => 0
  },
  right: {
    tooltipLeft: "-100%",
    arrowLeft: arrowSize => -arrowSize - 2
  }
};
class Tooltip extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      height: null // used for offsetting "top" positioned tooltips
    });
  }

  componentDidMount() {
    this._updateHeight();
  }
  UNSAFE_componentWillReceiveProps() {
    // If the contents have changed, reset our measure of the height
    this.setState({
      height: null
    });
  }
  componentDidUpdate() {
    this._updateHeight();
  }
  _renderToolTipDiv(isTooltipAbove) {
    const settings = Object.assign({}, HORIZONTAL_CORNERS[this.props.horizontalPosition], HORIZONTAL_ALIGNMNENTS[this.props.horizontalAlign], VERTICAL_CORNERS[this.props.verticalPosition]);
    let arrowAbove;
    let arrowBelow;
    if (isTooltipAbove) {
      // We put an absolutely positioned arrow in the correct place
      arrowAbove = /*#__PURE__*/React__namespace.createElement(TooltipArrow, {
        verticalDirection: VerticalDirection.Top,
        horizontalDirection: this.props.horizontalAlign,
        position: "absolute",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -this.props.arrowSize + 2,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });

      // And we use a visibility: hidden arrow below to shift up the
      // content by the correct amount
      arrowBelow = /*#__PURE__*/React__namespace.createElement(TooltipArrow, {
        verticalDirection: VerticalDirection.Top,
        horizontalDirection: this.props.horizontalAlign,
        visibility: "hidden",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
    } else {
      arrowAbove = /*#__PURE__*/React__namespace.createElement(TooltipArrow, {
        verticalDirection: VerticalDirection.Bottom,
        horizontalDirection: this.props.horizontalAlign,
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
      arrowBelow = null;
    }

    /* A positioned div below the input to be the parent for our
        tooltip */
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative",
        height: 0,
        display: this.props.show ? "block" : "none"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      // eslint-disable-next-line react/no-string-refs
      ref: "tooltipContainer",
      className: "tooltipContainer",
      style: {
        position: "absolute",
        // height must start out undefined, not null, so that
        // we can measure the actual height with jquery.
        // This is used to position the tooltip with top: -100%
        // when in verticalPosition: "top" mode
        height: this.state.height || undefined,
        left: settings.targetLeft
      }
    }, arrowAbove, /*#__PURE__*/React__namespace.createElement("div", {
      className: this.props.className
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "tooltipContent",
      style: {
        position: "relative",
        top: settings["top"],
        left: settings.tooltipLeft,
        border: "1px solid " + this.props.borderColor,
        boxShadow: "0 1px 3px " + this.props.borderColor,
        zIndex: zIndex - 1
      }
    }, this.props.children.slice(1)), arrowBelow));
  }
  _updateHeight() {
    const tooltipContainer = ReactDOM__default["default"].findDOMNode(
    // eslint-disable-next-line react/no-string-refs
    this.refs.tooltipContainer);
    const height = tooltipContainer.offsetHeight;
    if (height !== this.state.height) {
      this.setState({
        height
      });
    }
  }
  render() {
    const isTooltipAbove = this.props.verticalPosition === "top";

    /* We wrap the entire output in a span so that it displays inline */
    return /*#__PURE__*/React__namespace.createElement("span", null, isTooltipAbove && this._renderToolTipDiv(isTooltipAbove), /*#__PURE__*/React__namespace.createElement("div", {
      style: this.props.targetContainerStyle
    }, this.props.children[0]), !isTooltipAbove && this._renderToolTipDiv());
  }
}

// Sorry.  // Apology-Oriented-Programming
_defineProperty(Tooltip, "defaultProps", {
  className: "",
  arrowSize: 10,
  borderColor: "#ccc",
  verticalPosition: VerticalDirection.Bottom,
  horizontalPosition: HorizontalDirection.Left,
  horizontalAlign: HorizontalDirection.Left,
  targetContainerStyle: {}
});

/**
 * Icon paths to be used with `inline-icon.jsx`.
 *
 * These paths are taken directly from webapp's `icon-paths.js`. Unlike the
 * webapp equivalent, these can be directly required within Perseus files since
 * this is all bundled together anyway.
 */

const iconCheck = {
  path: "M8.70710678,12.2928932 C8.31658249,11.9023689 7.68341751,11.9023689 7.29289322,12.2928932 C6.90236893,12.6834175 6.90236893,13.3165825 7.29289322,13.7071068 L9.82842712,16.2426407 C10.2207367,16.6349502 10.8574274,16.6328935 11.2471942,16.2380576 L16.7116603,10.7025237 C17.0996535,10.3094846 17.0955629,9.67633279 16.7025237,9.28833966 C16.3094846,8.90034653 15.6763328,8.90443714 15.2883397,9.29747629 L10.5309507,14.1167372 L8.70710678,12.2928932 Z",
  width: 24,
  height: 24
};
const iconCheckMedium = {
  path: "M6.072 10.4l6.175-7.058a1 1 0 1 1 1.506 1.317L6.769 12.64a1 1 0 0 1-1.55-.054L2.203 8.604a1 1 0 1 1 1.594-1.208L6.072 10.4z",
  width: 16,
  height: 16
};
const iconChevronDown = {
  path: "M99.669 13.048q0 3.36-2.352 5.712l-41.664 41.664q-2.408 2.408-5.88 2.408t-5.712-2.408l-41.664-41.664q-2.408-2.24-2.408-5.712t2.408-5.88l4.76-4.816q2.52-2.352 5.88-2.352t5.656 2.352l31.136 31.136 31.08-31.136q2.352-2.352 5.712-2.352t5.88 2.352l4.816 4.816q2.352 2.52 2.352 5.88z",
  width: 100,
  height: 63.034
};
const iconChevronRight = {
  path: "M62.808 49.728q0 3.36-2.352 5.88l-41.72 41.664q-2.352 2.408-5.768 2.408t-5.768-2.408l-4.872-4.76q-2.352-2.52-2.352-5.88t2.352-5.712l31.08-31.136-31.08-31.024q-2.352-2.52-2.352-5.88t2.352-5.712l4.872-4.76q2.296-2.408 5.768-2.408t5.768 2.408l41.72 41.664q2.352 2.296 2.352 5.656z",
  width: 63.034,
  height: 100
};
const iconCircle = {
  path: "M100.035 50.046q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleArrowDown = {
  path: "M50.046 83.676q1.767 0 2.907-1.14l29.526-29.526q1.197-1.197 1.197-2.907t-1.197-2.964l-5.928-5.928q-1.197-1.14-2.964-1.14t-2.907 1.14l-12.312 12.312l0-32.661q0-1.71-1.254-2.964t-2.907-1.254l-8.322 0q-1.71 0-2.964 1.254t-1.254 2.964l0 32.661l-12.312-12.312q-1.197-1.254-2.907-1.254t-2.907 1.254l-5.928 5.928q-1.197 1.197-1.197 2.964t1.197 2.907l29.469 29.526q1.197 1.14 2.964 1.14zm49.989-33.63q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleArrowUp = {
  path: "M54.207 83.391q1.653 0 2.907-1.254t1.254-2.907l0-32.718l12.312 12.312q1.254 1.254 2.964 1.254t2.907-1.254l5.928-5.928q1.197-1.197 1.14-2.964 0-1.767-1.14-2.907l-29.526-29.526q-1.197-1.14-2.907-1.14t-2.964 1.14l-29.469 29.526q-1.197 1.254-1.197 2.964t1.197 2.907l5.928 5.928q1.197 1.197 2.907 1.197t2.907-1.197l12.312-12.312l0 32.718q0 1.653 1.254 2.907t2.964 1.254l8.322 0zm45.828-33.345q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleThin = {
  path: "M50.046 8.322q-8.493 0-16.188 3.306-15.561 6.669-22.173 22.23-3.363 7.695-3.363 16.188t3.306 16.188 8.949 13.281q5.586 5.586 13.281 8.892t16.188 3.306 16.188-3.306 13.281-8.892 8.892-13.281 3.306-16.188-3.306-16.188-8.892-13.281-13.281-8.949q-7.695-3.306-16.188-3.306zm0 91.713q-13.623 0-25.137-6.726t-18.183-18.183q-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.126q-11.514 6.726-25.08 6.726z",
  width: 100,
  height: 99.944
};
const iconDesktop = {
  path: "M94.208 52.119l0-43.746q0-.69-.506-1.15t-1.196-.506l-84.088 0q-.69 0-1.196.506t-.506 1.15l0 43.746q0 .69.506 1.196t1.196.506l84.088 0q.69 0 1.196-.506t.506-1.196zm6.716-43.746l0 57.224q0 3.45-2.484 5.934t-5.934 2.484l-28.566 0q0 3.128 2.53 7.774.828 1.61.828 2.622t-1.012 2.07q-1.012 1.012-2.346.966l-26.91 0q-1.38 0-2.392-1.012t-1.012-2.024q0-1.058 1.656-4.14t1.748-6.256l-28.612 0q-3.45 0-5.934-2.484t-2.484-5.934l0-57.224q0-3.45 2.484-5.934t5.934-2.438l84.088 0q3.45 0 5.98 2.438 2.438 2.484 2.438 5.934z",
  width: 100,
  height: 86.648
};
const iconDropdownArrow = {
  path: "M9 9.8c0 .5.7 1.7 1.5 2.8 1.5 1.9 1.5 1.9 3 0C15.7 9.7 15.4 9 12 9c-1.6 0-3 .4-3 .8z",
  width: 24,
  height: 24
};
const iconExclamationSign = {
  path: "M58.368 81.225l0-12.369q0-.912-.57-1.539t-1.425-.627l-12.54 0q-.855-.057-1.482.627t-.684 1.539l0 12.369q-.057.855.627 1.482t1.539.684l12.54 0q.855 0 1.425-.627t.57-1.539zm1.026-62.871q0-1.596-2.223-1.71l-14.307 0q-2.109 0-2.223 1.71l1.14 40.47q0 .627.627 1.14t1.539.456l12.084 0q.912-.057 1.539-.513t.684-1.083zm-9.348-18.354q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669z",
  width: 100,
  height: 99.944
};
// Grabbed from https://github.com/encharm/Font-Awesome-SVG-PNG
const iconGear = {
  path: "M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z",
  width: 1792,
  height: 1792
};
const iconMobilePhone = {
  path: "M36.04 89.557q0-2.584-1.836-4.42t-4.42-1.836-4.352 1.836q-1.836 1.836-1.836 4.42t1.836 4.352 4.42 1.836q2.652-.068 4.42-1.836t1.768-4.352zm16.184-12.444l0-54.74q0-1.088-.748-1.768t-1.768-.68l-39.78 0q-1.088 0-1.768.748t-.68 1.7l0 54.74q0 1.02.748 1.768t1.7.68l39.78 0q1.02-.068 1.768-.748t.748-1.7zm-14.892-65.892q0-1.224-1.292-1.292l-12.444 0q-1.224.068-1.224 1.292t1.224 1.224l12.444 0q1.292 0 1.292-1.224zm22.372-1.292l0 79.628q0 3.944-2.992 6.936t-7.004 2.992l-39.78 0q-4.012 0-7.004-2.924-2.924-2.924-2.924-7.004l0-79.628q0-4.012 2.924-6.936t7.004-2.992l39.78 0q4.012-.068 7.004 2.924t2.992 7.004z",
  width: 60.013,
  height: 100
};
const iconOk = {
  path: "M37.964 76.048q-2.576 0-4.368-1.792l-31.864-31.864q-1.792-1.792-1.792-4.368t1.792-4.368l8.736-8.68q1.792-1.792 4.368-1.792t4.312 1.792l18.816 18.872 42-42.056q1.792-1.792 4.368-1.792t4.312 1.792l8.736 8.736q1.792 1.792 1.792 4.368t-1.792 4.312l-55.048 55.048q-1.792 1.792-4.368 1.792z",
  width: 100,
  height: 76.637
};
const iconPlus = {
  path: "M99.758 43.09l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-29.45 0l0 29.45q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-29.45l-29.45 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l29.45 0l0-29.45q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836l0 29.45l29.45 0q2.852 0 4.836 1.984t1.984 4.836z",
  width: 100,
  height: 100
};
const iconRemove = {
  path: "M100.464 80.808q0 3.404-2.368 5.772l-11.47 11.544q-2.368 2.368-5.772 2.368t-5.698-2.368l-24.864-24.864-24.864 24.864q-2.368 2.368-5.772 2.368t-5.772-2.368l-11.47-11.544q-2.368-2.368-2.368-5.772t2.368-5.698l24.864-24.864-24.864-24.864q-2.368-2.368-2.368-5.772t2.368-5.772l11.47-11.47q2.368-2.368 5.772-2.368t5.772 2.368l24.864 24.864 24.864-24.864q2.294-2.368 5.698-2.368t5.772 2.368l11.47 11.47q2.368 2.368 2.368 5.772t-2.368 5.772l-24.864 24.864 24.864 24.864q2.368 2.294 2.368 5.698z",
  width: 100,
  height: 100
};
const iconStar = {
  path: "M15.1052249,9.55978547 L22.0028147,9.55978545 C23.6568673,9.55978545 23.9349557,10.3753626 22.6181351,11.3858845 L16.9943688,15.7015366 L19.2518801,22.8294455 C19.7526645,24.4106317 19.0984455,24.8825885 17.769353,23.8673293 L12.0490577,19.4977438 L6.5116497,23.8422153 C5.20921411,24.8640642 4.53299569,24.4067544 5.00266927,22.8160582 L7.10332364,15.7015366 L1.42794544,11.3634306 C0.110226041,10.3562014 0.383967283,9.54239221 2.0409646,9.54574013 L8.9924676,9.55978547 L11.1485117,2.72669438 C11.6458693,1.15043244 12.4548928,1.15900049 12.9494787,2.72669438 L15.1052249,9.55978547 Z",
  width: 24,
  height: 24
};
const iconTryAgain = {
  path: "M3.74890556,17.9799506 C2.19251241,16.1970909 1.10103636,13.4971457 1.13090903,11.1491783 C1.17160478,7.95052637 4.01704076,0.865059407 11.7028044,0.865059407 C19.388568,0.865059407 22.3026521,7.35203035 22.3026521,11.5879453 C22.3026521,15.8238603 19.386629,20.5574509 13.6832464,21.7131548 L13.6757539,17.3722171 C17.0812986,16.2190517 18.331158,14.1944123 18.3311578,11.5879451 C18.3311574,8.16554692 15.6664205,5.03476549 11.7028048,5.20494205 C7.73918903,5.37511861 5.59244567,8.66930079 5.59244567,11.1491783 C5.59244567,12.9090077 6.11128139,14.1753512 6.93640437,15.3053215 L8.14052356,14.2949456 C8.98559348,13.5858477 9.6994861,13.9070448 9.73489556,15.0076413 L9.91284941,20.5388014 C9.94832683,21.6415103 9.09967118,22.3514475 8.02194403,22.1254594 L2.60571602,20.9897332 C1.5259204,20.7633114 1.34338662,19.9984207 2.18070755,19.295825 L3.74890556,17.9799506 Z",
  width: 23,
  height: 23
};
const iconTablet = {
  path: "M45.322 90.706q0-1.86-1.302-3.224-1.364-1.364-3.224-1.364t-3.224 1.364-1.302 3.224q0 1.86 1.364 3.224 1.302 1.364 3.162 1.302 1.86.062 3.224-1.302t1.302-3.224zm27.218-11.346l0-68.014q0-.93-.682-1.612t-1.55-.682l-58.962 0q-.93 0-1.612.682t-.682 1.612l0 68.014q0 .93.682 1.612t1.612.62l58.962 0q.992-.062 1.612-.682t.62-1.55zm9.114-68.014l0 77.066q0 4.65-3.348 7.998t-7.998 3.348l-58.962 0q-4.65 0-7.998-3.348t-3.348-7.998l0-77.066q0-4.65 3.348-7.998t7.998-3.348l58.962 0q4.65 0 7.998 3.348t3.348 7.998z",
  width: 81.852,
  height: 100
};
const iconTrash = {
  path: "M31.293 37.506q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.218 0q-.912-.057-1.482-.627t-.57-1.482l0-37.506q0-2.109 2.052-2.109l4.218 0zm18.753 2.109l0 37.506q0 .912-.57 1.482t-1.539.627l-4.161 0q-1.995 0-2.109-2.109l0-37.506q.057-.912.627-1.482t1.482-.627l4.161 0q.969.057 1.539.627t.57 1.482zm14.592-2.109q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.161 0q-.969-.057-1.539-.627t-.57-1.482l0-37.506q0-2.109 2.109-2.109l4.161 0zm10.431 49.248l0-61.731l-58.368 0l0 61.731q.057 2.679.969 3.819t1.083 1.14l54.207 0q.171 0 1.14-1.083t.969-3.876zm-43.776-70.11l29.184 0l-3.135-7.581q-.456-.57-1.14-.741l-20.634 0q-.627.114-1.083.741zm-31.293 2.109q0-1.995 2.109-2.109l20.121 0l4.56-10.83q.969-2.394 3.477-4.104 2.565-1.71 5.187-1.71l20.805 0q2.622 0 5.187 1.71t3.477 4.104l4.56 10.83l20.178 0q.912.057 1.482.627t.57 1.482l0 4.161q0 1.995-2.052 2.109l-6.27 0l0 61.731q0 5.415-3.078 9.348t-7.353 3.933l-54.207 0q-4.275 0-7.353-3.819t-3.078-9.177l0-62.016l-6.213 0q-.969 0-1.539-.57t-.57-1.539l0-4.161z",
  width: 91.681,
  height: 100
};
const iconUndo = {
  path: "M10,6.6C10,7.2,9.8,8,9.3,9.1c0,0,0,0.1-0.1,0.1S9.2,9.3,9.2,9.4c0,0,0,0.1-0.1,0.1C9,9.6,9,9.6,8.9,9.6 c-0.1,0-0.1,0-0.1-0.1c0,0,0-0.1,0-0.1c0,0,0-0.1,0-0.1s0-0.1,0-0.1c0-0.3,0-0.5,0-0.7c0-0.4,0-0.7-0.1-1C8.6,7.1,8.5,6.9,8.4,6.7S8.2,6.3,8,6.1C7.8,5.9,7.6,5.8,7.4,5.7S6.9,5.5,6.7,5.5S6.1,5.4,5.8,5.4c-0.3,0-0.6,0-1,0H3.6v1.4c0,0.1,0,0.2-0.1,0.3C3.4,7.1,3.3,7.1,3.2,7.1C3.1,7.1,3,7.1,3,7L0.1,4.1C0,4.1,0,4,0,3.9s0-0.2,0.1-0.3L3,0.8C3,0.7,3.1,0.7,3.2,0.7c0.1,0,0.2,0,0.3,0.1C3.5,0.9,3.6,0.9,3.6,1v1.4h1.2c2.6,0,4.3,0.7,4.9,2.2C9.9,5.2,10,5.8,10,6.6z",
  width: 10,
  height: 10
};
const iconMinus = {
  path: "M8,13 L16,13 C16.5522847,13 17,12.5522847 17,12 C17,11.4477153 16.5522847,11 16,11 L8,11 C7.44771525,11 7,11.4477153 7,12 C7,12.5522847 7.44771525,13 8,13 Z",
  width: 24,
  height: 24
};

var iconPaths = /*#__PURE__*/Object.freeze({
    __proto__: null,
    iconCheck: iconCheck,
    iconCheckMedium: iconCheckMedium,
    iconChevronDown: iconChevronDown,
    iconChevronRight: iconChevronRight,
    iconCircle: iconCircle,
    iconCircleArrowDown: iconCircleArrowDown,
    iconCircleArrowUp: iconCircleArrowUp,
    iconCircleThin: iconCircleThin,
    iconDesktop: iconDesktop,
    iconDropdownArrow: iconDropdownArrow,
    iconExclamationSign: iconExclamationSign,
    iconGear: iconGear,
    iconMobilePhone: iconMobilePhone,
    iconOk: iconOk,
    iconPlus: iconPlus,
    iconRemove: iconRemove,
    iconStar: iconStar,
    iconTryAgain: iconTryAgain,
    iconTablet: iconTablet,
    iconTrash: iconTrash,
    iconUndo: iconUndo,
    iconMinus: iconMinus
});

// TODO(LP-11481): Change the primary API we use for logging in Perseus to use
// getDependencies() internally... simplify usage to just using a "singleton"
// which get's the injected logger.

/**
 * @typedef {Object} Errors utility for referencing the Perseus error taxonomy.
 */
const Errors = Object.freeze({
  /**
   * @property {ErrorKind} Unknown The kind of error is not known.
   */
  Unknown: "Unknown",
  /**
   * @property {ErrorKind} Internal The error is internal to the executing code.
   */
  Internal: "Internal",
  /**
   * @property {ErrorKind} InvalidInput There was a problem with the provided
   * input, such as the wrong format or a null value.
   */
  InvalidInput: "InvalidInput",
  /**
   * @property {ErrorKind} NotAllowed There was a problem due to the state of
   * the system not matching the requested operation or input. For example,
   * trying to create a username that is valid, but is already taken by
   * another user. Use {@link InvalidInput} instead when the input isn't
   * valid regardless of the state of the system. Use {@link NotFound} when
   * the failure is due to not being able to find a resource.
   */
  NotAllowed: "NotAllowed",
  /**
   * @property {ErrorKind} TransientService There was a problem when making a
   * request to a service.
   */
  TransientService: "TransientService",
  /**
   * @property {ErrorKind} Service There was a non-transient problem when
   * making a request to service.
   */
  Service: "Service"
});

/**
 * @type {ErrorKind} The kind of error being reported
 */

const Log = {
  // Logs a message
  log: (message, extra) => {
    getDependencies().Log.log(message, extra);
  },
  // Logs an error with a message
  error: (message, kind, extra) => {
    getDependencies().Log.error(message, kind, extra);
  }
};

class PerseusError extends Error {
  constructor(message, kind, options) {
    super(message);
    _defineProperty(this, "kind", void 0);
    _defineProperty(this, "metadata", void 0);
    this.kind = kind;
    this.metadata = options === null || options === void 0 ? void 0 : options.metadata;
  }
}

/**
 * These are things that widgets should exclude when serializing themselves.
 *
 * The use of this list needs to die. Basically, there are codepaths that
 * blindly serialize the "props" of a widget so that it can pass around its
 * info. Unfortunately, props aren't guaranteed to be serializable, and
 * automatically serializing schemaless list of attributes causes issues (e.g.
 * circular JSON structures sometimes).
 *
 * This blocks things that we know don't need to be serialized.
 */

const denylist = [
// standard props "added" by react
// (technically the renderer still adds them)
"key", "ref",
// added by src/renderer.jsx
"containerSizeClass", "widgetId", "onChange", "problemNum", "apiOptions", "questionCompleted", "findWidgets",
// added by src/editor.jsx, for widgets removing themselves
// this is soooo not the right place for this, but alas.
"onRemove",
// also added by src/editor.jsx
"id",
// Callbacks and items for interaction handling
"onBlur", "onFocus", "trackInteraction", "keypadElement"];
const removeDenylistProps = props => {
  const newProps = {
    ...props
  };
  for (const prop of denylist) {
    if (prop in newProps) {
      delete newProps[prop];
    }
  }
  return newProps;
};

/* eslint-disable @babel/no-invalid-this */
const USAGE = "Usage:\n" + "  this.change({propName: 5}, callback);\n" + '  this.change("propName", 5, callback);\n' + '  this.change("propName")';

/**
 * Primary helper function for this.change()
 *
 * Takes the parameters in a consistent style, once this.change() has
 * figured out which way it was called.
 */
const _changeMultiple = function (component, newProps, callback) {
  // Omit "default" props:
  // ref and key come from react, and don't actually represent
  //   the conceptual state of our component
  // onChange comes from our parent to allow this modification,
  //   and doesn't conceptually represent the state of our component
  const currProps = ___default["default"].omit(component.props, denylist);
  const nextProps = ___default["default"].extend(currProps, newProps);
  component.props.onChange(nextProps, callback);
};

/**
 * Helper function for changing a single prop
 */
const _changeSingle = function (component, propName, value, callback) {
  if (value === undefined) {
    // If called with a single prop name, return a lambda to change
    // a single prop on the current object
    return ___default["default"].partial(_changeSingle, component, propName);
  }
  // If called with two values, change a single prop of the
  // current object
  const newProps = {};
  newProps[propName] = value;
  _changeMultiple(component, newProps, callback);
};

/**
 * this.change()
 *
 * Can be called as follows:
 * this.change(newProps, callback);
 *
 * this.change(propName, propValue, callback);
 *
 * this.change(propName) -> returns a lambda that takes a prop value to
 * set and a callback to call after having set that value.
 */
// TODO(WEB-1727): use proper TypeScript syntax for overloaded functions
const change = function (newPropsOrSinglePropName, propValue, callback) {
  if (___default["default"].isObject(newPropsOrSinglePropName) && callback === undefined) {
    // Called with an object of multiple props to change
    callback = propValue;
    return _changeMultiple(
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this, newPropsOrSinglePropName,
    // object newProps
    callback);
  }
  if (typeof newPropsOrSinglePropName === "string") {
    // Called with a string propName of a single prop to change
    return _changeSingle(
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this, newPropsOrSinglePropName,
    // string propName
    propValue, callback);
  }
  throw new PerseusError("Invalid types sent to this.change(): " +
  // eslint-disable-next-line prefer-rest-params
  ___default["default"].toArray(arguments).join() + "\n" + USAGE, Errors.Internal);
};
const propTypes = {
  onChange: PropTypes__default["default"].func.isRequired
};

var changeable = /*#__PURE__*/Object.freeze({
    __proto__: null,
    change: change,
    propTypes: propTypes
});

const textWidthCache = {};
function getTextWidth(text) {
  if (!textWidthCache[text]) {
    // Hacky way to guess the width of an input box
    const $test = $__default["default"]("<span>").text(text).appendTo("body");
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
    textWidthCache[text] = $test.width() + 5;
    $test.remove();
  }
  return textWidthCache[text];
}
class TextListEditor extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      items: this.props.options.concat("")
    });
    _defineProperty(this, "onChange", (index, event) => {
      let items = ___default["default"].clone(this.state.items);
      items[index] = event.target.value;
      if (index === items.length - 1) {
        items = items.concat("");
      }
      this.setState({
        items: items
      });
      this.props.onChange(___default["default"].compact(items));
    });
    _defineProperty(this, "onKeyDown", (index, event) => {
      const which = event.nativeEvent.keyCode;

      // Backspace deletes an empty input...
      if (which === 8 /* backspace */ && this.state.items[index] === "") {
        event.preventDefault();
        const items = ___default["default"].clone(this.state.items);
        const focusIndex = index === 0 ? 0 : index - 1;
        if (index === items.length - 1 && (index === 0 || items[focusIndex] !== "")) {
          // ...except for the last one, iff it is the only empty
          // input at the end.
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
          ReactDOM__default["default"].findDOMNode(this.refs["input_" + focusIndex]).focus(); // eslint-disable-line react/no-string-refs
        } else {
          items.splice(index, 1);
          this.setState({
            items: items
          }, function () {
            // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
            ReactDOM__default["default"].findDOMNode(
            // eslint-disable-next-line react/no-string-refs
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.refs["input_" + focusIndex]
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'Element | Text'.
            ).focus();
          });
        }

        // Deleting the last character in the second-to-last input
        // removes it
      } else if (which === 8 /* backspace */ && this.state.items[index].length === 1 && index === this.state.items.length - 2) {
        event.preventDefault();
        const items = ___default["default"].clone(this.state.items);
        items.splice(index, 1);
        this.setState({
          items: items
        });
        this.props.onChange(___default["default"].compact(items));

        // Enter adds an option below the current one...
      } else if (which === 13 /* enter */) {
        event.preventDefault();
        const items = ___default["default"].clone(this.state.items);
        const focusIndex = index + 1;
        if (index === items.length - 2) {
          // ...unless the empty input is just below.
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
          ReactDOM__default["default"].findDOMNode(this.refs["input_" + focusIndex]).focus(); // eslint-disable-line react/no-string-refs
        } else {
          items.splice(focusIndex, 0, "");
          this.setState({
            items: items
          }, function () {
            // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
            ReactDOM__default["default"].findDOMNode(
            // eslint-disable-next-line react/no-string-refs
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.refs["input_" + focusIndex]
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'Element | Text'.
            ).focus();
          });
        }
      }
    });
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      items: nextProps.options.concat("")
    });
  }
  render() {
    const className = ["perseus-text-list-editor", "perseus-clearfix", "layout-" + this.props.layout].join(" ");
    const inputs = ___default["default"].map(this.state.items, function (item, i) {
      return /*#__PURE__*/React__namespace.createElement("li", {
        key: i
      }, /*#__PURE__*/React__namespace.createElement("input", {
        ref: "input_" + i,
        type: "text",
        value: item
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onChange: this.onChange.bind(this, i)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onKeyDown: this.onKeyDown.bind(this, i),
        style: {
          width: getTextWidth(item)
        }
      }));
    }, this);
    return /*#__PURE__*/React__namespace.createElement("ul", {
      className: className
    }, inputs);
  }
}
_defineProperty(TextListEditor, "propTypes", {
  options: PropTypes__default["default"].array,
  layout: PropTypes__default["default"].string,
  onChange: PropTypes__default["default"].func.isRequired
});
_defineProperty(TextListEditor, "defaultProps", {
  options: [],
  layout: "horizontal"
});

const EMPTY_ARRAY = [];
class StubTagEditor extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null, this.props.showTitle && /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        fontSize: 14
      }
    }, "Tags:"), /*#__PURE__*/React__namespace.createElement(TextListEditor, {
      options: this.props.value || EMPTY_ARRAY,
      layout: "vertical",
      onChange: this.props.onChange
    }));
  }
}
_defineProperty(StubTagEditor, "propTypes", {
  value: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  onChange: PropTypes__default["default"].func.isRequired,
  showTitle: PropTypes__default["default"].bool.isRequired
});
_defineProperty(StubTagEditor, "defaultProps", {
  value: EMPTY_ARRAY,
  showTitle: true
});

/**
 * [Most of] the Perseus client API.
 *
 * If making a change to this file, or otherwise to the perseus
 * API, you should increment:
 *  * the perseus api major version if it is a breaking change
 *  * the perseus api minor version if it is an additive-only change
 *  * nothing if it is purely a bug fix.
 *
 * Callbacks passed to Renderer/ItemRenderer:
 *  * onInputError:
 *    Called when there is an error grading a widget
 *  * onFocusChange: (newFocusPath, oldFocusPath, keypadDOMNode)
 *    Called when the user focus changes. The first two parameters are `path`
 *    arrays uniquely identifying the respect inputs. The third parameter,
 *    `keypadDOMNode`, is the DOM node of the custom keypad, or `null` if the
 *    keypad is disabled, which can be used by clients to accommodate for the
 *    appearance of the keypad on the screen.
 *    When focus changes to or from nothing being selected, `path` will be null.
 *  * interactionCallback: Called when the user interacts with a widget.
 *  * answerableCallback: Called with the current `answerability` of the
 *    problem, e.g. whether all required fields have input.
 *  * getAnotherHint: If provided, a button is rendered at the bottom of the
 *    hints (only when at least one hint has been shown, and not all hints
 *    have been shown) allowing the user to take another hint. This function
 *    is then called when the user clicks the button.
 *
 * Stable CSS ClassNames:
 * These are css class names that will continue to preserve their
 * semantic meaning across the same perseus api major version.
 */
const ApiOptions = {
  propTypes: PropTypes__default["default"].shape({
    isArticle: PropTypes__default["default"].bool.isRequired,
    onInputError: PropTypes__default["default"].func.isRequired,
    onFocusChange: PropTypes__default["default"].func.isRequired,
    GroupMetadataEditor: PropTypes__default["default"].func.isRequired,
    showAlignmentOptions: PropTypes__default["default"].bool.isRequired,
    readOnly: PropTypes__default["default"].bool.isRequired,
    answerableCallback: PropTypes__default["default"].func,
    getAnotherHint: PropTypes__default["default"].func,
    interactionCallback: PropTypes__default["default"].func,
    // A function that takes in the relative problem number (starts at
    // 0 and is incremented for each group widget), and the ID of the
    // group widget, then returns a react component that will be added
    // immediately above the renderer in the group widget. If the
    // function returns null, no annotation will be added.
    groupAnnotator: PropTypes__default["default"].func.isRequired,
    // If imagePlaceholder or widgetPlaceholder are set, perseus will
    // render the placeholder instead of the image or widget node.
    imagePlaceholder: PropTypes__default["default"].node,
    widgetPlaceholder: PropTypes__default["default"].node,
    // Base React elements that can be used in place of the standard DOM
    // DOM elements. For example, when provided, <Link /> will be used
    // in place of <a />. This allows clients to provide pre-styled
    // components or components with custom behavior.
    baseElements: PropTypes__default["default"].shape({
      // The <Link /> component provided here must adhere to the same
      // interface as React's base <a /> component.
      Link: PropTypes__default["default"].func
    }),
    // Function that takes dimensions and returns a React component
    // to display while an image is loading
    imagePreloader: PropTypes__default["default"].func,
    // Function that takes an object argument. The object should
    // include type and id, both strings, at least and can optionally
    // include a boolean "correct" value. This is used for keeping
    // track of widget interactions.
    trackInteraction: PropTypes__default["default"].func,
    // A boolean that indicates whether or not a custom keypad is
    // being used.  For mobile web this will be the ProvidedKeypad
    // component.  In this situation we use the MathInput component
    // from the math-input repo instead of the existing perseus math
    // input components.
    customKeypad: PropTypes__default["default"].bool,
    // If this is provided, it is called instead of appending an instance
    // of `math-input`'s keypad to the body. This is used by the native
    // apps so they can have the keypad be defined on the native side.
    // It is called with an function that, when called, blurs the input,
    // and is expected to return an object of the shape
    // keypadElementPropType from math-input/src/prop-types.js.
    nativeKeypadProxy: PropTypes__default["default"].func,
    // Indicates whether or not to use mobile styling.
    isMobile: PropTypes__default["default"].bool,
    // A function, called with a bool indicating whether use of the
    // drawing area (scratchpad) should be allowed/disallowed.
    // Previously handled by `Khan.scratchpad.enable/disable`
    setDrawingAreaAvailable: PropTypes__default["default"].func,
    // Whether to use the Draft.js editor or the legacy textarea
    useDraftEditor: PropTypes__default["default"].bool,
    // The color used for the hint progress indicator (eg. 1 / 3)
    hintProgressColor: PropTypes__default["default"].string,
    // Whether this Renderer is allowed to auto-scroll the rest of the
    // page. For example, if this is enabled, the most recently used
    // radio widget will attempt to keep the "selected" answer in view
    // after entering review mode.
    //
    // Defaults to `false`.
    canScrollPage: PropTypes__default["default"].bool,
    // Whether or not we are rendering content inside of a modal.
    inModal: PropTypes__default["default"].bool,
    // Whether to enable the cross-out feature on multiple-choice radio
    // widgets. This allows users to note which answers they believe to
    // be incorrect, to find the answer by process of elimination.
    //
    // We plan to roll this out to all call sites eventually, but for
    // now we have this flag, to add it to Generalized Test Prep first.
    crossOutEnabled: PropTypes__default["default"].bool,
    // The value in milliseconds by which the local state of content
    // in a editor is delayed before propagated to a prop. For example,
    // when text is typed in the text area of an Editor component,
    // there will be a delay equal to the value of `editorChangeDelay`
    // before the change is propagated. This is added for better
    // responsiveness of the editor when used in certain contexts such
    // as StructuredItem exercises where constant re-rendering for each
    // keystroke caused text typed in the text area to appear in it
    // only after a good few seconds.
    editorChangeDelay: PropTypes__default["default"].number
  }).isRequired,
  defaults: {
    isArticle: false,
    isMobile: false,
    onInputError: function () {},
    onFocusChange: function () {},
    GroupMetadataEditor: StubTagEditor,
    showAlignmentOptions: false,
    readOnly: false,
    groupAnnotator: function () {
      return null;
    },
    baseElements: {
      Link: props => {
        return /*#__PURE__*/React__namespace.createElement("a", props);
      }
    },
    setDrawingAreaAvailable: function () {},
    useDraftEditor: false,
    canScrollPage: false,
    inModal: false,
    crossOutEnabled: false,
    editorChangeDelay: 0
  }
};
const ClassNames = {
  RENDERER: "perseus-renderer",
  TWO_COLUMN_RENDERER: "perseus-renderer-two-columns",
  RESPONSIVE_RENDERER: "perseus-renderer-responsive",
  INPUT: "perseus-input",
  FOCUSED: "perseus-focused",
  RADIO: {
    OPTION: "perseus-radio-option",
    SELECTED: "perseus-radio-selected",
    OPTION_CONTENT: "perseus-radio-option-content"
  },
  INTERACTIVE: "perseus-interactive",
  CORRECT: "perseus-correct",
  INCORRECT: "perseus-incorrect",
  UNANSWERED: "perseus-unanswered",
  MOBILE: "perseus-mobile"
};

const KhanMath = {
  // Simplify formulas before display
  cleanMath: function (expr) {
    return typeof expr === "string" ? expr.replace(/\+\s*-/g, "- ").replace(/-\s*-/g, "+ ").replace(/\^1/g, "") : expr;
  },
  // Bound a number by 1e-6 and 1e20 to avoid exponents after toString
  bound: function (num) {
    if (num === 0) {
      return num;
    }
    if (num < 0) {
      return -KhanMath.bound(-num);
    }
    return Math.max(1e-6, Math.min(num, 1e20));
  },
  factorial: function (x) {
    if (x <= 1) {
      return x;
    }
    return x * KhanMath.factorial(x - 1);
  },
  getGCD: function (a, b) {
    if (arguments.length > 2) {
      // TODO(kevinb): rewrite using rest args instead of arguments
      // eslint-disable-next-line prefer-rest-params
      const rest = [].slice.call(arguments, 1);
      // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
      return KhanMath.getGCD(a, KhanMath.getGCD(...rest));
    }
    let mod;
    a = Math.abs(a);
    b = Math.abs(b);
    while (b) {
      mod = a % b;
      a = b;
      b = mod;
    }
    return a;
  },
  getLCM: function (a, b) {
    if (arguments.length > 2) {
      // TODO(kevinb): rewrite using rest args instead of arguments
      // eslint-disable-next-line prefer-rest-params
      const rest = [].slice.call(arguments, 1);
      // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
      return KhanMath.getLCM(a, KhanMath.getLCM(...rest));
    }
    return Math.abs(a * b) / KhanMath.getGCD(a, b);
  },
  primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],
  isPrime: function (n) {
    if (n <= 1) {
      return false;
    }
    if (n < 101) {
      return !!$__default["default"].grep(KhanMath.primes, function (p, i) {
        return Math.abs(p - n) <= 0.5;
      }).length;
    }
    if (n <= 1 || n > 2 && n % 2 === 0) {
      return false;
    }
    for (let i = 3, sqrt = Math.sqrt(n); i <= sqrt; i += 2) {
      if (n % i === 0) {
        return false;
      }
    }
    return true;
  },
  // @ts-expect-error [FEI-5003] - TS2366 - Function lacks ending return statement and return type does not include 'undefined'.
  getPrimeFactorization: function (number) {
    if (number === 1) {
      return [];
    }
    if (KhanMath.isPrime(number)) {
      return [number];
    }
    const maxf = Math.sqrt(number);
    for (let f = 2; f <= maxf; f++) {
      if (number % f === 0) {
        return $__default["default"].merge(KhanMath.getPrimeFactorization(f), KhanMath.getPrimeFactorization(number / f));
      }
    }
  },
  // Round a number to the nearest increment
  // E.g., if increment = 30 and num = 40, return 30. if increment = 30 and
  //     num = 45, return 60.
  roundToNearest: function (increment, num) {
    return Math.round(num / increment) * increment;
  },
  // Round a number to a certain number of decimal places
  roundTo: function (precision, num) {
    const factor = Math.pow(10, precision).toFixed(5);
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'number'. | TS2363 - The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. | TS2363 - The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    return Math.round((num * factor).toFixed(5)) / factor;
  },
  /**
   * Return a string of num rounded to a fixed precision decimal places,
   * with an approx symbol if num had to be rounded, and trailing 0s
   */
  toFixedApprox: function (num, precision) {
    // TODO(aria): Make this locale-dependent like KhanUtil.localeToFixed
    const fixedStr = num.toFixed(precision);
    if (kmath.number.equal(+fixedStr, num)) {
      return fixedStr;
    }
    return "\\approx " + fixedStr;
  },
  /**
   * Return a string of num rounded to precision decimal places, with an
   * approx symbol if num had to be rounded, but no trailing 0s if it was
   * not rounded.
   */
  roundToApprox: function (num, precision) {
    const fixed = KhanMath.roundTo(precision, num);
    if (kmath.number.equal(fixed, num)) {
      return String(fixed);
    }
    return KhanMath.toFixedApprox(num, precision);
  },
  // toFraction(4/8) => [1, 2]
  // toFraction(0.666) => [333, 500]
  // toFraction(0.666, 0.001) => [2, 3]
  //
  // tolerance can't be bigger than 1, sorry
  toFraction: function (decimal, tolerance) {
    if (tolerance == null) {
      tolerance = Math.pow(2, -46);
    }
    if (decimal < 0 || decimal > 1) {
      let fract = decimal % 1;
      fract += fract < 0 ? 1 : 0;
      const nd = KhanMath.toFraction(fract, tolerance);
      nd[0] += Math.round(decimal - fract) * nd[1];
      return nd;
    }
    if (Math.abs(Math.round(Number(decimal)) - decimal) <= tolerance) {
      return [Math.round(decimal), 1];
    }
    let loN = 0;
    let loD = 1;
    let hiN = 1;
    let hiD = 1;
    let midN = 1;
    let midD = 2;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (Math.abs(Number(midN / midD) - decimal) <= tolerance) {
        return [midN, midD];
      }
      if (midN / midD < decimal) {
        loN = midN;
        loD = midD;
      } else {
        hiN = midN;
        hiD = midD;
      }
      midN = loN + hiN;
      midD = loD + hiD;
    }
  },
  // Returns the format (string) of a given numeric string
  // Note: purposively more inclusive than answer-types' predicate.forms
  // That is, it is not necessarily true that interpreted input are numeric
  getNumericFormat: function (text) {
    text = $__default["default"].trim(text);
    text = text.replace(/\u2212/, "-").replace(/([+-])\s+/g, "$1");
    if (text.match(/^[+-]?\d+$/)) {
      return "integer";
    }
    if (text.match(/^[+-]?\d+\s+\d+\s*\/\s*\d+$/)) {
      return "mixed";
    }
    const fraction = text.match(/^[+-]?(\d+)\s*\/\s*(\d+)$/);
    if (fraction) {
      return parseFloat(fraction[1]) > parseFloat(fraction[2]) ? "improper" : "proper";
    }
    if (text.replace(/[,. ]/g, "").match(/^\d+$/)) {
      return "decimal";
    }
    if (text.match(/(pi?|\u03c0|t(?:au)?|\u03c4|pau)/)) {
      return "pi";
    }
    return null;
  },
  // Returns a string of the number in a specified format
  toNumericString: function (number, format) {
    if (number == null) {
      return "";
    }
    if (number === 0) {
      return "0"; // otherwise it might end up as 0% or 0pi
    }

    if (format === "percent") {
      return number * 100 + "%";
    }
    if (format === "pi") {
      const fraction = kmath.number.toFraction(number / Math.PI);
      const numerator = Math.abs(fraction[0]);
      const denominator = fraction[1];
      if (kmath.number.isInteger(numerator)) {
        const sign = number < 0 ? "-" : "";
        const pi = "\u03C0";
        return sign + (numerator === 1 ? "" : numerator) + pi + (denominator === 1 ? "" : "/" + denominator);
      }
    }
    if (___default["default"](["proper", "improper", "mixed", "fraction"]).contains(format)) {
      const fraction = kmath.number.toFraction(number);
      const numerator = Math.abs(fraction[0]);
      const denominator = fraction[1];
      const sign = number < 0 ? "-" : "";
      if (denominator === 1) {
        return sign + numerator; // for integers, irrational, d > 1000
      }

      if (format === "mixed") {
        const modulus = numerator % denominator;
        const integer = (numerator - modulus) / denominator;
        return sign + (integer ? integer + " " : "") + modulus + "/" + denominator;
      } // otherwise proper, improper, or fraction
      return sign + numerator + "/" + denominator;
    }

    // otherwise (decimal, float, long long)
    return String(number);
  }
};

/* eslint-disable no-useless-escape */
const MAXERROR_EPSILON = Math.pow(2, -42);
const errors = {
  APPROXIMATED_PI_ERROR: i18n__namespace._("Your answer is close, but you may " + "have approximated pi. Enter your " + "answer as a multiple of pi, like " + "<code>12\\ \\text{pi}</code> or " + "<code>2/3\\ \\text{pi}</code>"),
  EXTRA_SYMBOLS_ERROR: i18n__namespace._("We could not understand your " + "answer. Please check your answer for extra " + "text or symbols."),
  NEEDS_TO_BE_SIMPLFIED_ERROR: i18n__namespace._("Your answer is almost correct, " + "but it needs to be simplified."),
  MISSING_PERCENT_ERROR: i18n__namespace._("Your answer is almost correct, " + "but it is missing a " + "<code>\\%</code> at the end."),
  MULTIPLICATION_SIGN_ERROR: i18n__namespace._("I'm a computer. I only understand " + "multiplication if you use an asterisk " + "(*) as the multiplication sign."),
  WRONG_CASE_ERROR: i18n__namespace._("Your answer includes use of a variable with the wrong case."),
  WRONG_LETTER_ERROR: i18n__namespace._("Your answer includes a wrong variable letter.")
};

/*
 * Answer types
 *
 * Utility for creating answerable questions displayed in exercises
 *
 * Different answer types produce different kinds of input displays, and do
 * different kinds of checking on the solutions.
 *
 * Each of the objects contain two functions, setup and createValidator.
 *
 * The setup function takes a solutionarea and solution, and performs setup
 * within the solutionarea, and then returns an object which contains:
 *
 * answer: a function which, when called, will retrieve the current answer from
 *         the solutionarea, which can then be validated using the validator
 *         function
 * validator: a function returned from the createValidator function (defined
 *            below)
 * solution: the correct answer to the problem
 * showGuess: a function which, when given a guess, shows the guess within the
 *            provided solutionarea
 * showGuessCustom: a function which displays parts of a guess that are not
 *                  within the solutionarea; currently only used for custom
 *                  answers
 *
 * The createValidator function only takes a solution, and it returns a
 * function which can be used to validate an answer.
 *
 * The resulting validator function returns:
 * - true: if the answer is fully correct
 * - false: if the answer is incorrect
 * - "" (the empty string): if no answer has been provided (e.g. the answer box
 *   is left unfilled)
 * - a string: if there is some slight error
 *
 * In most cases, setup and createValidator don't really need the solution DOM
 * element so we have setupFunctional and createValidatorFunctional for them
 * which take only $solution.text() and $solution.data(). This makes it easier
 * to reuse specific answer types.
 *
 * TODO(alpert): Think of a less-absurd name for createValidatorFunctional.
 *
 */

const KhanAnswerTypes = {
  /*
   * predicate answer type
   *
   * performs simple predicate-based checking of a numeric solution, with
   * different kinds of number formats
   *
   * Uses the data-forms option on the solution to choose which number formats
   * are acceptable. Available data-forms:
   *
   * - integer:  3
   * - proper:   3/5
   * - improper: 5/3
   * - pi:       3 pi
   * - log:      log(5)
   * - percent:  15%
   * - mixed:    1 1/3
   * - decimal:  1.7
   *
   * The solution should be a predicate of the form:
   *
   * function(guess, maxError) {
   *     return abs(guess - 3) < maxError;
   * }
   *
   */
  predicate: {
    defaultForms: "integer, proper, improper, mixed, decimal",
    createValidatorFunctional: function (predicate, options) {
      // Extract the options from the given solution object
      options = ___default["default"].extend({
        simplify: "required",
        ratio: false,
        forms: KhanAnswerTypes.predicate.defaultForms
      }, options);
      let acceptableForms;
      // this is maintaining backwards compatibility
      // TODO(merlob) fix all places that depend on this, then delete
      if (!___default["default"].isArray(options.forms)) {
        acceptableForms = options.forms.split(/\s*,\s*/);
      } else {
        acceptableForms = options.forms;
      }

      // TODO(jack): remove options.inexact in favor of options.maxError
      if (options.inexact === undefined) {
        // If we aren't allowing inexact, ensure that we don't have a
        // large maxError as well.
        options.maxError = 0;
      }
      // Allow a small tolerance on maxError, to avoid numerical
      // representation issues (2.3 should be correct for a solution of
      // 2.45 with maxError=0.15).
      options.maxError = +options.maxError + MAXERROR_EPSILON;

      // If percent is an acceptable form, make sure it's the last one
      // in the list so we don't prematurely complain about not having
      // a percent sign when the user entered the correct answer in a
      // different form (such as a decimal or fraction)
      if (___default["default"].contains(acceptableForms, "percent")) {
        acceptableForms = ___default["default"].without(acceptableForms, "percent");
        acceptableForms.push("percent");
      }

      // Take text looking like a fraction, and turn it into a number
      const fractionTransformer = function (text) {
        text = text
        // Replace unicode minus sign with hyphen
        .replace(/\u2212/, "-")
        // Remove space after +, -
        .replace(/([+-])\s+/g, "$1")
        // Remove leading/trailing whitespace
        .replace(/(^\s*)|(\s*$)/gi, "");

        // Extract numerator and denominator
        const match = text.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
        // Fractions are represented as "-\frac{numerator}{denominator}"
        // in Mobile device input instead of "numerator/denominator" as
        // in web-browser.
        const mobileDeviceMatch = text.match(/^([+-]?)\\frac\{([+-]?\d+)\}\{([+-]?\d+)\}$/);
        const parsedInt = parseInt(text, 10);
        if (match || mobileDeviceMatch) {
          let num;
          let denom;
          let simplified = true;
          if (match) {
            num = parseFloat(match[1]);
            denom = parseFloat(match[2]);
          } else {
            num = parseFloat(mobileDeviceMatch[2]);
            if (mobileDeviceMatch[1] === "-") {
              if (num < 0) {
                simplified = false;
              }
              num = -num;
            }
            denom = parseFloat(mobileDeviceMatch[3]);
          }
          simplified = simplified && denom > 0 && (options.ratio || denom !== 1) && KhanMath.getGCD(num, denom) === 1;
          return [{
            value: num / denom,
            exact: simplified
          }];
        }
        if (!isNaN(parsedInt) && "" + parsedInt === text) {
          return [{
            value: parsedInt,
            exact: true
          }];
        }
        return [];
      };

      /*
       * Different forms of numbers
       *
       * Each function returns a list of objects of the form:
       *
       * {
       *    value: numerical value,
       *    exact: true/false
       * }
       */
      const forms = {
        // integer, which is encompassed by decimal
        integer: function (text) {
          // Compare the decimal form to the decimal form rounded to
          // an integer. Only accept if the user actually entered an
          // integer.
          const decimal = forms.decimal(text);
          const rounded = forms.decimal(text, 1);
          if (decimal[0].value != null && decimal[0].value === rounded[0].value || decimal[1].value != null && decimal[1].value === rounded[1].value) {
            return decimal;
          }
          return [];
        },
        // A proper fraction
        proper: function (text) {
          return $__default["default"].map(fractionTransformer(text), function (o) {
            // All fractions that are less than 1
            if (Math.abs(o.value) < 1) {
              return [o];
            }
            return [];
          });
        },
        // an improper fraction
        improper: function (text) {
          return $__default["default"].map(fractionTransformer(text), function (o) {
            // All fractions that are greater than 1
            if (Math.abs(o.value) >= 1) {
              return [o];
            }
            return [];
          });
        },
        // pi-like numbers
        pi: function (text) {
          let match;
          let possibilities = [];

          // Replace unicode minus sign with hyphen
          text = text.replace(/\u2212/, "-");

          // - pi
          // (Note: we also support \pi (for TeX), p, tau (and \tau,
          // and t), pau.)
          if (match = text.match(/^([+-]?)\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = [{
              value: parseFloat(match[1] + "1"),
              exact: true
            }];

            // 5 / 6 pi
          } else if (match = text.match(/^([+-]?\s*\d+\s*(?:\/\s*[+-]?\s*\d+)?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = fractionTransformer(match[1]);

            // 4 5 / 6 pi
          } else if (match = text.match(/^([+-]?)\s*(\d+)\s*([+-]?\d+)\s*\/\s*([+-]?\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            const sign = parseFloat(match[1] + "1");
            const integ = parseFloat(match[2]);
            const num = parseFloat(match[3]);
            const denom = parseFloat(match[4]);
            const simplified = num < denom && KhanMath.getGCD(num, denom) === 1;
            possibilities = [{
              value: sign * (integ + num / denom),
              exact: simplified
            }];

            // 5 pi / 6
          } else if (match = text.match(/^([+-]?\s*\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\s*\d+))?$/i)) {
            possibilities = fractionTransformer(match[1] + "/" + match[3]);

            // - pi / 4
          } else if (match = text.match(/^([+-]?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\d+))?$/i)) {
            possibilities = fractionTransformer(match[1] + "1/" + match[3]);

            // 0
          } else if (text === "0") {
            possibilities = [{
              value: 0,
              exact: true
            }];

            // 0.5 pi (fallback)
          } else if (match = text.match(/^(.+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = forms.decimal(match[1]);
          } else {
            possibilities = ___default["default"].reduce(KhanAnswerTypes.predicate.defaultForms.split(/\s*,\s*/), function (memo, form) {
              return memo.concat(forms[form](text));
            }, []);

            // If the answer is a floating point number that's
            // near a multiple of pi, mark is as being possibly
            // an approximation of pi.  We actually check if
            // it's a plausible approximation of pi/12, since
            // sometimes the correct answer is like pi/3 or pi/4.
            // We also say it's a pi-approximation if it involves
            // x/7 (since 22/7 is an approximation of pi.)
            // Never mark an integer as being an approximation
            // of pi.
            let approximatesPi = false;
            const number = parseFloat(text);
            if (!isNaN(number) && number !== parseInt(text)) {
              const piMult = Math.PI / 12;
              const roundedNumber = piMult * Math.round(number / piMult);
              if (Math.abs(number - roundedNumber) < 0.01) {
                approximatesPi = true;
              }
            } else if (text.match(/\/\s*7/)) {
              approximatesPi = true;
            }
            if (approximatesPi) {
              ___default["default"].each(possibilities, function (possibility) {
                possibility.piApprox = true;
              });
            }
            return possibilities;
          }
          let multiplier = Math.PI;
          if (text.match(/\\?tau|t|\u03c4/)) {
            multiplier = Math.PI * 2;
          }

          // We're taking an early stand along side xkcd in the
          // inevitable ti vs. pau debate... http://xkcd.com/1292
          if (text.match(/pau/)) {
            multiplier = Math.PI * 1.5;
          }
          $__default["default"].each(possibilities, function (ix, possibility) {
            possibility.value *= multiplier;
          });
          return possibilities;
        },
        // Converts '' to 1 and '-' to -1 so you can write "[___] x"
        // and accept sane things
        coefficient: function (text) {
          let possibilities = [];

          // Replace unicode minus sign with hyphen
          text = text.replace(/\u2212/, "-");
          if (text === "") {
            possibilities = [{
              value: 1,
              exact: true
            }];
          } else if (text === "-") {
            possibilities = [{
              value: -1,
              exact: true
            }];
          }
          return possibilities;
        },
        // simple log(c) form
        log: function (text) {
          let match;
          let possibilities = [];

          // Replace unicode minus sign with hyphen
          text = text.replace(/\u2212/, "-");
          text = text.replace(/[ \(\)]/g, "");
          if (match = text.match(/^log\s*(\S+)\s*$/i)) {
            // @ts-expect-error [FEI-5003] - TS2322 - Type '{ value: number | undefined; exact: boolean; }[]' is not assignable to type 'never[]'.
            possibilities = forms.decimal(match[1]);
          } else if (text === "0") {
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'never'. | TS2322 - Type 'boolean' is not assignable to type 'never'.
            possibilities = [{
              value: 0,
              exact: true
            }];
          }
          return possibilities;
        },
        // Numbers with percent signs
        percent: function (text) {
          text = $__default["default"].trim(text);
          // store whether or not there is a percent sign
          let hasPercentSign = false;
          if (text.indexOf("%") === text.length - 1) {
            text = $__default["default"].trim(text.substring(0, text.length - 1));
            hasPercentSign = true;
          }
          const transformed = forms.decimal(text);
          $__default["default"].each(transformed, function (ix, t) {
            t.exact = hasPercentSign;
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            t.value = t.value / 100;
          });
          return transformed;
        },
        // Mixed numbers, like 1 3/4
        mixed: function (text) {
          const match = text
          // Replace unicode minus sign with hyphen
          .replace(/\u2212/, "-")
          // Remove space after +, -
          .replace(/([+-])\s+/g, "$1")
          // Extract integer, numerator and denominator
          .match(/^([+-]?)(\d+)\s+(\d+)\s*\/\s*(\d+)$/);
          if (match) {
            const sign = parseFloat(match[1] + "1");
            const integ = parseFloat(match[2]);
            const num = parseFloat(match[3]);
            const denom = parseFloat(match[4]);
            const simplified = num < denom && KhanMath.getGCD(num, denom) === 1;
            return [{
              value: sign * (integ + num / denom),
              exact: simplified
            }];
          }
          return [];
        },
        // Decimal numbers -- compare entered text rounded to
        // 'precision' Reciprical of the precision against the correct
        // answer. We round to 1/1e10 by default, which is healthily
        // less than machine epsilon but should be more than any real
        // decimal answer would use. (The 'integer' answer type uses
        // precision == 1.)
        decimal: function (text) {
          let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e10;
          const normal = function (text) {
            text = $__default["default"].trim(text);
            const match = text
            // Replace unicode minus sign with hyphen
            .replace(/\u2212/, "-")
            // Remove space after +, -
            .replace(/([+-])\s+/g, "$1")
            // Extract integer, numerator and denominator. If
            // commas or spaces are used, they must be in the
            // "correct" places
            .match(/^([+-]?(?:\d{1,3}(?:[, ]?\d{3})*\.?|\d{0,3}(?:[, ]?\d{3})*\.(?:\d{3}[, ]?)*\d{1,3}))$/);

            // You can't start a number with `0,`, to prevent us
            // interpeting '0.342' as correct for '342'
            const badLeadingZero = text.match(/^0[0,]*,/);
            if (match && !badLeadingZero) {
              let x = parseFloat(match[1].replace(/[, ]/g, ""));
              if (options.inexact === undefined) {
                x = Math.round(x * precision) / precision;
              }
              return x;
            }
          };
          const commas = function (text) {
            text = text.replace(/([\.,])/g, function (_, c) {
              return c === "." ? "," : ".";
            });
            return normal(text);
          };
          return [{
            value: normal(text),
            exact: true
          }, {
            value: commas(text),
            exact: true
          }];
        }
      };

      // validator function
      return function (guess) {
        // The fallback variable is used in place of the answer, if no
        // answer is provided (i.e. the field is left blank)
        const fallback = options.fallback != null ? "" + options.fallback : "";
        guess = $__default["default"].trim(guess) || fallback;
        const score = {
          empty: guess === "",
          correct: false,
          message: null,
          guess: guess
        };

        // iterate over all the acceptable forms, and if one of the
        // answers is correct, return true
        $__default["default"].each(acceptableForms, function (i, form) {
          const transformed = forms[form](guess);
          for (let j = 0, l = transformed.length; j < l; j++) {
            const val = transformed[j].value;
            const exact = transformed[j].exact;
            const piApprox = transformed[j].piApprox;
            // If a string was returned, and it exactly matches,
            // return true
            if (predicate(val, options.maxError)) {
              // If the exact correct number was returned,
              // return true
              if (exact || options.simplify === "optional") {
                score.correct = true;
                score.message = options.message || null;
                // If the answer is correct, don't say it's
                // empty. This happens, for example, with the
                // coefficient type where guess === "" but is
                // interpreted as "1" which is correct.
                score.empty = false;
              } else if (form === "percent") {
                // Otherwise, an error was returned
                score.empty = true;
                score.message = errors.MISSING_PERCENT_ERROR;
              } else {
                if (options.simplify !== "enforced") {
                  score.empty = true;
                }
                score.message = errors.NEEDS_TO_BE_SIMPLFIED_ERROR;
              }
              // The return false below stops the looping of the
              // callback since predicate check  succeeded.
              // No more forms to look to verify the user guess.
              return false;
            }
            if (piApprox && predicate(val, Math.abs(val * 0.001))) {
              score.empty = true;
              score.message = errors.APPROXIMATED_PI_ERROR;
            }
          }
        });
        if (score.correct === false) {
          let interpretedGuess = false;
          ___default["default"].each(forms, function (form) {
            const anyAreNaN = ___default["default"].any(form(guess), function (t) {
              return t.value != null && !___default["default"].isNaN(t.value);
            });
            if (anyAreNaN) {
              interpretedGuess = true;
            }
          });
          if (!interpretedGuess) {
            score.empty = true;
            score.message = errors.EXTRA_SYMBOLS_ERROR;
            return score;
          }
        }
        return score;
      };
    }
  },
  /*
   * number answer type
   *
   * wraps the predicate answer type to performs simple number-based checking
   * of a solution
   */
  number: {
    convertToPredicate: function (correctAnswer, options) {
      const correctFloat = parseFloat(correctAnswer);
      return [function (guess, maxError) {
        return Math.abs(guess - correctFloat) < maxError;
      }, $__default["default"].extend({}, options, {
        type: "predicate"
      })];
    },
    createValidatorFunctional: function (correctAnswer, options) {
      return KhanAnswerTypes.predicate.createValidatorFunctional(
      // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
      ...KhanAnswerTypes.number.convertToPredicate(correctAnswer, options));
    }
  },
  /*
   * The expression answer type parses a given expression or equation
   * and semantically compares it to the solution. In addition, instant
   * feedback is provided by rendering the last answer that fully parsed.
   *
   * Parsing options:
   * functions (e.g. data-functions="f g h")
   *     A space or comma separated list of single-letter variables that
   *     should be interpreted as functions. Case sensitive. "e" and "i"
   *     are reserved.
   *
   *     no functions specified: f(x+y) == fx + fy
   *     with "f" as a function: f(x+y) != fx + fy
   *
   * Comparison options:
   * same-form (e.g. data-same-form)
   *     If present, the answer must match the solution's structure in
   *     addition to evaluating the same. Commutativity and excess negation
   *     are ignored, but all other changes will trigger a rejection. Useful
   *     for requiring a particular form of an equation, or if the answer
   *     must be factored.
   *
   *     example question:    Factor x^2 + x - 2
   *     example solution:    (x-1)(x+2)
   *     accepted answers:    (x-1)(x+2), (x+2)(x-1), ---(-x-2)(-1+x), etc.
   *     rejected answers:    x^2+x-2, x*x+x-2, x(x+1)-2, (x-1)(x+2)^1, etc.
   *     rejection message:   Your answer is not in the correct form
   *
   * simplify (e.g. data-simplify)
   *     If present, the answer must be fully expanded and simplified. Use
   *     carefully - simplification is hard and there may be bugs, or you
   *     might not agree on the definition of "simplified" used. You will
   *     get an error if the provided solution is not itself fully expanded
   *     and simplified.
   *
   *     example question:    Simplify ((n*x^5)^5) / (n^(-2)*x^2)^-3
   *     example solution:    x^31 / n
   *     accepted answers:    x^31 / n, x^31 / n^1, x^31 * n^(-1), etc.
   *     rejected answers:    (x^25 * n^5) / (x^(-6) * n^6), etc.
   *     rejection message:   Your answer is not fully expanded and simplified
   *
   * Rendering options:
   * times (e.g. data-times)
   *     If present, explicit multiplication (such as between numbers) will
   *     be rendered with a cross/x symbol (TeX: \times) instead of the usual
   *     center dot (TeX: \cdot).
   *
   *     normal rendering:    2 * 3^x -> 2 \cdot 3^{x}
   *     but with "times":    2 * 3^x -> 2 \times 3^{x}
   */
  expression: {
    parseSolution: function (solutionString, options) {
      let solution = KAS__namespace.parse(solutionString, options);
      if (!solution.parsed) {
        throw new PerseusError("The provided solution (" + solutionString + ") didn't parse.", Errors.InvalidInput);
      } else if (options.simplified && !solution.expr.isSimplified()) {
        throw new PerseusError("The provided solution (" + solutionString + ") isn't fully expanded and simplified.", Errors.InvalidInput);
      } else {
        solution = solution.expr;
      }
      return solution;
    },
    createValidatorFunctional: function (solution, options) {
      return function (guess) {
        const score = {
          empty: false,
          correct: false,
          message: null,
          guess: guess,
          // Setting `ungraded` to true indicates that if the
          // guess doesn't match any of the solutions, the guess
          // shouldn't be marked as incorrect; instead, `message`
          // should be shown to the user. This is different from
          // setting `empty` to true, since the behavior of `empty`
          // is that `message` only will be shown if the guess is
          // graded as empty for every solution.
          ungraded: false
        };

        // Don't bother parsing an empty input
        if (!guess) {
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'empty' because it is a read-only property.
          score.empty = true;
          return score;
        }
        const answer = KAS__namespace.parse(guess, options);

        // An unsuccessful parse doesn't count as wrong
        if (!answer.parsed) {
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'empty' because it is a read-only property.
          score.empty = true;
          return score;
        }

        // Solution will need to be parsed again if we're creating
        // this from a multiple question type
        if (typeof solution === "string") {
          solution = KhanAnswerTypes.expression.parseSolution(solution, options);
        }
        const result = KAS__namespace.compare(answer.expr, solution, options);
        if (result.equal) {
          // Correct answer
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'correct' because it is a read-only property.
          score.correct = true;
        } else if (result.wrongVariableNames || result.wrongVariableCase) {
          // We don't want to give people an error for getting the
          // variable names or the variable case wrong.
          // TODO(aasmund): This should ideally have been handled
          // under the `result.message` condition, but the
          // KAS messages currently aren't translatable.
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'ungraded' because it is a read-only property.
          score.ungraded = true;
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'message' because it is a read-only property.
          score.message = result.wrongVariableCase ? errors.WRONG_CASE_ERROR : errors.WRONG_LETTER_ERROR;
          // Don't tell the use they're "almost there" in this case, that may not be true and isn't helpful.
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'suppressAlmostThere' does not exist on type '{ readonly empty: false; readonly correct: false; readonly message: string | null | undefined; readonly guess: any; readonly ungraded: false; }'.
          score.suppressAlmostThere = true;
        } else if (result.message) {
          // Nearly correct answer
          // TODO(aasmund): This message also isn't translatable;
          // need to fix that in KAS
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'message' because it is a read-only property.
          score.message = result.message;
        } else {
          // Replace x with * and see if it would have been correct
          // TODO(aasmund): I think this branch is effectively dead,
          // because the replacement will only work in situations
          // where the variables are wrong (except if the variable
          // is x, in which case the replacement won't work either),
          // which is handled by another branch. When we implement a
          // more sophisticated variable check, revive this or
          // remove it completely if it will never come into play.
          const answerX = KAS__namespace.parse(guess.replace(/[xX]/g, "*"), options);
          if (answerX.parsed) {
            const resultX = KAS__namespace.compare(answerX.expr, solution, options);
            if (resultX.equal) {
              // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'ungraded' because it is a read-only property.
              score.ungraded = true;
              // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'message' because it is a read-only property.
              score.message = errors.MULTIPLICATION_SIGN_ERROR;
            } else if (resultX.message) {
              // TODO(aasmund): I18nize `score.message`
              // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'message' because it is a read-only property.
              score.message = resultX.message + " Also, I'm a computer. I only understand " + "multiplication if you use an " + "asterisk (*) as the multiplication " + "sign.";
            }
          }
        }
        return score;
      };
    }
  }
};

const ERROR_MESSAGE = i18n__namespace._("Sorry, I don't understand that!");
const insertBraces = value => {
  // HACK(alex): Make sure that all LaTeX super/subscripts are wrapped
  // in curly braces to avoid the mismatch between KAS and LaTeX sup/sub
  // parsing.
  //
  // What exactly is this mismatch? Due to its heritage of parsing plain
  // text math from <OldExpression />, KAS parses "x^12" as x^(12).
  // This is both generally what the user expects to happen, and is
  // consistent with other computer algebra systems. It is NOT
  // consistent with LaTeX however, where x^12 is equivalent to x^{1}2.
  //
  // Since the only LaTeX we parse comes from MathQuill, this wouldn't
  // be a problem if MathQuill just always gave us the latter version
  // (with explicit braces). However, instead it always gives the former.
  // This behavior is baked in pretty deep; my naive attempts at changing
  // it triggered all sorts of confusing errors. So instead we just make
  // sure to add in any missing braces before grading MathQuill input.
  //
  // TODO(alex): Properly hack MathQuill to always use explicit braces.
  return value.replace(/([_^])([^{])/g, "$1{$2}");
};
// The new, MathQuill input expression widget
class Expression extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_isMounted", false);
    _defineProperty(this, "errorTimeout", null);
    _defineProperty(this, "displayName", "Expression");
    _defineProperty(this, "state", {
      showErrorTooltip: false,
      showErrorText: false
    });
    _defineProperty(this, "componentDidMount", () => {
      // TODO(scottgrant): This is a hack to remove the deprecated call to
      // this.isMounted() but is still considered an anti-pattern.
      this._isMounted = true;
    });
    _defineProperty(this, "componentDidUpdate", prevProps => {
      if (!___default["default"].isEqual(this.props.value, prevProps.value) || !___default["default"].isEqual(this.props.functions, prevProps.functions)) {
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        clearTimeout(this.errorTimeout);
        if (this.parse(this.props.value, this.props).parsed) {
          // eslint-disable-next-line react/no-did-update-set-state
          this.setState({
            showErrorTooltip: false
          });
        } else {
          // Store timeout ID so that we can clear it above
          // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
          // eslint-disable-next-line no-restricted-syntax
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'Timeout' is not assignable to type 'number'.
          this.errorTimeout = setTimeout(() => {
            const apiResult = this.props.apiOptions.onInputError(null,
            // reserved for some widget identifier
            this.props.value, ERROR_MESSAGE);
            if (apiResult !== false) {
              this.setState({
                showErrorTooltip: true
              });
            }
          }, 2000);
        }
      }
    });
    _defineProperty(this, "componentWillUnmount", () => {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      clearTimeout(this.errorTimeout);
      this._isMounted = false;
    });
    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {
      onInputError = onInputError || function () {};
      return Expression.validate(this.getUserInput(), rubric, onInputError);
    });
    _defineProperty(this, "getUserInput", () => {
      return Expression.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "parse", (value, props) => {
      // TODO(jack): Disable icu for content creators here, or
      // make it so that solution answers with ','s or '.'s work
      const options = ___default["default"].pick(props || this.props, "functions");
      ___default["default"].extend(options, {
        decimal_separator: i18n__namespace.getDecimalSeparator()
      });
      return KAS__namespace.parse(insertBraces(value), options);
    });
    _defineProperty(this, "changeAndTrack", (e, cb) => {
      this.change("value", e, cb);
      this.props.trackInteraction();
    });
    _defineProperty(this, "_handleFocus", () => {
      /* c8 ignore next */
      this.props.onFocus([]);
    });
    _defineProperty(this, "_handleBlur", () => {
      /* c8 ignore next */
      this.props.onBlur([]);
    });
    _defineProperty(this, "focus", () => {
      if (this.props.apiOptions.customKeypad) {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        this.refs.input.focus();
      }
      return true;
    });
    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      this.refs.input.focus();
    });
    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
      this.refs.input.blur();
    });
    _defineProperty(this, "insert", text => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'insert' does not exist on type 'ReactInstance'.
      this.refs.input.insert(text);
    });
    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.
      /* c8 ignore next */
      return [[]];
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      /* c8 ignore next */
      return "expression";
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        value: newValue
      }, cb);
    });
  }
  //#region Previously a class extension
  /* Content creators input a list of answers which are matched from top to
   * bottom. The intent is that they can include spcific solutions which should
   * be graded as correct or incorrect (or ungraded!) first, then get more
   * general.
   *
   * We iterate through each answer, trying to match it with the user's input
   * using the following angorithm:
   * - Try to parse the user's input. If it doesn't parse then return "not
   *   graded".
   * - For each answer:
   *   ~ Try to validate the user's input against the answer. The answer is
   *     expected to parse.
   *   ~ If the user's input validates (the validator judges it "correct"), we've
   *     matched and can stop considering answers.
   * - If there were no matches or the matching answer is considered "ungraded",
   *   show the user an error. TODO(joel) - what error?
   * - Otherwise, pass through the resulting points and message.
   */
  static validate(userInput, rubric) {
    let onInputError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
    const options = ___default["default"].clone(rubric);
    ___default["default"].extend(options, {
      decimal_separator: i18n__namespace.getDecimalSeparator()
    });
    const createValidator = answer => {
      // We give options to KAS.parse here because it is parsing the
      // solution answer, not the student answer, and we don't want a
      // solution to work if the student is using a different language
      // (different from the content creation language, ie. English).
      const expression = KAS__namespace.parse(answer.value, rubric);
      // An answer may not be parsed if the expression was defined
      // incorrectly. For example if the answer is using a symbol defined
      // in the function variables list for the expression.
      if (!expression.parsed) {
        /* c8 ignore next */
        Log.error("Unable to parse solution answer for expression", Errors.InvalidInput, {
          loggedMetadata: {
            rubric: JSON.stringify(rubric)
          }
        });
        return null;
      }
      return KhanAnswerTypes.expression.createValidatorFunctional(expression.expr, ___default["default"]({}).extend(options, {
        simplify: answer.simplify,
        form: answer.form
      }));
    };

    // Find the first answer form that matches the user's input and that
    // is considered correct. Also, track whether the input is
    // considered "empty" for all answer forms, and keep the validation
    // result for the first answer form for which the user's input was
    // considered "ungraded".
    // (Terminology reminder: the answer forms are provided by the
    // assessment items; they are not the user's input. Each one might
    // represent a correct answer, an incorrect one (if the exercise
    // creator has predicted certain common wrong answers and wants to
    // provide guidance via a message), or an ungraded one (same idea,
    // but without giving the user an incorrect mark for the question).
    let matchingAnswerForm;
    let matchMessage;
    let allEmpty = true;
    let firstUngradedResult;
    for (const answerForm of rubric.answerForms || []) {
      const validate = createValidator(answerForm);
      if (!validate) {
        continue;
      }
      const result = validate(userInput);

      // Short-circuit as soon as the user's input matches some answer
      // (independently of whether the answer is correct)
      if (result.correct) {
        matchingAnswerForm = answerForm;
        matchMessage = result.message || "";
        break;
      }
      allEmpty = allEmpty && result.empty;
      // If this answer form is correct and the user's input is considered
      // "ungraded" for it, we'll want to keep the evaluation result for
      // later. If the user's input doesn't match any answer forms, we'll
      // show the message from this validation.
      if (answerForm.considered === "correct" && result.ungraded && !firstUngradedResult) {
        firstUngradedResult = result;
      }
    }

    // Now check to see if we matched any answer form at all, and if
    // we did, whether it's considered correct, incorrect, or ungraded
    if (!matchingAnswerForm) {
      if (firstUngradedResult) {
        // While we didn't directly match with any answer form, we
        // did at some point get an "ungraded" validation result,
        // which might indicate e.g. a mismatch in variable casing.
        // We'll return "invalid", which will let the user try again
        // with no penalty, and the hopefully helpful validation
        // message.
        return {
          type: "invalid",
          message: firstUngradedResult.message,
          suppressAlmostThere: firstUngradedResult.suppressAlmostThere
        };
      }
      if (allEmpty) {
        // If everything graded as empty, it's invalid.
        return {
          type: "invalid",
          message: null
        };
      }
      // We fell through all the possibilities and we're not empty,
      // so the answer is considered incorrect.
      return {
        type: "points",
        earned: 0,
        total: 1
      };
    }
    if (matchingAnswerForm.considered === "ungraded") {
      // We matched an ungraded answer form - return "invalid", which
      // will let the user try again with no penalty
      const apiResult = onInputError(null,
      // Reserved for some widget identifier
      userInput, matchMessage);
      return {
        type: "invalid",
        message: apiResult === false ? null : matchMessage
      };
    }
    // We matched a graded answer form, so we can now tell the user
    // whether their input was correct or incorrect, and hand out
    // points accordingly
    // TODO(eater): Seems silly to translate result to this
    // invalid/points thing and immediately translate it back in
    // ItemRenderer.scoreInput()
    return {
      type: "points",
      earned: matchingAnswerForm.considered === "correct" ? 1 : 0,
      total: 1,
      message: matchMessage
    };
  }
  static getUserInputFromProps(props) {
    return insertBraces(props.value);
  }
  static getOneCorrectAnswerFromRubric(rubric) {
    const correctAnswers = (rubric.answerForms || []).filter(answerForm => answerForm.considered === "correct");
    if (correctAnswers.length === 0) {
      return;
    }
    return correctAnswers[0].value;
  }
  //#endregion

  render() {
    if (this.props.apiOptions.customKeypad) {
      return /*#__PURE__*/React__namespace.createElement(mathInput.KeypadInput
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.value,
        keypadElement: this.props.keypadElement,
        onChange: this.changeAndTrack,
        onFocus: () => {
          var _this$props$keypadEle;
          // this.props.keypadElement should always be set
          // when apiOptions.customKeypad is set, but how
          // to convince TypeScript of this?
          (_this$props$keypadEle = this.props.keypadElement) === null || _this$props$keypadEle === void 0 ? void 0 : _this$props$keypadEle.configure(this.props.keypadConfiguration, () => {
            if (this._isMounted) {
              this._handleFocus();
            }
          });
        },
        onBlur: this._handleBlur
      });
    }
    // TODO(alex): Style this tooltip to be more consistent with other
    // tooltips on the site; align to left middle (once possible)
    const errorTooltip = /*#__PURE__*/React__namespace.createElement("span", {
      className: "error-tooltip",
      role: "tooltip"
    }, /*#__PURE__*/React__namespace.createElement(Tooltip, {
      className: "error-text-container",
      horizontalPosition: HorizontalDirection.Right,
      horizontalAlign: HorizontalDirection.Left,
      verticalPosition: VerticalDirection.Top,
      arrowSize: 10,
      borderColor: "#fcc335",
      show: this.state.showErrorText
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "error-icon",
      "data-test-id": "test-error-icon",
      onMouseEnter: () => {
        this.setState({
          showErrorText: true
        });
      },
      onMouseLeave: () => {
        this.setState({
          showErrorText: false
        });
      },
      onClick: () => {
        // TODO(alex): Better error feedback for mobile
        this.setState({
          showErrorText: !this.state.showErrorText
        });
      }
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconExclamationSign)), /*#__PURE__*/React__namespace.createElement("div", {
      className: "error-text"
    }, ERROR_MESSAGE)));
    const className = classNames__default["default"]({
      "perseus-widget-expression": true,
      "show-error-tooltip": this.state.showErrorTooltip
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, /*#__PURE__*/React__namespace.createElement(MathInput
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "input",
      className: ClassNames.INTERACTIVE,
      value: this.props.value,
      onChange: this.changeAndTrack,
      convertDotToTimes: this.props.times,
      buttonsVisible: this.props.buttonsVisible || "focused",
      buttonSets: this.props.buttonSets,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur
    }), this.state.showErrorTooltip && errorTooltip);
  }
}

/**
 * Determine the keypad configuration parameters for the input, based on the
 * provided properties.
 *
 * There are two configuration parameters to be passed to the keypad:
 *   (1) The keypad type. For the Expression widget, we always use the
 *       Expression keypad.
 *   (2) The extra keys; namely, any variables or constants (like Pi) that need
 *       to be included as keys on the keypad. These are scraped from the answer
 *       forms.
 */
_defineProperty(Expression, "defaultProps", {
  value: "",
  times: false,
  functions: [],
  buttonSets: ["basic", "trig", "prealgebra", "logarithms"],
  onFocus: () => {},
  onBlur: () => {},
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});
const keypadConfigurationForProps = widgetOptions => {
  // Always use the Expression keypad, regardless of the button sets that have
  // been enabled.
  const keypadType = mathInput.KeypadType.EXPRESSION;

  // Extract any and all variables and constants from the answer forms.
  const uniqueExtraVariables = {};
  const uniqueExtraConstants = {};
  for (const answerForm of widgetOptions.answerForms) {
    const maybeExpr = KAS__namespace.parse(answerForm.value, widgetOptions);
    if (maybeExpr.parsed) {
      const expr = maybeExpr.expr;

      // The keypad expects Greek letters to be capitalized (e.g., it
      // requires `PI` instead of `pi`). Right now, it only supports Pi
      // and Theta, so we special-case.
      const isGreek = symbol => symbol === "pi" || symbol === "theta";
      const toKey = symbol => isGreek(symbol) ? symbol.toUpperCase() : symbol;
      for (const variable of expr.getVars()) {
        uniqueExtraVariables[toKey(variable)] = true;
      }
      for (const constant of expr.getConsts()) {
        uniqueExtraConstants[toKey(constant)] = true;
      }
    }
  }

  // TODO(charlie): Alert the keypad as to which of these symbols should be
  // treated as functions.
  const extraVariables = Object.keys(uniqueExtraVariables);
  extraVariables.sort();
  const extraConstants = Object.keys(uniqueExtraConstants);
  extraConstants.sort();
  const extraKeys = [...extraVariables, ...extraConstants];
  if (!extraKeys.length) {
    // If there are no extra symbols available, we include Pi anyway, so
    // that the "extra symbols" button doesn't appear empty.
    extraKeys.push("PI");
  }
  return {
    keypadType,
    extraKeys
  };
};
const propUpgrades$2 = {
  /* c8 ignore next */
  "1": v0props => ({
    times: v0props.times,
    buttonSets: v0props.buttonSets,
    functions: v0props.functions,
    buttonsVisible: v0props.buttonsVisible,
    answerForms: [{
      considered: "correct",
      form: v0props.form,
      simplify: v0props.simplify,
      value: v0props.value
    }]
  })
};
var Expression$1 = {
  name: "expression",
  displayName: "Expression / Equation",
  defaultAlignment: "inline-block",
  widget: Expression,
  transform: widgetOptions => {
    const {
      times,
      functions,
      buttonSets,
      buttonsVisible
    } = widgetOptions;
    return {
      keypadConfiguration: keypadConfigurationForProps(widgetOptions),
      times,
      functions,
      buttonSets,
      buttonsVisible
    };
  },
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$2,
  // For use by the editor
  isLintable: true
};

/**
 * A React context for keeping track of whether an component is fully
 * loaded.  This is used to know when SvgImage and (Zoomable)TeX are finished
 * renderering.
 */
const defaultContext$2 = {
  assetStatuses: {},
  setAssetStatus: (assetKey, loaded) => {}
};
const context$2 = /*#__PURE__*/React__namespace.createContext(defaultContext$2);

/* eslint-disable @babel/no-invalid-this, getter-return, one-var */
let supportsPassive = false;
const svgLabelsRegex = /^web\+graphie:/;
// For offline exercises in the mobile app, we download the graphie data
// (svgs and localized data files) and serve them from the local file
// system (with file://). We replace urls that start with `web+graphie`
// in the perseus json with this `file+graphie` prefix to indicate that
// they should have the `file://` protocol instead of `https://`.
const svgLocalLabelsRegex$1 = /^file\+graphie:/;
const nestedMap$2 = function (children, func, context) {
  if (Array.isArray(children)) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type '(M | readonly M[])[]' is not assignable to type 'M | readonly M[]'.
    return ___default["default"].map(children, function (child) {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 3 arguments, but got 2.
      return nestedMap$2(child, func);
    });
  }
  return func.call(context, children);
};

/**
 * Used to compare equality of two input paths, which are represented as
 * arrays of strings.
 */
function inputPathsEqual(a, b) {
  if (a == null || b == null) {
    return a == null === (b == null);
  }
  return a.length === b.length && a.every((item, index) => {
    return b[index] === item;
  });
}
const rWidgetRule = /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]/;
const rTypeFromWidgetId = /^([a-z-]+) ([0-9]+)$/;
const rWidgetParts = new RegExp(rWidgetRule.source + "$");
const snowman = "\u2603";
const noScore = {
  type: "points",
  earned: 0,
  total: 0,
  message: null
};
const seededRNG$1 = function (seed) {
  let randomSeed = seed;
  return function () {
    // Robert Jenkins' 32 bit integer hash function.
    let seed = randomSeed;
    seed = seed + 0x7ed55d16 + (seed << 12) & 0xffffffff;
    seed = (seed ^ 0xc761c23c ^ seed >>> 19) & 0xffffffff;
    seed = seed + 0x165667b1 + (seed << 5) & 0xffffffff;
    seed = (seed + 0xd3a2646c ^ seed << 9) & 0xffffffff;
    seed = seed + 0xfd7046c5 + (seed << 3) & 0xffffffff;
    seed = (seed ^ 0xb55a4f09 ^ seed >>> 16) & 0xffffffff;
    return (randomSeed = seed & 0xfffffff) / 0x10000000;
  };
};

// Shuffle an array using a given random seed or function.
// If `ensurePermuted` is true, the input and ouput are guaranteed to be
// distinct permutations.
function shuffle$3(array, randomSeed) {
  let ensurePermuted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // Always return a copy of the input array
  const shuffled = ___default["default"].clone(array);

  // Handle edge cases (input array is empty or uniform)
  if (!shuffled.length || ___default["default"].all(shuffled, function (value) {
    return ___default["default"].isEqual(value, shuffled[0]);
  })) {
    return shuffled;
  }
  let random;
  if (typeof randomSeed === "function") {
    random = randomSeed;
  } else {
    random = seededRNG$1(randomSeed);
  }
  do {
    // Fischer-Yates shuffle
    for (let top = shuffled.length; top > 0; top--) {
      const newEnd = Math.floor(random() * top),
        temp = shuffled[newEnd];

      // @ts-expect-error [FEI-5003] - TS2542 - Index signature in type 'readonly T[]' only permits reading.
      shuffled[newEnd] = shuffled[top - 1];
      // @ts-expect-error [FEI-5003] - TS2542 - Index signature in type 'readonly T[]' only permits reading.
      shuffled[top - 1] = temp;
    }
  } while (ensurePermuted && ___default["default"].isEqual(array, shuffled));
  return shuffled;
}

/**
 * TODO(somewhatabstract, FEI-3463):
 * Drop this custom split thing.
 */
// In IE8, split doesn't work right. Implement it ourselves.
const split = "x".split(/(.)/g).length ? function (str, r) {
  return str.split(r);
} : function (str, r) {
  // Based on Steven Levithan's MIT-licensed split, available at
  // http://blog.stevenlevithan.com/archives/cross-browser-split
  const output = [];
  let lastIndex = r.lastIndex = 0;
  let match;
  while (match = r.exec(str)) {
    const m = match;
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'never'.
    output.push(str.slice(lastIndex, m.index));
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
    output.push(...m.slice(1));
    lastIndex = m.index + m[0].length;
  }

  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'never'.
  output.push(str.slice(lastIndex));
  return output;
};

/**
 * Combine two score objects.
 *
 * Given two score objects for two different widgets, combine them so that
 * if one is wrong, the total score is wrong, etc.
 */
function combineScores(scoreA, scoreB) {
  let message;
  if (scoreA.type === "points" && scoreB.type === "points") {
    if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
      // TODO(alpert): Figure out how to combine messages usefully
      message = null;
    } else {
      message = scoreA.message || scoreB.message;
    }
    return {
      type: "points",
      earned: scoreA.earned + scoreB.earned,
      total: scoreA.total + scoreB.total,
      message: message
    };
  }
  if (scoreA.type === "points" && scoreB.type === "invalid") {
    return scoreB;
  }
  if (scoreA.type === "invalid" && scoreB.type === "points") {
    return scoreA;
  }
  if (scoreA.type === "invalid" && scoreB.type === "invalid") {
    if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
      // TODO(alpert): Figure out how to combine messages usefully
      message = null;
    } else {
      message = scoreA.message || scoreB.message;
    }
    return {
      type: "invalid",
      message: message
    };
  }

  /**
   * The above checks cover all combinations of score type, so if we get here
   * then something is amiss with our inputs.
   */
  throw new PerseusError("PerseusScore with unknown type encountered", Errors.InvalidInput, {
    metadata: {
      scoreA: JSON.stringify(scoreA),
      scoreB: JSON.stringify(scoreB)
    }
  });
}
function keScoreFromPerseusScore(score, guess, state) {
  if (score.type === "points") {
    return {
      empty: false,
      correct: score.earned >= score.total,
      message: score.message,
      guess: guess,
      state: state
    };
  }
  if (score.type === "invalid") {
    return {
      empty: true,
      correct: false,
      message: score.message,
      suppressAlmostThere: score.suppressAlmostThere,
      guess: guess,
      state: state
    };
  }
  throw new PerseusError(
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'type' does not exist on type 'never'.
  "Invalid score type: " + score.type, Errors.InvalidInput, {
    metadata: {
      score: JSON.stringify(score),
      guess: JSON.stringify(guess),
      state: JSON.stringify(state)
    }
  });
}

/**
 * Return the first valid interpretation of 'text' as a number, in the form
 * {value: 2.3, exact: true}.
 */
function firstNumericalParse$1(text) {
  // TODO(alpert): This is sort of hacky...
  let first;
  const val = KhanAnswerTypes.predicate.createValidatorFunctional(function (ans) {
    first = ans;
    return true; /* break */
  }, {
    simplify: "optional",
    inexact: true,
    forms: "integer, proper, improper, pi, log, mixed, decimal"
  });
  val(text);
  return first;
}
function stringArrayOfSize$1(size) {
  return ___default["default"](size).times(function () {
    return "";
  });
}

/**
 * For a graph's x or y dimension, given the tick step,
 * the ranges extent (e.g. [-10, 10]), the pixel dimension constraint,
 * and the grid step, return a bunch of configurations for that dimension.
 *
 * Example:
 *      gridDimensionConfig(10, [-50, 50], 400, 5)
 *
 * Returns: {
 *      scale: 4,
 *      snap: 2.5,
 *      tickStep: 2,
 *      unityLabel: true
 * };
 */
function gridDimensionConfig(absTickStep, extent, dimensionConstraint, gridStep) {
  const scale = scaleFromExtent(extent, dimensionConstraint);
  const stepPx = absTickStep * scale;
  const unityLabel = stepPx > 30;
  return {
    scale: scale,
    tickStep: absTickStep / gridStep,
    unityLabel: unityLabel
  };
}
/**
 * Given the range, step, and boxSize, calculate the reasonable gridStep.
 * Used for when one was not given explicitly.
 *
 * Example:
 *      getGridStep([[-10, 10], [-10, 10]], [1, 1], 340)
 *
 * Returns: [1, 1]
 *
 * TODO(somewhatabstract, FEI-3464): Consolidate query string parsing functions.
 */
function getGridStep$1(range, step, boxSize) {
  // @ts-expect-error [FEI-5003] - TS2322 - Type '(number | null | undefined)[]' is not assignable to type 'Coordinates'.
  return ___default["default"](2).times(function (i) {
    const scale = scaleFromExtent(range[i], boxSize);
    const gridStep = gridStepFromTickStep(step[i], scale);
    return gridStep;
  });
}
function snapStepFromGridStep(gridStep) {
  return [gridStep[0] / 2, gridStep[1] / 2];
}

/**
 * Given the tickStep and the graph's scale, find a
 * grid step.
 * Example:
 *      gridStepFromTickStep(200, 0.2) // returns 100
 */
function gridStepFromTickStep(tickStep, scale) {
  const tickWidth = tickStep * scale;
  const x = tickStep;
  const y = Math.pow(10, Math.floor(Math.log(x) / Math.LN10));
  const leadingDigit = Math.floor(x / y);
  if (tickWidth < 25) {
    return tickStep;
  }
  if (tickWidth < 50) {
    if (leadingDigit === 5) {
      return tickStep;
    }
    return tickStep / 2;
  }
  if (leadingDigit === 1) {
    return tickStep / 2;
  }
  if (leadingDigit === 2) {
    return tickStep / 4;
  }
  if (leadingDigit === 5) {
    return tickStep / 5;
  }
}

/**
 * Given the range and a dimension, come up with the appropriate
 * scale.
 * Example:
 *      scaleFromExtent([-25, 25], 500) // returns 10
 */
function scaleFromExtent(extent, dimensionConstraint) {
  const span = extent[1] - extent[0];
  const scale = dimensionConstraint / span;
  return scale;
}

/**
 * Return a reasonable tick step given extent and dimension.
 * (extent is [begin, end] of the domain.)
 * Example:
 *      tickStepFromExtent([-10, 10], 300) // returns 2
 */
function tickStepFromExtent(extent, dimensionConstraint) {
  const span = extent[1] - extent[0];
  let tickFactor;
  // If single number digits
  if (15 < span && span <= 20) {
    tickFactor = 23;

    // triple digit or decimal
  } else if (span > 100 || span < 5) {
    tickFactor = 10;

    // double digit
  } else {
    tickFactor = 16;
  }
  const constraintFactor = dimensionConstraint / 500;
  const desiredNumTicks = tickFactor * constraintFactor;
  return tickStepFromNumTicks(span, desiredNumTicks);
}

/**
 * Find a good tick step for the desired number of ticks in the range
 * Modified from d3.scale.linear: d3_scale_linearTickRange.
 * Thanks, mbostock!
 * Example:
 *      tickStepFromNumTicks(50, 6) // returns 10
 */
function tickStepFromNumTicks(span, numTicks) {
  let step = Math.pow(10, Math.floor(Math.log(span / numTicks) / Math.LN10));
  const err = numTicks / span * step;

  // Filter ticks to get closer to the desired count.
  if (err <= 0.15) {
    step *= 10;
  } else if (err <= 0.35) {
    step *= 5;
  } else if (err <= 0.75) {
    step *= 2;
  }

  // Round start and stop values to step interval.
  return step;
}
const constrainTickStep = (step, range) => {
  const span = range[1] - range[0];
  const numTicks = span / step;
  if (numTicks <= 10) {
    // Will displays fine on mobile
    return step;
  }
  if (numTicks <= 20) {
    // Will be crowded on mobile, so hide every other tick
    return step * 2;
  }
  // Fallback in case we somehow have more than 20 ticks
  // Note: This shouldn't happen due to GraphSettings.validStep
  return tickStepFromNumTicks(span, 10);
};

/**
 * Constrain tick steps intended for desktop size graphs
 * to something more suitable for mobile size graphs.
 * Specifically, we aim for 10 or fewer ticks per graph axis.
 */
function constrainedTickStepsFromTickSteps(tickSteps, ranges) {
  return [constrainTickStep(tickSteps[0], ranges[0]), constrainTickStep(tickSteps[1], ranges[1])];
}

/**
 * Transparently update deprecated props so that the code to deal
 * with them only lives in one place: (Widget).deprecatedProps
 *
 * For example, if a boolean `foo` was deprecated in favor of a
 * number 'bar':
 *      deprecatedProps: {
 *          foo: function(props) {
 *              return {bar: props.foo ? 1 : 0};
 *          }
 *      }
 */
const DeprecationMixin$1 = {
  // This lifecycle stage is only called before first render
  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount: function () {
    const newProps = {};
    ___default["default"].each(this.deprecatedProps, function (func, prop) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      if (___default["default"].has(this.props, prop)) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ___default["default"].extend(newProps, func(this.props));
      }
    }, this);
    if (!___default["default"].isEmpty(newProps)) {
      // Set new props directly so that widget renders correctly
      // when it first mounts, even though these will be overwritten
      // almost immediately afterwards...
      ___default["default"].extend(this.props, newProps);

      // ...when we propagate the new props upwards and they come
      // back down again.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(this.props.onChange, 0, newProps);
    }
  }
};

/**
 * Approximate equality on numbers and primitives.
 */
function eq$1(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    return Math.abs(x - y) < 1e-9;
  }
  return x === y;
}

/**
 * Deep approximate equality on primitives, numbers, arrays, and objects.
 * Recursive.
 */
function deepEq$5(x, y) {
  if (Array.isArray(x) && Array.isArray(y)) {
    if (x.length !== y.length) {
      return false;
    }
    for (let i = 0; i < x.length; i++) {
      if (!deepEq$5(x[i], y[i])) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(x) || Array.isArray(y)) {
    return false;
  }
  if (typeof x === "function" && typeof y === "function") {
    return eq$1(x, y);
  }
  if (typeof x === "function" || typeof y === "function") {
    return false;
  }
  if (typeof x === "object" && typeof y === "object" && !!x && !!y) {
    return x === y || ___default["default"].all(x, function (v, k) {
      // @ts-expect-error [FEI-5003] - TS2536 - Type 'CollectionKey<T>' cannot be used to index type 'T'.
      return deepEq$5(y[k], v);
    }) && ___default["default"].all(y, function (v, k) {
      // @ts-expect-error [FEI-5003] - TS2536 - Type 'CollectionKey<T>' cannot be used to index type 'T'.
      return deepEq$5(x[k], v);
    });
  }
  if (typeof x === "object" && !!x || typeof y === "object" && !!y) {
    return false;
  }
  return eq$1(x, y);
}

/**
 * Query String Parser
 *
 * Original from:
 * http://stackoverflow.com/questions/901115/get-querystring-values-in-javascript/2880929#2880929
 */
function parseQueryString(query) {
  // TODO(jangmi, CP-3340): Use withLocation to access SSR safe location.
  // eslint-disable-next-line no-restricted-syntax
  query = query || window.location.search.substring(1);
  const urlParams = {};
  // Regex for replacing addition symbol with a space
  const a = /\+/g;
  const r = /([^&=]+)=?([^&]*)/g;
  const d = function (s) {
    return decodeURIComponent(s.replace(a, " "));
  };
  let e;
  while (e = r.exec(query)) {
    const m = e;
    urlParams[d(m[1])] = d(m[2]);
  }
  return urlParams;
}

/**
 * Query string adder
 * Works for URLs without #.
 * Original from:
 * http://stackoverflow.com/questions/5999118/add-or-update-query-string-parameter
 */
function updateQueryString$2(uri, key, value) {
  value = encodeURIComponent(value);
  const re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
  const separator = uri.indexOf("?") !== -1 ? "&" : "?";
  if (uri.match(re)) {
    return uri.replace(re, "$1" + key + "=" + value + "$2");
  }
  return uri + separator + key + "=" + value;
}

/**
 * A more strict encodeURIComponent that escapes `()'!`s
 * Especially useful for creating URLs that are embeddable in markdown
 *
 * Adapted from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
 * This function and the above original available under the
 * CC-BY-SA 2.5 license.
 */
function strongEncodeURIComponent(str) {
  return encodeURIComponent(str)
  // Note that although RFC3986 reserves "!", RFC5987 does not,
  // so we do not need to escape it
  .replace(/['()!]/g, window.escape) // i.e., %27 %28 %29
  .replace(/\*/g, "%2A");
}

/**
 * TODO(somewhatabstract, JIRA-XXXX):
 * This does not appear to be used within webapp. Could be dead code.
 * Need to check with mobile.
 */
// There are certain widgets where we don't want to provide the "answered"
// highlight indicator.
// The issue with just using the `graded` flag on questions is that showing
// that a certain widget is ungraded can sometimes reveal the answer to a
// question ("is this transformation possible? if so, do it")
// This is kind of a hack to get around this.
function widgetShouldHighlight(widget) {
  if (!widget) {
    return false;
  }
  switch (widget.type) {
    /**
     * Highlight bar denylist
     */
    case "measurer":
    case "protractor":
      return true;
    default:
      return false;
  }
}

/**
 * If a widget says that it is empty once it is graded.
 * Trying to encapsulate references to the score format.
 */
function scoreIsEmpty(score) {
  // HACK(benkomalo): ugh. this isn't great; the Perseus score objects
  // overload the type "invalid" for what should probably be three
  // distinct cases:
  //  - truly empty or not fully filled out
  //  - invalid or malformed inputs
  //  - "almost correct" like inputs where the widget wants to give
  //  feedback (e.g. a fraction needs to be reduced, or `pi` should
  //  be used instead of 3.14)
  //
  //  Unfortunately the coercion happens all over the place, as these
  //  Perseus style score objects are created *everywhere* (basically
  //  in every widget), so it's hard to change now. We assume that
  //  anything with a "message" is not truly empty, and one of the
  //  latter two cases for now.
  return score.type === "invalid" && (!score.message || score.message.length === 0);
}

/*
 * The touchHandlers are used to track the current state of the touch
 * event, such as whether or not the user is currently pressed down (either
 * through touch or mouse) on the screen.
 */
const touchHandlers = {
  pointerDown: false,
  currentTouchIdentifier: null
};
function resetTouchHandlers() {
  Object.assign(touchHandlers, {
    pointerDown: false,
    currentTouchIdentifier: null
  });
}

/**
 * Extracts the location of a touch or mouse event, allowing you to pass
 * in a "mouseup", "mousedown", or "mousemove" event and receive the
 * correct coordinates. Shouldn't be used with "vmouse" events.
 */
function extractPointerLocation(event) {
  let touchOrEvent;
  if (touchHandlers.pointerDown) {
    // Look for the touch matching the one we're tracking; ignore others
    if (touchHandlers.currentTouchIdentifier != null) {
      const len = event.changedTouches ? event.changedTouches.length : 0;
      for (let i = 0; i < len; i++) {
        if (event.changedTouches[i].identifier === touchHandlers.currentTouchIdentifier) {
          touchOrEvent = event.changedTouches[i];
        }
      }
    } else {
      touchOrEvent = event;
    }
    const isEndish = event.type === "touchend" || event.type === "touchcancel";
    if (touchOrEvent && isEndish) {
      touchHandlers.pointerDown = false;
      touchHandlers.currentTouchIdentifier = null;
    }
  } else {
    // touchstart or mousedown
    touchHandlers.pointerDown = true;
    if (event.changedTouches) {
      touchOrEvent = event.changedTouches[0];
      touchHandlers.currentTouchIdentifier = touchOrEvent.identifier;
    } else {
      touchOrEvent = event;
    }
  }
  if (touchOrEvent) {
    return {
      left: touchOrEvent.pageX,
      top: touchOrEvent.pageY
    };
  }
}

// Older browsers don't support passive events and so we need to feature-
// detect them and do event subscription differently for them.
// See: orderer.jsx
const supportsPassiveEvents = () => {
  // Test via a getter in the options object to see if the passive
  // property is accessed
  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function () {
        supportsPassive = true;
      }
    });
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    window.addEventListener("testPassive", null, opts);
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    window.removeEventListener("testPassive", null, opts);
  } catch (e) {
    // Intentionally left empty!
  }
  return supportsPassive;
};

/**
 * Pass this function as the touchstart for an element to
 * avoid sending the touch to the mobile scratchpad
 */
function captureScratchpadTouchStart$4(e) {
  e.stopPropagation();
}
function getImageSize(url, callback) {
  const img = new Image();
  img.onload = function () {
    // IE 11 seems to have problems calculating the heights of svgs
    // if they're not in the DOM. To solve this, we add the element to
    // the dom, wait for a rerender, and use `.clientWidth` and
    // `.clientHeight`. I think we could also solve the problem by
    // adding the image to the document before setting the src, but then
    // the experience would be worse for other browsers.
    // TODO(scottgrant): This is correctly calculating the width of SVG
    // images in browsers, but incorrectly saving the width of what may
    // be a smaller viewport when using the editor, and reusing that
    // width in a full-screen article.
    if (img.width === 0 && img.height === 0) {
      var _document$body;
      (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(img);
      // TODO(scottgrant): Remove this use of _.defer.
      ___default["default"].defer(function () {
        var _document$body2;
        callback(img.clientWidth, img.clientHeight);
        (_document$body2 = document.body) === null || _document$body2 === void 0 ? void 0 : _document$body2.removeChild(img);
      });
    } else {
      callback(img.width, img.height);
    }
  };
  img.src = getRealImageUrl(url);
}

// Sometimes other components want to download the actual image e.g. to
// determine its size. Here, we transform an .svg-labels url into the
// correct image url, and leave normal image urls alone
function getRealImageUrl(url) {
  if (isLabeledSVG(url)) {
    return getSvgUrl(url);
  }
  return url;
}
function isLabeledSVG(url) {
  return svgLabelsRegex.test(url) || svgLocalLabelsRegex$1.test(url);
}

// For each svg+labels, there are two urls we need to download from. This gets
// the base url without the suffix, and `getSvgUrl` and `getDataUrl` apply
// appropriate suffixes to get the image and other data
function getBaseUrl(url) {
  return url.replace(svgLabelsRegex, "https:").replace(svgLocalLabelsRegex$1, "file:");
}
function getSvgUrl(url) {
  return getBaseUrl(url) + ".svg";
}
function getDataUrl(url) {
  return getBaseUrl(url) + "-data.json";
}

/**
 * Gets the word right before where the textarea cursor is
 *
 * @param {Element} textarea - The textarea DOM element
 * @return {JSON} - An object with the word and its starting and ending positions in the textarea
 */
function getWordBeforeCursor(textarea) {
  const text = textarea.value;
  const endPos = textarea.selectionStart - 1;
  const startPos = Math.max(text.lastIndexOf("\n", endPos), text.lastIndexOf(" ", endPos)) + 1;
  return {
    string: text.substring(startPos, endPos + 1),
    pos: {
      start: startPos,
      end: endPos
    }
  };
}

/**
 * Moves the textarea cursor at the specified position
 *
 * @param {Element} textarea - The textarea DOM element
 * @param {int} pos - The position where the cursor will be moved
 */
function moveCursor(textarea, pos) {
  textarea.selectionStart = pos;
  textarea.selectionEnd = pos;
}
const textarea = {
  getWordBeforeCursor,
  moveCursor
};

/**
 * Many of our labels are automatically converted into math mode without
 * the dollar signs. Unfortunately, this makes them untranslatable! This
 * helper function removes the math mode symbols from a string if we want
 * to translate it but don't need the extra dollar signs.
 */
const unescapeMathMode$1 = label => label.startsWith("$") && label.endsWith("$") ? label.slice(1, -1) : label;
const random$1 = seededRNG$1(new Date().getTime() & 0xffffffff);
const Util = {
  inputPathsEqual,
  nestedMap: nestedMap$2,
  rWidgetRule,
  rTypeFromWidgetId,
  rWidgetParts,
  snowman,
  noScore,
  seededRNG: seededRNG$1,
  shuffle: shuffle$3,
  split,
  combineScores,
  keScoreFromPerseusScore,
  firstNumericalParse: firstNumericalParse$1,
  stringArrayOfSize: stringArrayOfSize$1,
  gridDimensionConfig,
  getGridStep: getGridStep$1,
  snapStepFromGridStep,
  scaleFromExtent,
  tickStepFromExtent,
  gridStepFromTickStep,
  tickStepFromNumTicks,
  constrainedTickStepsFromTickSteps,
  DeprecationMixin: DeprecationMixin$1,
  eq: eq$1,
  deepEq: deepEq$5,
  parseQueryString,
  updateQueryString: updateQueryString$2,
  strongEncodeURIComponent,
  widgetShouldHighlight,
  scoreIsEmpty,
  touchHandlers,
  resetTouchHandlers,
  extractPointerLocation,
  supportsPassiveEvents,
  captureScratchpadTouchStart: captureScratchpadTouchStart$4,
  getImageSize,
  getRealImageUrl,
  isLabeledSVG,
  getBaseUrl,
  getSvgUrl,
  getDataUrl,
  textarea,
  unescapeMathMode: unescapeMathMode$1,
  random: random$1
};

// Derived from the MIT-licensed:

/*jshint browser:true, node:true */

/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

// CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
// ============================================================

function transitionEnd() {
  const el = document.createElement("bootstrap");
  const transEndEventNames = {
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "oTransitionEnd otransitionend",
    transition: "transitionend"
  };
  for (const name in transEndEventNames) {
    if (el.style[name] !== undefined) {
      return {
        end: transEndEventNames[name]
      };
    }
  }
  return false; // explicit for ie8 (  ._.)
}

// http://blog.alexmaccaw.com/css-transitions
// @ts-expect-error [FEI-5003] - TS2339 - Property 'emulateTransitionEnd' does not exist on type 'JQuery<HTMLElement>'.
$__default["default"].fn.emulateTransitionEnd = function (duration) {
  let called = false;
  const $el = this;
  $__default["default"](this).one("bsTransitionEnd", function () {
    called = true;
  });
  const callback = function () {
    if (!called) {
      $__default["default"]($el).trigger($__default["default"].support.transition.end);
    }
  };

  // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax
  setTimeout(callback, duration);
  return this;
};
$__default["default"](function () {
  $__default["default"].support.transition = transitionEnd();
  if (!$__default["default"].support.transition) {
    return;
  }
  $__default["default"].event.special.bsTransitionEnd = {
    bindType: $__default["default"].support.transition.end,
    delegateType: $__default["default"].support.transition.end,
    handle: function (e) {
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      if ($__default["default"](e.target).is(this)) {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'IArguments' is not assignable to parameter of type '[t: TriggeredEvent<EventTarget, any, any, any>, ...args: any[]]'.
        // eslint-disable-next-line prefer-rest-params
        return e.handleObj.handler.apply(this, arguments);
      }
    }
  };
});

/**
 * Changes the viewport meta tag to the given contentString. Invokes callback
 * after viewport meta tag changes have taken effect.
 *
 * TODO(david): Return a promise instead of invoking a callback.
 */
function changeViewportTag(contentString, callback) {
  const scrollX = window.scrollX;
  const scrollY = window.scrollY;
  const viewport = document.querySelector("meta[name=viewport]");
  if (viewport) {
    viewport.setAttribute("content", contentString);
  } else {
    $__default["default"]("head").append("<meta name=\"viewport\" content=\"".concat(contentString, "\">"));
  }

  // Hacky way to get the page to take the changes
  // From http://stackoverflow.com/a/36894653
  // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'string'.
  document.body.style.opacity = 0.9999;

  // ... and undo the temporary change.
  // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax
  setTimeout(() => {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'string'.
    document.body.style.opacity = 1;

    // ... which involves restoring the scroll position, which may have
    // changed.
    window.scrollTo(scrollX, scrollY);

    // Invoke callback on the next tick to wait for scroll position to have
    // finished resetting.
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    callback && setTimeout(callback, 0);
  }, 0);
}

/**
 * The zoom service
 */
function ZoomServiceClass() {}
ZoomServiceClass.prototype._initialize = function (enableMobilePinch) {
  // Check to see if the service is already initialized
  if (this._$document) {
    return;
  }
  this._activeZoom = this._initialScrollPosition = this._initialTouchPosition = this._touchMoveListener = null;
  this._$document = $__default["default"](document);
  this._$window = $__default["default"](window);
  this._$body = $__default["default"](document.body);
  this._boundClick = $__default["default"].proxy(this._clickHandler, this);
  this._enableMobilePinch = enableMobilePinch;
};
ZoomServiceClass.prototype.handleZoomClick = function (e, enableMobilePinch) {
  this._initialize(enableMobilePinch);
  const target = e.target;
  if (!target || target.tagName !== "IMG") {
    return;
  }
  if (this._$body.hasClass("zoom-overlay-open")) {
    return;
  }
  if (e.metaKey || e.ctrlKey) {
    return window.open(e.target.src, "_blank");
  }
  if (!enableMobilePinch &&
  // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
  target.width >= window.innerWidth - Zoom.getOffset()) {
    return;
  }
  this._activeZoomClose(true);

  // Enable page zooming in (i.e. make sure there's no maximum-scale). Also,
  // disable page zoom out on mobile devices, because the container that the
  // image is placed in becomes bigger than the viewport if the page can be
  // zoomed out. We explored other fixes like fixing the overlay and page
  // size to be the viewport, but thought that might be even worse of a hack.
  // See for more info:
  // http://dbushell.com/2013/09/10/css-fixed-positioning-and-mobile-zoom/
  if (enableMobilePinch) {
    // Disable zoom out by setting minimum scale of 1 on the viewport tag.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1", () => this._zoom(target));
  } else {
    this._zoom(target);
  }
  if (!enableMobilePinch) {
    // todo(fat): probably worth throttling this
    this._$window.on("scroll.zoom", $__default["default"].proxy(this._scrollHandler, this));
    this._$document.on("keyup.zoom", $__default["default"].proxy(this._keyHandler, this));
    this._$document.on("touchstart.zoom", $__default["default"].proxy(this._touchStart, this));
  }

  // we use a capturing phase here to prevent unintended js events
  // sadly no useCapture in jquery api (http://bugs.jquery.com/ticket/14953)
  document.addEventListener("click", this._boundClick, true);
  e.stopPropagation();
};
ZoomServiceClass.prototype._zoom = function (target) {
  this._activeZoom = new Zoom(target, this._enableMobilePinch);
  this._activeZoom.zoomImage();
};
ZoomServiceClass.prototype._activeZoomClose = function (forceDispose) {
  if (!this._activeZoom) {
    return;
  }
  if (forceDispose) {
    this._activeZoom.dispose();
    this._disposeActiveZoom();
  } else {
    // Reset any underlying page zoom in case the user had pinched to zoom.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1,\n            maximum-scale=1", () => {
      if (this._activeZoom) {
        this._activeZoom.close();
        this._disposeActiveZoom();
      }
    });
  }
};
ZoomServiceClass.prototype._disposeActiveZoom = function () {
  this._$window.off(".zoom");
  this._$document.off(".zoom");
  document.removeEventListener("click", this._boundClick, true);
  this._activeZoom = null;
};
ZoomServiceClass.prototype._scrollHandler = function (e) {
  if (this._initialScrollPosition === null) {
    this._initialScrollPosition = window.scrollY;
  }
  const deltaY = this._initialScrollPosition - window.scrollY;
  if (Math.abs(deltaY) >= 40) {
    this._activeZoomClose();
  }
};
ZoomServiceClass.prototype._keyHandler = function (e) {
  if (e.keyCode === 27) {
    this._activeZoomClose();
  }
};
ZoomServiceClass.prototype._clickHandler = function (e) {
  e.stopPropagation();
  e.preventDefault();
  this._activeZoomClose();
};
ZoomServiceClass.prototype._touchStart = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  this._initialTouchPosition = e.originalEvent.touches[0].pageY;
  $__default["default"](e.target).on("touchmove.zoom", $__default["default"].proxy(this._touchMove, this));
};
ZoomServiceClass.prototype._touchMove = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  if (Math.abs(e.originalEvent.touches[0].pageY - this._initialTouchPosition) > 10) {
    this._activeZoomClose();
    $__default["default"](e.target).off("touchmove.zoom");
  }
};

/**
 * The zoom object
 */
function Zoom(img, enableMobilePinch) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this._fullHeight = this._fullWidth = this._overlay = null;

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this._targetImage = img;
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this._enableMobilePinch = enableMobilePinch;

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this._$body = $__default["default"](document.body);
}

/** Margin around the image when in the "zoomed"/lightbox state. */
Zoom._OFFSET = 80;
Zoom._MAX_WIDTH = 2560;
Zoom._MAX_HEIGHT = 4096;
Zoom.getOffset = function (zoomToFitOnMobile) {
  return zoomToFitOnMobile ? 0 : Zoom._OFFSET;
};
Zoom.prototype.getOffset = function () {
  return Zoom.getOffset(this._enableMobilePinch);
};
Zoom.prototype.zoomImage = function () {
  const img = document.createElement("img");
  const $zoomedImage = $__default["default"](img);
  img.onload = function () {
    // Load the image without specifying height and width so that we can find
    // the true height and width.
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this._fullHeight = Number(img.height);
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this._fullWidth = Number(img.width);

    // Set up our image to mirror the current image on the document.
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    const imageOffset = this._imageOffset = $__default["default"](this._targetImage).offset();

    // Position the image using viewport-fixed coordinates so that it is
    // exactly over the image on the document.
    //
    // Said another way ... get the coordinates of the image relative to
    // the viewport, and use those to position our new image (which is
    // absolutely positioned within a full-bleed fixed-position container).
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
    const left = this._left = imageOffset.left - $__default["default"](window).scrollLeft();
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
    const top = this._top = imageOffset.top - $__default["default"](window).scrollTop();
    $zoomedImage.css({
      left: left,
      top: top,
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      width: this._targetImage.width,
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      height: this._targetImage.height
    });

    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this._zoomOriginal();
  }.bind(this);
  img.src = this._targetImage.src;
  this.$zoomedImage = $zoomedImage;
};
Zoom.prototype._zoomOriginal = function () {
  var _document$body, _document$body2, _this$_overlay;
  this.$zoomedImage.addClass("zoom-img").attr("data-action", "zoom-out");
  $__default["default"](this._targetImage).css("visibility", "hidden");
  this._backdrop = document.createElement("div");
  this._backdrop.className = "zoom-backdrop";
  (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(this._backdrop);
  this._overlay = document.createElement("div");
  this._overlay.className = "zoom-overlay";
  (_document$body2 = document.body) === null || _document$body2 === void 0 ? void 0 : _document$body2.appendChild(this._overlay);
  (_this$_overlay = this._overlay) === null || _this$_overlay === void 0 ? void 0 : _this$_overlay.appendChild(this.$zoomedImage[0]);
  this._calculateZoom();
  this._triggerAnimation();
};
Zoom.prototype._calculateZoom = function () {
  const originalFullImageWidth = this._fullWidth;
  const originalFullImageHeight = this._fullHeight;
  const viewportHeight = window.innerHeight - this.getOffset();
  const viewportWidth = window.innerWidth - this.getOffset();
  const maxScaleFactor = originalFullImageWidth / this._targetImage.width;

  // Zoom to fit the viewport.
  const imageAspectRatio = originalFullImageWidth / originalFullImageHeight;
  const viewportAspectRatio = viewportWidth / viewportHeight;
  if (originalFullImageWidth < viewportWidth && originalFullImageHeight < viewportHeight) {
    this._imgScaleFactor = maxScaleFactor;
  } else if (imageAspectRatio < viewportAspectRatio) {
    this._imgScaleFactor = viewportHeight / originalFullImageHeight * maxScaleFactor;
  } else {
    this._imgScaleFactor = viewportWidth / (originalFullImageWidth !== null && originalFullImageWidth !== void 0 ? originalFullImageWidth : 0) * maxScaleFactor;
  }
};
Zoom.prototype._triggerAnimation = function () {
  // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
  const viewportY = $__default["default"](window).scrollTop() + window.innerHeight / 2;
  // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
  const viewportX = $__default["default"](window).scrollLeft() + window.innerWidth / 2;
  const scaleFactor = this._imgScaleFactor;
  const imageCenterY = this._imageOffset.top + this._targetImage.height / 2;
  const imageCenterX = this._imageOffset.left + this._targetImage.width / 2;
  this._translateY = (viewportY - imageCenterY) / scaleFactor;
  this._translateX = (viewportX - imageCenterX) / scaleFactor;

  // NOTE: This is re-used below.
  this._zoomedInTransformString = "\n        scale(".concat(scaleFactor, ")\n        translate3d(").concat(this._translateX, "px, ").concat(this._translateY, "px, 0)\n    ");
  this.$zoomedImage.css({
    transform: this._zoomedInTransformString
  }).addClass("zoom-transition").one($__default["default"].support.transition.end, $__default["default"].proxy(this._onZoomInFinish, this)).emulateTransitionEnd(300);
  this._$body.addClass("zoom-overlay-open");
};
Zoom.prototype._onZoomInFinish = function () {
  // Remove the transform on the image, but make it look exactly the same as
  // the image with the transform -- full-size and centered in the viewport
  // -- using margins + left/top + scroll
  //
  // We need to remove the transform for scrolling to work -- the browser
  // would still calculate the element position/sizing by its pre-transform
  // dimensions.

  const height = this._targetImage.height * this._imgScaleFactor;
  const width = this._targetImage.width * this._imgScaleFactor;
  let left = 0;
  let top = 0;
  let marginLeft = 0;
  let marginTop = 0;
  let scrollLeft = 0;
  let scrollTop = 0;

  // Horizontally center the image within the viewport, either by positioning
  // with CSS or scrolling the viewport.
  if (width < window.innerWidth) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'number'.
    left = "50%";
    marginLeft = -width / 2;
  } else {
    scrollLeft = (width - window.innerWidth) / 2;
  }

  // ... and similarly, vertically center the image within the viewport.
  if (height < window.innerHeight) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'number'.
    top = "50%";
    marginTop = -height / 2;
  } else {
    scrollTop = (height - window.innerHeight) / 2;
  }
  this.$zoomedImage.css({
    height: height,
    left: left,
    marginLeft: marginLeft,
    marginTop: marginTop,
    top: top,
    transform: "",
    width: width
  }).removeClass("zoom-transition");
  $__default["default"](this._overlay).scrollLeft(scrollLeft).scrollTop(scrollTop);
};
Zoom.prototype.close = function () {
  this._$body.removeClass("zoom-overlay-open").addClass("zoom-overlay-transitioning");

  // Upon closing the image, zoom it back out. Do this by first re-applying the
  // zoomed-in transform and resetting the CSS top/left + margins to what it
  // was right after zooming in -- basically undoing what we did in
  // _onZoomInFinish.
  // TODO(david): Adjust this translation of the transform to take into
  //     account the current scroll position of the image (if the user
  //     scrolled the image after it was zoomed).
  this.$zoomedImage.css({
    height: this._targetImage.height,
    left: this._left,
    marginLeft: 0,
    marginTop: 0,
    top: this._top,
    transform: this._zoomedInTransformString,
    width: this._targetImage.width
  }).removeClass("zoom-transition");
  $__default["default"](this._overlay).scrollLeft(0).scrollTop(0);

  // ... now that the image and its container have been set up to be in the
  // same state as right at the end of the zoom-in animation, reset the
  // transform to scale(1) to achieve the zoom-out-into-image-on-document
  // animation.
  // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax
  setTimeout(() => {
    this.$zoomedImage.css({
      transform: "scale(1)"
    }).addClass("zoom-transition").one($__default["default"].support.transition.end, $__default["default"].proxy(this.dispose, this)).emulateTransitionEnd(300);
  }, 10);
};
Zoom.prototype.dispose = function () {
  if (this.$zoomedImage && this.$zoomedImage[0].parentNode) {
    this.$zoomedImage.remove();
    this.$zoomedImage = null;
    this._overlay.parentNode.removeChild(this._overlay);
    this._backdrop.parentNode.removeChild(this._backdrop);
    this._$body.removeClass("zoom-overlay-transitioning");
  }
  $__default["default"](this._targetImage).css("visibility", "visible");
  this._targetImage.focus();
};
const ZoomService = new ZoomServiceClass();

// @baseFontFamily:        "Proxima Nova", sans-serif;
const baseFontFamily$1 = "'Proxima Nova',sans-serif";
// @boldFontFamily:        "Proxima Nova Semibold", sans-serif;
const boldFontFamily = "'Proxima Nova Semibold',sans-serif";
// @green:                 #76a005;
const green$1 = "#76A005";
// @kaGreen:               #71b307;
const kaGreen$1 = "#71B307";
// @blue:                  #1c758a;
const blue$1 = "#1C758A";
// @gray:                  #aaa;
const gray$1 = "#AAAAAA";
// @red:                   #ffbaba;
const red$1 = "#FFBABA";
// @grayLight:             #aaa;
const grayLight$1 = "#AAAAAA";
// @grayLighter:           #ddd;
const grayLighter$1 = "#DDDDDD";
// @learnstormBlue:        #4898fc;
const learnstormBlue$1 = "#4898FC";
const white$1 = "#FFFFFF";
const gray98 = "#FAFAFA";
const gray97 = "#F6F7F7";
const gray95 = "#F0F1F2";
const gray90 = "#E3E5E6";
const gray85 = "#D6D8DA";
const gray76 = "#BABEC2";
const gray68 = "#888D93";
const gray41 = "#626569";
const gray25 = "#3B3e40";
const gray17 = "#21242c";
const black$1 = "#000000";
const warning1 = "#F86700";
const warning3 = "#C75300";

// @pure-sm-min: 568px;
const pureSmMin$2 = "568px";
// @pure-md-min: 768px;
const pureMdMin$2 = "768px";
// @pure-lg-min: 1024px;
const pureLgMin$2 = "1024px";
// @pure-xl-min: 1280px;
const pureXlMin$2 = "1280px";
// @pure-xs-max: (@pure-sm-min - 1);
const pureXsMax$2 = "567px";
// @pure-sm-max: (@pure-md-min - 1);
const pureSmMax$2 = "767px";
// @pure-md-max: (@pure-lg-min - 1);
const pureMdMax$2 = "1023px";
// @pure-lg-max: (@pure-xl-min - 1);
const pureLgMax$2 = "1279px";
// @tableBackgroundAccent: #f9f9f9; // for striping
const tableBackgroundAccent$1 = "#F9F9F9";
// @zIndexScratchPad: 1;
const zIndexScratchPad = 1;
// @zIndexAboveScratchpad: @zIndexScratchPad + 1;
const zIndexAboveScratchpad$1 = 2;
// @zIndexInteractiveComponent: @zIndexAboveScratchpad + 1;
const zIndexInteractiveComponent$1 = 3;
// @zIndexCurrentlyDragging: @zIndexInteractiveComponent + 1;
const zIndexCurrentlyDragging = 4;
// @zIndexCalculator: @zIndexCurrentlyDragging + 1;
const zIndexCalculator = 5;
// @phoneMargin: 16px;
const phoneMargin = 16;
const negativePhoneMargin = -16;
const hintBorderWidth = 4;

// The 'base unit' -- our new typography and layout styles are defined in
// terms of multiples of the 'base unit'.
const baseUnitPx = 16;
const interactiveSizes$1 = {
  defaultBoxSize: 400,
  defaultBoxSizeSmall: 288
};
const circleSize$1 = 24;
const radioMarginWidth$1 = 2;
const warningColor = "#f86700";
const warningColorHover = "#df5c00";
const warningColorActive = "#c75300";
const publishBlockingErrorColor = "#be2612";
const radioBorderColor$1 = "#BABEC2";
const checkedColor$1 = "#71B307";
const articleMaxWidthInPx = 688;
const articleMaxWidthTableInPx = 512;

var constants$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    baseFontFamily: baseFontFamily$1,
    boldFontFamily: boldFontFamily,
    green: green$1,
    kaGreen: kaGreen$1,
    blue: blue$1,
    gray: gray$1,
    red: red$1,
    grayLight: grayLight$1,
    grayLighter: grayLighter$1,
    learnstormBlue: learnstormBlue$1,
    white: white$1,
    gray98: gray98,
    gray97: gray97,
    gray95: gray95,
    gray90: gray90,
    gray85: gray85,
    gray76: gray76,
    gray68: gray68,
    gray41: gray41,
    gray25: gray25,
    gray17: gray17,
    black: black$1,
    warning1: warning1,
    warning3: warning3,
    pureSmMin: pureSmMin$2,
    pureMdMin: pureMdMin$2,
    pureLgMin: pureLgMin$2,
    pureXlMin: pureXlMin$2,
    pureXsMax: pureXsMax$2,
    pureSmMax: pureSmMax$2,
    pureMdMax: pureMdMax$2,
    pureLgMax: pureLgMax$2,
    tableBackgroundAccent: tableBackgroundAccent$1,
    zIndexScratchPad: zIndexScratchPad,
    zIndexAboveScratchpad: zIndexAboveScratchpad$1,
    zIndexInteractiveComponent: zIndexInteractiveComponent$1,
    zIndexCurrentlyDragging: zIndexCurrentlyDragging,
    zIndexCalculator: zIndexCalculator,
    phoneMargin: phoneMargin,
    negativePhoneMargin: negativePhoneMargin,
    hintBorderWidth: hintBorderWidth,
    baseUnitPx: baseUnitPx,
    interactiveSizes: interactiveSizes$1,
    circleSize: circleSize$1,
    radioMarginWidth: radioMarginWidth$1,
    warningColor: warningColor,
    warningColorHover: warningColorHover,
    warningColorActive: warningColorActive,
    publishBlockingErrorColor: publishBlockingErrorColor,
    radioBorderColor: radioBorderColor$1,
    checkedColor: checkedColor$1,
    articleMaxWidthInPx: articleMaxWidthInPx,
    articleMaxWidthTableInPx: articleMaxWidthTableInPx
});

const MIN_VIEWPORT_HEIGHT = 480;
class FixedToResponsive extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_isMounted", false);
    _defineProperty(this, "state", {
      viewportHeight: null,
      viewportWidth: null
    });
    _defineProperty(this, "_cacheViewportSize", () => {
      if (this._isMounted) {
        this.setState({
          viewportHeight: Math.max(MIN_VIEWPORT_HEIGHT, window.innerHeight),
          viewportWidth: window.innerWidth
        });
      }
    });
  }
  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;

    // Cache viewport sizes instead of computing on each render.
    // We setState() in componentDidMount(), even though it's a React
    // anti-pattern, because we do actually want to trigger a re-render
    // after the initial render (because initial render may be
    // server-side).
    // TODO(david): Don't do this for each image. Do this once per page.
    if (window.innerHeight < MIN_VIEWPORT_HEIGHT) {
      // There is a weird issue when this gets rendered in an Android
      // webview where window.innerHeight might be initially very small,
      // like 46, but seems to be good after ~400ms.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(this._cacheViewportSize, 800);
    } else {
      this._cacheViewportSize();
    }
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    // The ideal behavior for responsified, fixed size child components is
    // that they shrink when they need to (while preserving aspect ratio)
    // but never grow larger than their original dimensions. We accomplish
    // this by absolutely positioning the children and telling them to fill
    // up all of a space that has the correct aspect ratio.
    const aspectRatio = this.props.width / this.props.height;

    // This works because padding percentages are interpreted in terms of
    // the width of the containing block, so:
    //     (fixed height / fixed width) * display width = display height
    // Based on http://refills.bourbon.io/components/#video && medium.com
    const spacer = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        // @ts-expect-error [FEI-5003] - TS2362 - The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
        paddingBottom: (1 / aspectRatio).toFixed(4) * 100 + "%"
      }
    });
    let {
      width,
      height
    } = this.props;

    // Constrain height to be at most 2/3 viewport height, maintaining
    // aspect ratio.
    if (this.props.constrainHeight && this.state.viewportHeight) {
      const maxHeight = 2 / 3 * this.state.viewportHeight;
      if (this.props.height >= maxHeight) {
        height = maxHeight;
        width = maxHeight * aspectRatio;
      }
    }

    // Prevent child components from growing (aka "the Peter Pan effect")
    const style = {
      maxWidth: width,
      maxHeight: height
    };

    // NOTE(jeremy): This depends on styles defined in perseus-renderer.less
    const className = classNames__default["default"]("fixed-to-responsive", this.props.className);
    const container = /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      style: style
    }, spacer, this.props.children);
    const shouldFullBleed = this.props.allowFullBleed && this.state.viewportWidth && width >= this.state.viewportWidth;
    if (shouldFullBleed) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          marginLeft: negativePhoneMargin,
          marginRight: negativePhoneMargin
        }
      }, container);
    }
    return container;
  }
}
_defineProperty(FixedToResponsive, "defaultProps", {
  className: "",
  constrainHeight: false,
  allowFullBleed: false
});

/* eslint-disable @babel/no-invalid-this */

/* Local helper methods. */

function getKey(eventName, id) {
  return eventName + ":" + id;
}
function getEventName(key) {
  return key.split(":")[0];
}
const MovableHelperMethods = {
  /**
   * Fire an onSomething type event to all functions in listeners
   */
  _fireEvent: function (listeners, currentValue, previousValue) {
    ___default["default"].invoke(listeners, "call", this, currentValue, previousValue);
  },
  /**
   * Combine the array of constraints functions
   * Returns either an [x, y] coordinate or false
   */
  _applyConstraints: function (current, previous, extraOptions) {
    let skipRemaining = false;
    return ___default["default"].reduce(this.state.constraints, (memo, constraint) => {
      // A move that has been cancelled won't be propagated to later
      // constraints calls
      if (memo === false) {
        return false;
      }
      if (skipRemaining) {
        return memo;
      }
      const result = constraint.call(this, memo, previous, {
        onSkipRemaining: () => {
          skipRemaining = true;
        },
        ...extraOptions
      });
      if (result === false) {
        // Returning false cancels the move
        return false;
      }
      if (kmath.point.is(result, 2)) {
        // Returning a coord from constraints overrides the move
        return result;
      }
      if (result === true || result == null) {
        // Returning true or undefined allow the move to occur
        return memo;
      }
      // Anything else is an error
      throw new PerseusError("Constraint returned invalid result: " + result, Errors.Internal);
    }, current, this);
  },
  /**
   * Call all draw functions, and update our prevState for the next
   * draw function
   */
  draw: function () {
    const currState = this.cloneState();
    MovableHelperMethods._fireEvent.call(this, this.state.draw, currState, this.prevState);
    this.prevState = currState;
  },
  /**
   * Add a listener to any event: startMove, constraints, onMove, onMoveEnd,
   * etc. If a listener is already bound to the given eventName and id, then
   * it is overwritten by func.
   *
   * eventName: the string name of the event to listen to. one of:
   *   "onMoveStart", "onMove", "onMoveEnd", "draw", "remove"
   *
   * id: a string id that can be used to remove this event at a later time
   *   note: adding multiple listeners with the same id is undefined behavior
   *
   * func: the function to call when the event happens, which is called
   *   with the event's standard parameters [usually (coord, prevCoord) or
   *   (state, prevState)]
   */
  listen: function (eventName, id, func) {
    this._listenerMap = this._listenerMap || {};

    // If there's an existing handler, replace it by using its index in
    // `this.state[eventName]`; otherwise, add this handler to the end
    const key = getKey(eventName, id);
    const index = this._listenerMap[key] = this._listenerMap[key] || this.state[eventName].length;
    this.state[eventName][index] = func;
  },
  /**
   * Remove a previously added listener, by the id specified in the
   * corresponding listen() call
   *
   * If the given id has not been registered already, this is a no-op
   */
  unlisten: function (eventName, id) {
    this._listenerMap = this._listenerMap || {};
    const key = getKey(eventName, id);
    const index = this._listenerMap[key];
    if (index !== undefined) {
      // Remove handler from list of event handlers and listenerMap
      this.state[eventName].splice(index, 1);
      delete this._listenerMap[key];

      // Re-index existing events: if they occur after `index`, decrement
      const keys = ___default["default"].keys(this._listenerMap);
      ___default["default"].each(keys, function (key) {
        if (getEventName(key) === eventName &&
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._listenerMap[key] > index) {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._listenerMap[key]--;
        }
      }, this);
    }
  }
};

/**
 * Utility functions for writing Interactive2 movablethings
 */

/**
 * Compute the correct vendor-prefixed `transform`.
 */
let prefixedTransform = null;
function computePrefixedTransform() {
  // Temporary element for testing prefix validity
  const el = document.createElement("div");
  const prefixes = ["transform", "msTransform", "MozTransform", "WebkitTransform", "OTransform"];
  let correctPrefix = null;
  ___default["default"].each(prefixes, function (prefix) {
    if (typeof el.style[prefix] !== "undefined") {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      correctPrefix = prefix;
    }
  });
  return correctPrefix;
}

/**
 * Compute whether the browser can use 3d transforms by trying to use the
 * translateZ transformation.
 */
let canUse3dTransform = null;
function computeCanUse3dTransform() {
  const el = document.createElement("div");
  const prefix = InteractiveUtil.getPrefixedTransform();

  // Prefix could be null.
  // @ts-expect-error [FEI-5003] - TS2538 - Type 'null' cannot be used as an index type. | TS2538 - Type 'undefined' cannot be used as an index type.
  el.style[prefix] = "translateZ(0px)";
  // @ts-expect-error [FEI-5003] - TS2538 - Type 'null' cannot be used as an index type. | TS2538 - Type 'undefined' cannot be used as an index type.
  return !!el.style[prefix];
}
const InteractiveUtil = {
  assert: function (isTrue, message) {
    if (!isTrue) {
      throw new PerseusError("Assertion Error" + (message ? ": " + message : ""), Errors.Internal);
    }
  },
  /**
   * Create getters for this.state, based on the default state, `defaults`
   */
  createGettersFor: function (Class, defaults) {
    ___default["default"].each(___default["default"].keys(defaults), function (key) {
      if (Class.prototype[key] === undefined) {
        Class.prototype[key] = function () {
          return this.state[key];
        };
      }
    });
  },
  /**
   * Add MovableHelperMethods methods to a MovableThing class
   */
  addMovableHelperMethodsTo: function (Class) {
    ___default["default"].each(MovableHelperMethods, function (methodFunc, methodName) {
      if (Class.prototype[methodName] === undefined) {
        Class.prototype[methodName] = methodFunc;
      }
    });
  },
  /**
   * Turn a function or an array of functions into an array of functions
   */
  arrayify: function (funcOrArray) {
    if (funcOrArray == null) {
      return [];
    }
    if (___default["default"].isArray(funcOrArray)) {
      return ___default["default"].filter(___default["default"].flatten(funcOrArray), ___default["default"].identity);
    }
    return [funcOrArray];
  },
  /**
   * Convert all function-or-array arguments to arrays of functions
   */
  normalizeOptions: function (arrayOptionNames, options) {
    // TODO(jack): Having to clone here is annoying; this
    // function should really just modify this.state in place
    // (and maybe be a function on MovableHelperMethods to get access
    // to this.state), which would also be nicer because we could
    // normalizeOptions once in this.modify
    const result = ___default["default"].clone(options);
    ___default["default"].each(arrayOptionNames, function (eventName) {
      const funcOrArray = options[eventName];
      // Only propagate values which were set; not present values
      // shouldn't be added to options because we'd like them to
      // fall through to defaults
      if (funcOrArray !== undefined) {
        const funcArray = InteractiveUtil.arrayify(funcOrArray);
        result[eventName] = funcArray;
      }
    });
    return result;
  },
  /**
   * Get the correct vendor-prefixed `transform`.
   */
  getPrefixedTransform: function () {
    // Cache result to avoid re-computation
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'string | null | undefined' is not assignable to type 'null'.
    prefixedTransform = prefixedTransform || computePrefixedTransform();
    return prefixedTransform;
  },
  /**
   * Get whether the browser can use 3d transforms.
   */
  getCanUse3dTransform: function () {
    if (canUse3dTransform == null) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'boolean' is not assignable to type 'null'.
      canUse3dTransform = computeCanUse3dTransform();
    }
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'boolean'.
    return canUse3dTransform;
  }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var raphael = {exports: {}};

/*!
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */

(function () {
  var setAttr;
  if ("".trim) {
    setAttr = function (node, att, value) {
      node.setAttribute(att, String(value).trim());
    };
  } else {
    setAttr = function (node, att, value) {
      node.setAttribute(att, String(value));
    };
  }
  function R() {
    if (R.is(arguments[0], array)) {
      var a = arguments[0],
        cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
        res = cnv.set();
      for (var i = 0, ii = a[length]; i < ii; i++) {
        var j = a[i] || {};
        elements[has](j.type) && res[push](cnv[j.type]().attr(j));
      }
      return res;
    }
    return create[apply](R, arguments);
  }
  R.version = "1.5.2";
  var separator = /[, ]+/,
    elements = {
      circle: 1,
      rect: 1,
      path: 1,
      ellipse: 1,
      text: 1,
      image: 1
    },
    formatrg = /\{(\d+)\}/g,
    proto = "prototype",
    has = "hasOwnProperty",
    doc = document,
    win = window,
    oldRaphael = {
      was: Object[proto][has].call(win, "Raphael"),
      is: win.Raphael
    },
    Paper = function () {
      this.customAttributes = {};
    },
    paperproto,
    appendChild = "appendChild",
    apply = "apply",
    concat = "concat",
    supportsTouch = ("createTouch" in doc),
    E = "",
    S = " ",
    Str = String,
    split = "split",
    events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
    touchMap = {
      mousedown: "touchstart",
      mousemove: "touchmove",
      mouseup: "touchend"
    },
    join = "join",
    length = "length",
    lowerCase = Str[proto].toLowerCase,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    PI = math.PI,
    nu = "number",
    string = "string",
    array = "array",
    toString = "toString",
    fillString = "fill",
    objectToString = Object[proto][toString],
    push = "push",
    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
    isnan = {
      "NaN": 1,
      "Infinity": 1,
      "-Infinity": 1
    },
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    round = math.round,
    toFloat = parseFloat,
    toInt = parseInt,
    ms = " progid:DXImageTransform.Microsoft",
    upperCase = Str[proto].toUpperCase,
    availableAttrs = {
      blur: 0,
      "clip-rect": "0 0 1e9 1e9",
      cursor: "default",
      cx: 0,
      cy: 0,
      fill: "#fff",
      "fill-opacity": 1,
      font: '10px "Arial"',
      "font-family": '"Arial"',
      "font-size": "10",
      "font-style": "normal",
      "font-weight": 400,
      gradient: 0,
      height: 0,
      href: "http://raphaeljs.com/",
      opacity: 1,
      path: "M0,0",
      r: 0,
      rotation: 0,
      rx: 0,
      ry: 0,
      scale: "1 1",
      src: "",
      stroke: "#000",
      "stroke-dasharray": "",
      "stroke-linecap": "butt",
      "stroke-linejoin": "butt",
      "stroke-miterlimit": 0,
      "stroke-opacity": 1,
      "stroke-width": 1,
      target: "_blank",
      "text-anchor": "middle",
      title: "Raphael",
      translation: "0 0",
      width: 0,
      x: 0,
      y: 0
    },
    availableAnimAttrs = {
      along: "along",
      blur: nu,
      "clip-rect": "csv",
      cx: nu,
      cy: nu,
      fill: "colour",
      "fill-opacity": nu,
      "font-size": nu,
      height: nu,
      opacity: nu,
      path: "path",
      r: nu,
      rotation: "csv",
      rx: nu,
      ry: nu,
      scale: "csv",
      stroke: "colour",
      "stroke-opacity": nu,
      "stroke-width": nu,
      translation: "csv",
      width: nu,
      x: nu,
      y: nu
    },
    rp = "replace",
    animKeyFrames = /^(from|to|\d+%?)$/,
    commaSpaces = /\s*,\s*/,
    hsrg = {
      hs: 1,
      rg: 1
    },
    p2s = /,?([achlmqrstvxz]),?/gi,
    pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
    radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
    sortByKey = function (a, b) {
      return a.key - b.key;
    };
  R.type = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML";
  if (R.type == "VML") {
    var d = doc.createElement("div"),
      b;
    d.innerHTML = '<v:shape adj="1"/>';
    b = d.firstChild;
    b.style.behavior = "url(#default#VML)";
    if (!(b && typeof b.adj == "object")) {
      return R.type = null;
    }
    d = null;
  }
  R.svg = !(R.vml = R.type == "VML");
  Paper[proto] = R[proto];
  paperproto = Paper[proto];
  R._id = 0;
  R._oid = 0;
  R.fn = {};
  R.is = function (o, type) {
    type = lowerCase.call(type);
    if (type == "finite") {
      return !isnan[has](+o);
    }
    return type == "null" && o === null || type == typeof o || type == "object" && o === Object(o) || type == "array" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
  };
  R.angle = function (x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
      var x = x1 - x2,
        y = y1 - y2;
      if (!x && !y) {
        return 0;
      }
      return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
    } else {
      return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    }
  };
  R.rad = function (deg) {
    return deg % 360 * PI / 180;
  };
  R.deg = function (rad) {
    return rad * 180 / PI % 360;
  };
  R.snapTo = function (values, value, tolerance) {
    tolerance = R.is(tolerance, "finite") ? tolerance : 10;
    if (R.is(values, array)) {
      var i = values.length;
      while (i--) if (abs(values[i] - value) <= tolerance) {
        return values[i];
      }
    } else {
      values = +values;
      var rem = value % values;
      if (rem < tolerance) {
        return value - rem;
      }
      if (rem > values - tolerance) {
        return value - rem + values;
      }
    }
    return value;
  };
  function createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = [],
      i = 0;
    for (; i < 32; i++) {
      s[i] = (~~(math.random() * 16))[toString](16);
    }
    s[12] = 4; // bits 12-15 of the time_hi_and_version field to 0010
    s[16] = (s[16] & 3 | 8)[toString](16); // bits 6-7 of the clock_seq_hi_and_reserved to 01
    return "r-" + s[join]("");
  }
  R.setWindow = function (newwin) {
    win = newwin;
    doc = win.document;
  };
  // colour utilities
  var toHex = function (color) {
      if (R.vml) {
        // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
        var trim = /^\s+|\s+$/g;
        var bod;
        try {
          var docum = new ActiveXObject("htmlfile");
          docum.write("<body>");
          docum.close();
          bod = docum.body;
        } catch (e) {
          bod = createPopup().document.body;
        }
        var range = bod.createTextRange();
        toHex = cacher(function (color) {
          try {
            bod.style.color = Str(color)[rp](trim, E);
            var value = range.queryCommandValue("ForeColor");
            value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;
            return "#" + ("000000" + value[toString](16)).slice(-6);
          } catch (e) {
            return "none";
          }
        });
      } else {
        var i = doc.createElement("i");
        i.title = "Rapha\xebl Colour Picker";
        i.style.display = "none";
        doc.body[appendChild](i);
        toHex = cacher(function (color) {
          i.style.color = color;
          return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        });
      }
      return toHex(color);
    },
    hsbtoString = function () {
      return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
      return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
      return this.hex;
    };
  R.hsb2rgb = function (h, s, b, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
      b = h.b;
      s = h.s;
      h = h.h;
      o = h.o;
    }
    return R.hsl2rgb(h, s, b / 2, o);
  };
  R.hsl2rgb = function (h, s, l, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
      l = h.l;
      s = h.s;
      h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
      h /= 360;
      s /= 100;
      l /= 100;
    }
    var rgb = {},
      channels = ["r", "g", "b"],
      t2,
      t1,
      t3;
    if (!s) {
      rgb = {
        r: l,
        g: l,
        b: l
      };
    } else {
      if (l < .5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;
        if (t3 * 6 < 1) {
          rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
        } else if (t3 * 2 < 1) {
          rgb[channels[i]] = t2;
        } else if (t3 * 3 < 2) {
          rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          rgb[channels[i]] = t1;
        }
      }
    }
    rgb.r *= 255;
    rgb.g *= 255;
    rgb.b *= 255;
    rgb.hex = "#" + (16777216 | rgb.b | rgb.g << 8 | rgb.r << 16).toString(16).slice(1);
    R.is(o, "finite") && (rgb.opacity = o);
    rgb.toString = rgbtoString;
    return rgb;
  };
  R.rgb2hsb = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }
    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }
    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }
    var max = mmax(red, green, blue),
      min = mmin(red, green, blue),
      hue,
      saturation,
      brightness = max;
    if (min == max) {
      return {
        h: 0,
        s: 0,
        b: max,
        toString: hsbtoString
      };
    } else {
      var delta = max - min;
      saturation = delta / max;
      if (red == max) {
        hue = (green - blue) / delta;
      } else if (green == max) {
        hue = 2 + (blue - red) / delta;
      } else {
        hue = 4 + (red - green) / delta;
      }
      hue /= 6;
      hue < 0 && hue++;
      hue > 1 && hue--;
    }
    return {
      h: hue,
      s: saturation,
      b: brightness,
      toString: hsbtoString
    };
  };
  R.rgb2hsl = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }
    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }
    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }
    var max = mmax(red, green, blue),
      min = mmin(red, green, blue),
      h,
      s,
      l = (max + min) / 2,
      hsl;
    if (min == max) {
      hsl = {
        h: 0,
        s: 0,
        l: l
      };
    } else {
      var delta = max - min;
      s = l < .5 ? delta / (max + min) : delta / (2 - max - min);
      if (red == max) {
        h = (green - blue) / delta;
      } else if (green == max) {
        h = 2 + (blue - red) / delta;
      } else {
        h = 4 + (red - green) / delta;
      }
      h /= 6;
      h < 0 && h++;
      h > 1 && h--;
      hsl = {
        h: h,
        s: s,
        l: l
      };
    }
    hsl.toString = hsltoString;
    return hsl;
  };
  R._path2string = function () {
    return this.join(",")[rp](p2s, "$1");
  };
  function cacher(f, scope, postprocessor) {
    function newf() {
      var arg = Array[proto].slice.call(arguments, 0),
        args = arg[join]("\u25ba"),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];
      if (cache[has](args)) {
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }
      count[length] >= 1e3 && delete cache[count.shift()];
      count[push](args);
      cache[args] = f[apply](scope, arg);
      return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
  }
  R.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none",
        error: 1
      };
    }
    if (colour == "none") {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none"
      };
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    var red,
      green,
      blue,
      opacity,
      t,
      values,
      rgb = colour.match(colourRegExp);
    if (rgb) {
      if (rgb[2]) {
        blue = toInt(rgb[2].substring(5), 16);
        green = toInt(rgb[2].substring(3, 5), 16);
        red = toInt(rgb[2].substring(1, 3), 16);
      }
      if (rgb[3]) {
        blue = toInt((t = rgb[3].charAt(3)) + t, 16);
        green = toInt((t = rgb[3].charAt(2)) + t, 16);
        red = toInt((t = rgb[3].charAt(1)) + t, 16);
      }
      if (rgb[4]) {
        values = rgb[4][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
      }
      if (rgb[5]) {
        values = rgb[5][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsb2rgb(red, green, blue, opacity);
      }
      if (rgb[6]) {
        values = rgb[6][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsl2rgb(red, green, blue, opacity);
      }
      rgb = {
        r: red,
        g: green,
        b: blue
      };
      rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
      R.is(opacity, "finite") && (rgb.opacity = opacity);
      return rgb;
    }
    return {
      r: -1,
      g: -1,
      b: -1,
      hex: "none",
      error: 1
    };
  }, R);
  R.getColor = function (value) {
    var start = this.getColor.start = this.getColor.start || {
        h: 0,
        s: 1,
        b: value || .75
      },
      rgb = this.hsb2rgb(start.h, start.s, start.b);
    start.h += .075;
    if (start.h > 1) {
      start.h = 0;
      start.s -= .2;
      start.s <= 0 && (this.getColor.start = {
        h: 0,
        s: 1,
        b: start.b
      });
    }
    return rgb.hex;
  };
  R.getColor.reset = function () {
    delete this.start;
  };
  // path utilities
  R.parsePathString = cacher(function (pathString) {
    if (!pathString) {
      return null;
    }
    var paramCounts = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      },
      data = [];
    if (R.is(pathString, array) && R.is(pathString[0], array)) {
      // rough assumption
      data = pathClone(pathString);
    }
    if (!data[length]) {
      Str(pathString)[rp](pathCommand, function (a, b, c) {
        var params = [],
          name = lowerCase.call(b);
        c[rp](pathValues, function (a, b) {
          b && params[push](+b);
        });
        if (name == "m" && params[length] > 2) {
          data[push]([b][concat](params.splice(0, 2)));
          name = "l";
          b = b == "m" ? "l" : "L";
        }
        while (params[length] >= paramCounts[name]) {
          data[push]([b][concat](params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }
    data[toString] = R._path2string;
    return data;
  });
  R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
      x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
      y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
      mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
      my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
      nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
      ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
      ax = (1 - t) * p1x + t * c1x,
      ay = (1 - t) * p1y + t * c1y,
      cx = (1 - t) * c2x + t * p2x,
      cy = (1 - t) * c2y + t * p2y,
      alpha = 90 - math.atan((mx - nx) / (my - ny)) * 180 / PI;
    (mx > nx || my < ny) && (alpha += 180);
    return {
      x: x,
      y: y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha: alpha
    };
  };
  var pathDimensions = cacher(function (path) {
      if (!path) {
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      path = path2curve(path);
      var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;
      for (var i = 0, ii = path[length]; i < ii; i++) {
        p = path[i];
        if (p[0] == "M") {
          x = p[1];
          y = p[2];
          X[push](x);
          Y[push](y);
        } else {
          var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
          X = X[concat](dim.min.x, dim.max.x);
          Y = Y[concat](dim.min.y, dim.max.y);
          x = p[5];
          y = p[6];
        }
      }
      var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y);
      return {
        x: xmin,
        y: ymin,
        width: mmax[apply](0, X) - xmin,
        height: mmax[apply](0, Y) - ymin
      };
    }),
    pathClone = function (pathArray) {
      var res = [];
      if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
      }
      for (var i = 0, ii = pathArray[length]; i < ii; i++) {
        res[i] = [];
        for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
          res[i][j] = pathArray[i][j];
        }
      }
      res[toString] = R._path2string;
      return res;
    },
    pathToRelative = cacher(function (pathArray) {
      if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
      }
      var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;
      if (pathArray[0][0] == "M") {
        x = pathArray[0][1];
        y = pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[push](["M", x, y]);
      }
      for (var i = start, ii = pathArray[length]; i < ii; i++) {
        var r = res[i] = [],
          pa = pathArray[i];
        if (pa[0] != lowerCase.call(pa[0])) {
          r[0] = lowerCase.call(pa[0]);
          switch (r[0]) {
            case "a":
              r[1] = pa[1];
              r[2] = pa[2];
              r[3] = pa[3];
              r[4] = pa[4];
              r[5] = pa[5];
              r[6] = +(pa[6] - x).toFixed(3);
              r[7] = +(pa[7] - y).toFixed(3);
              break;
            case "v":
              r[1] = +(pa[1] - y).toFixed(3);
              break;
            case "m":
              mx = pa[1];
              my = pa[2];
            default:
              for (var j = 1, jj = pa[length]; j < jj; j++) {
                r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
              }
          }
        } else {
          r = res[i] = [];
          if (pa[0] == "m") {
            mx = pa[1] + x;
            my = pa[2] + y;
          }
          for (var k = 0, kk = pa[length]; k < kk; k++) {
            res[i][k] = pa[k];
          }
        }
        var len = res[i][length];
        switch (res[i][0]) {
          case "z":
            x = mx;
            y = my;
            break;
          case "h":
            x += +res[i][len - 1];
            break;
          case "v":
            y += +res[i][len - 1];
            break;
          default:
            x += +res[i][len - 2];
            y += +res[i][len - 1];
        }
      }
      res[toString] = R._path2string;
      return res;
    }, 0, pathClone),
    pathToAbsolute = cacher(function (pathArray) {
      if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
      }
      var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;
      if (pathArray[0][0] == "M") {
        x = +pathArray[0][1];
        y = +pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[0] = ["M", x, y];
      }
      for (var i = start, ii = pathArray[length]; i < ii; i++) {
        var r = res[i] = [],
          pa = pathArray[i];
        if (pa[0] != upperCase.call(pa[0])) {
          r[0] = upperCase.call(pa[0]);
          switch (r[0]) {
            case "A":
              r[1] = pa[1];
              r[2] = pa[2];
              r[3] = pa[3];
              r[4] = pa[4];
              r[5] = pa[5];
              r[6] = +(pa[6] + x);
              r[7] = +(pa[7] + y);
              break;
            case "V":
              r[1] = +pa[1] + y;
              break;
            case "H":
              r[1] = +pa[1] + x;
              break;
            case "M":
              mx = +pa[1] + x;
              my = +pa[2] + y;
            default:
              for (var j = 1, jj = pa[length]; j < jj; j++) {
                r[j] = +pa[j] + (j % 2 ? x : y);
              }
          }
        } else {
          for (var k = 0, kk = pa[length]; k < kk; k++) {
            res[i][k] = pa[k];
          }
        }
        switch (r[0]) {
          case "Z":
            x = mx;
            y = my;
            break;
          case "H":
            x = r[1];
            break;
          case "V":
            y = r[1];
            break;
          case "M":
            mx = res[i][res[i][length] - 2];
            my = res[i][res[i][length] - 1];
          default:
            x = res[i][res[i][length] - 2];
            y = res[i][res[i][length] - 1];
        }
      }
      res[toString] = R._path2string;
      return res;
    }, null, pathClone),
    l2c = function (x1, y1, x2, y2) {
      return [x1, y1, x2, y2, x2, y2];
    },
    q2c = function (x1, y1, ax, ay, x2, y2) {
      var _13 = 1 / 3,
        _23 = 2 / 3;
      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
    },
    a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
      // for more information of where this math came from visit:
      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
      var _120 = PI * 120 / 180,
        rad = PI / 180 * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function (x, y, rad) {
          var X = x * math.cos(rad) - y * math.sin(rad),
            Y = x * math.sin(rad) + y * math.cos(rad);
          return {
            x: X,
            y: Y
          };
        });
      if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate(x2, y2, -rad);
        x2 = xy.x;
        y2 = xy.y;
        var x = (x1 - x2) / 2,
          y = (y1 - y2) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
          h = math.sqrt(h);
          rx = h * rx;
          ry = h * ry;
        }
        var rx2 = rx * rx,
          ry2 = ry * ry,
          k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
          cx = k * rx * y / ry + (x1 + x2) / 2,
          cy = k * -ry * x / rx + (y1 + y2) / 2,
          f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
          f2 = math.asin(((y2 - cy) / ry).toFixed(9));
        f1 = x1 < cx ? PI - f1 : f1;
        f2 = x2 < cx ? PI - f2 : f2;
        f1 < 0 && (f1 = PI * 2 + f1);
        f2 < 0 && (f2 = PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (abs(df) > _120) {
        var f2old = f2,
          x2old = x2,
          y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * math.cos(f2);
        y2 = cy + ry * math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
      }
      df = f2 - f1;
      var c1 = math.cos(f1),
        s1 = math.sin(f1),
        c2 = math.cos(f2),
        s2 = math.sin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
      m2[0] = 2 * m1[0] - m2[0];
      m2[1] = 2 * m1[1] - m2[1];
      if (recursive) {
        return [m2, m3, m4][concat](res);
      } else {
        res = [m2, m3, m4][concat](res)[join]()[split](",");
        var newres = [];
        for (var i = 0, ii = res[length]; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }
        return newres;
      }
    },
    findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
      var t1 = 1 - t;
      return {
        x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
        y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
      };
    },
    curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
      var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
      abs(t1) > "1e12" && (t1 = .5);
      abs(t2) > "1e12" && (t2 = .5);
      if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x[push](dot.x);
        y[push](dot.y);
      }
      if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x[push](dot.x);
        y[push](dot.y);
      }
      a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
      b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
      c = p1y - c1y;
      t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
      t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
      abs(t1) > "1e12" && (t1 = .5);
      abs(t2) > "1e12" && (t2 = .5);
      if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x[push](dot.x);
        y[push](dot.y);
      }
      if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x[push](dot.x);
        y[push](dot.y);
      }
      return {
        min: {
          x: mmin[apply](0, x),
          y: mmin[apply](0, y)
        },
        max: {
          x: mmax[apply](0, x),
          y: mmax[apply](0, y)
        }
      };
    }),
    path2curve = cacher(function (path, path2) {
      var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        },
        attrs2 = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        },
        processPath = function (path, d) {
          var nx, ny;
          if (!path) {
            return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
          }
          !(path[0] in {
            T: 1,
            Q: 1
          }) && (d.qx = d.qy = null);
          switch (path[0]) {
            case "M":
              d.X = path[1];
              d.Y = path[2];
              break;
            case "A":
              path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
              break;
            case "S":
              nx = d.x + (d.x - (d.bx || d.x));
              ny = d.y + (d.y - (d.by || d.y));
              path = ["C", nx, ny][concat](path.slice(1));
              break;
            case "T":
              d.qx = d.x + (d.x - (d.qx || d.x));
              d.qy = d.y + (d.y - (d.qy || d.y));
              path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
              break;
            case "Q":
              d.qx = path[1];
              d.qy = path[2];
              path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
              break;
            case "L":
              path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
              break;
            case "H":
              path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
              break;
            case "V":
              path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
              break;
            case "Z":
              path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
              break;
          }
          return path;
        },
        fixArc = function (pp, i) {
          if (pp[i][length] > 7) {
            pp[i].shift();
            var pi = pp[i];
            while (pi[length]) {
              pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = mmax(p[length], p2 && p2[length] || 0);
          }
        },
        fixM = function (path1, path2, a1, a2, i) {
          if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
            path2.splice(i, 0, ["M", a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = mmax(p[length], p2 && p2[length] || 0);
          }
        };
      for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
        p[i] = processPath(p[i], attrs);
        fixArc(p, i);
        p2 && (p2[i] = processPath(p2[i], attrs2));
        p2 && fixArc(p2, i);
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i],
          seg2 = p2 && p2[i],
          seglen = seg[length],
          seg2len = p2 && seg2[length];
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
      }
      return p2 ? [p, p2] : p;
    }, null, pathClone),
    parseDots = cacher(function (gradient) {
      var dots = [];
      for (var i = 0, ii = gradient[length]; i < ii; i++) {
        var dot = {},
          par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
        dot.color = R.getRGB(par[1]);
        if (dot.color.error) {
          return null;
        }
        dot.color = dot.color.hex;
        par[2] && (dot.offset = par[2] + "%");
        dots[push](dot);
      }
      for (i = 1, ii = dots[length] - 1; i < ii; i++) {
        if (!dots[i].offset) {
          var start = toFloat(dots[i - 1].offset || 0),
            end = 0;
          for (var j = i + 1; j < ii; j++) {
            if (dots[j].offset) {
              end = dots[j].offset;
              break;
            }
          }
          if (!end) {
            end = 100;
            j = ii;
          }
          end = toFloat(end);
          var d = (end - start) / (j - i + 1);
          for (; i < j; i++) {
            start += d;
            dots[i].offset = start + "%";
          }
        }
      }
      return dots;
    }),
    getContainer = function (x, y, w, h) {
      var container;
      if (R.is(x, string) || R.is(x, "object")) {
        container = R.is(x, string) ? doc.getElementById(x) : x;
        if (container.tagName) {
          if (y == null) {
            return {
              container: container,
              width: container.style.pixelWidth || container.offsetWidth,
              height: container.style.pixelHeight || container.offsetHeight
            };
          } else {
            return {
              container: container,
              width: y,
              height: w
            };
          }
        }
      } else {
        return {
          container: 1,
          x: x,
          y: y,
          width: w,
          height: h
        };
      }
    },
    plugins = function (con, add) {
      var that = this;
      for (var prop in add) {
        if (add[has](prop) && !(prop in con)) {
          switch (typeof add[prop]) {
            case "function":
              (function (f) {
                con[prop] = con === that ? f : function () {
                  return f[apply](that, arguments);
                };
              })(add[prop]);
              break;
            case "object":
              con[prop] = con[prop] || {};
              plugins.call(this, con[prop], add[prop]);
              break;
            default:
              con[prop] = add[prop];
              break;
          }
        }
      }
    },
    tear = function (el, paper) {
      el == paper.top && (paper.top = el.prev);
      el == paper.bottom && (paper.bottom = el.next);
      el.next && (el.next.prev = el.prev);
      el.prev && (el.prev.next = el.next);
    },
    tofront = function (el, paper) {
      if (paper.top === el) {
        return;
      }
      tear(el, paper);
      el.next = null;
      el.prev = paper.top;
      paper.top.next = el;
      paper.top = el;
    },
    toback = function (el, paper) {
      if (paper.bottom === el) {
        return;
      }
      tear(el, paper);
      el.next = paper.bottom;
      el.prev = null;
      paper.bottom.prev = el;
      paper.bottom = el;
    },
    insertafter = function (el, el2, paper) {
      tear(el, paper);
      el2 == paper.top && (paper.top = el);
      el2.next && (el2.next.prev = el);
      el.next = el2.next;
      el.prev = el2;
      el2.next = el;
    },
    insertbefore = function (el, el2, paper) {
      tear(el, paper);
      el2 == paper.bottom && (paper.bottom = el);
      el2.prev && (el2.prev.next = el);
      el.prev = el2.prev;
      el2.prev = el;
      el.next = el2;
    },
    removed = function (methodname) {
      return function () {
        throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
      };
    };
  R.pathToRelative = pathToRelative;
  // SVG
  if (R.svg) {
    paperproto.svgns = "http://www.w3.org/2000/svg";
    paperproto.xlink = "http://www.w3.org/1999/xlink";
    round = function (num) {
      return +num + (~~num === num) * .5;
    };
    var $ = function (el, attr) {
      if (attr) {
        for (var key in attr) {
          if (attr[has](key)) {
            setAttr(el, key, Str(attr[key]));
          }
        }
      } else {
        el = doc.createElementNS(paperproto.svgns, el);
        el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
        return el;
      }
    };
    R[toString] = function () {
      return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var thePath = function (pathString, SVG) {
      var el = $("path");
      SVG.canvas && SVG.canvas[appendChild](el);
      var p = new Element(el, SVG);
      p.type = "path";
      setFillAndStroke(p, {
        fill: "none",
        stroke: "#000",
        path: pathString
      });
      return p;
    };
    var addGradientFill = function (o, gradient, SVG) {
      var type = "linear",
        fx = .5,
        fy = .5,
        s = o.style;
      gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
        type = "radial";
        if (_fx && _fy) {
          fx = toFloat(_fx);
          fy = toFloat(_fy);
          var dir = (fy > .5) * 2 - 1;
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) && fy != .5 && (fy = fy.toFixed(5) - 1e-5 * dir);
        }
        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);
      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);
        if (isNaN(angle)) {
          return null;
        }
        var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
          max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
        vector[2] *= max;
        vector[3] *= max;
        if (vector[2] < 0) {
          vector[0] = -vector[2];
          vector[2] = 0;
        }
        if (vector[3] < 0) {
          vector[1] = -vector[3];
          vector[3] = 0;
        }
      }
      var dots = parseDots(gradient);
      if (!dots) {
        return null;
      }
      var id = o.getAttribute(fillString);
      id = id.match(/^url\(#(.*)\)$/);
      id && SVG.defs.removeChild(doc.getElementById(id[1]));
      var el = $(type + "Gradient");
      el.id = createUUID();
      $(el, type == "radial" ? {
        fx: fx,
        fy: fy
      } : {
        x1: vector[0],
        y1: vector[1],
        x2: vector[2],
        y2: vector[3]
      });
      SVG.defs[appendChild](el);
      for (var i = 0, ii = dots[length]; i < ii; i++) {
        var stop = $("stop");
        $(stop, {
          offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
          "stop-color": dots[i].color || "#fff"
        });
        el[appendChild](stop);
      }
      $(o, {
        fill: "url(#" + el.id + ")",
        opacity: 1,
        "fill-opacity": 1
      });
      s.fill = E;
      s.opacity = 1;
      s.fillOpacity = 1;
      return 1;
    };
    var updatePosition = function (o) {
      var bbox = o.getBBox();
      $(o.pattern, {
        patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)
      });
    };
    var setFillAndStroke = function (o, params) {
      var dasharray = {
          "": [0],
          "none": [0],
          "-": [3, 1],
          ".": [1, 1],
          "-.": [3, 1, 1, 1],
          "-..": [3, 1, 1, 1, 1, 1],
          ". ": [1, 3],
          "- ": [4, 3],
          "--": [8, 3],
          "- .": [4, 3, 1, 3],
          "--.": [8, 3, 1, 3],
          "--..": [8, 3, 1, 3, 1, 3]
        },
        node = o.node,
        attrs = o.attrs,
        rot = o.rotate(),
        addDashes = function (o, value) {
          value = dasharray[lowerCase.call(value)];
          if (value) {
            var width = o.attrs["stroke-width"] || "1",
              butt = {
                round: width,
                square: width,
                butt: 0
              }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
              dashes = [];
            var i = value[length];
            while (i--) {
              dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
            }
            $(node, {
              "stroke-dasharray": dashes[join](",")
            });
          }
        };
      params[has]("rotation") && (rot = params.rotation);
      var rotxy = Str(rot)[split](separator);
      if (!(rotxy.length - 1)) {
        rotxy = null;
      } else {
        rotxy[1] = +rotxy[1];
        rotxy[2] = +rotxy[2];
      }
      toFloat(rot) && o.rotate(0, true);
      for (var att in params) {
        if (params[has](att)) {
          if (!availableAttrs[has](att)) {
            continue;
          }
          var value = params[att];
          attrs[att] = value;
          switch (att) {
            case "blur":
              o.blur(value);
              break;
            case "rotation":
              o.rotate(value, true);
              break;
            case "href":
            case "title":
            case "target":
              var pn = node.parentNode;
              if (lowerCase.call(pn.tagName) != "a") {
                var hl = $("a");
                pn.insertBefore(hl, node);
                hl[appendChild](node);
                pn = hl;
              }
              if (att == "target" && value == "blank") {
                pn.setAttributeNS(o.paper.xlink, "show", "new");
              } else {
                pn.setAttributeNS(o.paper.xlink, att, value);
              }
              break;
            case "cursor":
              node.style.cursor = value;
              break;
            case "clip-rect":
              var rect = Str(value)[split](separator);
              if (rect[length] == 4) {
                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                var el = $("clipPath"),
                  rc = $("rect");
                el.id = createUUID();
                $(rc, {
                  x: rect[0],
                  y: rect[1],
                  width: rect[2],
                  height: rect[3]
                });
                el[appendChild](rc);
                o.paper.defs[appendChild](el);
                $(node, {
                  "clip-path": "url(#" + el.id + ")"
                });
                o.clip = rc;
              }
              if (!value) {
                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
                clip && clip.parentNode.removeChild(clip);
                $(node, {
                  "clip-path": E
                });
                delete o.clip;
              }
              break;
            case "path":
              if (o.type == "path") {
                $(node, {
                  d: value ? attrs.path = pathToAbsolute(value) : "M0,0"
                });
              }
              break;
            case "width":
              setAttr(node, att, value);
              if (attrs.fx) {
                att = "x";
                value = attrs.x;
              } else {
                break;
              }
            case "x":
              if (attrs.fx) {
                value = -attrs.x - (attrs.width || 0);
              }
            case "rx":
              if (att == "rx" && o.type == "rect") {
                break;
              }
            case "cx":
              rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;
            case "height":
              setAttr(node, att, value);
              if (attrs.fy) {
                att = "y";
                value = attrs.y;
              } else {
                break;
              }
            case "y":
              if (attrs.fy) {
                value = -attrs.y - (attrs.height || 0);
              }
            case "ry":
              if (att == "ry" && o.type == "rect") {
                break;
              }
            case "cy":
              rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;
            case "r":
              if (o.type == "rect") {
                $(node, {
                  rx: value,
                  ry: value
                });
              } else {
                setAttr(node, att, value);
              }
              break;
            case "src":
              if (o.type == "image") {
                node.setAttributeNS(o.paper.xlink, "href", value);
              }
              break;
            case "stroke-width":
              node.style.strokeWidth = value;
              // Need following line for Firefox
              setAttr(node, att, value);
              if (attrs["stroke-dasharray"]) {
                addDashes(o, attrs["stroke-dasharray"]);
              }
              break;
            case "stroke-dasharray":
              addDashes(o, value);
              break;
            case "translation":
              var xy = Str(value)[split](separator);
              xy[0] = +xy[0] || 0;
              xy[1] = +xy[1] || 0;
              if (rotxy) {
                rotxy[1] += xy[0];
                rotxy[2] += xy[1];
              }
              translate.call(o, xy[0], xy[1]);
              break;
            case "scale":
              xy = Str(value)[split](separator);
              o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
              break;
            case fillString:
              var isURL = Str(value).match(ISURL);
              if (isURL) {
                el = $("pattern");
                var ig = $("image");
                el.id = createUUID();
                $(el, {
                  x: 0,
                  y: 0,
                  patternUnits: "userSpaceOnUse",
                  height: 1,
                  width: 1
                });
                $(ig, {
                  x: 0,
                  y: 0
                });
                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
                el[appendChild](ig);
                var img = doc.createElement("img");
                img.style.cssText = "position:absolute;left:-9999em;top-9999em";
                img.onload = function () {
                  $(el, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  $(ig, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  doc.body.removeChild(this);
                  o.paper.safari();
                };
                doc.body[appendChild](img);
                img.src = isURL[1];
                o.paper.defs[appendChild](el);
                node.style.fill = "url(#" + el.id + ")";
                $(node, {
                  fill: "url(#" + el.id + ")"
                });
                o.pattern = el;
                o.pattern && updatePosition(o);
                break;
              }
              var clr = R.getRGB(value);
              if (!clr.error) {
                delete params.gradient;
                delete attrs.gradient;
                !R.is(attrs.opacity, "undefined") && R.is(params.opacity, "undefined") && $(node, {
                  opacity: attrs.opacity
                });
                !R.is(attrs["fill-opacity"], "undefined") && R.is(params["fill-opacity"], "undefined") && $(node, {
                  "fill-opacity": attrs["fill-opacity"]
                });
              } else if (({
                circle: 1,
                ellipse: 1
              }[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
                attrs.gradient = value;
                attrs.fill = "none";
                break;
              }
              clr[has]("opacity") && $(node, {
                "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });
            case "stroke":
              clr = R.getRGB(value);
              setAttr(node, att, clr.hex);
              att == "stroke" && clr[has]("opacity") && $(node, {
                "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });
              break;
            case "gradient":
              (({
                circle: 1,
                ellipse: 1
              })[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
              break;
            case "opacity":
              if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                $(node, {
                  "stroke-opacity": value > 1 ? value / 100 : value
                });
              }
            // fall
            case "fill-opacity":
              if (attrs.gradient) {
                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));
                if (gradient) {
                  var stops = gradient.getElementsByTagName("stop");
                  setAttr(stops[stops[length] - 1], "stop-opacity", value);
                }
                break;
              }
            default:
              att == "font-size" && (value = toInt(value, 10) + "px");
              var cssrule = att[rp](/(\-.)/g, function (w) {
                return upperCase.call(w.substring(1));
              });
              node.style[cssrule] = value;
              // Need following line for Firefox
              setAttr(node, att, value);
              break;
          }
        }
      }
      tuneText(o, params);
      if (rotxy) {
        o.rotate(rotxy.join(S));
      } else {
        toFloat(rot) && o.rotate(rot, true);
      }
    };
    var leading = 1.2,
      tuneText = function (el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
          return;
        }
        var a = el.attrs,
          node = el.node,
          fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;
        if (params[has]("text")) {
          a.text = params.text;
          while (node.firstChild) {
            node.removeChild(node.firstChild);
          }
          var texts = Str(params.text)[split]("\n");
          for (var i = 0, ii = texts[length]; i < ii; i++) if (texts[i]) {
            var tspan = $("tspan");
            i && $(tspan, {
              dy: fontSize * leading,
              x: a.x
            });
            tspan[appendChild](doc.createTextNode(texts[i]));
            node[appendChild](tspan);
          }
        } else {
          texts = node.getElementsByTagName("tspan");
          for (i = 0, ii = texts[length]; i < ii; i++) {
            i && $(texts[i], {
              dy: fontSize * leading,
              x: a.x
            });
          }
        }
        $(node, {
          y: a.y
        });
        var bb = el.getBBox(),
          dif = a.y - (bb.y + bb.height / 2);
        dif && R.is(dif, "finite") && $(node, {
          y: a.y + dif
        });
      },
      Element = function (node, svg) {
        this[0] = node;
        this.id = R._oid++;
        this.node = node;
        node.raphael = this;
        this.paper = svg;
        this.attrs = this.attrs || {};
        this.transformations = []; // rotate, translate, scale
        this._ = {
          tx: 0,
          ty: 0,
          rt: {
            deg: 0,
            cx: 0,
            cy: 0
          },
          sx: 1,
          sy: 1
        };
        !svg.bottom && (svg.bottom = this);
        this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        this.next = null;
      };
    var elproto = Element[proto];
    Element[proto].rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }
      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }
        return this._.rt.deg;
      }
      var bbox = this.getBBox();
      deg = Str(deg)[split](separator);
      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }
      deg = toFloat(deg[0]);
      if (cx != null && cx !== false) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }
      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      cx = cx == null ? bbox.x + bbox.width / 2 : cx;
      cy = cy == null ? bbox.y + bbox.height / 2 : cy;
      if (this._.rt.deg) {
        this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
        this.clip && $(this.clip, {
          transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)
        });
      } else {
        this.transformations[0] = E;
        this.clip && $(this.clip, {
          transform: E
        });
      }
      $(this.node, {
        transform: this.transformations[join](S)
      });
      return this;
    };
    Element[proto].hide = function () {
      !this.removed && (this.node.style.display = "none");
      return this;
    };
    Element[proto].show = function () {
      !this.removed && (this.node.style.display = "");
      return this;
    };
    Element[proto].remove = function () {
      if (this.removed) {
        return;
      }
      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);
      for (var i in this) {
        delete this[i];
      }
      this.removed = true;
    };
    Element[proto].getBBox = function () {
      if (this.removed) {
        return this;
      }
      if (this.type == "path") {
        return pathDimensions(this.attrs.path);
      }
      if (this.node.style.display == "none") {
        this.show();
        var hide = true;
      }
      var bbox = {};
      try {
        bbox = this.node.getBBox();
      } catch (e) {
        // Firefox 3.0.x plays badly here
      } finally {
        bbox = bbox || {};
      }
      if (this.type == "text") {
        bbox = {
          x: bbox.x,
          y: Infinity,
          width: 0,
          height: 0
        };
        for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
          var bb = this.node.getExtentOfChar(i);
          bb.y < bbox.y && (bbox.y = bb.y);
          bb.y + bb.height - bbox.y > bbox.height && (bbox.height = bb.y + bb.height - bbox.y);
          bb.x + bb.width - bbox.x > bbox.width && (bbox.width = bb.x + bb.width - bbox.x);
        }
      }
      hide && this.hide();
      return bbox;
    };
    Element[proto].attr = function (name, value) {
      if (this.removed) {
        return this;
      }
      if (name == null) {
        var res = {};
        for (var i in this.attrs) if (this.attrs[has](i)) {
          res[i] = this.attrs[i];
        }
        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }
      if (value == null && R.is(name, string)) {
        if (name == "translation") {
          return translate.call(this);
        }
        if (name == "rotation") {
          return this.rotate();
        }
        if (name == "scale") {
          return this.scale();
        }
        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }
        return this.attrs[name];
      }
      if (value == null && R.is(name, array)) {
        var values = {};
        for (var j = 0, jj = name.length; j < jj; j++) {
          values[name[j]] = this.attr(name[j]);
        }
        return values;
      }
      if (value != null) {
        var params = {};
        params[name] = value;
      } else if (name != null && R.is(name, "object")) {
        params = name;
      }
      for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
        var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
        this.attrs[key] = params[key];
        for (var subkey in par) if (par[has](subkey)) {
          params[subkey] = par[subkey];
        }
      }
      setFillAndStroke(this, params);
      return this;
    };
    Element[proto].toFront = function () {
      if (this.removed) {
        return this;
      }
      this.node.parentNode[appendChild](this.node);
      var svg = this.paper;
      svg.top != this && tofront(this, svg);
      return this;
    };
    Element[proto].toBack = function () {
      if (this.removed) {
        return this;
      }
      if (this.node.parentNode.firstChild != this.node) {
        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
        toback(this, this.paper);
        this.paper;
      }
      return this;
    };
    Element[proto].insertAfter = function (element) {
      if (this.removed) {
        return this;
      }
      var node = element.node || element[element.length - 1].node;
      if (node.nextSibling) {
        node.parentNode.insertBefore(this.node, node.nextSibling);
      } else {
        node.parentNode[appendChild](this.node);
      }
      insertafter(this, element, this.paper);
      return this;
    };
    Element[proto].insertBefore = function (element) {
      if (this.removed) {
        return this;
      }
      var node = element.node || element[0].node;
      node.parentNode.insertBefore(this.node, node);
      insertbefore(this, element, this.paper);
      return this;
    };
    Element[proto].blur = function (size) {
      // Experimental. No Safari support. Use it on your own risk.
      var t = this;
      if (+size !== 0) {
        var fltr = $("filter"),
          blur = $("feGaussianBlur");
        t.attrs.blur = size;
        fltr.id = createUUID();
        $(blur, {
          stdDeviation: +size || 1.5
        });
        fltr.appendChild(blur);
        t.paper.defs.appendChild(fltr);
        t._blur = fltr;
        $(t.node, {
          filter: "url(#" + fltr.id + ")"
        });
      } else {
        if (t._blur) {
          t._blur.parentNode.removeChild(t._blur);
          delete t._blur;
          delete t.attrs.blur;
        }
        t.node.removeAttribute("filter");
      }
    };
    var theCircle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas[appendChild](el);
        var res = new Element(el, svg);
        res.attrs = {
          cx: x,
          cy: y,
          r: r,
          fill: "none",
          stroke: "#000"
        };
        res.type = "circle";
        $(el, res.attrs);
        return res;
      },
      theRect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas[appendChild](el);
        var res = new Element(el, svg);
        res.attrs = {
          x: x,
          y: y,
          width: w,
          height: h,
          r: r || 0,
          rx: r || 0,
          ry: r || 0,
          fill: "none",
          stroke: "#000"
        };
        res.type = "rect";
        $(el, res.attrs);
        return res;
      },
      theEllipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas[appendChild](el);
        var res = new Element(el, svg);
        res.attrs = {
          cx: x,
          cy: y,
          rx: rx,
          ry: ry,
          fill: "none",
          stroke: "#000"
        };
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
      },
      theImage = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {
          x: x,
          y: y,
          width: w,
          height: h,
          preserveAspectRatio: "none"
        });
        el.setAttributeNS(svg.xlink, "href", src);
        svg.canvas && svg.canvas[appendChild](el);
        var res = new Element(el, svg);
        res.attrs = {
          x: x,
          y: y,
          width: w,
          height: h,
          src: src
        };
        res.type = "image";
        return res;
      },
      theText = function (svg, x, y, text) {
        var el = $("text");
        $(el, {
          x: x,
          y: y,
          "text-anchor": "middle"
        });
        svg.canvas && svg.canvas[appendChild](el);
        var res = new Element(el, svg);
        res.attrs = {
          x: x,
          y: y,
          "text-anchor": "middle",
          text: text,
          font: availableAttrs.font,
          stroke: "none",
          fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
      },
      setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        setAttr(this.canvas, "width", this.width);
        setAttr(this.canvas, "height", this.height);
        return this;
      },
      create = function () {
        var con = getContainer[apply](0, arguments),
          container = con && con.container,
          x = con.x,
          y = con.y,
          width = con.width,
          height = con.height;
        if (!container) {
          throw new Error("SVG container not found.");
        }
        var cnvs = $("svg");
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
          xmlns: "http://www.w3.org/2000/svg",
          version: 1.1,
          width: width,
          height: height
        });
        if (container == 1) {
          cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
          doc.body[appendChild](cnvs);
        } else {
          if (container.firstChild) {
            container.insertBefore(cnvs, container.firstChild);
          } else {
            container[appendChild](cnvs);
          }
        }
        container = new Paper();
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        plugins.call(container, container, R.fn);
        container.clear();
        return container;
      };
    paperproto.clear = function () {
      var c = this.canvas;
      while (c.firstChild) {
        c.removeChild(c.firstChild);
      }
      this.bottom = this.top = null;
      (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
      c[appendChild](this.desc);
      c[appendChild](this.defs = $("defs"));
    };
    paperproto.remove = function () {
      this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
      for (var i in this) {
        this[i] = removed(i);
      }
    };
  }

  // VML
  if (R.vml) {
    var map = {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
      },
      bites = /([clmz]),?([^clmz]*)/gi,
      blurregexp = / progid:\S+Blur\([^\)]+\)/g,
      val = /-?[^,\s-]+/g,
      coordsize = 1e3 + S + 1e3,
      zoom = 10,
      pathlike = {
        path: 1,
        rect: 1
      },
      path2vml = function (path) {
        var total = /[ahqstv]/ig,
          command = pathToAbsolute;
        Str(path).match(total) && (command = path2curve);
        total = /[clmz]/g;
        if (command == pathToAbsolute && !Str(path).match(total)) {
          var res = Str(path)[rp](bites, function (all, command, args) {
            var vals = [],
              isMove = lowerCase.call(command) == "m",
              res = map[command];
            args[rp](val, function (value) {
              if (isMove && vals[length] == 2) {
                res += vals + map[command == "m" ? "l" : "L"];
                vals = [];
              }
              vals[push](round(value * zoom));
            });
            return res + vals;
          });
          return res;
        }
        var pa = command(path),
          p,
          r;
        res = [];
        for (var i = 0, ii = pa[length]; i < ii; i++) {
          p = pa[i];
          r = lowerCase.call(pa[i][0]);
          r == "z" && (r = "x");
          for (var j = 1, jj = p[length]; j < jj; j++) {
            r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
          }
          res[push](r);
        }
        return res[join](S);
      };
    R[toString] = function () {
      return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    thePath = function (pathString, vml) {
      var g = createNode("group");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = vml.coordsize;
      g.coordorigin = vml.coordorigin;
      var el = createNode("shape"),
        ol = el.style;
      ol.width = vml.width + "px";
      ol.height = vml.height + "px";
      el.coordsize = coordsize;
      el.coordorigin = vml.coordorigin;
      g[appendChild](el);
      var p = new Element(el, g, vml),
        attr = {
          fill: "none",
          stroke: "#000"
        };
      pathString && (attr.path = pathString);
      p.type = "path";
      p.path = [];
      p.Path = E;
      setFillAndStroke(p, attr);
      vml.canvas[appendChild](g);
      return p;
    };
    setFillAndStroke = function (o, params) {
      o.attrs = o.attrs || {};
      var node = o.node,
        a = o.attrs,
        s = node.style,
        xy,
        newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
        res = o;
      for (var par in params) if (params[has](par)) {
        a[par] = params[par];
      }
      if (newpath) {
        a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
        o.X = a.x;
        o.Y = a.y;
        o.W = a.width;
        o.H = a.height;
      }
      params.href && (node.href = params.href);
      params.title && (node.title = params.title);
      params.target && (node.target = params.target);
      params.cursor && (s.cursor = params.cursor);
      "blur" in params && o.blur(params.blur);
      if (params.path && o.type == "path" || newpath) {
        node.path = path2vml(a.path);
      }
      if (params.rotation != null) {
        o.rotate(params.rotation, true);
      }
      if (params.translation) {
        xy = Str(params.translation)[split](separator);
        translate.call(o, xy[0], xy[1]);
        if (o._.rt.cx != null) {
          o._.rt.cx += +xy[0];
          o._.rt.cy += +xy[1];
          o.setBox(o.attrs, xy[0], xy[1]);
        }
      }
      if (params.scale) {
        xy = Str(params.scale)[split](separator);
        o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
      }
      if ("clip-rect" in params) {
        var rect = Str(params["clip-rect"])[split](separator);
        if (rect[length] == 4) {
          rect[2] = +rect[2] + +rect[0];
          rect[3] = +rect[3] + +rect[1];
          var div = node.clipRect || doc.createElement("div"),
            dstyle = div.style,
            group = node.parentNode;
          dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
          if (!node.clipRect) {
            dstyle.position = "absolute";
            dstyle.top = 0;
            dstyle.left = 0;
            dstyle.width = o.paper.width + "px";
            dstyle.height = o.paper.height + "px";
            group.parentNode.insertBefore(div, group);
            div[appendChild](group);
            node.clipRect = div;
          }
        }
        if (!params["clip-rect"]) {
          node.clipRect && (node.clipRect.style.clip = E);
        }
      }
      if (o.type == "image" && params.src) {
        node.src = params.src;
      }
      if (o.type == "image" && params.opacity) {
        node.filterOpacity = ms + ".Alpha(opacity=" + params.opacity * 100 + ")";
        s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
      }
      params.font && (s.font = params.font);
      params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^['"]+|['"]+$/g, E) + '"');
      params["font-size"] && (s.fontSize = params["font-size"]);
      params["font-weight"] && (s.fontWeight = params["font-weight"]);
      params["font-style"] && (s.fontStyle = params["font-style"]);
      if (params.opacity != null || params["stroke-width"] != null || params.fill != null || params.stroke != null || params["stroke-width"] != null || params["stroke-opacity"] != null || params["fill-opacity"] != null || params["stroke-dasharray"] != null || params["stroke-miterlimit"] != null || params["stroke-linejoin"] != null || params["stroke-linecap"] != null) {
        node = o.shape || node;
        var fill = node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0],
          newfill = false;
        !fill && (newfill = fill = createNode(fillString));
        if ("fill-opacity" in params || "opacity" in params) {
          var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
          opacity = mmin(mmax(opacity, 0), 1);
          fill.opacity = opacity;
        }
        params.fill && (fill.on = true);
        if (fill.on == null || params.fill == "none") {
          fill.on = false;
        }
        if (fill.on && params.fill) {
          var isURL = params.fill.match(ISURL);
          if (isURL) {
            fill.src = isURL[1];
            fill.type = "tile";
          } else {
            fill.color = R.getRGB(params.fill).hex;
            fill.src = E;
            fill.type = "solid";
            if (R.getRGB(params.fill).error && (res.type in {
              circle: 1,
              ellipse: 1
            } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
              a.fill = "none";
              a.gradient = params.fill;
            }
          }
        }
        newfill && node[appendChild](fill);
        var stroke = node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0],
          newstroke = false;
        !stroke && (newstroke = stroke = createNode("stroke"));
        if (params.stroke && params.stroke != "none" || params["stroke-width"] || params["stroke-opacity"] != null || params["stroke-dasharray"] || params["stroke-miterlimit"] || params["stroke-linejoin"] || params["stroke-linecap"]) {
          stroke.on = true;
        }
        (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
        var strokeColor = R.getRGB(params.stroke);
        stroke.on && params.stroke && (stroke.color = strokeColor.hex);
        opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
        var width = (toFloat(params["stroke-width"]) || 1) * .75;
        opacity = mmin(mmax(opacity, 0), 1);
        params["stroke-width"] == null && (width = a["stroke-width"]);
        params["stroke-width"] && (stroke.weight = width);
        width && width < 1 && (opacity *= width) && (stroke.weight = 1);
        stroke.opacity = opacity;
        params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
        stroke.miterlimit = params["stroke-miterlimit"] || 8;
        params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
        if (params["stroke-dasharray"]) {
          var dasharray = {
            "-": "shortdash",
            ".": "shortdot",
            "-.": "shortdashdot",
            "-..": "shortdashdotdot",
            ". ": "dot",
            "- ": "dash",
            "--": "longdash",
            "- .": "dashdot",
            "--.": "longdashdot",
            "--..": "longdashdotdot"
          };
          stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
        }
        newstroke && node[appendChild](stroke);
      }
      if (res.type == "text") {
        s = res.paper.span.style;
        a.font && (s.font = a.font);
        a["font-family"] && (s.fontFamily = a["font-family"]);
        a["font-size"] && (s.fontSize = a["font-size"]);
        a["font-weight"] && (s.fontWeight = a["font-weight"]);
        a["font-style"] && (s.fontStyle = a["font-style"]);
        res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
        res.W = a.w = res.paper.span.offsetWidth;
        res.H = a.h = res.paper.span.offsetHeight;
        res.X = a.x;
        res.Y = a.y + round(res.H / 2);

        // text-anchor emulationm
        switch (a["text-anchor"]) {
          case "start":
            res.node.style["v-text-align"] = "left";
            res.bbx = round(res.W / 2);
            break;
          case "end":
            res.node.style["v-text-align"] = "right";
            res.bbx = -round(res.W / 2);
            break;
          default:
            res.node.style["v-text-align"] = "center";
            break;
        }
      }
    };
    addGradientFill = function (o, gradient) {
      o.attrs = o.attrs || {};
      o.attrs;
        var fill,
        type = "linear",
        fxfy = ".5 .5";
      o.attrs.gradient = gradient;
      gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
        type = "radial";
        if (fx && fy) {
          fx = toFloat(fx);
          fy = toFloat(fy);
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
          fxfy = fx + S + fy;
        }
        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);
      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);
        if (isNaN(angle)) {
          return null;
        }
      }
      var dots = parseDots(gradient);
      if (!dots) {
        return null;
      }
      o = o.shape || o.node;
      fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
      !fill.parentNode && o.appendChild(fill);
      if (dots[length]) {
        fill.on = true;
        fill.method = "none";
        fill.color = dots[0].color;
        fill.color2 = dots[dots[length] - 1].color;
        var clrs = [];
        for (var i = 0, ii = dots[length]; i < ii; i++) {
          dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
        }
        fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);
        if (type == "radial") {
          fill.type = "gradientradial";
          fill.focus = "100%";
          fill.focussize = fxfy;
          fill.focusposition = fxfy;
        } else {
          fill.type = "gradient";
          fill.angle = (270 - angle) % 360;
        }
      }
      return 1;
    };
    Element = function (node, group, vml) {
      this[0] = node;
      this.id = R._oid++;
      this.node = node;
      node.raphael = this;
      this.X = 0;
      this.Y = 0;
      this.attrs = {};
      this.Group = group;
      this.paper = vml;
      this._ = {
        tx: 0,
        ty: 0,
        rt: {
          deg: 0
        },
        sx: 1,
        sy: 1
      };
      !vml.bottom && (vml.bottom = this);
      this.prev = vml.top;
      vml.top && (vml.top.next = this);
      vml.top = this;
      this.next = null;
    };
    elproto = Element[proto];
    elproto.rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }
      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }
        return this._.rt.deg;
      }
      deg = Str(deg)[split](separator);
      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }
      deg = toFloat(deg[0]);
      if (cx != null) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }
      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      this.setBox(this.attrs, cx, cy);
      this.Group.style.rotation = this._.rt.deg;
      // gradient fix for rotation. TODO
      // var fill = (this.shape || this.node).getElementsByTagName(fillString);
      // fill = fill[0] || {};
      // var b = ((360 - this._.rt.deg) - 270) % 360;
      // !R.is(fill.angle, "undefined") && (fill.angle = b);
      return this;
    };
    elproto.setBox = function (params, cx, cy) {
      if (this.removed) {
        return this;
      }
      var gs = this.Group.style,
        os = this.shape && this.shape.style || this.node.style;
      params = params || {};
      for (var i in params) if (params[has](i)) {
        this.attrs[i] = params[i];
      }
      cx = cx || this._.rt.cx;
      cy = cy || this._.rt.cy;
      var attr = this.attrs,
        x,
        y,
        w,
        h;
      switch (this.type) {
        case "circle":
          x = attr.cx - attr.r;
          y = attr.cy - attr.r;
          w = h = attr.r * 2;
          break;
        case "ellipse":
          x = attr.cx - attr.rx;
          y = attr.cy - attr.ry;
          w = attr.rx * 2;
          h = attr.ry * 2;
          break;
        case "image":
          x = +attr.x;
          y = +attr.y;
          w = attr.width || 0;
          h = attr.height || 0;
          break;
        case "text":
          this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
          x = attr.x - round(this.W / 2);
          y = attr.y - this.H / 2;
          w = this.W;
          h = this.H;
          break;
        case "rect":
        case "path":
          if (!this.attrs.path) {
            x = 0;
            y = 0;
            w = this.paper.width;
            h = this.paper.height;
          } else {
            var dim = pathDimensions(this.attrs.path);
            x = dim.x;
            y = dim.y;
            w = dim.width;
            h = dim.height;
          }
          break;
        default:
          x = 0;
          y = 0;
          w = this.paper.width;
          h = this.paper.height;
          break;
      }
      cx = cx == null ? x + w / 2 : cx;
      cy = cy == null ? y + h / 2 : cy;
      var left = cx - this.paper.width / 2,
        top = cy - this.paper.height / 2,
        t;
      gs.left != (t = left + "px") && (gs.left = t);
      gs.top != (t = top + "px") && (gs.top = t);
      this.X = pathlike[has](this.type) ? -left : x;
      this.Y = pathlike[has](this.type) ? -top : y;
      this.W = w;
      this.H = h;
      if (pathlike[has](this.type)) {
        os.left != (t = -left * zoom + "px") && (os.left = t);
        os.top != (t = -top * zoom + "px") && (os.top = t);
      } else if (this.type == "text") {
        os.left != (t = -left + "px") && (os.left = t);
        os.top != (t = -top + "px") && (os.top = t);
      } else {
        gs.width != (t = this.paper.width + "px") && (gs.width = t);
        gs.height != (t = this.paper.height + "px") && (gs.height = t);
        os.left != (t = x - left + "px") && (os.left = t);
        os.top != (t = y - top + "px") && (os.top = t);
        os.width != (t = w + "px") && (os.width = t);
        os.height != (t = h + "px") && (os.height = t);
      }
    };
    elproto.hide = function () {
      !this.removed && (this.Group.style.display = "none");
      return this;
    };
    elproto.show = function () {
      !this.removed && (this.Group.style.display = "block");
      return this;
    };
    elproto.getBBox = function () {
      if (this.removed) {
        return this;
      }
      if (pathlike[has](this.type)) {
        return pathDimensions(this.attrs.path);
      }
      return {
        x: this.X + (this.bbx || 0),
        y: this.Y,
        width: this.W,
        height: this.H
      };
    };
    elproto.remove = function () {
      if (this.removed) {
        return;
      }
      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);
      this.Group.parentNode.removeChild(this.Group);
      this.shape && this.shape.parentNode.removeChild(this.shape);
      for (var i in this) {
        delete this[i];
      }
      this.removed = true;
    };
    elproto.attr = function (name, value) {
      if (this.removed) {
        return this;
      }
      if (name == null) {
        var res = {};
        for (var i in this.attrs) if (this.attrs[has](i)) {
          res[i] = this.attrs[i];
        }
        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }
      if (value == null && R.is(name, "string")) {
        if (name == "translation") {
          return translate.call(this);
        }
        if (name == "rotation") {
          return this.rotate();
        }
        if (name == "scale") {
          return this.scale();
        }
        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }
        return this.attrs[name];
      }
      if (this.attrs && value == null && R.is(name, array)) {
        var ii,
          values = {};
        for (i = 0, ii = name[length]; i < ii; i++) {
          values[name[i]] = this.attr(name[i]);
        }
        return values;
      }
      var params;
      if (value != null) {
        params = {};
        params[name] = value;
      }
      value == null && R.is(name, "object") && (params = name);
      if (params) {
        for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
          var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
          this.attrs[key] = params[key];
          for (var subkey in par) if (par[has](subkey)) {
            params[subkey] = par[subkey];
          }
        }
        if (params.text && this.type == "text") {
          this.node.string = params.text;
        }
        setFillAndStroke(this, params);
        if (params.gradient && ({
          circle: 1,
          ellipse: 1
        }[has](this.type) || Str(params.gradient).charAt() != "r")) {
          addGradientFill(this, params.gradient);
        }
        (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
      }
      return this;
    };
    elproto.toFront = function () {
      !this.removed && this.Group.parentNode[appendChild](this.Group);
      this.paper.top != this && tofront(this, this.paper);
      return this;
    };
    elproto.toBack = function () {
      if (this.removed) {
        return this;
      }
      if (this.Group.parentNode.firstChild != this.Group) {
        this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
        toback(this, this.paper);
      }
      return this;
    };
    elproto.insertAfter = function (element) {
      if (this.removed) {
        return this;
      }
      if (element.constructor == Set) {
        element = element[element.length - 1];
      }
      if (element.Group.nextSibling) {
        element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
      } else {
        element.Group.parentNode[appendChild](this.Group);
      }
      insertafter(this, element, this.paper);
      return this;
    };
    elproto.insertBefore = function (element) {
      if (this.removed) {
        return this;
      }
      if (element.constructor == Set) {
        element = element[0];
      }
      element.Group.parentNode.insertBefore(this.Group, element.Group);
      insertbefore(this, element, this.paper);
      return this;
    };
    elproto.blur = function (size) {
      var s = this.node.runtimeStyle,
        f = s.filter;
      f = f.replace(blurregexp, E);
      if (+size !== 0) {
        this.attrs.blur = size;
        s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
        s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
      } else {
        s.filter = f;
        s.margin = 0;
        delete this.attrs.blur;
      }
    };
    theCircle = function (vml, x, y, r) {
      var g = createNode("group"),
        o = createNode("oval");
        o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "circle";
      setFillAndStroke(res, {
        stroke: "#000",
        fill: "none"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.r = r;
      res.setBox({
        x: x - r,
        y: y - r,
        width: r * 2,
        height: r * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };
    function rectPath(x, y, w, h, r) {
      if (r) {
        return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
      } else {
        return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
      }
    }
    theRect = function (vml, x, y, w, h, r) {
      var path = rectPath(x, y, w, h, r),
        res = vml.path(path),
        a = res.attrs;
      res.X = a.x = x;
      res.Y = a.y = y;
      res.W = a.width = w;
      res.H = a.height = h;
      a.r = r;
      a.path = path;
      res.type = "rect";
      return res;
    };
    theEllipse = function (vml, x, y, rx, ry) {
      var g = createNode("group"),
        o = createNode("oval");
        o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "ellipse";
      setFillAndStroke(res, {
        stroke: "#000"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.rx = rx;
      res.attrs.ry = ry;
      res.setBox({
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };
    theImage = function (vml, src, x, y, w, h) {
      var g = createNode("group"),
        o = createNode("image");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      o.src = src;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "image";
      res.attrs.src = src;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = w;
      res.attrs.h = h;
      res.setBox({
        x: x,
        y: y,
        width: w,
        height: h
      });
      vml.canvas[appendChild](g);
      return res;
    };
    theText = function (vml, x, y, text) {
      var g = createNode("group"),
        el = createNode("shape"),
        ol = el.style,
        path = createNode("path");
        path.style;
        var o = createNode("textpath");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
      path.textpathok = true;
      ol.width = vml.width;
      ol.height = vml.height;
      o.string = Str(text);
      o.on = true;
      el[appendChild](o);
      el[appendChild](path);
      g[appendChild](el);
      var res = new Element(o, g, vml);
      res.shape = el;
      res.textpath = path;
      res.type = "text";
      res.attrs.text = text;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = 1;
      res.attrs.h = 1;
      setFillAndStroke(res, {
        font: availableAttrs.font,
        stroke: "none",
        fill: "#000"
      });
      res.setBox();
      vml.canvas[appendChild](g);
      return res;
    };
    setSize = function (width, height) {
      var cs = this.canvas.style;
      width == +width && (width += "px");
      height == +height && (height += "px");
      cs.width = width;
      cs.height = height;
      cs.clip = "rect(0 " + width + " " + height + " 0)";
      return this;
    };
    var createNode;
    doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
    try {
      !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
      createNode = function (tagName) {
        return doc.createElement('<rvml:' + tagName + ' class="rvml">');
      };
    } catch (e) {
      createNode = function (tagName) {
        return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
      };
    }
    create = function () {
      var con = getContainer[apply](0, arguments),
        container = con.container,
        height = con.height,
        width = con.width,
        x = con.x,
        y = con.y;
      if (!container) {
        throw new Error("VML container not found.");
      }
      var res = new Paper(),
        c = res.canvas = doc.createElement("div"),
        cs = c.style;
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      width == +width && (width += "px");
      height == +height && (height += "px");
      res.width = 1e3;
      res.height = 1e3;
      res.coordsize = zoom * 1e3 + S + zoom * 1e3;
      res.coordorigin = "0 0";
      res.span = doc.createElement("span");
      res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      c[appendChild](res.span);
      cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
      if (container == 1) {
        doc.body[appendChild](c);
        cs.left = x + "px";
        cs.top = y + "px";
        cs.position = "absolute";
      } else {
        if (container.firstChild) {
          container.insertBefore(c, container.firstChild);
        } else {
          container[appendChild](c);
        }
      }
      plugins.call(res, res, R.fn);
      return res;
    };
    paperproto.clear = function () {
      this.canvas.innerHTML = E;
      this.span = doc.createElement("span");
      this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      this.canvas[appendChild](this.span);
      this.bottom = this.top = null;
    };
    paperproto.remove = function () {
      this.canvas.parentNode.removeChild(this.canvas);
      for (var i in this) {
        this[i] = removed(i);
      }
      return true;
    };
  }

  // rest
  // WebKit rendering bug workaround method
  var version = navigator.userAgent.match(/Version\/(.*?)\s/);
  if (navigator.vendor == "Apple Computer, Inc." && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
    paperproto.safari = function () {
      var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
        stroke: "none"
      });
      win.setTimeout(function () {
        rect.remove();
      });
    };
  } else {
    paperproto.safari = function () {};
  }

  // Events
  var preventDefault = function () {
      this.returnValue = false;
    },
    preventTouch = function () {
      return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
      this.cancelBubble = true;
    },
    stopTouch = function () {
      return this.originalEvent.stopPropagation();
    },
    addEvent = function () {
      if (doc.addEventListener) {
        return function (obj, type, fn, element) {
          var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;
          var f = function (e) {
            if (supportsTouch && touchMap[has](type)) {
              for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                if (e.targetTouches[i].target == obj) {
                  var olde = e;
                  e = e.targetTouches[i];
                  e.originalEvent = olde;
                  e.preventDefault = preventTouch;
                  e.stopPropagation = stopTouch;
                  break;
                }
              }
            }
            return fn.call(element, e);
          };
          obj.addEventListener(realName, f, false);
          return function () {
            obj.removeEventListener(realName, f, false);
            return true;
          };
        };
      } else if (doc.attachEvent) {
        return function (obj, type, fn, element) {
          var f = function (e) {
            e = e || win.event;
            e.preventDefault = e.preventDefault || preventDefault;
            e.stopPropagation = e.stopPropagation || stopPropagation;
            return fn.call(element, e);
          };
          obj.attachEvent("on" + type, f);
          var detacher = function () {
            obj.detachEvent("on" + type, f);
            return true;
          };
          return detacher;
        };
      }
    }(),
    drag = [],
    dragMove = function (e) {
      var x = e.clientX,
        y = e.clientY,
        scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
        scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
        dragi,
        j = drag.length;
      while (j--) {
        dragi = drag[j];
        if (supportsTouch) {
          var i = e.touches.length,
            touch;
          while (i--) {
            touch = e.touches[i];
            if (touch.identifier == dragi.el._drag.id) {
              x = touch.clientX;
              y = touch.clientY;
              (e.originalEvent ? e.originalEvent : e).preventDefault();
              break;
            }
          }
        } else {
          e.preventDefault();
        }
        x += scrollX;
        y += scrollY;
        dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
      }
    },
    dragUp = function (e) {
      R.unmousemove(dragMove).unmouseup(dragUp);
      var i = drag.length,
        dragi;
      while (i--) {
        dragi = drag[i];
        dragi.el._drag = {};
        dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
      }
      drag = [];
    };
  for (var i = events[length]; i--;) {
    (function (eventName) {
      R[eventName] = Element[proto][eventName] = function (fn, scope) {
        if (R.is(fn, "function")) {
          this.events = this.events || [];
          this.events.push({
            name: eventName,
            f: fn,
            unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)
          });
        }
        return this;
      };
      R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
        var events = this.events,
          l = events[length];
        while (l--) if (events[l].name == eventName && events[l].f == fn) {
          events[l].unbind();
          events.splice(l, 1);
          !events.length && delete this.events;
          return this;
        }
        return this;
      };
    })(events[i]);
  }
  elproto.hover = function (f_in, f_out, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
  };
  elproto.unhover = function (f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
  };
  elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
    this._drag = {};
    this.mousedown(function (e) {
      (e.originalEvent || e).preventDefault();
      var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
        scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
      this._drag.x = e.clientX + scrollX;
      this._drag.y = e.clientY + scrollY;
      this._drag.id = e.identifier;
      onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
      !drag.length && R.mousemove(dragMove).mouseup(dragUp);
      drag.push({
        el: this,
        move: onmove,
        end: onend,
        move_scope: move_scope,
        start_scope: start_scope,
        end_scope: end_scope
      });
    });
    return this;
  };
  elproto.undrag = function (onmove, onstart, onend) {
    var i = drag.length;
    while (i--) {
      drag[i].el == this && drag[i].move == onmove && drag[i].end == onend && drag.splice(i++, 1);
    }
    !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
  };
  paperproto.circle = function (x, y, r) {
    return theCircle(this, x || 0, y || 0, r || 0);
  };
  paperproto.rect = function (x, y, w, h, r) {
    return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
  };
  paperproto.ellipse = function (x, y, rx, ry) {
    return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
  };
  paperproto.path = function (pathString) {
    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
    return thePath(R.format[apply](R, arguments), this);
  };
  paperproto.image = function (src, x, y, w, h) {
    return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
  };
  paperproto.text = function (x, y, text) {
    return theText(this, x || 0, y || 0, Str(text));
  };
  paperproto.set = function (itemsArray) {
    arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
    return new Set(itemsArray);
  };
  paperproto.setSize = setSize;
  paperproto.top = paperproto.bottom = null;
  paperproto.raphael = R;
  function x_y() {
    return this.x + S + this.y;
  }
  elproto.resetScale = function () {
    if (this.removed) {
      return this;
    }
    this._.sx = 1;
    this._.sy = 1;
    this.attrs.scale = "1 1";
  };
  elproto.scale = function (x, y, cx, cy) {
    if (this.removed) {
      return this;
    }
    if (x == null && y == null) {
      return {
        x: this._.sx,
        y: this._.sy,
        toString: x_y
      };
    }
    y = y || x;
    !+y && (y = x);
    var dx,
      dy,
      a = this.attrs;
    if (x != 0) {
      var bb = this.getBBox(),
        rcx = bb.x + bb.width / 2,
        rcy = bb.y + bb.height / 2,
        kx = abs(x / this._.sx),
        ky = abs(y / this._.sy);
      cx = +cx || cx == 0 ? cx : rcx;
      cy = +cy || cy == 0 ? cy : rcy;
      var posx = this._.sx > 0,
        posy = this._.sy > 0,
        dirx = ~~(x / abs(x)),
        diry = ~~(y / abs(y)),
        dkx = kx * dirx,
        dky = ky * diry,
        s = this.node.style,
        ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
        ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
        fr = x * dirx > y * diry ? ky : kx;
      switch (this.type) {
        case "rect":
        case "image":
          var neww = a.width * kx,
            newh = a.height * ky;
          this.attr({
            height: newh,
            r: a.r * fr,
            width: neww,
            x: ncx - neww / 2,
            y: ncy - newh / 2
          });
          break;
        case "circle":
        case "ellipse":
          this.attr({
            rx: a.rx * kx,
            ry: a.ry * ky,
            r: a.r * fr,
            cx: ncx,
            cy: ncy
          });
          break;
        case "text":
          this.attr({
            x: ncx,
            y: ncy
          });
          break;
        case "path":
          var path = pathToRelative(a.path),
            skip = true,
            fx = posx ? dkx : kx,
            fy = posy ? dky : ky;
          for (var i = 0, ii = path[length]; i < ii; i++) {
            var p = path[i],
              P0 = upperCase.call(p[0]);
            if (P0 == "M" && skip) {
              continue;
            } else {
              skip = false;
            }
            if (P0 == "A") {
              p[path[i][length] - 2] *= fx;
              p[path[i][length] - 1] *= fy;
              p[1] *= kx;
              p[2] *= ky;
              p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
            } else if (P0 == "H") {
              for (var j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fx;
              }
            } else if (P0 == "V") {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fy;
              }
            } else {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= j % 2 ? fx : fy;
              }
            }
          }
          var dim2 = pathDimensions(path);
          dx = ncx - dim2.x - dim2.width / 2;
          dy = ncy - dim2.y - dim2.height / 2;
          path[0][1] += dx;
          path[0][2] += dy;
          this.attr({
            path: path
          });
          break;
      }
      if (this.type in {
        text: 1,
        image: 1
      } && (dirx != 1 || diry != 1)) {
        if (this.transformations) {
          this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
          setAttr(this.node, "transform", this.transformations[join](S));
          dx = dirx == -1 ? -a.x - (neww || 0) : a.x;
          dy = diry == -1 ? -a.y - (newh || 0) : a.y;
          this.attr({
            x: dx,
            y: dy
          });
          a.fx = dirx - 1;
          a.fy = diry - 1;
        } else {
          this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx, ", M12=0, M21=0, M22=", diry, ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      } else {
        if (this.transformations) {
          this.transformations[2] = E;
          setAttr(this.node, "transform", this.transformations[join](S));
          a.fx = 0;
          a.fy = 0;
        } else {
          this.node.filterMatrix = E;
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      }
      a.scale = [x, y, cx, cy][join](S);
      this._.sx = x;
      this._.sy = y;
    }
    return this;
  };
  elproto.clone = function () {
    if (this.removed) {
      return null;
    }
    var attr = this.attr();
    delete attr.scale;
    delete attr.translation;
    return this.paper[this.type]().attr(attr);
  };
  var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
      // Is this a straight line?
      // Added for huge speed improvements
      if (p1x === c1x && p1y === c1y && c2x === p2x && c2y == p2y) {
        var dx = p2x - p1x,
          dy = p2y - p1y;
        var totalLength = Math.sqrt(dx * dx + dy * dy);
        if (length == null) {
          return totalLength;
        } else {
          var fract = length / totalLength;
          return {
            start: {
              x: p1x,
              y: p1y
            },
            m: {
              x: p1x,
              y: p1y
            },
            n: {
              x: p2x,
              y: p2y
            },
            end: {
              x: p2x,
              y: p2y
            },
            x: p1x + fract * dx,
            y: p1y + fract * dy,
            alpha: 90 - math.atan(dx / dy) * 180 / PI
          };
        }
      }
      var len = 0,
        precision = 100,
        name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
        cache = curveslengths[name],
        old,
        dot;
      !cache && (curveslengths[name] = cache = {
        data: []
      });
      cache.timer && clearTimeout(cache.timer);
      cache.timer = setTimeout(function () {
        delete curveslengths[name];
      }, 2000);
      if (length != null) {
        var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        precision = ~~total * 10;
      }
      for (var i = 0; i < precision + 1; i++) {
        if (cache.data[length] > i) {
          dot = cache.data[i * precision];
        } else {
          dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
          cache.data[i] = dot;
        }
        i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));
        if (length != null && len >= length) {
          return dot;
        }
        old = dot;
      }
      if (length == null) {
        return len;
      }
    },
    getLengthFactory = function (istotal, subpath) {
      return function (path, length, onlystart) {
        path = path2curve(path);
        var x,
          y,
          p,
          l,
          sp = "",
          subpaths = {},
          point,
          len = 0;
        for (var i = 0, ii = path.length; i < ii; i++) {
          p = path[i];
          if (p[0] == "M") {
            x = +p[1];
            y = +p[2];
          } else {
            l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
            if (len + l > length) {
              if (subpath && !subpaths.start) {
                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                if (onlystart) {
                  return sp;
                }
                subpaths.start = sp;
                sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
                len += l;
                x = +p[5];
                y = +p[6];
                continue;
              }
              if (!istotal && !subpath) {
                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                return {
                  x: point.x,
                  y: point.y,
                  alpha: point.alpha
                };
              }
            }
            len += l;
            x = +p[5];
            y = +p[6];
          }
          sp += p;
        }
        subpaths.end = sp;
        point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
        point.alpha && (point = {
          x: point.x,
          y: point.y,
          alpha: point.alpha
        });
        return point;
      };
    };
  var getTotalLength = getLengthFactory(1),
    getPointAtLength = getLengthFactory(),
    getSubpathsAtLength = getLengthFactory(0, 1);
  elproto.getTotalLength = function () {
    if (this.type != "path") {
      return;
    }
    if (this.node.getTotalLength) {
      return this.node.getTotalLength();
    }
    return getTotalLength(this.attrs.path);
  };
  elproto.getPointAtLength = function (length) {
    if (this.type != "path") {
      return;
    }
    return getPointAtLength(this.attrs.path, length);
  };
  elproto.getSubpath = function (from, to) {
    if (this.type != "path") {
      return;
    }
    if (abs(this.getTotalLength() - to) < "1e-6") {
      return getSubpathsAtLength(this.attrs.path, from).end;
    }
    var a = getSubpathsAtLength(this.attrs.path, to, 1);
    return from ? getSubpathsAtLength(a, from).end : a;
  };

  // animation easing formulas
  R.easing_formulas = {
    linear: function (n) {
      return n;
    },
    "<": function (n) {
      return pow(n, 3);
    },
    ">": function (n) {
      return pow(n - 1, 3) + 1;
    },
    "<>": function (n) {
      n = n * 2;
      if (n < 1) {
        return pow(n, 3) / 2;
      }
      n -= 2;
      return (pow(n, 3) + 2) / 2;
    },
    backIn: function (n) {
      var s = 1.70158;
      return n * n * ((s + 1) * n - s);
    },
    backOut: function (n) {
      n = n - 1;
      var s = 1.70158;
      return n * n * ((s + 1) * n + s) + 1;
    },
    elastic: function (n) {
      if (n == 0 || n == 1) {
        return n;
      }
      var p = .3,
        s = p / 4;
      return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
    },
    bounce: function (n) {
      var s = 7.5625,
        p = 2.75,
        l;
      if (n < 1 / p) {
        l = s * n * n;
      } else {
        if (n < 2 / p) {
          n -= 1.5 / p;
          l = s * n * n + .75;
        } else {
          if (n < 2.5 / p) {
            n -= 2.25 / p;
            l = s * n * n + .9375;
          } else {
            n -= 2.625 / p;
            l = s * n * n + .984375;
          }
        }
      }
      return l;
    }
  };
  var animationElements = [],
    animation = function () {
      var Now = +new Date();
      for (var l = 0; l < animationElements[length]; l++) {
        var e = animationElements[l];
        if (e.stop || e.el.removed) {
          continue;
        }
        var time = Now - e.start,
          ms = e.ms,
          easing = e.easing,
          from = e.from,
          diff = e.diff,
          to = e.to,
          t = e.t,
          that = e.el,
          set = {},
          now;
        if (time < ms) {
          var pos = easing(time / ms);
          for (var attr in from) if (from[has](attr)) {
            switch (availableAnimAttrs[attr]) {
              case "along":
                now = pos * ms * diff[attr];
                to.back && (now = to.len - now);
                var point = getPointAtLength(to[attr], now);
                that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
                diff.x = point.x;
                diff.y = point.y;
                that.translate(point.x - diff.sx, point.y - diff.sy);
                to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                break;
              case nu:
                now = +from[attr] + pos * ms * diff[attr];
                break;
              case "colour":
                now = "rgb(" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b))][join](",") + ")";
                break;
              case "path":
                now = [];
                for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                  now[i] = [from[attr][i][0]];
                  for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                    now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                  }
                  now[i] = now[i][join](S);
                }
                now = now[join](S);
                break;
              case "csv":
                switch (attr) {
                  case "translation":
                    var x = pos * ms * diff[attr][0] - t.x,
                      y = pos * ms * diff[attr][1] - t.y;
                    t.x += x;
                    t.y += y;
                    now = x + S + y;
                    break;
                  case "rotation":
                    now = +from[attr][0] + pos * ms * diff[attr][0];
                    from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
                    break;
                  case "scale":
                    now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], 2 in to[attr] ? to[attr][2] : E, 3 in to[attr] ? to[attr][3] : E][join](S);
                    break;
                  case "clip-rect":
                    now = [];
                    i = 4;
                    while (i--) {
                      now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                    }
                    break;
                }
                break;
              default:
                var from2 = [].concat(from[attr]);
                now = [];
                i = that.paper.customAttributes[attr].length;
                while (i--) {
                  now[i] = +from2[i] + pos * ms * diff[attr][i];
                }
                break;
            }
            set[attr] = now;
          }
          that.attr(set);
          that._run && that._run.call(that);
        } else {
          if (to.along) {
            point = getPointAtLength(to.along, to.len * !to.back);
            that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
            to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
          }
          (t.x || t.y) && that.translate(-t.x, -t.y);
          to.scale && (to.scale += E);
          that.attr(to);
          animationElements.splice(l--, 1);
        }
      }
      R.svg && that && that.paper && that.paper.safari();
      animationElements[length] && setTimeout(animation);
    },
    keyframesRun = function (attr, element, time, prev, prevcallback) {
      var dif = time - prev;
      element.timeouts.push(setTimeout(function () {
        R.is(prevcallback, "function") && prevcallback.call(element);
        element.animate(attr, dif, attr.easing);
      }, prev));
    },
    upto255 = function (color) {
      return mmax(mmin(color, 255), 0);
    },
    translate = function (x, y) {
      if (x == null) {
        return {
          x: this._.tx,
          y: this._.ty,
          toString: x_y
        };
      }
      this._.tx += +x;
      this._.ty += +y;
      switch (this.type) {
        case "circle":
        case "ellipse":
          this.attr({
            cx: +x + this.attrs.cx,
            cy: +y + this.attrs.cy
          });
          break;
        case "rect":
        case "image":
        case "text":
          this.attr({
            x: +x + this.attrs.x,
            y: +y + this.attrs.y
          });
          break;
        case "path":
          var path = pathToRelative(this.attrs.path);
          path[0][1] += +x;
          path[0][2] += +y;
          this.attr({
            path: path
          });
          break;
      }
      return this;
    };
  elproto.animateWith = function (element, params, ms, easing, callback) {
    for (var i = 0, ii = animationElements.length; i < ii; i++) {
      if (animationElements[i].el.id == element.id) {
        params.start = animationElements[i].start;
      }
    }
    return this.animate(params, ms, easing, callback);
  };
  elproto.animateAlong = along();
  elproto.animateAlongBack = along(1);
  function along(isBack) {
    return function (path, ms, rotate, callback) {
      var params = {
        back: isBack
      };
      R.is(rotate, "function") ? callback = rotate : params.rot = rotate;
      path && path.constructor == Element && (path = path.attrs.path);
      path && (params.along = path);
      return this.animate(params, ms, callback);
    };
  }
  function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
    var cx = 3 * p1x,
      bx = 3 * (p2x - p1x) - cx,
      ax = 1 - cx - bx,
      cy = 3 * p1y,
      by = 3 * (p2y - p1y) - cy,
      ay = 1 - cy - by;
    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }
    function solve(x, epsilon) {
      var t = solveCurveX(x, epsilon);
      return ((ay * t + by) * t + cy) * t;
    }
    function solveCurveX(x, epsilon) {
      var t0, t1, t2, x2, d2, i;
      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;
        if (abs(x2) < epsilon) {
          return t2;
        }
        d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
        if (abs(d2) < 1e-6) {
          break;
        }
        t2 = t2 - x2 / d2;
      }
      t0 = 0;
      t1 = 1;
      t2 = x;
      if (t2 < t0) {
        return t0;
      }
      if (t2 > t1) {
        return t1;
      }
      while (t0 < t1) {
        x2 = sampleCurveX(t2);
        if (abs(x2 - x) < epsilon) {
          return t2;
        }
        if (x > x2) {
          t0 = t2;
        } else {
          t1 = t2;
        }
        t2 = (t1 - t0) / 2 + t0;
      }
      return t2;
    }
    return solve(t, 1 / (200 * duration));
  }
  elproto.onAnimation = function (f) {
    this._run = f || 0;
    return this;
  };
  elproto.animate = function (params, ms, easing, callback) {
    var element = this;
    element.timeouts = element.timeouts || [];
    if (R.is(easing, "function") || !easing) {
      callback = easing || null;
    }
    if (element.removed) {
      callback && callback.call(element);
      return element;
    }
    var from = {},
      to = {},
      animateable = false,
      diff = {};
    for (var attr in params) if (params[has](attr)) {
      if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
        animateable = true;
        from[attr] = element.attr(attr);
        from[attr] == null && (from[attr] = availableAttrs[attr]);
        to[attr] = params[attr];
        switch (availableAnimAttrs[attr]) {
          case "along":
            var len = getTotalLength(params[attr]);
            var point = getPointAtLength(params[attr], len * !!params.back);
            var bb = element.getBBox();
            diff[attr] = len / ms;
            diff.tx = bb.x;
            diff.ty = bb.y;
            diff.sx = point.x;
            diff.sy = point.y;
            to.rot = params.rot;
            to.back = params.back;
            to.len = len;
            params.rot && (diff.r = toFloat(element.rotate()) || 0);
            break;
          case nu:
            diff[attr] = (to[attr] - from[attr]) / ms;
            break;
          case "colour":
            from[attr] = R.getRGB(from[attr]);
            var toColour = R.getRGB(to[attr]);
            diff[attr] = {
              r: (toColour.r - from[attr].r) / ms,
              g: (toColour.g - from[attr].g) / ms,
              b: (toColour.b - from[attr].b) / ms
            };
            break;
          case "path":
            var pathes = path2curve(from[attr], to[attr]);
            from[attr] = pathes[0];
            var toPath = pathes[1];
            diff[attr] = [];
            for (var i = 0, ii = from[attr][length]; i < ii; i++) {
              diff[attr][i] = [0];
              for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
              }
            }
            break;
          case "csv":
            var values = Str(params[attr])[split](separator),
              from2 = Str(from[attr])[split](separator);
            switch (attr) {
              case "translation":
                from[attr] = [0, 0];
                diff[attr] = [values[0] / ms, values[1] / ms];
                break;
              case "rotation":
                from[attr] = from2[1] == values[1] && from2[2] == values[2] ? from2 : [0, values[1], values[2]];
                diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
                break;
              case "scale":
                params[attr] = values;
                from[attr] = Str(from[attr])[split](separator);
                diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
                break;
              case "clip-rect":
                from[attr] = Str(from[attr])[split](separator);
                diff[attr] = [];
                i = 4;
                while (i--) {
                  diff[attr][i] = (values[i] - from[attr][i]) / ms;
                }
                break;
            }
            to[attr] = values;
            break;
          default:
            values = [].concat(params[attr]);
            from2 = [].concat(from[attr]);
            diff[attr] = [];
            i = element.paper.customAttributes[attr][length];
            while (i--) {
              diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
            }
            break;
        }
      }
    }
    if (!animateable) {
      var attrs = [],
        lastcall;
      for (var key in params) if (params[has](key) && animKeyFrames.test(key)) {
        attr = {
          value: params[key]
        };
        key == "from" && (key = 0);
        key == "to" && (key = 100);
        attr.key = toInt(key, 10);
        attrs.push(attr);
      }
      attrs.sort(sortByKey);
      if (attrs[0].key) {
        attrs.unshift({
          key: 0,
          value: element.attrs
        });
      }
      for (i = 0, ii = attrs[length]; i < ii; i++) {
        keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
      }
      lastcall = attrs[attrs[length] - 1].value.callback;
      if (lastcall) {
        element.timeouts.push(setTimeout(function () {
          lastcall.call(element);
        }, ms));
      }
    } else {
      var easyeasy = R.easing_formulas[easing];
      if (!easyeasy) {
        easyeasy = Str(easing).match(bezierrg);
        if (easyeasy && easyeasy[length] == 5) {
          var curve = easyeasy;
          easyeasy = function (t) {
            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
          };
        } else {
          easyeasy = function (t) {
            return t;
          };
        }
      }
      animationElements.push({
        start: params.start || +new Date(),
        ms: ms,
        easing: easyeasy,
        from: from,
        diff: diff,
        to: to,
        el: element,
        t: {
          x: 0,
          y: 0
        }
      });
      R.is(callback, "function") && (element._ac = setTimeout(function () {
        callback.call(element);
      }, ms));
      animationElements[length] == 1 && setTimeout(animation);
    }
    return this;
  };
  elproto.stop = function () {
    for (var i = 0; i < animationElements.length; i++) {
      animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
    }
    for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
      clearTimeout(this.timeouts[i]);
    }
    this.timeouts = [];
    clearTimeout(this._ac);
    delete this._ac;
    return this;
  };
  elproto.translate = function (x, y) {
    return this.attr({
      translation: x + " " + y
    });
  };
  elproto[toString] = function () {
    return "Rapha\xebl\u2019s object";
  };
  R.ae = animationElements;

  // Set
  var Set = function (items) {
    this.items = [];
    this[length] = 0;
    this.type = "set";
    if (items) {
      for (var i = 0, ii = items[length]; i < ii; i++) {
        if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
          this[this.items[length]] = this.items[this.items[length]] = items[i];
          this[length]++;
        }
      }
    }
  };
  Set[proto][push] = function () {
    var item, len;
    for (var i = 0, ii = arguments[length]; i < ii; i++) {
      item = arguments[i];
      if (item && (item.constructor == Element || item.constructor == Set)) {
        len = this.items[length];
        this[len] = this.items[len] = item;
        this[length]++;
      }
    }
    return this;
  };
  Set[proto].pop = function () {
    delete this[this[length]--];
    return this.items.pop();
  };
  for (var method in elproto) if (elproto[has](method)) {
    Set[proto][method] = function (methodname) {
      return function () {
        for (var i = 0, ii = this.items[length]; i < ii; i++) {
          this.items[i][methodname][apply](this.items[i], arguments);
        }
        return this;
      };
    }(method);
  }
  Set[proto].attr = function (name, value) {
    if (name && R.is(name, array) && R.is(name[0], "object")) {
      for (var j = 0, jj = name[length]; j < jj; j++) {
        this.items[j].attr(name[j]);
      }
    } else {
      for (var i = 0, ii = this.items[length]; i < ii; i++) {
        this.items[i].attr(name, value);
      }
    }
    return this;
  };
  Set[proto].animate = function (params, ms, easing, callback) {
    (R.is(easing, "function") || !easing) && (callback = easing || null);
    var len = this.items[length],
      i = len,
      item,
      set = this,
      collector;
    callback && (collector = function () {
      ! --len && callback.call(set);
    });
    easing = R.is(easing, string) ? easing : collector;
    item = this.items[--i].animate(params, ms, easing, collector);
    while (i--) {
      this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
    }
    return this;
  };
  Set[proto].insertAfter = function (el) {
    var i = this.items[length];
    while (i--) {
      this.items[i].insertAfter(el);
    }
    return this;
  };
  Set[proto].getBBox = function () {
    var x = [],
      y = [],
      w = [],
      h = [];
    for (var i = this.items[length]; i--;) {
      var box = this.items[i].getBBox();
      x[push](box.x);
      y[push](box.y);
      w[push](box.x + box.width);
      h[push](box.y + box.height);
    }
    x = mmin[apply](0, x);
    y = mmin[apply](0, y);
    return {
      x: x,
      y: y,
      width: mmax[apply](0, w) - x,
      height: mmax[apply](0, h) - y
    };
  };
  Set[proto].clone = function (s) {
    s = new Set();
    for (var i = 0, ii = this.items[length]; i < ii; i++) {
      s[push](this.items[i].clone());
    }
    return s;
  };
  R.registerFont = function (font) {
    if (!font.face) {
      return font;
    }
    this.fonts = this.fonts || {};
    var fontcopy = {
        w: font.w,
        face: {},
        glyphs: {}
      },
      family = font.face["font-family"];
    for (var prop in font.face) if (font.face[has](prop)) {
      fontcopy.face[prop] = font.face[prop];
    }
    if (this.fonts[family]) {
      this.fonts[family][push](fontcopy);
    } else {
      this.fonts[family] = [fontcopy];
    }
    if (!font.svg) {
      fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
      for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
        var path = font.glyphs[glyph];
        fontcopy.glyphs[glyph] = {
          w: path.w,
          k: {},
          d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
            return {
              l: "L",
              c: "C",
              x: "z",
              t: "m",
              r: "l",
              v: "c"
            }[command] || "M";
          }) + "z"
        };
        if (path.k) {
          for (var k in path.k) if (path[has](k)) {
            fontcopy.glyphs[glyph].k[k] = path.k[k];
          }
        }
      }
    }
    return font;
  };
  paperproto.getFont = function (family, weight, style, stretch) {
    stretch = stretch || "normal";
    style = style || "normal";
    weight = +weight || {
      normal: 400,
      bold: 700,
      lighter: 300,
      bolder: 800
    }[weight] || 400;
    if (!R.fonts) {
      return;
    }
    var font = R.fonts[family];
    if (!font) {
      var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
      for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
        if (name.test(fontName)) {
          font = R.fonts[fontName];
          break;
        }
      }
    }
    var thefont;
    if (font) {
      for (var i = 0, ii = font[length]; i < ii; i++) {
        thefont = font[i];
        if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
          break;
        }
      }
    }
    return thefont;
  };
  paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
    origin = origin || "middle"; // baseline|middle
    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    var out = this.set(),
      letters = Str(string)[split](E),
      shift = 0,
      scale;
    R.is(font, string) && (font = this.getFont(font));
    if (font) {
      scale = (size || 16) / font.face["units-per-em"];
      var bb = font.face.bbox.split(separator),
        top = +bb[0],
        height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + +font.face.descent : (bb[3] - bb[1]) / 2);
      for (var i = 0, ii = letters[length]; i < ii; i++) {
        var prev = i && font.glyphs[letters[i - 1]] || {},
          curr = font.glyphs[letters[i]];
        shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
        curr && curr.d && out[push](this.path(curr.d).attr({
          fill: "#000",
          stroke: "none",
          translation: [shift, 0]
        }));
      }
      out.scale(scale, scale, top, height).translate(x - top, y - height);
    }
    return out;
  };
  R.format = function (token, params) {
    var args = R.is(params, array) ? [0][concat](params) : arguments;
    token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
      return args[++i] == null ? E : args[i];
    }));
    return token || E;
  };
  R.ninja = function () {
    oldRaphael.was ? win.Raphael = oldRaphael.is : Raphael = undefined;
    return R;
  };
  R.el = elproto;
  R.st = Set[proto];
  raphael.exports = R;
})();

/**
 * Color constants we use throughout Perseus (originally on KhanUtil).
 *
 * Note that if the color palette changes substantially, it may also need to be
 * updated in khan-exercises and cherry-picked into graphie-to-png's
 * khan-exercises submodule, as graphie-to-png still relies on the palette
 * provided on KhanUtil.
 */
const KhanColors = {
  BLUE: "#6495ED",
  ORANGE: "#FFA500",
  PINK: "#FF00AF",
  GREEN: "#28AE7B",
  PURPLE: "#9D38BD",
  RED: "#DF0030",
  GRAY: "gray",
  BLACK: "black",
  LIGHT_BLUE: "#9AB8ED",
  LIGHT_ORANGE: "#EDD19B",
  LIGHT_PINK: "#ED9BD3",
  LIGHT_GREEN: "#9BEDCE",
  LIGHT_PURPLE: "#DA9BED",
  LIGHT_RED: "#ED9AAC",
  LIGHT_GRAY: "#ED9B9B",
  LIGHT_BLACK: "#ED9B9B",
  GRAY10: "#D6D6D6",
  GRAY20: "#CDCDCD",
  GRAY30: "#B3B3B3",
  GRAY40: "#9A9A9A",
  GRAY50: "#808080",
  GRAY60: "#666666",
  GRAY70: "#4D4D4D",
  GRAY80: "#333333",
  GRAY90: "#1A1A1A",
  BLUE_A: "#CCFAFF",
  BLUE_B: "#80F6FF",
  BLUE_C: "#63D9EA",
  BLUE_D: "#11ACCD",
  BLUE_E: "#0C7F99",
  TEAL_A: "#94FFF5",
  TEAL_B: "#26EDD5",
  TEAL_C: "#01D1C1",
  TEAL_D: "#01A995",
  TEAL_E: "#208170",
  GREEN_A: "#B6FFB0",
  GREEN_B: "#8AF281",
  GREEN_C: "#74CF70",
  GREEN_D: "#1FAB54",
  GREEN_E: "#0D923F",
  GOLD_A: "#FFD0A9",
  GOLD_B: "#FFBB71",
  GOLD_C: "#FF9C39",
  GOLD_D: "#E07D10",
  GOLD_E: "#A75A05",
  RED_A: "#FCA9A9",
  RED_B: "#FF8482",
  RED_C: "#F9685D",
  RED_D: "#E84D39",
  RED_E: "#BC2612",
  MAROON_A: "#FFBDE0",
  MAROON_B: "#FF92C6",
  MAROON_C: "#ED5FA6",
  MAROON_D: "#CA337C",
  MAROON_E: "#9E034E",
  PURPLE_A: "#DDD7FF",
  PURPLE_B: "#C6B9FC",
  PURPLE_C: "#AA87FF",
  PURPLE_D: "#7854AB",
  PURPLE_E: "#543B78",
  MINT_A: "#F5F9E8",
  MINT_B: "#EDF2DF",
  MINT_C: "#E0E5CC",
  GRAY_A: "#F6F7F7",
  GRAY_B: "#F0F1F2",
  GRAY_C: "#E3E5E6",
  GRAY_D: "#D6D8DA",
  GRAY_E: "#BABEC2",
  GRAY_F: "#888D93",
  GRAY_G: "#626569",
  GRAY_H: "#3B3E40",
  GRAY_I: "#21242C",
  KA_BLUE: "#314453",
  KA_GREEN: "#71B307",
  // Don't actually use _BACKGROUND! Make things transparent instead. The
  // background color used in exercises is subject to change at the whim
  // of any redesigns.
  _BACKGROUND: "#FDFDFD",
  // TODO(eater): Get rid of this altogether.
  INTERACTING: "#71B307",
  // KA_GREEN
  INTERACTIVE: "#71B307",
  // KA_GREEN
  DYNAMIC: "#6495ED" // BLUE
};

function render(element, container, callback) {
  // TODO(LP-11406): Replace this, or callers, with React Portal
  // @ts-expect-error [FEI-5003] - TS2322 - Type 'void' is not assignable to type 'ElementRef<ElementType>'.
  // eslint-disable-next-line no-restricted-syntax
  return ReactDOM__default["default"].render(
  /*#__PURE__*/
  /**
   * `RenderStateRoot` is responsible for tracking whether it's
   * the initial render or subsequent renders.  It's used by
   * `useUniqueId` and will be used by `UniqueIDProvider` and
   * `WithSSRPlaceholder` in the future.  We're placing it as
   * high up in the render tree as possible to ensure that any
   * components using that hook or those components will function
   * correctly.
   */
  React__namespace.createElement(wonderBlocksCore.RenderStateRoot, {
    throwIfNested: false
  }, element), container, callback);
}

function findChildOrAdd(elem, className) {
  const $child = $__default["default"](elem).find("." + className);
  if ($child.length === 0) {
    return $__default["default"]("<span>").addClass(className).appendTo($__default["default"](elem));
  }
  return $child;
}
function doCallback(elem, callback) {
  let tries = 0;
  (function check() {
    const height = elem.scrollHeight;
    // Heuristic to guess if the font has kicked in
    // so we have box metrics (magic number ick,
    // but this seems to work mostly-consistently)
    if (height > 18 || tries >= 10) {
      callback();
    } else {
      tries++;
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(check, 100);
    }
  })();
}
var Tex$1 = {
  // Process a node and add math inside of it. This attempts to use KaTeX to
  // format the math, and if that fails it falls back to MathJax.
  //
  // elem: The element which the math should be added to.
  //
  // text: The text that should be formatted inside of the node. If the node
  //       has already had math formatted inside of it before, this doesn't
  //       have to be provided. If this is not provided, and the node hasn't
  //       been formatted before, the text content of the node is used.
  //
  // force: (optional) if the node has been processed before, then it will
  //        not be formatted again, unless this argument is true
  //
  // callback: (optional) a callback to be run after the math has been
  //           processed
  processMath: async function (elem, text, force, callback) {
    const $elem = $__default["default"](elem);

    // Only process if it hasn't been done before, or it is forced
    if ($elem.attr("data-math-formula") == null || force) {
      const $katexHolder = findChildOrAdd($elem, "katex-holder");
      const $mathjaxHolder = findChildOrAdd($elem, "mathjax-holder");

      // Search for MathJax-y script tags inside of the node. These are
      // used by MathJax to denote the formula to be typeset. Before, we
      // would update the formula by updating the contents of the script
      // tag, which shouldn't happen any more, but we manage them just in
      // case.
      const script = $mathjaxHolder.find("script[type='math/tex']")[0];

      // If text wasn't provided, we look in two places
      if (text == null) {
        if ($elem.attr("data-math-formula")) {
          // The old typeset formula
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'string | undefined' is not assignable to type 'string'.
          text = $elem.attr("data-math-formula");
        } else if (script) {
          // The contents of the <script> tag
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'text' does not exist on type 'HTMLElement'.
          text = script.text || script.textContent;
        }
      }
      text = text != null ? text + "" : "";

      // Attempt to clean up some of the math
      text = KhanMath.cleanMath(text);

      // Store the formula that we're using
      $elem.attr("data-math-formula", text);
      const {
        TeX
      } = await getDependencies();
      // We use createElement instead of JSX here because we can't name this file tex.tsx;
      // that name is already taken.
      render( /*#__PURE__*/React__namespace.createElement(TeX, {
        children: text
      }), $katexHolder[0], () => {
        if (callback) {
          doCallback(elem, callback);
        }
      });
    }
  },
  // Function to restore a node to a non-math-processed state
  cleanupMath: function (elem) {
    const $elem = $__default["default"](elem);

    // Only mess with it if it's been processed before
    if ($elem.attr("data-math-formula")) {
      // Remove MathJax remnants
      if (typeof MathJax !== "undefined") {
        const jax = MathJax.Hub.getJaxFor($elem.find("script")[0]);
        if (jax) {
          const e = jax.SourceElement();
          if (e.previousSibling && e.previousSibling.className) {
            jax.Remove();
          }
        }
      }

      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      $elem.text($elem.attr("data-math-formula"));
      $elem.attr("data-math-formula", null);
      $elem.attr("data-math-type", null);
    }
    return elem;
  },
  // Function to retrieve the formula of a typeset math node
  retrieveMathFormula: function (elem) {
    return $__default["default"](elem).attr("data-math-formula");
  }
};

/* eslint-disable @babel/no-invalid-this */
const {
  processMath: processMath$1
} = Tex$1;

/* Convert cartesian coordinates [x, y] to polar coordinates [r,
 * theta], with theta in degrees, or in radians if angleInRadians is
 * specified.
 */
function cartToPolar(coord, angleInRadians) {
  const r = Math.sqrt(Math.pow(coord[0], 2) + Math.pow(coord[1], 2));
  let theta = Math.atan2(coord[1], coord[0]);
  // convert angle range from [-pi, pi] to [0, 2pi]
  if (theta < 0) {
    theta += 2 * Math.PI;
  }
  if (!angleInRadians) {
    theta = theta * 180 / Math.PI;
  }
  return [r, theta];
}
function polar(r, th) {
  if (typeof r === "number") {
    r = [r, r];
  }
  th = th * Math.PI / 180;
  return [r[0] * Math.cos(th), r[1] * Math.sin(th)];
}
const GraphUtils = {
  unscaledSvgPath: function (points) {
    // If this is an empty closed path, return "" instead of "z", which
    // would give an error
    if (points[0] === true) {
      return "";
    }
    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      }
      return (i === 0 ? "M" : "L") + point[0] + " " + point[1];
    }).join("");
  },
  getDistance: function (point1, point2) {
    return kmath.point.distanceToPoint(point1, point2);
  },
  /**
   * Return the difference between two sets of coordinates
   */
  coordDiff: function (startCoord, endCoord) {
    return ___default["default"].map(endCoord, function (val, i) {
      return endCoord[i] - startCoord[i];
    });
  },
  /**
   * Round the given coordinates to a given snap value
   * (e.g., nearest 0.2 increment)
   */
  snapCoord: function (coord, snap) {
    return ___default["default"].map(coord, function (val, i) {
      return KhanMath.roundToNearest(snap[i], val);
    });
  },
  // Find the angle in degrees between two or three points
  findAngle: function (point1, point2, vertex) {
    if (vertex === undefined) {
      const x = point1[0] - point2[0];
      const y = point1[1] - point2[1];
      if (!x && !y) {
        return 0;
      }
      return (180 + Math.atan2(-y, -x) * 180 / Math.PI + 360) % 360;
    }
    return GraphUtils.findAngle(point1, vertex) - GraphUtils.findAngle(point2, vertex);
  },
  graphs: {}
};
const Graphie$1 = GraphUtils.Graphie = function () {};
___default["default"].extend(Graphie$1.prototype, {
  cartToPolar: cartToPolar,
  polar: polar
});
const labelDirections = {
  center: [-0.5, -0.5],
  above: [-0.5, -1.0],
  "above right": [0.0, -1.0],
  right: [0.0, -0.5],
  "below right": [0.0, 0.0],
  below: [-0.5, 0.0],
  "below left": [-1.0, 0.0],
  left: [-1.0, -0.5],
  "above left": [-1.0, -1.0]
};

/**
 * Safari applies some SVG-specific styles to things that are not SVGs, so we
 * need to exclude those styles from things that are not SVGs.
 *
 * To see this behavior in action, open https://codepen.io/anon/pen/zENEoa in
 * Safari.
 *
 * Usage `$.extend({}, someStyles, SVG_SPECIFIC_STYLE_MASK)`
 */
const SVG_SPECIFIC_STYLE_MASK = {
  "stroke-width": null
};
GraphUtils.createGraphie = function (el) {
  let xScale = 40;
  let yScale = 40;
  let xRange;
  let yRange;
  $__default["default"](el).css("position", "relative");
  const raphael$1 = raphael.exports(el);

  // For a sometimes-reproducible IE8 bug; doesn't affect SVG browsers at all
  $__default["default"](el).children("div").css("position", "absolute");

  // Set up some reasonable defaults
  let currentStyle = {
    "stroke-width": 2,
    fill: "none"
  };
  const scaleVector = function (point) {
    if (typeof point === "number") {
      return scaleVector([point, point]);
    }
    const x = point[0];
    const y = point[1];
    return [x * xScale, y * yScale];
  };
  const scalePoint = function scalePoint(point) {
    if (typeof point === "number") {
      return scalePoint([point, point]);
    }
    const x = point[0];
    const y = point[1];
    return [(x - xRange[0]) * xScale, (yRange[1] - y) * yScale];
  };
  const unscalePoint = function (point) {
    if (typeof point === "number") {
      return unscalePoint([point, point]);
    }
    const x = point[0];
    const y = point[1];
    return [x / xScale + xRange[0], yRange[1] - y / yScale];
  };
  const unscaleVector = function (point) {
    if (typeof point === "number") {
      return unscaleVector([point, point]);
    }
    return [point[0] / xScale, point[1] / yScale];
  };
  const setLabelMargins = function (span, size) {
    const $span = $__default["default"](span);
    const direction = $span.data("labelDirection");
    let [width, height] = size;
    // This can happen when a span
    // is invisible but we still want to update the CSS. At worst, we will
    // be off by a few pixels instead of in a different position entirely.
    if (width === 0 && height === 0) {
      [width, height] = [1, 1];
      Log.log("Label size was 0x0 in graphie.js; using 1x1 instead");
    }
    $span.css("visibility", "");
    if (typeof direction === "number") {
      const x = Math.cos(direction);
      const y = Math.sin(direction);
      const scale = Math.min(width / 2 / Math.abs(x), height / 2 / Math.abs(y));
      $span.css({
        marginLeft: -width / 2 + x * scale,
        marginTop: -height / 2 - y * scale
      });
    } else {
      const multipliers = labelDirections[direction || "center"];
      $span.css({
        marginLeft: Math.round(width * multipliers[0]),
        marginTop: Math.round(height * multipliers[1])
      });
    }
  };
  const svgPath = function (points, alreadyScaled) {
    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      }
      const scaled = alreadyScaled ? point : scalePoint(point);
      return (i === 0 ? "M" : "L") + KhanMath.bound(scaled[0]) + " " + KhanMath.bound(scaled[1]);
    }).join("");
  };
  const svgParabolaPath = function (a, b, c) {
    const computeParabola = function (x) {
      return (a * x + b) * x + c;
    };

    // If points are collinear, plot a line instead
    if (a === 0) {
      const points = ___default["default"].map(xRange, function (x) {
        return [x, computeParabola(x)];
      });
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
      return svgPath(points);
    }

    // Calculate x coordinates of points on parabola
    const xVertex = -b / (2 * a);
    const distToEdge = Math.max(Math.abs(xVertex - xRange[0]), Math.abs(xVertex - xRange[1]));

    // To guarantee that drawn parabola to spans the viewport, use a point
    // on the edge of the graph furtherest from the vertex
    const xPoint = xVertex + distToEdge;

    // Compute parabola and other point on the curve
    const vertex = [xVertex, computeParabola(xVertex)];
    const point = [xPoint, computeParabola(xPoint)];

    // Calculate SVG 'control' point, defined by spec
    const control = [vertex[0], vertex[1] - (point[1] - vertex[1])];

    // Calculate mirror points across parabola's axis of symmetry
    const dx = Math.abs(vertex[0] - point[0]);
    const left = [vertex[0] - dx, point[1]];
    const right = [vertex[0] + dx, point[1]];

    // Scale and bound
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(point: number | Coord) => Coord' is not assignable to parameter of type 'Iteratee<any[][], any, any[]>'.
    const points = ___default["default"].map([left, control, right], scalePoint);
    const values = ___default["default"].map(___default["default"].flatten(points), KhanMath.bound);
    return "M" + values[0] + "," + values[1] + " Q" + values[2] + "," + values[3] + " " + values[4] + "," + values[5];
  };
  const svgSinusoidPath = function (a, b, c, d) {
    // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
    const quarterPeriod = Math.abs(Math.PI / (2 * b));
    const computeSine = function (x) {
      return a * Math.sin(b * x - c) + d;
    };
    const computeDerivative = function (x) {
      return a * b * Math.cos(c - b * x);
    };
    const coordsForOffset = function (initial, i) {
      // Return the cubic coordinates (including the two anchor and two
      // control points) for the ith portion of the sinusoid.
      const x0 = initial + quarterPeriod * i;
      const x1 = x0 + quarterPeriod;

      // Interpolate using derivative technique
      // See: http://stackoverflow.com/questions/13932704/how-to-draw-sine-waves-with-svg-js
      const xCoords = [x0, x0 * 2 / 3 + x1 * 1 / 3, x0 * 1 / 3 + x1 * 2 / 3, x1];
      const yCoords = [computeSine(x0), computeSine(x0) + computeDerivative(x0) * (x1 - x0) / 3, computeSine(x1) - computeDerivative(x1) * (x1 - x0) / 3, computeSine(x1)];

      // Zip and scale
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(point: number | Coord) => Coord' is not assignable to parameter of type 'Iteratee<any[][], any, any[]>'.
      return ___default["default"].map(___default["default"].zip(xCoords, yCoords), scalePoint);
    };

    // How many quarter-periods do we need to span the graph?
    const extent = xRange[1] - xRange[0];
    const numQuarterPeriods = Math.ceil(extent / quarterPeriod) + 1;

    // Find starting coordinate: first anchor point curve left of xRange[0]
    let initial = c / b;
    const distToEdge = initial - xRange[0];
    initial -= quarterPeriod * Math.ceil(distToEdge / quarterPeriod);

    // First portion of path is special-case, requiring move-to ('M')
    let coords = coordsForOffset(initial, 0);
    let path = "M" + coords[0][0] + "," + coords[0][1] + " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];
    for (let i = 1; i < numQuarterPeriods; i++) {
      coords = coordsForOffset(initial, i);
      path += " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];
    }
    return path;
  };

  // `svgPath` is independent of graphie range, so we export it independently
  GraphUtils.svgPath = svgPath;
  const processAttributes = function (attrs) {
    const transformers = {
      scale: function (scale) {
        if (typeof scale === "number") {
          scale = [scale, scale];
        }
        xScale = scale[0];
        yScale = scale[1];

        // Update the canvas size
        raphael$1.setSize((xRange[1] - xRange[0]) * xScale, (yRange[1] - yRange[0]) * yScale);
      },
      clipRect: function (pair) {
        const point = pair[0];
        const size = pair[1];
        point[1] += size[1]; // because our coordinates are flipped

        return {
          "clip-rect": scalePoint(point).concat(scaleVector(size)).join(" ")
        };
      },
      strokeWidth: function (val) {
        return {
          "stroke-width": parseFloat(val)
        };
      },
      rx: function (val) {
        return {
          rx: scaleVector([val, 0])[0]
        };
      },
      ry: function (val) {
        return {
          ry: scaleVector([0, val])[1]
        };
      },
      r: function (val) {
        const scaled = scaleVector([val, val]);
        return {
          rx: scaled[0],
          ry: scaled[1]
        };
      }
    };
    const processed = {};
    $__default["default"].each(attrs || {}, function (key, value) {
      const transformer = transformers[key];
      if (typeof transformer === "function") {
        $__default["default"].extend(processed, transformer(value));
      } else {
        const dasherized = key
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'replace' does not exist on type 'string | number | symbol'.
        .replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
        processed[dasherized] = value;
      }
    });
    return processed;
  };
  const addArrowheads = function arrows(path) {
    const type = path.constructor.prototype;
    if (type === raphael.exports.el) {
      if (path.type === "path" && typeof path.arrowheadsDrawn === "undefined") {
        const w = path.attr("stroke-width");
        const s = 0.6 + 0.4 * w;
        const l = path.getTotalLength();
        const set = raphael$1.set();
        const head = raphael$1.path(graphie.isMobile ? "M-4,4 C-4,4 -0.25,0 -0.25,0 C-0.25,0 -4,-4 -4,-4" : "M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
        const end = path.getPointAtLength(l - 0.4);
        const almostTheEnd = path.getPointAtLength(l - 0.75 * s);
        const angle = Math.atan2(end.y - almostTheEnd.y, end.x - almostTheEnd.x) * 180 / Math.PI;
        const attrs = path.attr();
        delete attrs.path;
        let subpath = path.getSubpath(0, l - 0.75 * s);
        subpath = raphael$1.path(subpath).attr(attrs);
        subpath.arrowheadsDrawn = true;
        path.remove();

        // For some unknown reason 0 doesn't work for the rotation
        // origin so we use a tiny number.
        head.rotate(angle, graphie.isMobile ? 1e-5 : 0.75, 0).scale(s, s, 0.75, 0).translate(almostTheEnd.x, almostTheEnd.y).attr(attrs).attr({
          "stroke-linejoin": "round",
          "stroke-linecap": "round"
        });
        head.arrowheadsDrawn = true;
        set.push(subpath);
        set.push(head);
        return set;
      }
    } else if (type === raphael.exports.st) {
      for (let i = 0, l = path.items.length; i < l; i++) {
        arrows(path.items[i]);
      }
    }
    return path;
  };
  const drawingTools = {
    circle: function (center, radius) {
      return raphael$1.ellipse(...scalePoint(center).concat(scaleVector([radius, radius])));
    },
    // (x, y) is coordinate of bottom left corner
    rect: function (x, y, width, height) {
      // Raphael needs (x, y) to be coordinate of upper left corner
      const corner = scalePoint([x, y + height]);
      const dims = scaleVector([width, height]);
      const elem = raphael$1.rect(...corner.concat(dims));
      if (graphie.isMobile) {
        elem.node.style.shapeRendering = "crispEdges";
      }
      return elem;
    },
    ellipse: function (center, radii) {
      return raphael$1.ellipse(...scalePoint(center).concat(scaleVector(radii)));
    },
    fixedEllipse: function (center,
    // Different type than Coord, this is radiusX, radiusY
    radii, maxScale, padding) {
      // Scale point and radius
      const scaledPoint = scalePoint(center);
      const scaledRadii = scaleVector(radii);
      const width = 2 * scaledRadii[0] * maxScale + padding;
      const height = 2 * scaledRadii[1] * maxScale + padding;

      // Calculate absolute left, top
      const left = scaledPoint[0] - width / 2;
      const top = scaledPoint[1] - height / 2;

      // Wrap in <div>
      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px"
      });
      // wrapper.setAttribute("data-graphie-type", "ellipse");

      // Create Raphael canvas
      const localRaphael = raphael.exports(wrapper, width, height);
      const visibleShape = localRaphael.ellipse(width / 2, height / 2, scaledRadii[0], scaledRadii[1]);
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    arc: function (center, radius, startAngle, endAngle, sector) {
      startAngle = (startAngle % 360 + 360) % 360;
      endAngle = (endAngle % 360 + 360) % 360;
      const cent = scalePoint(center);
      const radii = scaleVector(radius);
      const startVector = polar(radius, startAngle);
      const endVector = polar(radius, endAngle);
      const startPoint = scalePoint([center[0] + startVector[0], center[1] + startVector[1]]);
      const endPoint = scalePoint([center[0] + endVector[0], center[1] + endVector[1]]);
      const largeAngle = ((endAngle - startAngle) % 360 + 360) % 360 > 180;
      return raphael$1.path("M" + startPoint.join(" ") + "A" + radii.join(" ") + " 0 " + (
      // ellipse rotation
      largeAngle ? 1 : 0) + " 0 " +
      // sweep flag
      endPoint.join(" ") + (sector ? "L" + cent.join(" ") + "z" : ""));
    },
    path: function (points) {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
      const p = raphael$1.path(svgPath(points));
      p.graphiePath = points;
      return p;
    },
    fixedPath: function (points, center, createPath) {
      points = ___default["default"].map(points, scalePoint);
      center = center ? scalePoint(center) : null;
      createPath = createPath || svgPath;
      const pathLeft = ___default["default"].min(___default["default"].pluck(points, 0));
      const pathRight = ___default["default"].max(___default["default"].pluck(points, 0));
      const pathTop = ___default["default"].min(___default["default"].pluck(points, 1));
      const pathBottom = ___default["default"].max(___default["default"].pluck(points, 1));

      // Apply padding to line
      const padding = [4, 4];

      // Calculate and apply additional offset
      const extraOffset = [pathLeft, pathTop];

      // Apply padding and offset to points
      points = ___default["default"].map(points, function (point) {
        return kmath.vector.add(kmath.vector.subtract(point, extraOffset), kmath.vector.scale(padding, 0.5));
      });

      // Calculate <div> dimensions
      const width = pathRight - pathLeft + padding[0];
      const height = pathBottom - pathTop + padding[1];
      const left = extraOffset[0] - padding[0] / 2;
      const top = extraOffset[1] - padding[1] / 2;

      // Create <div>
      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // If user specified a center, set it
        // NOTE(kevinb): jQuery doesn't like that `transformOrigin `could be `null`
        // so we cast to `any` here.
        transformOrigin: center ? width / 2 + center[0] + "px " + (height / 2 + center[1]) + "px" : null
      });

      // Create Raphael canvas
      const localRaphael = raphael.exports(wrapper, width, height);

      // Calculate path
      const visibleShape = localRaphael.path(createPath(points));
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    scaledPath: function (points) {
      const p = raphael$1.path(svgPath(points, /* alreadyScaled */true));
      p.graphiePath = points;
      return p;
    },
    line: function (start, end) {
      const l = this.path([start, end]);
      if (graphie.isMobile) {
        l.node.style.shapeRendering = "crispEdges";
      }
      return l;
    },
    parabola: function (a, b, c) {
      // Plot a parabola of the form: f(x) = (a * x + b) * x + c
      return raphael$1.path(svgParabolaPath(a, b, c));
    },
    fixedLine: function (start, end, thickness) {
      // Apply padding to line
      const padding = [thickness, thickness];

      // Scale points to get values in pixels
      start = scalePoint(start);
      end = scalePoint(end);

      // Calculate and apply additional offset
      const extraOffset = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];

      // Apply padding and offset to start, end points
      start = kmath.vector.add(kmath.vector.subtract(start, extraOffset), kmath.vector.scale(padding, 0.5));
      end = kmath.vector.add(kmath.vector.subtract(end, extraOffset), kmath.vector.scale(padding, 0.5));

      // Calculate <div> dimensions
      const left = extraOffset[0] - padding[0] / 2;
      const top = extraOffset[1] - padding[1] / 2;
      const width = Math.abs(start[0] - end[0]) + padding[0];
      const height = Math.abs(start[1] - end[1]) + padding[1];

      // Create <div>
      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // Outsiders should feel like the line's 'origin' (i.e., for
        // rotation) is the starting point
        transformOrigin: start[0] + "px " + start[1] + "px"
      });

      // Create Raphael canvas
      const localRaphael = raphael.exports(wrapper, width, height);

      // Calculate path
      const path = "M" + start[0] + " " + start[1] + " " + "L" + end[0] + " " + end[1];
      const visibleShape = localRaphael.path(path);
      visibleShape.graphiePath = [start, end];
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    sinusoid: function (a, b, c, d) {
      // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
      return raphael$1.path(svgSinusoidPath(a, b, c, d));
    },
    grid: function (xr, yr) {
      const step = currentStyle.step || [1, 1];
      const set = raphael$1.set();
      let x = step[0] * Math.ceil(xr[0] / step[0]);
      for (; x <= xr[1]; x += step[0]) {
        set.push(this.line([x, yr[0]], [x, yr[1]]));
      }
      let y = step[1] * Math.ceil(yr[0] / step[1]);
      for (; y <= yr[1]; y += step[1]) {
        set.push(this.line([xr[0], y], [xr[1], y]));
      }
      return set;
    },
    label: function (point, text, direction, latex) {
      latex = typeof latex === "undefined" || latex;
      const $span = $__default["default"]("<span>").addClass("graphie-label");
      const pad = currentStyle["label-distance"];
      $span.css($__default["default"].extend({}, {
        position: "absolute",
        padding: (pad != null ? pad : 7) + "px",
        color: "black"
      })).data("labelDirection", direction).appendTo(el);

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'setPosition' does not exist on type 'JQuery<HTMLElement>'.
      $span.setPosition = function (point) {
        const scaledPoint = scalePoint(point);
        $span.css({
          left: scaledPoint[0],
          top: scaledPoint[1]
        });
      };

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'setPosition' does not exist on type 'JQuery<HTMLElement>'.
      $span.setPosition(point);
      const span = $span[0];

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'processMath' does not exist on type 'JQuery<HTMLElement>'.
      $span.processMath = function (math, force) {
        processMath$1(span, math, force, function () {
          const width = span.scrollWidth;
          const height = span.scrollHeight;
          setLabelMargins(span, [width, height]);
        });
      };

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'processText' does not exist on type 'JQuery<HTMLElement>'.
      $span.processText = function (text) {
        $span.html(text);
        const width = span.scrollWidth;
        const height = span.scrollHeight;
        setLabelMargins(span, [width, height]);
      };
      if (latex) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'processMath' does not exist on type 'JQuery<HTMLElement>'.
        $span.processMath(text, /* force */false);
      } else {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'processText' does not exist on type 'JQuery<HTMLElement>'.
        $span.processText(text);
      }
      return $span;
    },
    plotParametric: function (fn, range, shade, fn2) {
      // Note: fn2 should only be set if 'shade' is true, as it denotes
      // the function between which fn should have its area shaded.
      // In general, plotParametric shouldn't be used to shade the area
      // between two arbitrary parametrics functions over an interval,
      // as the method assumes that fn and fn2 are both of the form
      // fn(t) = (t, fn'(t)) for some initial fn'.
      fn2 = fn2 || function (t) {
        return [t, 0];
      };

      // We truncate to 500,000, since anything bigger causes
      // overflow in the firefox svg renderer.  This is safe
      // since 500,000 is outside the viewport anyway.  We
      // write these functions the way we do to handle undefined.
      const clipper = xy => {
        if (Math.abs(xy[1]) > 500000) {
          return [xy[0], Math.min(Math.max(xy[1], -500000), 500000)];
        }
        return xy;
      };
      const clippedFn = x => clipper(fn(x));
      const clippedFn2 = x => clipper(fn2(x));
      if (!currentStyle.strokeLinejoin) {
        currentStyle.strokeLinejoin = "round";
      }
      if (!currentStyle.strokeLinecap) {
        currentStyle.strokeLinecap = "round";
      }
      const min = range[0];
      const max = range[1];
      let step = (max - min) / (currentStyle["plot-points"] || 800);
      if (step === 0) {
        step = 1;
      }
      const paths = raphael$1.set();
      let points = [];
      let lastDiff = GraphUtils.coordDiff(clippedFn(min), clippedFn2(min));
      let lastFlip = min;
      for (let t = min; t <= max; t += step) {
        const top = clippedFn(t);
        const bottom = clippedFn2(t);
        const diff = GraphUtils.coordDiff(top, bottom);

        // Find points where it flips
        // Create path that sketches area between the two functions
        if (
        // if there is an asymptote here, meaning that the graph
        // switches signs and has a large difference
        diff[1] < 0 !== lastDiff[1] < 0 && Math.abs(diff[1] - lastDiff[1]) > 2 * yScale ||
        // or the function is undefined
        isNaN(diff[1])) {
          // split the path at this point, and draw it
          if (shade) {
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
            points.push(top);

            // backtrack to draw paired function
            for (let u = t - step; u >= lastFlip; u -= step) {
              // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
              points.push(clippedFn2(u));
            }
            lastFlip = t;
          }
          paths.push(this.path(points));
          // restart the path, excluding this point
          points = [];
          if (shade) {
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
            points.push(top);
          }
        } else {
          // otherwise, just add the point to the path
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
          points.push(top);
        }
        lastDiff = diff;
      }
      if (shade) {
        // backtrack to draw paired function
        for (let u = max - step; u >= lastFlip; u -= step) {
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
          points.push(clippedFn2(u));
        }
      }
      paths.push(this.path(points));
      return paths;
    },
    plotPolar: function (fn, range) {
      const min = range[0];
      const max = range[1];

      // There is probably a better heuristic for this
      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }
      return this.plotParametric(function (th) {
        return polar(fn(th), th * 180 / Math.PI);
      }, range);
    },
    plot: function (fn, range, swapAxes, shade, fn2) {
      const min = range[0];
      const max = range[1];
      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }
      if (swapAxes) {
        if (fn2) {
          // TODO(charlie): support swapped axis area shading
          throw new PerseusError("Can't shade area between functions with swapped axes.", Errors.Internal);
        }
        return this.plotParametric(function (y) {
          return [fn(y), y];
        }, range, shade);
      }
      if (fn2) {
        if (shade) {
          return this.plotParametric(function (x) {
            return [x, fn(x)];
          }, range, shade, function (x) {
            return [x, fn2(x)];
          });
        }
        throw new PerseusError("fn2 should only be set when 'shade' is True.", Errors.Internal);
      }
      return this.plotParametric(function (x) {
        return [x, fn(x)];
      }, range, shade);
    },
    /**
     * Given a piecewise function, return a Raphael set of paths that
     * can be used to draw the function, e.g. using style().
     * Calls plotParametric.
     *
     * @param  {[]} fnArray    array of functions which when called
     *                         with a parameter i return the value of
     *                         the function at i
     * @param  {[]} rangeArray array of ranges over which the
     *                         corresponding functions are defined
     * @return {Set<any>}      set of paths
     */
    plotPiecewise: function (fnArray, rangeArray) {
      const paths = raphael$1.set();
      const self = this;
      ___default["default"].times(fnArray.length, function (i) {
        const fn = fnArray[i];
        const range = rangeArray[i];
        const fnPaths = self.plotParametric(function (x) {
          return [x, fn(x)];
        }, range);
        ___default["default"].each(fnPaths, function (fnPath) {
          paths.push(fnPath);
        });
      });
      return paths;
    },
    /**
     * Given an array of coordinates of the form [x, y], create and
     * return a Raphael set of Raphael circle objects at those
     * coordinates
     *
     * @param  {Array<[number, number]>} endpointArray
     * @return {Set<any>} set of circles
     */
    plotEndpointCircles: function (endpointArray) {
      const circles = raphael$1.set();
      const self = this;
      ___default["default"].each(endpointArray, function (coord, i) {
        circles.push(self.circle(coord, 0.15));
      });
      return circles;
    },
    plotAsymptotes: function (fn, range) {
      const min = range[0];
      const max = range[1];
      const step = (max - min) / (currentStyle["plot-points"] || 800);
      const asymptotes = raphael$1.set();
      let lastVal = fn(min);
      for (let t = min; t <= max; t += step) {
        const funcVal = fn(t);
        if (funcVal < 0 !== lastVal < 0 && Math.abs(funcVal - lastVal) > 2 * yScale) {
          asymptotes.push(this.line([t, yScale], [t, -yScale]));
        }
        lastVal = funcVal;
      }
      return asymptotes;
    }
  };
  const graphie = new Graphie$1();
  ___default["default"].extend(graphie, {
    raphael: raphael$1,
    init: function (options) {
      let scale = options.scale || [40, 40];
      scale = typeof scale === "number" ? [scale, scale] : scale;
      xScale = scale[0];
      yScale = scale[1];
      if (options.range == null) {
        throw new PerseusError("range should be specified in graph init", Errors.Internal);
      }
      xRange = options.range[0];
      yRange = options.range[1];
      const w = (xRange[1] - xRange[0]) * xScale;
      const h = (yRange[1] - yRange[0]) * yScale;
      raphael$1.setSize(w, h);
      $__default["default"](el).css({
        width: w,
        height: h
      });
      this.range = options.range;
      this.scale = scale;
      this.dimensions = [w, h];
      this.xpixels = w;
      this.ypixels = h;
      this.isMobile = options.isMobile;
      return this;
    },
    style: function (attrs, fn) {
      const processed = processAttributes(attrs);
      if (typeof fn === "function") {
        const oldStyle = currentStyle;
        currentStyle = $__default["default"].extend({}, currentStyle, processed);
        const result = fn.call(graphie);
        currentStyle = oldStyle;
        return result;
      }
      $__default["default"].extend(currentStyle, processed);
    },
    scalePoint: scalePoint,
    scaleVector: scaleVector,
    unscalePoint: unscalePoint,
    unscaleVector: unscaleVector,
    // Custom SVG path functions that are dependent on graphie range
    // `svgPath`, while independent of range, is exported for consistency
    svgPath: svgPath,
    svgParabolaPath: svgParabolaPath,
    svgSinusoidPath: svgSinusoidPath
  });
  $__default["default"].each(drawingTools, function (name) {
    graphie[name] = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const last = args[args.length - 1];
      const oldStyle = currentStyle;
      let result;

      // The last argument is probably trying to change the style
      if (typeof last === "object" && !___default["default"].isArray(last)) {
        currentStyle = {
          ...currentStyle,
          ...processAttributes(last)
        };
        const rest = [].slice.call(args, 0, args.length - 1);
        result = drawingTools[name](...rest);
      } else {
        currentStyle = $__default["default"].extend({}, currentStyle);
        result = drawingTools[name](...args);
      }

      // Bad heuristic for recognizing Raphael elements and sets
      const type = result.constructor.prototype;
      if (type === raphael.exports.el || type === raphael.exports.st) {
        result.attr(currentStyle);
        if (currentStyle.arrows) {
          result = addArrowheads(result);
        }
      } else if (result instanceof $__default["default"]) {
        // We assume that if it's not a Raphael element/set, it
        // does not contain SVG.
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'css' does not exist on type '{}'.
        result.css({
          ...currentStyle,
          ...SVG_SPECIFIC_STYLE_MASK
        });
      }
      currentStyle = oldStyle;
      return result;
    };
  });

  // Initializes graphie settings for a graph and draws the basic graph
  // features (axes, grid, tick marks, and axis labels)
  // Options expected are:
  // - range: [[a, b], [c, d]] or [a, b]
  // - scale: [a, b] or number
  // - gridOpacity: number (0 - 1)
  // - gridStep: [a, b] or number (relative to units)
  // - tickStep: [a, b] or number (relative to grid steps)
  // - tickLen: [a, b] or number (in pixels)
  // - labelStep: [a, b] or number (relative to tick steps)
  // - yLabelFormat: fn to format label string for y-axis
  // - xLabelFormat: fn to format label string for x-axis
  // - smartLabelPositioning: true or false to ignore minus sign
  graphie.graphInit = function (options) {
    options = options || {};
    $__default["default"].each(options, function (prop, val) {
      // allow options to be specified by a single number for shorthand if
      // the horizontal and vertical components are the same
      if (
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'match' does not exist on type 'string | number | symbol'.
      !prop.match(/.*Opacity$/) && prop !== "range" && typeof val === "number") {
        options[prop] = [val, val];
      }

      // allow symmetric ranges to be specified by the absolute values
      if (prop === "range" || prop === "gridRange") {
        if (val.constructor === Array) {
          // but don't mandate symmetric ranges
          if (val[0].constructor !== Array) {
            options[prop] = [[-val[0], val[0]], [-val[1], val[1]]];
          }
        } else if (typeof val === "number") {
          options[prop] = [[-val, val], [-val, val]];
        }
      }
    });
    const range = options.range || [[-10, 10], [-10, 10]];
    const gridRange = options.gridRange || options.range;
    const scale = options.scale || [20, 20];
    const grid = options.grid != null ? options.grid : true;
    const gridOpacity = options.gridOpacity || 0.1;
    const gridStep = options.gridStep || [1, 1];
    const axes = options.axes != null ? options.axes : true;
    const axisArrows = options.axisArrows || "";
    const axisOpacity = options.axisOpacity || 1.0;
    const axisCenter = options.axisCenter || [Math.min(Math.max(range[0][0], 0), range[0][1]), Math.min(Math.max(range[1][0], 0), range[1][1])];
    const axisLabels = options.axisLabels != null ? options.axisLabels : false;
    const ticks = options.ticks != null ? options.ticks : true;
    const tickStep = options.tickStep || [2, 2];
    const tickLen = options.tickLen || [5, 5];
    const tickOpacity = options.tickOpacity || 1.0;
    const labels = options.labels || options.labelStep || false;
    const labelStep = options.labelStep || [1, 1];
    const labelOpacity = options.labelOpacity || 1.0;
    let unityLabels = options.unityLabels || false;
    const labelFormat = options.labelFormat || function (a) {
      return a;
    };
    let xLabelFormat = options.xLabelFormat || labelFormat;
    let yLabelFormat = options.yLabelFormat || labelFormat;
    const smartLabelPositioning = options.smartLabelPositioning != null ? options.smartLabelPositioning : true;
    const realRange = [[range[0][0] - (range[0][0] > 0 ? 1 : 0), range[0][1] + (range[0][1] < 0 ? 1 : 0)], [range[1][0] - (range[1][0] > 0 ? 1 : 0), range[1][1] + (range[1][1] < 0 ? 1 : 0)]];
    if (!___default["default"].isArray(unityLabels)) {
      unityLabels = [unityLabels, unityLabels];
    }
    if (smartLabelPositioning) {
      const minusIgnorer = function (lf) {
        return function (a) {
          return (lf(a) + "").replace(/-(\d)/g, "\\llap{-}$1");
        };
      };
      xLabelFormat = minusIgnorer(xLabelFormat);
      yLabelFormat = minusIgnorer(yLabelFormat);
    }
    this.init({
      range: realRange,
      scale: scale,
      isMobile: options.isMobile
    });

    // draw grid
    if (grid) {
      this.grid(gridRange[0], gridRange[1], {
        stroke: options.isMobile ? KhanColors.GRAY_C : "#000000",
        opacity: options.isMobile ? 1 : gridOpacity,
        step: gridStep,
        strokeWidth: options.isMobile ? 1 : 2
      });
    }

    // draw axes
    if (axes) {
      // this is a slight hack until <-> arrowheads work
      if (axisArrows === "<->" || axisArrows === true) {
        this.style({
          stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
          opacity: options.isMobile ? 1 : axisOpacity,
          strokeWidth: options.isMobile ? 1 : 2,
          arrows: "->"
        }, function () {
          if (range[1][0] < 0 && range[1][1] > 0) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.path([axisCenter, [gridRange[0][0], axisCenter[1]]]);
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.path([axisCenter, [gridRange[0][1], axisCenter[1]]]);
          }
          if (range[0][0] < 0 && range[0][1] > 0) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.path([axisCenter, [axisCenter[0], gridRange[1][0]]]);
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.path([axisCenter, [axisCenter[0], gridRange[1][1]]]);
          }
        });

        // also, we don't support "<-" arrows yet, but why you
        // would want that on your graph is beyond me.
      } else if (axisArrows === "->" || axisArrows === "") {
        this.style({
          stroke: "#000000",
          opacity: axisOpacity,
          strokeWidth: 2,
          arrows: axisArrows
        }, function () {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.path([[gridRange[0][0], axisCenter[1]], [gridRange[0][1], axisCenter[1]]]);
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.path([[axisCenter[0], gridRange[1][0]], [axisCenter[0], gridRange[1][1]]]);
        });
      }
      if (axisLabels && axisLabels.length === 2) {
        this.label([gridRange[0][1], axisCenter[1]], axisLabels[0], "right");
        this.label([axisCenter[0], gridRange[1][1]], axisLabels[1], "above");
      }
    }

    // draw tick marks
    if (ticks) {
      const halfWidthTicks = options.isMobile;
      this.style({
        stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : tickOpacity,
        strokeWidth: 1
      }, function () {
        // horizontal axis
        let step = gridStep[0] * tickStep[0];
        let len = tickLen[0] / scale[1];
        let start = gridRange[0][0];
        let stop = gridRange[0][1];
        if (range[1][0] < 0 && range[1][1] > 0) {
          for (let x = step + axisCenter[0]; x <= stop; x += step) {
            if (x < stop || !axisArrows) {
              // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
              this.line([x, -len + axisCenter[1]], [x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }
          for (let x = -step + axisCenter[0]; x >= start; x -= step) {
            if (x > start || !axisArrows) {
              // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
              this.line([x, -len + axisCenter[1]], [x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }
        }

        // vertical axis
        step = gridStep[1] * tickStep[1];
        len = tickLen[1] / scale[0];
        start = gridRange[1][0];
        stop = gridRange[1][1];
        if (range[0][0] < 0 && range[0][1] > 0) {
          for (let y = step + axisCenter[1]; y <= stop; y += step) {
            if (y < stop || !axisArrows) {
              // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
              this.line([-len + axisCenter[0], y], [halfWidthTicks ? 0 : len + axisCenter[0], y]);
            }
          }
          for (let y = -step + axisCenter[1]; y >= start; y -= step) {
            if (y > start || !axisArrows) {
              // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
              this.line([-len + axisCenter[0], y], [halfWidthTicks ? 0 : len + axisCenter[0], y]);
            }
          }
        }
      });
    }

    // draw axis labels
    if (labels) {
      this.style({
        stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : labelOpacity
      }, function () {
        // horizontal axis
        let step = gridStep[0] * tickStep[0] * labelStep[0];
        let start = gridRange[0][0];
        let stop = gridRange[0][1];
        const xAxisPosition = axisCenter[0] < 0 ? "above" : "below";
        const yAxisPosition = axisCenter[0] < 0 ? "right" : "left";
        const xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0;
        const yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0;
        const axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0;
        const showUnityX = unityLabels[0] || axisOffCenter;
        const showUnityY = unityLabels[1] || axisOffCenter;

        // positive x-axis
        for (let x = (xShowZero ? 0 : step) + axisCenter[0]; x <= stop; x += step) {
          if (x < stop || !axisArrows) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
          }
        }

        // negative x-axis
        for (let x = -step * (showUnityX ? 1 : 2) + axisCenter[0]; x >= start; x -= step) {
          if (x > start || !axisArrows) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
          }
        }
        step = gridStep[1] * tickStep[1] * labelStep[1];
        start = gridRange[1][0];
        stop = gridRange[1][1];

        // positive y-axis
        for (let y = (yShowZero ? 0 : step) + axisCenter[1]; y <= stop; y += step) {
          if (y < stop || !axisArrows) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
          }
        }

        // negative y-axis
        for (let y = -step * (showUnityY ? 1 : 2) + axisCenter[1]; y >= start; y -= step) {
          if (y > start || !axisArrows) {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
          }
        }
      });
    }
  };
  return graphie;
};

/* eslint-disable */
(function ($, window, document, undefined$1) {
  if (typeof $ === "undefined") {
    return;
  }
  var dataPropertyName = "virtualMouseBindings",
    touchTargetPropertyName = "virtualTouchID",
    virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "),
    touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
    mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
    mouseEventProps = $.event.props.concat(mouseHookProps),
    activeDocHandlers = {},
    resetTimerID = 0,
    startX = 0,
    startY = 0,
    didScroll = false,
    clickBlockList = [],
    blockMouseTriggers = false,
    blockTouchTriggers = false,
    eventCaptureSupported = ("addEventListener" in document),
    $document = $(document),
    nextTouchID = 1,
    lastTouchID = 0;
  $.vmouse = {
    moveDistanceThreshold: 10,
    clickDistanceThreshold: 10,
    resetTimerDuration: 1500
  };
  function getNativeEvent(event) {
    while (event && typeof event.originalEvent !== "undefined") {
      event = event.originalEvent;
    }
    return event;
  }
  function createVirtualEvent(event, eventType) {
    var t = event.type,
      oe,
      props,
      ne,
      prop,
      ct,
      touch,
      i,
      j,
      len;
    event = $.Event(event);
    event.type = eventType;
    oe = event.originalEvent;
    props = $.event.props;

    // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
    // https://github.com/jquery/jquery-mobile/issues/3280
    if (t.search(/mouse/) > -1) {
      props = mouseEventProps;
    }

    // copy original event properties over to the new event
    // this would happen if we could call $.event.fix instead of $.Event
    // but we don't have a way to force an event to be fixed multiple times
    if (oe) {
      for (i = props.length, prop; i;) {
        prop = props[--i];
        event[prop] = oe[prop];
      }
    }

    // make sure that if the mouse and click virtual events are generated
    // without a .which one is defined
    if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
      event.which = 1;
    }
    if (t.search(/^touch/) !== -1) {
      ne = getNativeEvent(oe);
      t = ne.touches;
      ct = ne.changedTouches;
      touch = t && t.length ? t[0] : ct && ct.length ? ct[0] : undefined$1;
      if (touch) {
        for (j = 0, len = touchEventProps.length; j < len; j++) {
          prop = touchEventProps[j];
          event[prop] = touch[prop];
        }
      }
    }
    return event;
  }
  function getVirtualBindingFlags(element) {
    var flags = {},
      b,
      k;
    while (element) {
      b = $.data(element, dataPropertyName);
      for (k in b) {
        if (b[k]) {
          flags[k] = flags.hasVirtualBinding = true;
        }
      }
      element = element.parentNode;
    }
    return flags;
  }
  function getClosestElementWithVirtualBinding(element, eventType) {
    var b;
    while (element) {
      b = $.data(element, dataPropertyName);
      if (b && (!eventType || b[eventType])) {
        return element;
      }
      element = element.parentNode;
    }
    return null;
  }
  function enableTouchBindings() {
    blockTouchTriggers = false;
  }
  function disableTouchBindings() {
    blockTouchTriggers = true;
  }
  function enableMouseBindings() {
    lastTouchID = 0;
    clickBlockList.length = 0;
    blockMouseTriggers = false;

    // When mouse bindings are enabled, our
    // touch bindings are disabled.
    disableTouchBindings();
  }
  function disableMouseBindings() {
    // When mouse bindings are disabled, our
    // touch bindings are enabled.
    enableTouchBindings();
  }
  function startResetTimer() {
    clearResetTimer();
    resetTimerID = setTimeout(function () {
      resetTimerID = 0;
      enableMouseBindings();
    }, $.vmouse.resetTimerDuration);
  }
  function clearResetTimer() {
    if (resetTimerID) {
      clearTimeout(resetTimerID);
      resetTimerID = 0;
    }
  }
  function triggerVirtualEvent(eventType, event, flags) {
    var ve;
    if (flags && flags[eventType] || !flags && getClosestElementWithVirtualBinding(event.target, eventType)) {
      ve = createVirtualEvent(event, eventType);
      $(event.target).trigger(ve);
    }
    return ve;
  }
  function mouseEventCallback(event) {
    var touchID = $.data(event.target, touchTargetPropertyName);
    if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
      var ve = triggerVirtualEvent("v" + event.type, event);
      if (ve) {
        if (ve.isDefaultPrevented()) {
          event.preventDefault();
        }
        if (ve.isPropagationStopped()) {
          event.stopPropagation();
        }
        if (ve.isImmediatePropagationStopped()) {
          event.stopImmediatePropagation();
        }
      }
    }
  }
  function handleTouchStart(event) {
    var touches = getNativeEvent(event).touches,
      target,
      flags;
    if (touches && touches.length === 1) {
      target = event.target;
      flags = getVirtualBindingFlags(target);
      if (flags.hasVirtualBinding) {
        lastTouchID = nextTouchID++;
        $.data(target, touchTargetPropertyName, lastTouchID);
        clearResetTimer();
        disableMouseBindings();
        didScroll = false;
        var t = getNativeEvent(event).touches[0];
        startX = t.pageX;
        startY = t.pageY;
        triggerVirtualEvent("vmouseover", event, flags);
        triggerVirtualEvent("vmousedown", event, flags);
      }
    }
  }
  function handleScroll(event) {
    if (blockTouchTriggers) {
      return;
    }
    if (!didScroll) {
      triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
    }
    didScroll = true;
    startResetTimer();
  }
  function handleTouchMove(event) {
    if (blockTouchTriggers) {
      return;
    }
    var t = getNativeEvent(event).touches[0],
      didCancel = didScroll,
      moveThreshold = $.vmouse.moveDistanceThreshold,
      didScroll = didScroll || Math.abs(t.pageX - startX) > moveThreshold || Math.abs(t.pageY - startY) > moveThreshold,
      flags = getVirtualBindingFlags(event.target);
    if (didScroll && !didCancel) {
      triggerVirtualEvent("vmousecancel", event, flags);
    }
    triggerVirtualEvent("vmousemove", event, flags);
    startResetTimer();
  }
  function handleTouchEnd(event) {
    if (blockTouchTriggers) {
      return;
    }
    disableTouchBindings();
    var flags = getVirtualBindingFlags(event.target),
      t;
    triggerVirtualEvent("vmouseup", event, flags);
    if (!didScroll) {
      var ve = triggerVirtualEvent("vclick", event, flags);
      if (ve && ve.isDefaultPrevented()) {
        // The target of the mouse events that follow the touchend
        // event don't necessarily match the target used during the
        // touch. This means we need to rely on coordinates for blocking
        // any click that is generated.
        t = getNativeEvent(event).changedTouches[0];
        clickBlockList.push({
          touchID: lastTouchID,
          x: t.clientX,
          y: t.clientY
        });

        // Prevent any mouse events that follow from triggering
        // virtual event notifications.
        blockMouseTriggers = true;
      }
    }
    triggerVirtualEvent("vmouseout", event, flags);
    didScroll = false;
    startResetTimer();
  }
  function hasVirtualBindings(ele) {
    var bindings = $.data(ele, dataPropertyName),
      k;
    if (bindings) {
      for (k in bindings) {
        if (bindings[k]) {
          return true;
        }
      }
    }
    return false;
  }
  function dummyMouseHandler() {}
  function getSpecialEventObject(eventType) {
    var realType = eventType.substr(1);
    return {
      setup: function (data, namespace) {
        // If this is the first virtual mouse binding for this element,
        // add a bindings object to its data.

        if (!hasVirtualBindings(this)) {
          $.data(this, dataPropertyName, {});
        }

        // If setup is called, we know it is the first binding for this
        // eventType, so initialize the count for the eventType to zero.
        var bindings = $.data(this, dataPropertyName);
        bindings[eventType] = true;

        // If this is the first virtual mouse event for this type,
        // register a global handler on the document.

        activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;
        if (activeDocHandlers[eventType] === 1) {
          $document.bind(realType, mouseEventCallback);
        }

        // Some browsers, like Opera Mini, won't dispatch mouse/click events
        // for elements unless they actually have handlers registered on them.
        // To get around this, we register dummy handlers on the elements.

        $(this).bind(realType, dummyMouseHandler);

        // For now, if event capture is not supported, we rely on mouse handlers.
        if (eventCaptureSupported) {
          // If this is the first virtual mouse binding for the document,
          // register our touchstart handler on the document.

          activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;
          if (activeDocHandlers["touchstart"] === 1) {
            $document.bind("touchstart", handleTouchStart).bind("touchend", handleTouchEnd)

            // On touch platforms, touching the screen and then dragging your finger
            // causes the window content to scroll after some distance threshold is
            // exceeded. On these platforms, a scroll prevents a click event from being
            // dispatched, and on some platforms, even the touchend is suppressed. To
            // mimic the suppression of the click event, we need to watch for a scroll
            // event. Unfortunately, some platforms like iOS don't dispatch scroll
            // events until *AFTER* the user lifts their finger (touchend). This means
            // we need to watch both scroll and touchmove events to figure out whether
            // or not a scroll happenens before the touchend event is fired.
            .bind("touchmove", handleTouchMove).bind("scroll", handleScroll);
          }
        }
      },
      teardown: function (data, namespace) {
        // If this is the last virtual binding for this eventType,
        // remove its global handler from the document.

        --activeDocHandlers[eventType];
        if (!activeDocHandlers[eventType]) {
          $document.unbind(realType, mouseEventCallback);
        }
        if (eventCaptureSupported) {
          // If this is the last virtual mouse binding in existence,
          // remove our document touchstart listener.

          --activeDocHandlers["touchstart"];
          if (!activeDocHandlers["touchstart"]) {
            $document.unbind("touchstart", handleTouchStart).unbind("touchmove", handleTouchMove).unbind("touchend", handleTouchEnd).unbind("scroll", handleScroll);
          }
        }
        var $this = $(this),
          bindings = $.data(this, dataPropertyName);

        // teardown may be called when an element was
        // removed from the DOM. If this is the case,
        // jQuery core may have already stripped the element
        // of any data bindings so we need to check it before
        // using it.
        if (bindings) {
          bindings[eventType] = false;
        }

        // Unregister the dummy event handler.

        $this.unbind(realType, dummyMouseHandler);

        // If this is the last virtual mouse binding on the
        // element, remove the binding data from the element.

        if (!hasVirtualBindings(this)) {
          $this.removeData(dataPropertyName);
        }
      }
    };
  }

  // Expose our custom events to the jQuery bind/unbind mechanism.

  for (var i = 0; i < virtualEventNames.length; i++) {
    $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
  }

  // Add a capture click handler to block clicks.
  // Note that we require event capture support for this so if the device
  // doesn't support it, we punt for now and rely solely on mouse events.
  if (eventCaptureSupported) {
    document.addEventListener("click", function (e) {
      var cnt = clickBlockList.length,
        target = e.target,
        x,
        y,
        ele,
        i,
        o;
      if (cnt) {
        x = e.clientX;
        y = e.clientY;
        threshold = $.vmouse.clickDistanceThreshold;

        // The idea here is to run through the clickBlockList to see if
        // the current click event is in the proximity of one of our
        // vclick events that had preventDefault() called on it. If we find
        // one, then we block the click.
        //
        // Why do we have to rely on proximity?
        //
        // Because the target of the touch event that triggered the vclick
        // can be different from the target of the click event synthesized
        // by the browser. The target of a mouse/click event that is syntehsized
        // from a touch event seems to be implementation specific. For example,
        // some browsers will fire mouse/click events for a link that is near
        // a touch event, even though the target of the touchstart/touchend event
        // says the user touched outside the link. Also, it seems that with most
        // browsers, the target of the mouse/click event is not calculated until the
        // time it is dispatched, so if you replace an element that you touched
        // with another element, the target of the mouse/click will be the new
        // element underneath that point.
        //
        // Aside from proximity, we also check to see if the target and any
        // of its ancestors were the ones that blocked a click. This is necessary
        // because of the strange mouse/click target calculation done in the
        // Android 2.1 browser, where if you click on an element, and there is a
        // mouse/click handler on one of its ancestors, the target will be the
        // innermost child of the touched element, even if that child is no where
        // near the point of touch.

        ele = target;
        while (ele) {
          for (i = 0; i < cnt; i++) {
            o = clickBlockList[i];
            if (ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold || $.data(ele, touchTargetPropertyName) === o.touchID) {
              // XXX: We may want to consider removing matches from the block list
              //      instead of waiting for the reset timer to fire.
              e.preventDefault();
              e.stopPropagation();
              return;
            }
          }
          ele = ele.parentNode;
        }
      }
    }, true);
  }
})($__default["default"], window, document);

/**
 * A work-in-progress of _ methods for objects.
 * That is, they take an object as a parameter,
 * and return an object instead of an array.
 *
 * TODO(aria): Move this out of interactive2
 */

/**
 * Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */
const pluck = function (table, subKey) {
  return ___default["default"].object(___default["default"].map(table, function (value, key) {
    return [key, value[subKey]];
  }));
};

/**
 * Maps an object to an object
 *
 * > mapObject({a: '1', b: '2'}, (value, key) => {
 *       return value + 1;
 *   });
 * {a: 2, b: 3}
 */
const mapObject$3 = function (obj, lambda) {
  const result = {};
  ___default["default"].each(___default["default"].keys(obj), function (key) {
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'K'.
    result[key] = lambda(obj[key], key);
  });
  return result;
};

/**
 * Maps an array to an object
 *
 * > mapObjectFromArray(['a', 'b'], function(elem) {
 *       return elem + elem;
 *   });
 * {a: 'aa', b: 'bb'}
 */
const mapObjectFromArray$1 = function (arr, lambda) {
  const result = {};
  ___default["default"].each(arr, function (elem) {
    result[elem] = lambda(elem);
  });
  return result;
};
var objective_ = {
  pluck: pluck,
  mapObject: mapObject$3,
  mapObjectFromArray: mapObjectFromArray$1
};

/* eslint-disable @babel/no-invalid-this */

/*
 * These functions, when called on the wrapped object, simply pass the
 * arguments to the underlying Raphael object.
 */
const PASS_TO_RAPHAEL = ["attr", "animate"];
const WrappedDefaults = ___default["default"].extend({
  transform: function (transformation) {
    const prefixedTransform = InteractiveUtil.getPrefixedTransform();
    // @ts-expect-error [FEI-5003] - TS2538 - Type 'null' cannot be used as an index type. | TS2538 - Type 'undefined' cannot be used as an index type.
    this.wrapper.style[prefixedTransform] = transformation;
  },
  toFront: function () {
    const parentNode = this.wrapper.parentNode;
    // TODO(emily): Sometimes, we call `.remove()` but then hold a
    // reference to this object, and sometimes call `.toFront` on it.
    // Notably, this happens in the reflection transformation in the
    // Transformer widget. This is a hacky fix. Make this less bad.
    if (parentNode) {
      parentNode.appendChild(this.wrapper);
    }
  },
  toBack: function () {
    const parentNode = this.wrapper.parentNode;
    if (parentNode.firstChild !== this.wrapper) {
      parentNode.insertBefore(this.wrapper, parentNode.firstChild);
    }
  },
  remove: function () {
    this.visibleShape.remove();
    $__default["default"](this.wrapper).remove();
  },
  getMouseTarget: function () {
    return this.visibleShape[0];
  },
  moveTo: function (point) {
    const delta = kmath.vector.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
    const do3dTransform = InteractiveUtil.getCanUse3dTransform();
    const transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px)" + (do3dTransform ? " translateZ(0)" : "");
    this.transform(transformation);
  },
  hide: function () {
    this.visibleShape.hide();
  },
  show: function () {
    this.visibleShape.show();
  }
}, objective_.mapObjectFromArray(PASS_TO_RAPHAEL, function (attribute) {
  return function () {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.visibleShape[attribute](...arguments);
  };
}));

const DEFAULT_OPTIONS$2 = {
  maxScale: 1,
  mouselayer: false,
  shadow: false,
  disableMouseEventsOnWrapper: false
};
const WrappedEllipse = function (graphie, center, radii, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS$2, options);

  // Add `wrapper`, `visibleShape`, and remaining properties.
  const fixedEllipse = graphie.fixedEllipse(center, radii, options.maxScale, options.padding);
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, fixedEllipse, {
    graphie: graphie,
    initialPoint: center
  });
  if (options.interactiveKindForTesting) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.setAttribute("data-interactive-kind-for-testing", options.interactiveKindForTesting);
  }

  // Add to appropriate graphie layer
  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.style.touchAction = "none";

    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }
  if (options.shadow) {
    const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    const wrapper = this.wrapper;
    wrapper.style.filter = filter;

    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.moveTo = function (point) {
      const delta = kmath.vector.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
      const do3dTransform = InteractiveUtil.getCanUse3dTransform();
      const transform = "translateX(" + Math.round(delta[0]) + "px) " + "translateY(" + Math.round(delta[1]) + "px)" + (do3dTransform ? " translateZ(0)" : "");
      this.transform(transform);
    };
  }
  if (options.disableMouseEventsOnWrapper) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.style.pointerEvents = "none";
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.visibleShape.node.style.pointerEvents = "auto";
  }
};
___default["default"].extend(WrappedEllipse.prototype, WrappedDefaults);

const DEFAULT_OPTIONS$1 = {
  thickness: 2,
  mouselayer: false
};
const WrappedLine = function (graphie, start, end, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS$1, options);

  // Always make the line as large as possible and horizontal; this
  // simplifies a lot of the transforms, e.g., we can rotate by exactly the
  // angle of the argument points in `moveTo`.
  const initialStart = [graphie.range[0][0], 0];
  const initialEnd = [graphie.range[0][1], 0];

  // Add `wrapper` and `visibleShape`
  ___default["default"].extend(
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this, graphie.fixedLine(initialStart, initialEnd, options.thickness));
  if (options.interactiveKindForTesting) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.setAttribute("data-interactive-kind-for-testing", options.interactiveKindForTesting);
  }

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.visibleShape.attr(options.normalStyle);

  // Save properties for computing transformations
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(initialStart),
    initialLength: kmath.point.distanceToPoint(graphie.scalePoint(initialStart), graphie.scalePoint(initialEnd))
  });

  // Add to appropriate graphie layer
  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.style.touchAction = "none";

    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }

  // Move to argument points
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.moveTo(start, end);
};
___default["default"].extend(WrappedLine.prototype, WrappedDefaults, {
  getMouseTarget: function () {
    return this.wrapper;
  },
  moveTo: function (start, end) {
    const scaledStart = this.graphie.scalePoint(start);
    const scaledEnd = this.graphie.scalePoint(end);

    // Compute transformation parameters
    const polarDiff = kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledEnd, scaledStart));
    const lineLength = polarDiff[0];
    const angle = KhanMath.bound(polarDiff[1]);
    const delta = kmath.vector.subtract(scaledStart, this.initialPoint);
    const scale = KhanMath.bound(lineLength / this.initialLength);

    // Construct and apply transformation string
    const do3dTransform = InteractiveUtil.getCanUse3dTransform();
    const transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px) " + (do3dTransform ? " translateZ(0)" : "") + "rotate(" + angle + "deg) " + "scaleX(" + scale + ") scaleY(1)";
    this.transform(transformation);
  }
});

const DEFAULT_OPTIONS = {
  center: null,
  // gets ignored in `graphie.fixedPath` if `null`
  createPath: null,
  // gets defaulted in `graphie.fixedPath` if `null`
  mouselayer: false
};
const WrappedPath = function (graphie, points, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS, options);

  // Add `wrapper` and `visibleShape`
  ___default["default"].extend(
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this, graphie.fixedPath(points, options.center, options.createPath));

  // Add remaining properties
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(___default["default"].head(points))
  });

  // Add to appropriate graphie layer
  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.wrapper.style.touchAction = "none";

    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }
};
___default["default"].extend(WrappedPath.prototype, WrappedDefaults);

/* eslint-disable @babel/no-invalid-this */
const {
  getCanUse3dTransform
} = InteractiveUtil;
function sum$1(array) {
  return ___default["default"].reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}
function clockwise$1(points) {
  const segments = ___default["default"].zip(points, points.slice(1).concat(points.slice(0, 1)));
  const areas = ___default["default"].map(segments, function (segment) {
    const p1 = segment[0];
    const p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });
  return sum$1(areas) > 0;
}

/* vector-add multiple [x, y] coords/vectors */
function addPoints() {
  const zipped = ___default["default"].zip(...arguments);
  return ___default["default"].map(zipped, sum$1);
}
function reverseVector(vector) {
  return ___default["default"].map(vector, function (coord) {
    return coord * -1;
  });
}
function scaledDistanceFromAngle(angle) {
  const a = 3.51470560176242 * 20;
  const b = 0.5687298702748785 * 20;
  const c = -0.037587715462826674;
  return (a - b) * Math.exp(c * angle) + b;
}
function scaledPolarRad(radius, radians) {
  return [radius * Math.cos(radians), radius * Math.sin(radians) * -1 // SVG flips y axis
  ];
}

function scaledPolarDeg(radius, degrees) {
  const radians = degrees * Math.PI / 180;
  return scaledPolarRad(radius, radians);
}

// Global dragging state
let dragging = false;
const InteractiveUtils = {
  // Useful for shapes that are only sometimes drawn. If a shape isn't
  // needed, it can be replaced with bogusShape which just has stub methods
  // that successfully do nothing.
  // The alternative would be 'if..typeof' checks all over the place.
  bogusShape: {
    animate: function () {},
    attr: function () {},
    remove: function () {}
  }
};
___default["default"].extend(GraphUtils.Graphie.prototype, {
  // graphie puts text spans on top of the SVG, which looks good, but gets
  // in the way of mouse events. This adds another SVG element on top
  // of everything else where we can add invisible shapes with mouse
  // handlers wherever we want.
  addMouseLayer: function (options) {
    const graph = this;
    options = ___default["default"].extend({
      allowScratchpad: false,
      setDrawingAreaAvailable: function () {}
    }, options);
    const mouselayerZIndex = 2;
    graph.mouselayer = raphael.exports(graph.raphael.canvas.parentNode, graph.xpixels, graph.ypixels);
    $__default["default"](graph.mouselayer.canvas).css("z-index", mouselayerZIndex);
    if (options.onClick || options.onMouseDown || options.onMouseMove || options.onMouseOver || options.onMouseOut) {
      const canvasClickTarget = graph.mouselayer.rect(0, 0, graph.xpixels, graph.ypixels).attr({
        fill: "#000",
        opacity: 0
      });
      let isClickingCanvas = false;
      $__default["default"](graph.mouselayer.canvas).on("vmousedown", function (e) {
        if (e.target === canvasClickTarget[0]) {
          if (options.onMouseDown) {
            options.onMouseDown(graph.getMouseCoord(e));
          }
          isClickingCanvas = true;
          if (options.onMouseMove) {
            const handler = options.onMouseMove;
            $__default["default"](document).bind("vmousemove.mouseLayer", function (e) {
              if (isClickingCanvas) {
                e.preventDefault();
                handler(graph.getMouseCoord(e));
              }
            });
          }
          $__default["default"](document).bind("vmouseup.mouseLayer", function (e) {
            $__default["default"](document).unbind(".mouseLayer");

            // Only register clicks that started on the canvas,
            // and not on another mouseLayer target
            if (isClickingCanvas && options.onClick) {
              options.onClick(graph.getMouseCoord(e));
            }
            isClickingCanvas = false;
          });
        }
      });
      if (options.onMouseOver) {
        const handler = options.onMouseOver;
        $__default["default"](graph.mouselayer.canvas).on("vmouseover", function (e) {
          handler(graph.getMouseCoord(e));
        });
      }
      if (options.onMouseOut) {
        const handler = options.onMouseOut;
        $__default["default"](graph.mouselayer.canvas).on("vmouseout", function (e) {
          handler(graph.getMouseCoord(e));
        });
      }
    }
    if (!options.allowScratchpad) {
      var _options$setDrawingAr, _options;
      (_options$setDrawingAr = (_options = options).setDrawingAreaAvailable) === null || _options$setDrawingAr === void 0 ? void 0 : _options$setDrawingAr.call(_options, false);
    }

    // Add mouse and visible wrapper layers for DOM-node-wrapped movables
    graph._mouselayerWrapper = document.createElement("div");
    $__default["default"](graph._mouselayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0,
      zIndex: mouselayerZIndex
    });
    graph._visiblelayerWrapper = document.createElement("div");
    $__default["default"](graph._visiblelayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0
    });
    const el = graph.raphael.canvas.parentNode;
    el.appendChild(graph._visiblelayerWrapper);
    el.appendChild(graph._mouselayerWrapper);

    // Add functions for adding to wrappers
    graph.addToMouseLayerWrapper = function (el) {
      this._mouselayerWrapper.appendChild(el);
    };
    graph.addToVisibleLayerWrapper = function (el) {
      this._visiblelayerWrapper.appendChild(el);
    };
  },
  /**
   * Get mouse coordinates in pixels
   */
  getMousePx: function (event) {
    const graphie = this;
    const mouseX =
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
    event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    const mouseY =
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
    event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    return [mouseX, mouseY];
  },
  /**
   * Get mouse coordinates in graph coordinates
   */
  getMouseCoord: function (event) {
    return this.unscalePoint(this.getMousePx(event));
  },
  /**
   * Unlike all other Graphie-related code, the following three functions use
   * a lot of scaled coordinates (so that labels appear the same size
   * regardless of current shape/figure scale). These are prefixed with 's'.
   */
  labelAngle: function (options) {
    const graphie = this;
    ___default["default"].defaults(options, {
      point1: [0, 0],
      vertex: [0, 0],
      point3: [0, 0],
      label: null,
      numArcs: 1,
      showRightAngleMarker: true,
      pushOut: 0,
      clockwise: false,
      style: {}
    });
    let text = options.text === undefined ? "" : options.text;
    const vertex = options.vertex;
    const sVertex = graphie.scalePoint(vertex);
    let p1;
    let p3;
    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }
    const startAngle = GraphUtils.findAngle(p1, vertex);
    const endAngle = GraphUtils.findAngle(p3, vertex);
    const angle = (endAngle + 360 - startAngle) % 360;
    const halfAngle = (startAngle + angle / 2) % 360;
    const sPadding = 5 * options.pushOut;
    let sRadius = sPadding + scaledDistanceFromAngle(angle);
    const temp = [];
    if (Math.abs(angle - 90) < 1e-9 && options.showRightAngleMarker) {
      const v1 = addPoints(sVertex, scaledPolarDeg(sRadius, startAngle));
      const v2 = addPoints(sVertex, scaledPolarDeg(sRadius, endAngle));
      sRadius *= Math.SQRT2;
      const v3 = addPoints(sVertex, scaledPolarDeg(sRadius, halfAngle));
      ___default["default"].each([v1, v2], function (v) {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
        temp.push(graphie.scaledPath([v, v3], options.style));
      });
    } else {
      // Draw arcs
      ___default["default"].times(options.numArcs, function (i) {
        temp.push(
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
        graphie.arc(vertex, graphie.unscaleVector(sRadius), startAngle, endAngle, options.style));
        sRadius += 3;
      });
    }
    if (text) {
      const match = text.match(/\$deg(\d)?/);
      if (match) {
        const precision = match[1] || 1;
        text = text.replace(match[0], KhanMath.toFixedApprox(angle, precision) + "^{\\circ}");
      }
      const sOffset = scaledPolarDeg(sRadius + 15, halfAngle);
      const sPosition = addPoints(sVertex, sOffset);
      const position = graphie.unscalePoint(sPosition);

      // Reuse label if possible
      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text, /* force */true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }
    return temp;
  },
  labelSide: function (options) {
    const graphie = this;
    ___default["default"].defaults(options, {
      point1: [0, 0],
      point2: [0, 0],
      label: null,
      text: "",
      numTicks: 0,
      numArrows: 0,
      clockwise: false,
      style: {}
    });
    let p1;
    let p2;
    if (options.clockwise) {
      p1 = options.point1;
      p2 = options.point2;
    } else {
      p1 = options.point2;
      p2 = options.point1;
    }
    const midpoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
    const sMidpoint = graphie.scalePoint(midpoint);
    const parallelAngle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
    const perpendicularAngle = parallelAngle + Math.PI / 2;
    const temp = [];
    let sCumulativeOffset = 0;
    if (options.numTicks) {
      const n = options.numTicks;
      const sSpacing = 5;
      const sHeight = 5;
      const style = ___default["default"].extend({}, options.style, {
        strokeWidth: 2
      });
      ___default["default"].times(n, function (i) {
        const sOffset = sSpacing * (i - (n - 1) / 2);
        const sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
        const sHeightVector = scaledPolarRad(sHeight, perpendicularAngle);
        const sPath = [addPoints(sMidpoint, sOffsetVector, sHeightVector), addPoints(sMidpoint, sOffsetVector, reverseVector(sHeightVector))];

        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
        temp.push(graphie.scaledPath(sPath, style));
      });
      sCumulativeOffset += sSpacing * (n - 1) + 15;
    }
    if (options.numArrows) {
      const n = options.numArrows;
      const start = [p1, p2].sort(function (a, b) {
        if (a[1] === b[1]) {
          return a[0] - b[0];
        }
        return a[1] - b[1];
      })[0];
      const sStart = graphie.scalePoint(start);
      const style = ___default["default"].extend({}, options.style, {
        arrows: "->",
        strokeWidth: 2
      });
      const sSpacing = 5;
      ___default["default"].times(n, function (i) {
        const sOffset = sCumulativeOffset + sSpacing * i;
        let sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
        if (start !== p1) {
          sOffsetVector = reverseVector(sOffsetVector);
        }
        const sEnd = addPoints(sMidpoint, sOffsetVector);

        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any' is not assignable to parameter of type 'never'.
        temp.push(graphie.scaledPath([sStart, sEnd], style));
      });
    }
    let text = options.text;
    if (text) {
      const match = text.match(/\$len(\d)?/);
      if (match) {
        const distance = GraphUtils.getDistance(p1, p2);
        const precision = match[1] || 1;
        text = text.replace(match[0], KhanMath.toFixedApprox(distance, precision));
      }
      const sOffset = 20;
      const sOffsetVector = scaledPolarRad(sOffset, perpendicularAngle);
      const sPosition = addPoints(sMidpoint, sOffsetVector);
      const position = graphie.unscalePoint(sPosition);

      // Reuse label if possible
      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text, /* force */true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }
    return temp;
  },
  /* Can also be used to label points that aren't vertices */
  labelVertex: function (options) {
    const graphie = this;
    ___default["default"].defaults(options, {
      point1: null,
      vertex: [0, 0],
      point3: null,
      label: null,
      text: "",
      clockwise: false,
      style: {}
    });
    if (!options.text) {
      return;
    }
    const vertex = options.vertex;
    const sVertex = graphie.scalePoint(vertex);
    let p1;
    let p3;
    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }
    let angle = 135;
    let halfAngle;
    if (p1 && p3) {
      const startAngle = GraphUtils.findAngle(p1, vertex);
      const endAngle = GraphUtils.findAngle(p3, vertex);
      angle = (endAngle + 360 - startAngle) % 360;
      halfAngle = (startAngle + angle / 2 + 180) % 360;
    } else if (p1) {
      const parallelAngle = GraphUtils.findAngle(vertex, p1);
      halfAngle = parallelAngle + 90;
    } else if (p3) {
      const parallelAngle = GraphUtils.findAngle(p3, vertex);
      halfAngle = parallelAngle + 90;
    } else {
      // Standalone point
      halfAngle = 135;
    }
    const sRadius = 10 + scaledDistanceFromAngle(360 - angle);
    const sOffsetVector = scaledPolarDeg(sRadius, halfAngle);
    const sPosition = addPoints(sVertex, sOffsetVector);
    const position = graphie.unscalePoint(sPosition);

    // Reuse label if possible
    if (options.label) {
      options.label.setPosition(position);
      options.label.processMath(options.text, /* force */true);
    } else {
      graphie.label(position, options.text, "center", options.style);
    }
  },
  // Add a point to the graph that can be dragged around.
  // It allows automatic constraints on its movement as well as automatically
  // managing line segments that terminate at the point.
  //
  // Options can be set to control how the point behaves:
  //   coord[]:
  //     The initial position of the point
  //   snapX, snapY:
  //     The minimum increment the point can be moved
  //
  // The return value is an object that can be used to manipulate the point:
  //   The coordX and coordY properties tell you the current position
  //
  //   By adding an onMove() method to the returned object, you can install an
  //   event handler that gets called every time the user moves the point.
  //
  //   The returned object also provides a moveTo(x,y) method that will move
  //   the point to a specific coordinate
  //
  // Constraints can be set on the on the returned object:
  //
  //  - Set point to be immovable:
  //        movablePoint.constraints.fixed = true
  //
  //  - Constrain point to a fixed distance from another point. The resulting
  //    point will move in a circle:
  //        movablePoint.fixedDistance = {
  //           dist: 2,
  //           point: point1
  //        }
  //
  //  - Constrain point to a line defined by a fixed angle between it and
  //    two other points:
  //        movablePoint.fixedAngle = {
  //           angle: 45,
  //           vertex: point1,
  //           ref: point2
  //        }
  //
  //  - Confined the point to traveling in a vertical or horizontal line,
  //    respectively
  //        movablePoint.constrainX = true;
  //        movablePoint.constrainY = true;
  //
  //  - Connect a movableLineSegment to a movablePoint. The point is attached
  //    to a specific end of the line segment by adding the segment either to
  //    the list of lines that start at the point or the list of lines that
  //    end at the point (movableLineSegment can do this for you):
  //        movablePoint.lineStarts.push(movableLineSegment);
  //          - or -
  //        movablePoint.lineEnds.push(movableLineSegment);
  //
  //  - Connect a movablePolygon to a movablePoint in exacty the same way:
  //        movablePoint.polygonVertices.push(movablePolygon);
  //
  addMovablePoint: function (options) {
    const movablePoint = $__default["default"].extend(true, {
      graph: this,
      coord: [0, 0],
      snapX: 0,
      snapY: 0,
      pointSize: 4,
      highlight: false,
      dragging: false,
      visible: true,
      bounded: true,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false,
        fixedAngle: {},
        fixedDistance: {}
      },
      lineStarts: [],
      lineEnds: [],
      polygonVertices: [],
      normalStyle: {},
      highlightStyle: {
        fill: KhanColors.INTERACTING,
        stroke: KhanColors.INTERACTING
      },
      labelStyle: {
        color: KhanColors.INTERACTIVE
      },
      vertexLabel: "",
      mouseTarget: null
    }, options);
    const normalColor = movablePoint.constraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    movablePoint.normalStyle = ___default["default"].extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle);

    // deprecated: don't use coordX/coordY; use coord[]
    if (options.coordX !== undefined) {
      movablePoint.coord[0] = options.coordX;
    }
    if (options.coordY !== undefined) {
      movablePoint.coord[1] = options.coordY;
    }
    const graph = movablePoint.graph;
    const applySnapAndConstraints = function (coord) {
      // coord should be the scaled coordinate

      // move point away from edge of graph unless it's invisible or fixed
      if (movablePoint.visible && movablePoint.bounded && !movablePoint.constraints.fixed) {
        // can't go beyond 10 pixels from the edge
        coord = graph.constrainToBounds(coord, 10);
      }
      let coordX = coord[0];
      let coordY = coord[1];

      // snap coordinates to grid
      if (movablePoint.snapX !== 0) {
        coordX = Math.round(coordX / movablePoint.snapX) * movablePoint.snapX;
      }
      if (movablePoint.snapY !== 0) {
        coordY = Math.round(coordY / movablePoint.snapY) * movablePoint.snapY;
      }

      // snap to points around circle
      if (movablePoint.constraints.fixedDistance.snapPoints) {
        const mouse = graph.scalePoint(coord);
        let mouseX = mouse[0];
        let mouseY = mouse[1];
        const snapRadians = 2 * Math.PI / movablePoint.constraints.fixedDistance.snapPoints;
        const radius = movablePoint.constraints.fixedDistance.dist;
        const centerCoord = movablePoint.constraints.fixedDistance.point;
        const centerX = (centerCoord[0] - graph.range[0][0]) * graph.scale[0];
        const centerY = (-centerCoord[1] + graph.range[1][1]) * graph.scale[1];
        let mouseXrel = mouseX - centerX;
        let mouseYrel = -mouseY + centerY;
        let radians = Math.atan(mouseYrel / mouseXrel);
        const outsideArcTanRange = mouseXrel < 0;

        // adjust so that angles increase from 0 to 2 pi as you go
        // around the circle
        if (outsideArcTanRange) {
          radians += Math.PI;
        }

        // perform the snap
        radians = Math.round(radians / snapRadians) * snapRadians;

        // convert from radians back to pixels
        mouseXrel = radius * Math.cos(radians);
        mouseYrel = radius * Math.sin(radians);
        // convert back to coordinates relative to graphie canvas
        mouseX = mouseXrel + centerX;
        mouseY = -mouseYrel + centerY;
        coordX = KhanMath.roundTo(5, mouseX / graph.scale[0] + graph.range[0][0]);
        coordY = KhanMath.roundTo(5, graph.range[1][1] - mouseY / graph.scale[1]);
      }
      const result = movablePoint.applyConstraint([coordX, coordY]);
      return result;
    };

    // Using the passed coordinates, apply any constraints and return
    // the closest coordinates that match the constraints.
    movablePoint.applyConstraint = function (coord, extraConstraints, override) {
      let newCoord = coord.slice();
      const constraints = {};
      if (override) {
        $__default["default"].extend(constraints, {
          fixed: false,
          constrainX: false,
          constrainY: false,
          fixedAngle: {},
          fixedDistance: {}
        }, extraConstraints);
      } else {
        $__default["default"].extend(constraints, this.constraints, extraConstraints);
      }

      // constrain to vertical movement
      if (constraints.constrainX) {
        newCoord = [this.coord[0], coord[1]];

        // constrain to horizontal movement
      } else if (constraints.constrainY) {
        newCoord = [coord[0], this.coord[1]];

        // both distance and angle are constrained
      } else if (typeof constraints.fixedAngle.angle === "number" && typeof constraints.fixedDistance.dist === "number") {
        const vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
        const ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
        const distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;
        const constrainedAngle = (constraints.fixedAngle.angle + GraphUtils.findAngle(ref, vertex)) * Math.PI / 180;
        const length = constraints.fixedDistance.dist;
        newCoord[0] = length * Math.cos(constrainedAngle) + distPoint[0];
        newCoord[1] = length * Math.sin(constrainedAngle) + distPoint[1];

        // angle is constrained
      } else if (typeof constraints.fixedAngle.angle === "number") {
        const vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
        const ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
        const constrainedAngle = (constraints.fixedAngle.angle + GraphUtils.findAngle(ref, vertex)) * Math.PI / 180;
        const angle = GraphUtils.findAngle(coord, vertex) * Math.PI / 180;
        const distance = GraphUtils.getDistance(coord, vertex);
        let length = distance * Math.cos(constrainedAngle - angle);
        length = length < 1.0 ? 1.0 : length;
        newCoord[0] = length * Math.cos(constrainedAngle) + vertex[0];
        newCoord[1] = length * Math.sin(constrainedAngle) + vertex[1];

        // distance is constrained
      } else if (typeof constraints.fixedDistance.dist === "number") {
        const distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;
        let angle = GraphUtils.findAngle(coord, distPoint);
        const length = constraints.fixedDistance.dist;
        angle = angle * Math.PI / 180;
        newCoord[0] = length * Math.cos(angle) + distPoint[0];
        newCoord[1] = length * Math.sin(angle) + distPoint[1];

        // point is fixed
      } else if (constraints.fixed) {
        newCoord = movablePoint.coord;
      }
      return newCoord;
    };
    movablePoint.coord = applySnapAndConstraints(movablePoint.coord);
    const highlightScale = 2;
    if (movablePoint.visible) {
      graph.style(movablePoint.normalStyle, function () {
        const radii = [movablePoint.pointSize / graph.scale[0], movablePoint.pointSize / graph.scale[1]];
        const options = {
          maxScale: highlightScale,
          // Add in 2px of padding to avoid clipping at the edges.
          padding: 2
        };
        movablePoint.visibleShape = new WrappedEllipse(graph, movablePoint.coord,
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type '[number, number]'.
        radii, options);
        movablePoint.visibleShape.attr(___default["default"].omit(movablePoint.normalStyle, "scale"));
        movablePoint.visibleShape.toFront();
      });
    }
    movablePoint.normalStyle.scale = 1;
    movablePoint.highlightStyle.scale = highlightScale;
    if (movablePoint.vertexLabel) {
      movablePoint.labeledVertex = this.label([0, 0], "", "center", movablePoint.labelStyle);
    }
    movablePoint.drawLabel = function () {
      if (movablePoint.vertexLabel) {
        movablePoint.graph.labelVertex({
          vertex: movablePoint.coord,
          label: movablePoint.labeledVertex,
          text: movablePoint.vertexLabel,
          style: movablePoint.labelStyle
        });
      }
    };
    movablePoint.drawLabel();
    movablePoint.grab = function (offset) {
      // The offset for the gesture. When provided, the movable point will
      // track the mouse's position, plus this offset. This is typically
      // used to lock the distance between a user's finger and the movable
      // point, when dragging.
      offset = offset || [0, 0];
      $__default["default"](document).bind("vmousemove.point vmouseup.point", function (event) {
        event.preventDefault();
        movablePoint.dragging = true;
        dragging = true;

        // Adjust the target coordinate by accounting for the gesture's
        // offset.
        let coord = kmath.vector.add(graph.getMouseCoord(event), offset);
        coord = applySnapAndConstraints(coord);
        let coordX = coord[0];
        let coordY = coord[1];
        let mouseX;
        let mouseY;
        if (event.type === "vmousemove") {
          let doMove = true;
          // The caller has the option of adding an onMove() method
          // to the movablePoint object we return as a sort of event
          // handler. By returning false from onMove(), the move
          // can be vetoed, providing custom constraints on where
          // the point can be moved. By returning array [x, y], the
          // move can be overridden
          if (___default["default"].isFunction(movablePoint.onMove)) {
            const result = movablePoint.onMove(coordX, coordY);
            if (result === false) {
              doMove = false;
            }
            if (___default["default"].isArray(result)) {
              coordX = result[0];
              coordY = result[1];
            }
          }
          // coord{X|Y} may have been modified by constraints or
          // onMove handler; adjust mouse{X|Y} to match
          mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
          mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];
          if (doMove) {
            const point = graph.unscalePoint([mouseX, mouseY]);
            movablePoint.visibleShape.moveTo(point);
            movablePoint.mouseTarget.moveTo(point);
            movablePoint.coord = [coordX, coordY];
            movablePoint.updateLineEnds();
            $__default["default"](movablePoint).trigger("move");
          }
          movablePoint.drawLabel();
        } else if (event.type === "vmouseup") {
          $__default["default"](document).unbind(".point");
          movablePoint.dragging = false;
          dragging = false;
          if (___default["default"].isFunction(movablePoint.onMoveEnd)) {
            const result = movablePoint.onMoveEnd(coordX, coordY);
            if (___default["default"].isArray(result)) {
              coordX = result[0];
              coordY = result[1];
              mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
              mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];
              const point = graph.unscalePoint([mouseX, mouseY]);
              movablePoint.visibleShape.moveTo(point);
              movablePoint.mouseTarget.moveTo(point);
              movablePoint.coord = [coordX, coordY];
            }
          }
          if (!movablePoint.highlight) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        }
      });
    };
    if (movablePoint.visible && !movablePoint.constraints.fixed) {
      // the invisible shape in front of the point that gets mouse events
      if (!movablePoint.mouseTarget) {
        const radii = graph.unscaleVector(16);
        const options = {
          mouselayer: true,
          padding: 0,
          disableMouseEventsOnWrapper: true,
          interactiveKindForTesting: "movable-point"
        };
        movablePoint.mouseTarget = new WrappedEllipse(graph, movablePoint.coord, radii, options);
        movablePoint.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
      const $mouseTarget = $__default["default"](movablePoint.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          movablePoint.highlight = true;
          if (!dragging) {
            movablePoint.visibleShape.animate(movablePoint.highlightStyle, 50);
            if (movablePoint.onHighlight) {
              movablePoint.onHighlight();
            }
          }
        } else if (event.type === "vmouseout") {
          movablePoint.highlight = false;
          if (!movablePoint.dragging && !dragging) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();

          // The offset between the cursor or finger and the initial
          // coordinates of the point. This is tracked so as to avoid
          // locking the moving point to the user's finger on touch
          // devices, which would obscure it, no matter how large we
          // made the touch target. Instead, we respect the offset at
          // which the point was grabbed for the entirety of the
          // gesture, if it's a touch-based interaction.
          const startCoord = movablePoint.coord;
          const startMouseCoord = graph.getMouseCoord(event);
          const isMouse = !("ontouchstart" in window);
          const touchOffset = isMouse ? [0, 0] : kmath.vector.subtract(startCoord, startMouseCoord);
          movablePoint.grab(touchOffset);
        }
      });
    }

    // Method to let the caller animate the point to a new position.
    // Useful as part of a hint to show the user the correct place
    // to put the point.
    movablePoint.moveTo = function (coordX, coordY, updateLines) {
      const distance = GraphUtils.getDistance(this.graph.scalePoint([coordX, coordY]), this.graph.scalePoint(this.coord));
      const time = distance * 5;
      const cb = updateLines && function (coord) {
        movablePoint.coord = coord;
        movablePoint.updateLineEnds();
      };
      this.visibleShape.animateTo([coordX, coordY], time, cb);
      this.mouseTarget.animateTo([coordX, coordY], time, cb);
      this.coord = [coordX, coordY];
      if (___default["default"].isFunction(this.onMove)) {
        this.onMove(coordX, coordY);
      }
    };

    // After moving the point, call this to update all line segments
    // terminating at the point
    movablePoint.updateLineEnds = function () {
      $__default["default"](this.lineStarts).each(function () {
        this.coordA = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.lineEnds).each(function () {
        this.coordZ = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.polygonVertices).each(function () {
        this.transform();
      });
    };

    // Put the point at a new position without any checks, animation,
    // or callbacks
    movablePoint.setCoord = function (coord) {
      if (this.visible) {
        this.visibleShape.moveTo(coord);
        if (this.mouseTarget != null) {
          this.mouseTarget.moveTo(coord);
        }
      }
      this.coord = coord.slice();
    };

    // Put the point at the new position, checking that it is
    // within the graph's bounds
    movablePoint.setCoordConstrained = function (coord) {
      this.setCoord(applySnapAndConstraints(coord));
    };

    // Change z-order to back
    movablePoint.toBack = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toBack();
        }
        this.visibleShape.toBack();
      }
    };

    // Change z-order to front
    movablePoint.toFront = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toFront();
        }
        this.visibleShape.toFront();
      }
    };
    movablePoint.remove = function () {
      if (this.visibleShape) {
        this.visibleShape.remove();
      }
      if (this.mouseTarget) {
        this.mouseTarget.remove();
      }
      if (this.labeledVertex) {
        this.labeledVertex.remove();
      }
    };
    return movablePoint;
  },
  // MovableLineSegment is a line segment that can be dragged around the
  // screen. By attaching a smartPoint to each (or one) end, the ends can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovableLineSegment({ pointA: smartPoint1, pointZ: smartPoint2 });
  // Or just one end:
  //   addMovableLineSegment({ pointA: smartPoint, coordZ: [0, 0] });
  //
  // Include "fixed: true" in the options if you don't want the entire line
  // to be draggable (you can still use points to make the endpoints
  // draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - lineSegment.coordA / lineSegment.coordZ
  //         The coordinates of each end of the line segment
  //
  //   - lineSegment.transform(syncToPoints)
  //         Repositions the line segment. Call after changing coordA
  //         and/or coordZ, or pass syncToPoints = true to use the current
  //         position of the corresponding smartPoints, if the segment was
  //         defined using smartPoints
  //
  addMovableLineSegment: function (options) {
    const lineSegment = $__default["default"].extend({
      graph: this,
      coordA: [0, 0],
      coordZ: [1, 1],
      snapX: 0,
      snapY: 0,
      fixed: false,
      ticks: 0,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors.INTERACTING,
        "stroke-width": 6
      },
      labelStyle: {
        stroke: KhanColors.INTERACTIVE,
        color: KhanColors.INTERACTIVE
      },
      highlight: false,
      dragging: false,
      tick: [],
      extendLine: false,
      extendRay: false,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false
      },
      sideLabel: "",
      vertexLabels: [],
      numArrows: 0,
      numTicks: 0,
      movePointsWithLine: false
    }, options);
    const normalColor = lineSegment.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    lineSegment.normalStyle = ___default["default"].extend({}, {
      "stroke-width": 2,
      stroke: normalColor
    }, options.normalStyle);
    // arrowStyle should be kept in sync with styling of the line
    lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.normalStyle, {
      color: lineSegment.normalStyle.stroke
    });

    // If the line segment is defined by movablePoints, coordA/coordZ are
    // owned by the points, otherwise they're owned by us
    if (options.pointA !== undefined) {
      lineSegment.coordA = options.pointA.coord;
      lineSegment.pointA.lineStarts.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = options.coordA.slice();
    }
    if (options.pointZ !== undefined) {
      lineSegment.coordZ = options.pointZ.coord;
      lineSegment.pointZ.lineEnds.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = lineSegment.coordA.slice();
    }
    const graph = lineSegment.graph;
    graph.style(lineSegment.normalStyle);
    for (let i = 0; i < lineSegment.ticks; ++i) {
      lineSegment.tick[i] = InteractiveUtils.bogusShape;
    }
    let path = GraphUtils.unscaledSvgPath([[0, 0], [1, 0]]);
    for (let i = 0; i < lineSegment.ticks; ++i) {
      const tickoffset = 0.5 - (lineSegment.ticks - 1 + i * 2) / graph.scale[0];
      // TODO(kevinb) figure out why path isn't being used
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      path += GraphUtils.unscaledSvgPath([[tickoffset, -7], [tickoffset, 7]]);
    }
    options = {
      thickness: Math.max(lineSegment.normalStyle["stroke-width"], lineSegment.highlightStyle["stroke-width"])
    };
    lineSegment.visibleLine = new WrappedLine(graph, [0, 0], [1, 0], options);
    lineSegment.visibleLine.attr(lineSegment.normalStyle);

    // Add mouse target
    if (!lineSegment.fixed) {
      const options = {
        thickness: 30,
        mouselayer: true,
        interactiveKindForTesting: "movable-line"
      };
      lineSegment.mouseTarget = new WrappedLine(graph, [0, 0], [1, 0], options);
      lineSegment.mouseTarget.attr({
        fill: "#000",
        opacity: 0.0
      });
    }

    // Reposition the line segment. Call after changing coordA and/or
    // coordZ, or pass syncToPoints = true to use the current position of
    // the corresponding movablePoints, if the segment was defined using
    // movablePoints
    lineSegment.transform = function (syncToPoints) {
      if (syncToPoints) {
        if (typeof this.pointA === "object") {
          this.coordA = this.pointA.coord;
        }
        if (typeof this.pointZ === "object") {
          this.coordZ = this.pointZ.coord;
        }
      }
      const getScaledAngle = function (line) {
        const scaledA = line.graph.scalePoint(line.coordA);
        const scaledZ = line.graph.scalePoint(line.coordZ);
        return kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledZ, scaledA))[1];
      };
      const getClipPoint = function (graph, coord, angle) {
        graph = lineSegment.graph;
        const xExtent = graph.range[0][1] - graph.range[0][0];
        const yExtent = graph.range[1][1] - graph.range[1][0];
        const distance = xExtent + yExtent;
        const angleVec = graph.unscaleVector(kmath.vector.cartFromPolarDeg(1, angle));
        const distVec = kmath.vector.scale(kmath.vector.normalize(angleVec), distance);
        const farCoord = kmath.vector.add(coord, distVec);
        const scaledAngle = kmath.vector.polarDegFromCart(angleVec)[1];
        const clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
        return clipPoint;
      };
      const angle = getScaledAngle(this);
      let start = this.coordA;
      let end = this.coordZ;

      // Extend start, end if necessary (i.e., if not a line segment)
      if (this.extendLine) {
        start = getClipPoint(graph, start, 360 - angle);
        end = getClipPoint(graph, end, (540 - angle) % 360);
      } else if (this.extendRay) {
        end = getClipPoint(graph, start, 360 - angle);
      }
      const elements = [this.visibleLine];
      if (!this.fixed) {
        elements.push(this.mouseTarget);
      }
      ___default["default"].each(elements, function (element) {
        element.moveTo(start, end);
      });
      const createArrow = function (graph, style) {
        const center = [0.75, 0];
        let points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]];
        const scale = 1.4;
        points = ___default["default"].map(points, function (point) {
          const pv = kmath.vector.subtract(point, center);
          const pvScaled = kmath.vector.scale(pv, scale);
          return kmath.vector.add(center, pvScaled);
        });
        const createCubicPath = function (points) {
          let path = "M" + points[0][0] + " " + points[0][1];
          for (let i = 1; i < points.length; i += 3) {
            path += "C" + points[i][0] + " " + points[i][1] + " " + points[i + 1][0] + " " + points[i + 1][1] + " " + points[i + 2][0] + " " + points[i + 2][1];
          }
          return path;
        };
        const unscaledPoints = ___default["default"].map(points, graph.unscalePoint);
        const options = {
          center: graph.unscalePoint(center),
          createPath: createCubicPath
        };
        const arrowHead = new WrappedPath(graph, unscaledPoints, options);
        arrowHead.attr(___default["default"].extend({
          "stroke-linejoin": "round",
          "stroke-linecap": "round",
          "stroke-dasharray": ""
        }, style));

        // Add custom function for transforming arrowheads that
        // accounts for center, scaling, etc.
        arrowHead.toCoordAtAngle = function (coord, angle) {
          const clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
          const do3dTransform = getCanUse3dTransform();
          arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + (do3dTransform ? "translateZ(0) " : "") + "rotate(" + (360 - KhanMath.bound(angle)) + "deg)");
        };
        return arrowHead;
      };

      // Add arrows
      if (this._arrows == null) {
        this._arrows = [];
        if (this.extendLine) {
          this._arrows.push(createArrow(graph, this.normalStyle));
          this._arrows.push(createArrow(graph, this.normalStyle));
        } else if (this.extendRay) {
          this._arrows.push(createArrow(graph, this.normalStyle));
        }
      }
      const coordForArrow = [this.coordA, this.coordZ];
      const angleForArrow = [360 - angle, (540 - angle) % 360];
      ___default["default"].each(this._arrows, function (arrow, i) {
        arrow.toCoordAtAngle(coordForArrow[i], angleForArrow[i]);
      });

      // Temporary objects: array of SVG nodes that get recreated on drag
      ___default["default"].invoke(this.temp, "remove");
      this.temp = [];
      const isClockwise = this.coordA[0] < this.coordZ[0] || this.coordA[0] === this.coordZ[0] && this.coordA[1] > this.coordZ[1];

      // Update side label
      if (this.sideLabel) {
        this.temp.push(this.graph.labelSide({
          point1: this.coordA,
          point2: this.coordZ,
          label: this.labeledSide,
          text: this.sideLabel,
          numArrows: this.numArrows,
          numTicks: this.numTicks,
          clockwise: isClockwise,
          style: this.labelStyle
        }));
      }

      // Update vertex labels
      if (this.vertexLabels.length) {
        this.graph.labelVertex({
          vertex: this.coordA,
          point3: this.coordZ,
          label: this.labeledVertices[0],
          text: this.vertexLabels[0],
          clockwise: isClockwise,
          style: this.labelStyle
        });
        this.graph.labelVertex({
          point1: this.coordA,
          vertex: this.coordZ,
          label: this.labeledVertices[1],
          text: this.vertexLabels[1],
          clockwise: isClockwise,
          style: this.labelStyle
        });
      }
      this.temp = ___default["default"].flatten(this.temp);
    };

    // Change z-order to back;
    lineSegment.toBack = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toBack();
      }
      lineSegment.visibleLine.toBack();
    };

    // Change z-order to front
    lineSegment.toFront = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toFront();
      }
      lineSegment.visibleLine.toFront();
    };
    lineSegment.remove = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.remove();
      }
      lineSegment.visibleLine.remove();
      if (lineSegment.labeledSide) {
        lineSegment.labeledSide.remove();
      }
      if (lineSegment.labeledVertices) {
        ___default["default"].invoke(lineSegment.labeledVertices, "remove");
      }
      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "remove");
      }
      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "remove");
      }
    };
    lineSegment.hide = function () {
      lineSegment.visibleLine.hide();
      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "hide");
      }
      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "hide");
      }
    };
    lineSegment.show = function () {
      lineSegment.visibleLine.show();
      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "show");
      }
      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "show");
      }
    };
    if (lineSegment.sideLabel) {
      lineSegment.labeledSide = this.label([0, 0], "", "center", lineSegment.labelStyle);
    }
    if (lineSegment.vertexLabels.length) {
      lineSegment.labeledVertices = ___default["default"].map(lineSegment.vertexLabels, function (label) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        return this.label([0, 0], "", "center", lineSegment.labelStyle);
      }, this);
    }
    if (!lineSegment.fixed && !lineSegment.constraints.fixed) {
      const $mouseTarget = $__default["default"](lineSegment.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging) {
            lineSegment.highlight = true;
            lineSegment.visibleLine.animate(lineSegment.highlightStyle, 50);
            lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
              color: lineSegment.highlightStyle.stroke,
              stroke: lineSegment.highlightStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmouseout") {
          lineSegment.highlight = false;
          if (!lineSegment.dragging) {
            lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
            lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
              color: lineSegment.normalStyle.stroke,
              stroke: lineSegment.normalStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();
          let coordX =
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          (event.pageX -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          $__default["default"](graph.raphael.canvas.parentNode).offset().left) / graph.scale[0] + graph.range[0][0];
          let coordY = graph.range[1][1] -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          (event.pageY -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          $__default["default"](graph.raphael.canvas.parentNode).offset().top) / graph.scale[1];
          if (lineSegment.snapX > 0) {
            coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
          }
          if (lineSegment.snapY > 0) {
            coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
          }
          const mouseOffsetA = [lineSegment.coordA[0] - coordX, lineSegment.coordA[1] - coordY];
          const mouseOffsetZ = [lineSegment.coordZ[0] - coordX, lineSegment.coordZ[1] - coordY];
          const offsetLeft = -Math.min(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          const offsetRight = Math.max(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          const offsetTop = Math.max(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          const offsetBottom = -Math.min(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          $__default["default"](document).bind("vmousemove.lineSegment vmouseup.lineSegment", function (event) {
            event.preventDefault();
            lineSegment.dragging = true;
            dragging = true;
            let mouseX =
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            event.pageX -
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            $__default["default"](graph.raphael.canvas.parentNode).offset().left;
            let mouseY =
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            event.pageY -
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            $__default["default"](graph.raphael.canvas.parentNode).offset().top;
            // no part of the line segment can go beyond 10
            // pixels from the edge
            mouseX = Math.max(offsetLeft + 10, Math.min(graph.xpixels - 10 - offsetRight, mouseX));
            mouseY = Math.max(offsetTop + 10, Math.min(graph.ypixels - 10 - offsetBottom, mouseY));
            let coordX = mouseX / graph.scale[0] + graph.range[0][0];
            let coordY = graph.range[1][1] - mouseY / graph.scale[1];
            if (lineSegment.snapX > 0) {
              coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
            }
            if (lineSegment.snapY > 0) {
              coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
            }
            if (event.type === "vmousemove") {
              if (lineSegment.constraints.constrainX) {
                coordX = lineSegment.coordA[0] - mouseOffsetA[0];
              }
              if (lineSegment.constraints.constrainY) {
                coordY = lineSegment.coordA[1] - mouseOffsetA[1];
              }
              const dX = coordX + mouseOffsetA[0] - lineSegment.coordA[0];
              const dY = coordY + mouseOffsetA[1] - lineSegment.coordA[1];
              lineSegment.coordA = [coordX + mouseOffsetA[0], coordY + mouseOffsetA[1]];
              lineSegment.coordZ = [coordX + mouseOffsetZ[0], coordY + mouseOffsetZ[1]];
              lineSegment.transform();
              if (lineSegment.movePointsWithLine) {
                // If the points are movablePoints, adjust
                // their coordinates when the line itself is
                // dragged
                if (typeof lineSegment.pointA === "object") {
                  lineSegment.pointA.setCoord([lineSegment.pointA.coord[0] + dX, lineSegment.pointA.coord[1] + dY]);
                }
                if (typeof lineSegment.pointZ === "object") {
                  lineSegment.pointZ.setCoord([lineSegment.pointZ.coord[0] + dX, lineSegment.pointZ.coord[1] + dY]);
                }
              }
              if (___default["default"].isFunction(lineSegment.onMove)) {
                lineSegment.onMove(dX, dY);
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".lineSegment");
              lineSegment.dragging = false;
              dragging = false;
              if (!lineSegment.highlight) {
                lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
                lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
                  color: lineSegment.normalStyle.stroke,
                  stroke: lineSegment.normalStyle.stroke
                });
                lineSegment.transform();
              }
              if (___default["default"].isFunction(lineSegment.onMoveEnd)) {
                lineSegment.onMoveEnd();
              }
            }
            $__default["default"](lineSegment).trigger("move");
          });
        }
      });
    }
    if (lineSegment.pointA !== undefined) {
      lineSegment.pointA.toFront();
    }
    if (lineSegment.pointZ !== undefined) {
      lineSegment.pointZ.toFront();
    }
    lineSegment.transform();
    return lineSegment;
  },
  // MovablePolygon is a polygon that can be dragged around the screen.
  // By attaching a smartPoint to each vertex, the points can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovablePolygon({points: [...]});
  //
  // Include "fixed: true" in the options if you don't want the entire
  // polygon to be draggable (you can still use points to make the
  // vertices draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - polygon.points
  //         The polygon's dynamic smartPoints and static coordinates, mixed.
  //
  //   - polygon.coords
  //         The polygon's current coordinates (generated, don't edit).
  //
  //   - polygon.transform()
  //         Repositions the polygon. Call after changing any points.
  //
  addMovablePolygon: function (options) {
    const graphie = this;
    const polygon = $__default["default"].extend({
      snapX: 0,
      snapY: 0,
      fixed: false,
      constrainToGraph: true,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors.INTERACTING,
        "stroke-width": 2,
        fill: KhanColors.INTERACTING,
        "fill-opacity": 0.05
      },
      pointHighlightStyle: {
        fill: KhanColors.INTERACTING,
        stroke: KhanColors.INTERACTING
      },
      labelStyle: {
        stroke: KhanColors.DYNAMIC,
        "stroke-width": 1,
        color: KhanColors.DYNAMIC
      },
      angleLabels: [],
      showRightAngleMarkers: [],
      sideLabels: [],
      vertexLabels: [],
      numArcs: [],
      numArrows: [],
      numTicks: [],
      updateOnPointMove: true,
      closed: true
    }, ___default["default"].omit(options, "points"));
    const normalColor = polygon.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    polygon.normalStyle = ___default["default"].extend({
      "stroke-width": 2,
      "fill-opacity": 0,
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle);

    // don't deep copy the points array with $.extend;
    // we may want to append to it later for click-to-add-points
    polygon.points = options.points;
    const isPoint = function (coordOrPoint) {
      return !___default["default"].isArray(coordOrPoint);
    };
    polygon.update = function () {
      const n = polygon.points.length;

      // Update coords
      polygon.coords = ___default["default"].map(polygon.points, function (coordOrPoint, i) {
        if (isPoint(coordOrPoint)) {
          return coordOrPoint.coord;
        }
        return coordOrPoint;
      });

      // Calculate bounding box
      polygon.left = ___default["default"].min(___default["default"].pluck(polygon.coords, 0));
      polygon.right = ___default["default"].max(___default["default"].pluck(polygon.coords, 0));
      polygon.top = ___default["default"].max(___default["default"].pluck(polygon.coords, 1));
      polygon.bottom = ___default["default"].min(___default["default"].pluck(polygon.coords, 1));
      let scaledCoords = ___default["default"].map(polygon.coords, function (coord) {
        return graphie.scalePoint(coord);
      });

      // Create path
      if (polygon.closed) {
        scaledCoords.push(true);
      } else {
        // For open polygons, concatenate a reverse of the path,
        // to remove the inside area of the path, which would
        // otherwise be clickable (even if the closing line segment
        // wasn't drawn
        scaledCoords = scaledCoords.concat(___default["default"].clone(scaledCoords).reverse());
      }
      polygon.path = GraphUtils.unscaledSvgPath(scaledCoords);

      // Temporary objects
      ___default["default"].invoke(polygon.temp, "remove");
      polygon.temp = [];
      const isClockwise = clockwise$1(polygon.coords);

      // Update angle labels
      if (polygon.angleLabels.length || polygon.showRightAngleMarkers.length) {
        ___default["default"].each(polygon.labeledAngles, function (label, i) {
          polygon.temp.push(graphie.labelAngle({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.angleLabels[i],
            showRightAngleMarker: polygon.showRightAngleMarkers[i],
            numArcs: polygon.numArcs[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      }

      // Update side labels
      if (polygon.sideLabels.length) {
        ___default["default"].each(polygon.labeledSides, function (label, i) {
          polygon.temp.push(graphie.labelSide({
            point1: polygon.coords[i],
            point2: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.sideLabels[i],
            numArrows: polygon.numArrows[i],
            numTicks: polygon.numTicks[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      }

      // Update vertex labels
      if (polygon.vertexLabels.length) {
        ___default["default"].each(polygon.labeledVertices, function (label, i) {
          graphie.labelVertex({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.vertexLabels[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          });
        });
      }
      polygon.temp = ___default["default"].flatten(polygon.temp);
    };
    polygon.transform = function () {
      polygon.update();
      polygon.visibleShape.attr({
        path: polygon.path
      });
      if (!polygon.fixed) {
        polygon.mouseTarget.attr({
          path: polygon.path
        });
      }
    };
    polygon.remove = function () {
      polygon.visibleShape.remove();
      if (!polygon.fixed) {
        polygon.mouseTarget.remove();
      }
      if (polygon.labeledAngles) {
        ___default["default"].invoke(polygon.labeledAngles, "remove");
      }
      if (polygon.labeledSides) {
        ___default["default"].invoke(polygon.labeledSides, "remove");
      }
      if (polygon.labeledVertices) {
        ___default["default"].invoke(polygon.labeledVertices, "remove");
      }
      if (polygon.temp.length) {
        ___default["default"].invoke(polygon.temp, "remove");
      }
    };
    polygon.toBack = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toBack();
      }
      polygon.visibleShape.toBack();
    };
    polygon.toFront = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toFront();
      }
      polygon.visibleShape.toFront();
    };

    // Setup

    if (polygon.updateOnPointMove) {
      ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (coordOrPoint) {
        coordOrPoint.polygonVertices.push(polygon);
      });
    }
    polygon.coords = new Array(polygon.points.length);
    if (polygon.angleLabels.length) {
      const numLabels = Math.max(polygon.angleLabels.length, polygon.showRightAngleMarkers.length);
      polygon.labeledAngles = ___default["default"].times(numLabels, function () {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }
    if (polygon.sideLabels.length) {
      polygon.labeledSides = ___default["default"].map(polygon.sideLabels, function (label) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }
    if (polygon.vertexLabels.length) {
      polygon.labeledVertices = ___default["default"].map(polygon.vertexLabels, function (label) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }
    polygon.update();
    polygon.visibleShape = graphie.raphael.path(polygon.path);
    polygon.visibleShape.attr(polygon.normalStyle);
    if (!polygon.fixed) {
      polygon.mouseTarget = graphie.mouselayer.path(polygon.path);
      polygon.mouseTarget.attr({
        fill: "#000",
        opacity: 0,
        cursor: "move"
      });
      $__default["default"](polygon.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging || polygon.dragging) {
            polygon.highlight = true;
            polygon.visibleShape.animate(polygon.highlightStyle, 50);
            ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (point) {
              point.visibleShape.animate(polygon.pointHighlightStyle, 50);
            });
          }
        } else if (event.type === "vmouseout") {
          polygon.highlight = false;
          if (!polygon.dragging) {
            polygon.visibleShape.animate(polygon.normalStyle, 50);
            const points = ___default["default"].filter(polygon.points, isPoint);
            if (!___default["default"].any(___default["default"].pluck(points, "dragging"))) {
              ___default["default"].each(points, function (point) {
                point.visibleShape.animate(point.normalStyle, 50);
              });
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();
          ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (point) {
            point.dragging = true;
          });
          let startX =
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          (event.pageX -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          $__default["default"](graphie.raphael.canvas.parentNode).offset().left) / graphie.scale[0] + graphie.range[0][0];
          let startY = graphie.range[1][1] -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          (event.pageY -
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
          $__default["default"](graphie.raphael.canvas.parentNode).offset().top) / graphie.scale[1];
          if (polygon.snapX > 0) {
            startX = Math.round(startX / polygon.snapX) * polygon.snapX;
          }
          if (polygon.snapY > 0) {
            startY = Math.round(startY / polygon.snapY) * polygon.snapY;
          }
          let lastX = startX;
          let lastY = startY;
          const polygonCoords = polygon.coords.slice();
          const offsetLeft = (startX - polygon.left) * graphie.scale[0];
          const offsetRight = (polygon.right - startX) * graphie.scale[0];
          const offsetTop = (polygon.top - startY) * graphie.scale[1];
          const offsetBottom = (startY - polygon.bottom) * graphie.scale[1];
          $__default["default"](document).bind("vmousemove.polygon vmouseup.polygon", function (event) {
            event.preventDefault();
            polygon.dragging = true;
            dragging = true;
            let mouseX =
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            event.pageX -
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
            let mouseY =
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            event.pageY -
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            $__default["default"](graphie.raphael.canvas.parentNode).offset().top;

            // no part of the polygon can go beyond 10 pixels from
            // the edge
            if (polygon.constrainToGraph) {
              mouseX = Math.max(offsetLeft + 10, Math.min(graphie.xpixels - 10 - offsetRight, mouseX));
              mouseY = Math.max(offsetTop + 10, Math.min(graphie.ypixels - 10 - offsetBottom, mouseY));
            }
            let currentX = mouseX / graphie.scale[0] + graphie.range[0][0];
            let currentY = graphie.range[1][1] - mouseY / graphie.scale[1];
            if (polygon.snapX > 0) {
              currentX = Math.round(currentX / polygon.snapX) * polygon.snapX;
            }
            if (polygon.snapY > 0) {
              currentY = Math.round(currentY / polygon.snapY) * polygon.snapY;
            }
            if (event.type === "vmousemove") {
              let dX = currentX - startX;
              let dY = currentY - startY;
              let doMove = true;
              if (___default["default"].isFunction(polygon.onMove)) {
                const onMoveResult = polygon.onMove(dX, dY);
                if (onMoveResult === false) {
                  doMove = false;
                } else if (___default["default"].isArray(onMoveResult)) {
                  dX = onMoveResult[0];
                  dY = onMoveResult[1];
                  currentX = startX + dX;
                  currentY = startY + dY;
                }
              }
              const increment = function (i) {
                return [polygonCoords[i][0] + dX, polygonCoords[i][1] + dY];
              };
              if (doMove) {
                ___default["default"].each(polygon.points, function (coordOrPoint, i) {
                  if (isPoint(coordOrPoint)) {
                    coordOrPoint.setCoord(increment(i));
                  } else {
                    polygon.points[i] = increment(i);
                  }
                });
                polygon.transform();
                $__default["default"](polygon).trigger("move");
                lastX = currentX;
                lastY = currentY;
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".polygon");
              const points = ___default["default"].filter(polygon.points, isPoint);
              ___default["default"].each(points, function (point) {
                point.dragging = false;
              });
              polygon.dragging = false;
              dragging = false;
              if (!polygon.highlight) {
                polygon.visibleShape.animate(polygon.normalStyle, 50);
                ___default["default"].each(points, function (point) {
                  point.visibleShape.animate(point.normalStyle, 50);
                });
              }
              if (___default["default"].isFunction(polygon.onMoveEnd)) {
                polygon.onMoveEnd(lastX - startX, lastY - startY);
              }
            }
          });
        }
      });
    }

    // Bring any movable points to the front
    ___default["default"].invoke(___default["default"].filter(polygon.points, isPoint), "toFront");
    return polygon;
  },
  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point's x and y coordinates are clamped within
   * the graph.
   */
  constrainToBounds: function (point, padding) {
    const lower = this.unscalePoint([padding, this.ypixels - padding]);
    const upper = this.unscalePoint([this.xpixels - padding, padding]);
    const coordX = Math.max(lower[0], Math.min(upper[0], point[0]));
    const coordY = Math.max(lower[1], Math.min(upper[1], point[1]));
    return [coordX, coordY];
  },
  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point is moved along the ray specified by angle
   * until inside graph.
   */
  constrainToBoundsOnAngle: function (point, padding, angle) {
    const lower = this.unscalePoint([padding, this.ypixels - padding]);
    const upper = this.unscalePoint([this.xpixels - padding, padding]);
    let result = point.slice();
    if (result[0] < lower[0]) {
      result = [lower[0], result[1] + (lower[0] - result[0]) * Math.tan(angle)];
    } else if (result[0] > upper[0]) {
      result = [upper[0], result[1] - (result[0] - upper[0]) * Math.tan(angle)];
    }
    if (result[1] < lower[1]) {
      result = [result[0] + (lower[1] - result[1]) / Math.tan(angle), lower[1]];
    } else if (result[1] > upper[1]) {
      result = [result[0] - (result[1] - upper[1]) / Math.tan(angle), upper[1]];
    }
    return result;
  },
  // MovableAngle is an angle that can be dragged around the screen.
  // By attaching a smartPoint to the vertex and ray control points, the
  // rays can be manipulated individually.
  //
  // Use only with smartPoints; add the smartPoints first, then:
  //   addMovableAngle({points: [...]});
  //
  // The rays can be controlled to snap on degrees (more useful than snapping
  // on coordinates) by setting snapDegrees to a positive integer.
  //
  // The returned object includes the following properties/methods:
  //
  //   - movableAngle.points
  //         The movableAngle's dynamic smartPoints.
  //
  //   - movableAngle.coords
  //         The movableAngle's current coordinates (generated, don't edit).
  //
  addMovableAngle: function (options) {
    return new MovableAngle(this, options);
  },
  // center: movable point
  // radius: int
  // circ: graphie circle
  // perim: invisible mouse target for dragging/changing radius
  addCircleGraph: function (options) {
    const graphie = this;
    const circle = $__default["default"].extend({
      center: [0, 0],
      radius: 2,
      snapX: 0.5,
      snapY: 0.5,
      snapRadius: 0.5,
      minRadius: 1,
      centerConstraints: {},
      centerNormalStyle: {},
      centerHighlightStyle: {
        stroke: KhanColors.INTERACTING,
        fill: KhanColors.INTERACTING
      },
      circleNormalStyle: {
        stroke: KhanColors.INTERACTIVE,
        "fill-opacity": 0
      },
      circleHighlightStyle: {
        stroke: KhanColors.INTERACTING,
        fill: KhanColors.INTERACTING,
        "fill-opacity": 0.05
      }
    }, options);
    const normalColor = circle.centerConstraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    const centerNormalStyle = options ? options.centerNormalStyle : null;
    circle.centerNormalStyle = ___default["default"].extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, centerNormalStyle);
    circle.centerPoint = graphie.addMovablePoint({
      graph: graphie,
      coord: circle.center,
      normalStyle: circle.centerNormalStyle,
      snapX: circle.snapX,
      snapY: circle.snapY,
      constraints: circle.centerConstraints
    });
    circle.circ = graphie.circle(circle.center, circle.radius, circle.circleNormalStyle);
    circle.perim = graphie.mouselayer.circle(graphie.scalePoint(circle.center)[0], graphie.scalePoint(circle.center)[1], graphie.scaleVector(circle.radius)[0]).attr({
      "stroke-width": 20,
      opacity: 0.002 // This is as close to 0 as MSIE will allow
    });

    // Highlight circle circumference on center point hover
    if (!circle.centerConstraints.fixed) {
      $__default["default"](circle.centerPoint.mouseTarget.getMouseTarget()).on("vmouseover vmouseout", function (event) {
        if (circle.centerPoint.highlight || circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleHighlightStyle, 50);
        } else {
          circle.circ.animate(circle.circleNormalStyle, 50);
        }
      });
    }
    circle.toFront = function () {
      circle.circ.toFront();
      circle.perim.toFront();
      circle.centerPoint.visibleShape.toFront();
      if (!circle.centerConstraints.fixed) {
        circle.centerPoint.mouseTarget.toFront();
      }
    };
    circle.centerPoint.onMove = function (x, y) {
      circle.toFront();
      circle.circ.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });
      circle.perim.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });
      if (circle.onMove) {
        circle.onMove(x, y);
      }
    };
    $__default["default"](circle.centerPoint).on("move", function () {
      circle.center = this.coord;
      $__default["default"](circle).trigger("move");
    });

    // circle.setCenter(x, y) moves the circle to the specified
    // x, y coordinate as if the user had dragged it there.
    circle.setCenter = function (x, y) {
      circle.centerPoint.setCoord([x, y]);
      circle.centerPoint.onMove(x, y);
      circle.center = [x, y];
    };

    // circle.setRadius(r) sets the circle's radius to the specified
    // value as if the user had dragged it there.
    circle.setRadius = function (r) {
      circle.radius = r;
      circle.perim.attr({
        r: graphie.scaleVector(r)[0]
      });
      circle.circ.attr({
        rx: graphie.scaleVector(r)[0],
        ry: graphie.scaleVector(r)[1]
      });
    };
    circle.remove = function () {
      circle.centerPoint.remove();
      circle.circ.remove();
      circle.perim.remove();
    };

    // Define a set of axes using polar coordinates to specify
    // which resizing cursor we want to show based on where the
    // mouse position lies in relation to the circle's center.
    // The first two columns in cursorAxes refer to the minimum
    // and maximum angle values bounding a circle sector, and
    // the third column refers to the cursor name that will be
    // applied if the mouse position falls inside the given sector.
    const cursorAxes = [[Math.PI * -1.0, Math.PI * -0.875, "ew-resize"], [Math.PI * -0.875, Math.PI * -0.625, "nesw-resize"], [Math.PI * -0.625, Math.PI * -0.375, "ns-resize"], [Math.PI * -0.375, Math.PI * -0.125, "nwse-resize"], [Math.PI * -0.125, Math.PI * 0.125, "ew-resize"], [Math.PI * 0.125, Math.PI * 0.375, "nesw-resize"], [Math.PI * 0.375, Math.PI * 0.625, "ns-resize"], [Math.PI * 0.625, Math.PI * 0.875, "nwse-resize"], [Math.PI * 0.875, Math.PI * 1.0, "ew-resize"]];

    // When the mouse moves along the circle's perimeter, we
    // dynamically set a CSS rule to show the correct
    // bidirectional cursor so a student knows they can resize
    // our circle. To do this, we convert the x and y coordinates
    // of the mouse position into polar coordinates and use the
    // defined cursorAxes above to set our rule.
    $__default["default"](circle.perim.node).on("vmousemove", event => {
      let [x, y] = this.getMouseCoord(event);
      x -= circle.center[0];
      y -= circle.center[1];
      const theta = Math.atan2(y, x);
      cursorAxes.forEach(function (axes) {
        const [min, max, cursorName] = axes;
        if (theta >= min && theta < max) {
          $__default["default"](circle.perim.node).css("cursor", cursorName);
        }
      });
    });

    // Set a default resizing-friendly cursor to be safe.
    $__default["default"](circle.perim.node).css("cursor", "nesw-resize");

    // Prevent the page from scrolling when we grab and drag the circle on
    // a mobile device.
    circle.perim.node.addEventListener("touchstart", function (event) {
      event.preventDefault();
    }, {
      passive: false
    });
    $__default["default"](circle.perim.node).on("vmouseover vmouseout vmousedown", function (event) {
      if (event.type === "vmouseover") {
        circle.highlight = true;
        if (!dragging) {
          // TODO(jack): Figure out why this doesn't work
          // for circleHighlightStyle's that change
          // stroke-dasharray
          circle.circ.animate(circle.circleHighlightStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerHighlightStyle, 50);
        }
      } else if (event.type === "vmouseout") {
        circle.highlight = false;
        if (!circle.dragging && !circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleNormalStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerNormalStyle, 50);
        }
      } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
        event.preventDefault();
        circle.toFront();
        const startRadius = circle.radius;
        $__default["default"](document).on("vmousemove vmouseup", function (event) {
          event.preventDefault();
          circle.dragging = true;
          dragging = true;
          if (event.type === "vmousemove") {
            const coord = graphie.constrainToBounds(graphie.getMouseCoord(event), 10);
            let radius = GraphUtils.getDistance(circle.centerPoint.coord, coord);
            radius = Math.max(circle.minRadius, Math.round(radius / circle.snapRadius) * circle.snapRadius);
            const oldRadius = circle.radius;
            let doResize = true;
            if (circle.onResize) {
              const onResizeResult = circle.onResize(radius, oldRadius);
              if (___default["default"].isNumber(onResizeResult)) {
                radius = onResizeResult;
              } else if (onResizeResult === false) {
                doResize = false;
              }
            }
            if (doResize) {
              circle.setRadius(radius);
              $__default["default"](circle).trigger("move");
            }
          } else if (event.type === "vmouseup") {
            $__default["default"](document).off("vmousemove vmouseup");
            circle.dragging = false;
            dragging = false;
            if (circle.onResizeEnd) {
              circle.onResizeEnd(circle.radius, startRadius);
            }
          }
        });
      }
    });
    return circle;
  },
  addRotateHandle: function () {
    const drawRotateHandle = function (graphie, center, radius, halfWidth, lengthAngle, angle, interacting) {
      const getRotateHandlePoint = function (offset, distanceFromArrowMidline) {
        const distFromRotationCenter = radius + distanceFromArrowMidline;
        const vec = kmath.vector.cartFromPolarDeg(distFromRotationCenter, angle + offset);
        const absolute = kmath.vector.add(center, vec);
        const pixels = graphie.scalePoint(absolute);
        return pixels[0] + "," + pixels[1];
      };
      const innerR = graphie.scaleVector(radius - halfWidth);
      const outerR = graphie.scaleVector(radius + halfWidth);

      // Draw the double-headed arrow thing that shows users where to
      // click and drag to rotate
      return graphie.raphael.path(
      // upper arrowhead
      " M" + getRotateHandlePoint(lengthAngle, -halfWidth) + " L" + getRotateHandlePoint(lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(2 * lengthAngle, 0) + " L" + getRotateHandlePoint(lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(lengthAngle, halfWidth) +
      // outer arc
      " A" + outerR[0] + "," + outerR[1] + ",0,0,1," + getRotateHandlePoint(-lengthAngle, halfWidth) +
      // lower arrowhead
      " L" + getRotateHandlePoint(-lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(-2 * lengthAngle, 0) + " L" + getRotateHandlePoint(-lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(-lengthAngle, -halfWidth) +
      // inner arc
      " A" + innerR[0] + "," + innerR[1] + ",0,0,0," + getRotateHandlePoint(lengthAngle, -halfWidth) + " Z").attr({
        stroke: null,
        fill: interacting ? KhanColors.INTERACTING : KhanColors.INTERACTIVE
      });
    };
    return function (options) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const graph = this;
      let rotatePoint = options.center;
      const radius = options.radius;
      const lengthAngle = options.lengthAngle || 30;
      const hideArrow = options.hideArrow || false;
      const mouseTarget = options.mouseTarget;
      const id = ___default["default"].uniqueId("rotateHandle");

      // Normalize rotatePoint into something that always looks
      // like a movablePoint
      if (___default["default"].isArray(rotatePoint)) {
        rotatePoint = {
          coord: rotatePoint
        };
      }
      const rotateHandle = graph.addMovablePoint({
        coord: kmath.point.addVector(rotatePoint.coord, kmath.vector.cartFromPolarDeg(radius, options.angleDeg || 0)),
        constraints: {
          fixedDistance: {
            dist: radius,
            point: rotatePoint
          }
        },
        mouseTarget: mouseTarget
      });

      // move the rotatePoint in front of the rotateHandle to avoid
      // confusing clicking/scaling of the rotateHandle when the user
      // intends to click on the rotatePoint
      rotatePoint.toFront();
      let rotatePointPrevCoord = rotatePoint.coord;
      let rotateHandlePrevCoord = rotateHandle.coord;
      let rotateHandleStartCoord = rotateHandlePrevCoord;
      let isRotating = false;
      let isHovering = false;
      let drawnRotateHandle;
      const redrawRotateHandle = function (handleCoord) {
        if (hideArrow) {
          return; // Don't draw anything!
        }

        const handleVec = kmath.vector.subtract(handleCoord, rotatePoint.coord);
        const handlePolar = kmath.vector.polarDegFromCart(handleVec);
        const angle = handlePolar[1];
        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }
        drawnRotateHandle = drawRotateHandle(graph, rotatePoint.coord, options.radius, isRotating || isHovering ? options.hoverWidth / 2 : options.width / 2, lengthAngle, angle, isRotating || isHovering);
      };

      // when the rotation center moves, we need to move
      // the rotationHandle as well, or it will end up out
      // of sync
      $__default["default"](rotatePoint).on("move." + id, function () {
        const delta = kmath.vector.subtract(rotatePoint.coord, rotatePointPrevCoord);
        rotateHandle.setCoord(kmath.vector.add(rotateHandle.coord, delta));
        redrawRotateHandle(rotateHandle.coord);
        rotatePointPrevCoord = rotatePoint.coord;
        rotateHandle.constraints.fixedDistance.point = rotatePoint;
        rotateHandlePrevCoord = rotateHandle.coord;
      });

      // Rotate polygon with rotateHandle
      rotateHandle.onMove = function (x, y) {
        if (!isRotating) {
          rotateHandleStartCoord = rotateHandlePrevCoord;
          isRotating = true;
        }
        let coord = [x, y];
        if (options.onMove) {
          const oldPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandlePrevCoord, rotatePoint.coord));
          const newPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(coord, rotatePoint.coord));
          const oldAngle = oldPolar[1];
          const newAngle = newPolar[1];
          let result = options.onMove(newAngle, oldAngle);
          if (result != null && result !== true) {
            if (result === false) {
              result = oldAngle;
            }
            coord = kmath.vector.add(rotatePoint.coord, kmath.vector.cartFromPolarDeg(oldPolar[0], result));
          }
        }
        redrawRotateHandle(coord);
        rotateHandlePrevCoord = coord;
        return coord;
      };
      rotateHandle.onMoveEnd = function () {
        isRotating = false;
        redrawRotateHandle(rotateHandle.coord);
        if (options.onMoveEnd) {
          const oldPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandleStartCoord, rotatePoint.coord));
          const newPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandle.coord, rotatePoint.coord));
          options.onMoveEnd(newPolar[1], oldPolar[1]);
        }
      };

      // Remove the default dot added by the movablePoint since we have
      // our double-arrow thing
      rotateHandle.visibleShape.remove();
      if (!mouseTarget) {
        // Make the default mouse target bigger to encompass the whole
        // area around the double-arrow thing
        rotateHandle.mouseTarget.attr({
          scale: 2
        });
      }
      const $mouseTarget = $__default["default"](rotateHandle.mouseTarget.getMouseTarget());
      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redrawRotateHandle(rotateHandle.coord);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redrawRotateHandle(rotateHandle.coord);
      });
      redrawRotateHandle(rotateHandle.coord);
      const oldRemove = rotateHandle.remove;
      rotateHandle.remove = function () {
        oldRemove.call(rotateHandle);
        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }
        $__default["default"](rotatePoint).off("move." + id);
      };
      rotateHandle.update = function () {
        redrawRotateHandle(rotateHandle.coord);
      };
      return rotateHandle;
    };
  }(),
  addReflectButton: function () {
    const drawButton = function (graphie, buttonCoord, lineCoords, size, distanceFromCenter, leftStyle, rightStyle) {
      // Avoid invalid lines
      if (kmath.point.equal(lineCoords[0], lineCoords[1])) {
        lineCoords = [lineCoords[0], kmath.point.addVector(lineCoords[0], [1, 1])];
      }
      const lineDirection = kmath.vector.normalize(kmath.vector.subtract(lineCoords[1], lineCoords[0]));
      const lineVec = kmath.vector.scale(lineDirection, size / 2);
      const centerVec = kmath.vector.scale(lineDirection, distanceFromCenter);
      const leftCenterVec = kmath.vector.rotateDeg(centerVec, 90);
      const rightCenterVec = kmath.vector.rotateDeg(centerVec, -90);
      const negLineVec = kmath.vector.negate(lineVec);
      const leftVec = kmath.vector.rotateDeg(lineVec, 90);
      const rightVec = kmath.vector.rotateDeg(lineVec, -90);
      const leftCenter = kmath.point.addVectors(buttonCoord, leftCenterVec);
      const rightCenter = kmath.point.addVectors(buttonCoord, rightCenterVec);
      const leftCoord1 = kmath.point.addVectors(buttonCoord, leftCenterVec, lineVec, leftVec);
      const leftCoord2 = kmath.point.addVectors(buttonCoord, leftCenterVec, negLineVec, leftVec);
      const rightCoord1 = kmath.point.addVectors(buttonCoord, rightCenterVec, lineVec, rightVec);
      const rightCoord2 = kmath.point.addVectors(buttonCoord, rightCenterVec, negLineVec, rightVec);
      const leftButton = graphie.path([leftCenter, leftCoord1, leftCoord2, true], leftStyle);
      const rightButton = graphie.path([rightCenter, rightCoord1, rightCoord2, true], rightStyle);
      return {
        remove: function () {
          leftButton.remove();
          rightButton.remove();
        }
      };
    };
    return function (options) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const graphie = this;
      const line = options.line;
      const button = graphie.addMovablePoint({
        constraints: options.constraints,
        coord: kmath.line.midpoint([line.pointA.coord, line.pointZ.coord]),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        onMove: function (x, y) {
          // Don't allow the button to actually move. This is a hack
          // around the inability to both set a point as fixed AND
          // allow it to be clicked.
          return false;
        },
        onMoveEnd: function (x, y) {
          if (options.onMoveEnd) {
            options.onMoveEnd.call(this, x, y);
          }
        }
      });
      let isHovering = false;
      let isFlipped = false;
      let currentlyDrawnButton;
      const isHighlight = function () {
        return isHovering;
      };
      const styles = ___default["default"].map([0, 1], function (isHighlight) {
        const baseStyle = isHighlight ? options.highlightStyle : options.normalStyle;
        return ___default["default"].map([0, 1], function (opacity) {
          return ___default["default"].defaults({
            "fill-opacity": opacity
          }, baseStyle);
        });
      });
      const getStyle = function (isRight) {
        if (isFlipped) {
          isRight = !isRight;
        }
        return styles[+isHighlight()][+isRight];
      };
      const redraw = function (coord, lineCoords) {
        if (currentlyDrawnButton) {
          currentlyDrawnButton.remove();
        }
        currentlyDrawnButton = drawButton(graphie, coord, lineCoords, isHighlight() ? options.size * 1.5 : options.size, isHighlight() ? options.size * 0.125 : 0.25, getStyle(0), getStyle(1));
      };
      const update = function (coordA, coordZ) {
        coordA = coordA || line.pointA.coord;
        coordZ = coordZ || line.pointZ.coord;
        const buttonCoord = kmath.line.midpoint([coordA, coordZ]);
        button.setCoord(buttonCoord);
        redraw(buttonCoord, [coordA, coordZ]);
      };
      $__default["default"](line).on("move", ___default["default"].bind(update, button, null, null));
      const $mouseTarget = $__default["default"](button.mouseTarget.getMouseTarget());
      $mouseTarget.on("vclick", function () {
        const result = options.onClick();
        if (result !== false) {
          isFlipped = !isFlipped;
          redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
        }
      });

      // Bring the reflection line handles in front of the button, so
      // that if we drag the reflectPoints really close together, we can
      // still move the handles away from each other, rather than only
      // being able to apply the reflection.
      line.pointA.toFront();
      line.pointZ.toFront();

      // Replace the visual point with the double triangle thing
      button.visibleShape.remove();
      const pointScale = graphie.scaleVector(options.size)[0] / 20;
      button.mouseTarget.attr({
        scale: 1.5 * pointScale
      });
      $mouseTarget.css("cursor", "pointer");

      // Make the arrow-thing grow and shrink with mouseover/out
      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      const oldButtonRemove = button.remove;
      button.remove = function () {
        currentlyDrawnButton.remove();
        oldButtonRemove.call(button);
      };
      button.update = update;
      button.isFlipped = function () {
        return isFlipped;
      };

      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 0.
      update();
      return button;
    };
  }(),
  protractor: function (center) {
    // @ts-expect-error [FEI-5003] - TS2350 - Only a void function can be called with the 'new' keyword.
    return new Protractor(this, center);
  },
  ruler: function (options) {
    // @ts-expect-error [FEI-5003] - TS2350 - Only a void function can be called with the 'new' keyword.
    return new Ruler(this, options || {});
  },
  addPoints: addPoints
});
function Protractor(graph, center) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.set = graph.raphael.set();

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.cx = center[0];
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.cy = center[1];
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  const pro = this;
  const r = graph.unscaleVector(180.5)[0];
  const imgPos = graph.scalePoint([
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.cx - r,
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.cy + r - graph.unscaleVector(10.5)[1]]);
  const image = graph.mouselayer.image("https://ka-perseus-graphie.s3.amazonaws.com/e9d032f2ab8b95979f674fbfa67056442ba1ff6a.png", imgPos[0], imgPos[1], 360, 180);
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.set.push(image);

  // Prevent the page from scrolling when we grab and drag the image on a
  // mobile device.
  image.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });
  const arrowHelper = function (angle, pixelsFromEdge) {
    const scaledRadius = graph.scaleVector(r);
    scaledRadius[0] -= 16;
    scaledRadius[1] -= 16;
    const scaledCenter = graph.scalePoint(center);
    const x = Math.sin((angle + 90) * Math.PI / 180) * (scaledRadius[0] + pixelsFromEdge) + scaledCenter[0];
    const y = Math.cos((angle + 90) * Math.PI / 180) * (scaledRadius[1] + pixelsFromEdge) + scaledCenter[1];
    return x + "," + y;
  };
  const arrow = graph.raphael.path(" M" + arrowHelper(180, 6) + " L" + arrowHelper(180, 2) + " L" + arrowHelper(183, 10) + " L" + arrowHelper(180, 18) + " L" + arrowHelper(180, 14) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,1," + arrowHelper(170, 14) + " L" + arrowHelper(170, 18) + " L" + arrowHelper(167, 10) + " L" + arrowHelper(170, 2) + " L" + arrowHelper(170, 6) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,0," + arrowHelper(180, 6) + " Z").attr({
    stroke: null,
    fill: KhanColors.INTERACTIVE
  });

  // add it to the set so it translates with everything else
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.set.push(arrow);

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.centerPoint = graph.addMovablePoint({
    coord: center,
    visible: false
  });

  // Use a movablePoint for rotation
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateHandle = graph.addMovablePoint({
    bounded: false,
    coord: [
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    Math.sin(275 * Math.PI / 180) * r + this.cx,
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    Math.cos(275 * Math.PI / 180) * r + this.cy],
    onMove: function (x, y) {
      const angle = Math.atan2(pro.centerPoint.coord[1] - y, pro.centerPoint.coord[0] - x) * 180 / Math.PI;
      pro.rotate(-angle - 5, true);
    }
  });

  // Add a constraint so the point moves in a circle
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateHandle.constraints.fixedDistance.dist = r;
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateHandle.constraints.fixedDistance.point = this.centerPoint;

  // Remove the default dot added by the movablePoint since we have our
  // double-arrow thing
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateHandle.visibleShape.remove();
  // Make the mouse target bigger to encompass the whole area around the
  // double-arrow thing
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateHandle.mouseTarget.attr({
    scale: 2.0
  });
  let isDragging = false;
  let isHovering = false;
  const isHighlight = function () {
    return isHovering || isDragging;
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  const self = this;
  const $mouseTarget = $__default["default"](self.rotateHandle.mouseTarget.getMouseTarget());
  $mouseTarget.bind("vmousedown", function (event) {
    isDragging = true;
    $mouseTarget.css("cursor", "-webkit-grabbing");
    $mouseTarget.css("cursor", "grabbing");
    arrow.animate({
      scale: 1.5,
      fill: KhanColors.INTERACTING
    }, 50);
    $__default["default"](document).bind("vmouseup.rotateHandle", function (event) {
      isDragging = false;
      $mouseTarget.css("cursor", "-webkit-grab");
      $mouseTarget.css("cursor", "grab");
      if (!isHighlight()) {
        arrow.animate({
          scale: 1.0,
          fill: KhanColors.INTERACTIVE
        }, 50);
      }
      $__default["default"](document).unbind("vmouseup.rotateHandle");
    });
  });
  $mouseTarget.bind("vmouseover", function (event) {
    isHovering = true;
    arrow.animate({
      scale: 1.5,
      fill: KhanColors.INTERACTING
    }, 50);
  });
  $mouseTarget.bind("vmouseout", function (event) {
    isHovering = false;
    if (!isHighlight()) {
      arrow.animate({
        scale: 1.0,
        fill: KhanColors.INTERACTIVE
      }, 50);
    }
  });

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  const setNodes = $__default["default"].map(this.set, function (el) {
    return el.node;
  });
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.makeTranslatable = function makeTranslatable() {
    $__default["default"](setNodes).css("cursor", "move");
    $mouseTarget.css("cursor", "-webkit-grab");
    $mouseTarget.css("cursor", "grab");
    $__default["default"](setNodes).bind("vmousedown", function (event) {
      event.preventDefault();
      let startx =
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
      event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
      let starty =
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
      event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top;
      $__default["default"](document).bind("vmousemove.protractor", function (event) {
        let mouseX =
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
        event.pageX -
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
        $__default["default"](graph.raphael.canvas.parentNode).offset().left;
        let mouseY =
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
        event.pageY -
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
        $__default["default"](graph.raphael.canvas.parentNode).offset().top;
        // can't go beyond 10 pixels from the edge
        mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
        mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
        const dx = mouseX - startx;
        const dy = mouseY - starty;
        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
        startx = mouseX;
        starty = mouseY;
      });
      $__default["default"](document).one("vmouseup", function (event) {
        $__default["default"](document).unbind("vmousemove.protractor");
      });
    });
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotation = 0;

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotate = function (offset, absolute) {
    const center = graph.scalePoint(this.centerPoint.coord);
    if (absolute) {
      this.rotation = 0;
    }
    this.set.rotate(this.rotation + offset, center[0], center[1]);
    this.rotation = this.rotation + offset;
    return this;
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.moveTo = function moveTo(x, y) {
    const start = graph.scalePoint(pro.centerPoint.coord);
    const end = graph.scalePoint([x, y]);
    const time = GraphUtils.getDistance(start, end) * 2;
    $__default["default"]({
      x: start[0],
      y: start[1]
    }).animate({
      x: end[0],
      y: end[1]
    }, {
      duration: time,
      step: function (now, fx) {
        let dx = 0;
        let dy = 0;
        if (fx.prop === "x") {
          dx = now - graph.scalePoint(pro.centerPoint.coord)[0];
        } else if (fx.prop === "y") {
          dy = now - graph.scalePoint(pro.centerPoint.coord)[1];
        }
        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
      }
    });
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rotateTo = function rotateTo(angle) {
    if (Math.abs(this.rotation - angle) > 180) {
      this.rotation += 360;
    }
    const time = Math.abs(this.rotation - angle) * 5;
    $__default["default"]({
      0: this.rotation
    }).animate({
      0: angle
    }, {
      duration: time,
      step: function (now, fx) {
        pro.rotate(now, true);
        pro.rotateHandle.setCoord([Math.sin((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[0], Math.cos((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[1]]);
      }
    });
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.remove = function () {
    this.set.remove();
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.makeTranslatable();
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  return this;
}
function Ruler(graphie, options) {
  ___default["default"].defaults(options, {
    center: [0, 0],
    pixelsPerUnit: 40,
    ticksPerUnit: 10,
    // 10 or power of 2
    units: 10,
    // the length the ruler can measure
    label: "",
    // e.g "cm" (the shorter, the better)
    style: {
      fill: null,
      stroke: KhanColors.GRAY
    }
  });
  const light = ___default["default"].extend({}, options.style, {
    strokeWidth: 1
  });
  const bold = ___default["default"].extend({}, options.style, {
    strokeWidth: 2
  });
  const width = options.units * options.pixelsPerUnit;
  const height = 50;
  const leftBottom = graphie.unscalePoint(kmath.vector.subtract(graphie.scalePoint(options.center), kmath.vector.scale([width, -height], 0.5)));
  const graphieUnitsPerUnit = options.pixelsPerUnit / graphie.scale[0];
  const graphieUnitsHeight = height / graphie.scale[0];
  const rightTop = kmath.vector.add(leftBottom, [options.units * graphieUnitsPerUnit, graphieUnitsHeight]);
  const tickHeight = 1.0;
  let tickHeightMap;
  if (options.ticksPerUnit === 10) {
    // decimal, as on a centimeter ruler
    tickHeightMap = {
      10: tickHeight,
      5: tickHeight * 0.55,
      1: tickHeight * 0.35
    };
  } else {
    const sizes = [1, 0.6, 0.45, 0.3];
    tickHeightMap = {};
    for (let i = options.ticksPerUnit; i >= 1; i /= 2) {
      tickHeightMap[i] = tickHeight * (sizes.shift() || 0.2);
    }
  }
  const tickFrequencies = ___default["default"].keys(tickHeightMap).sort(function (a, b) {
    // @ts-expect-error [FEI-5003] - TS2362 - The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. | TS2363 - The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    return b - a;
  });
  function getTickHeight(i) {
    for (let k = 0; k < tickFrequencies.length; k++) {
      const key = tickFrequencies[k];
      // @ts-expect-error [FEI-5003] - TS2363 - The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
      if (i % key === 0) {
        return tickHeightMap[key];
      }
    }
    return 0;
  }
  const left = leftBottom[0];
  const bottom = leftBottom[1];
  const right = rightTop[0];
  const top = rightTop[1];
  const numTicks = options.units * options.ticksPerUnit + 1;
  const set = graphie.raphael.set();
  const px = 1 / graphie.scale[0];
  set.push(graphie.line([left - px, bottom], [right + px, bottom], bold));
  set.push(graphie.line([left - px, top], [right + px, top], bold));
  ___default["default"].times(numTicks, function (i) {
    const n = i / options.ticksPerUnit;
    const x = left + n * graphieUnitsPerUnit;
    const height = getTickHeight(i) * graphieUnitsHeight;
    const style = i === 0 || i === numTicks - 1 ? bold : light;
    set.push(graphie.line([x, bottom], [x, bottom + height], style));
    if (n % 1 === 0) {
      const coord = graphie.scalePoint([x, top]);
      let text;
      let offset;
      if (n === 0) {
        // Unit label
        text = options.label;
        offset = {
          mm: 13,
          cm: 11,
          m: 8,
          km: 11,
          in: 8,
          ft: 8,
          yd: 10,
          mi: 10
        }[text] || 3 * text.toString().length;
      } else {
        // Tick label
        text = n;
        offset = -3 * (n.toString().length + 1);
      }
      const label = graphie.raphael.text(coord[0] + offset, coord[1] + 10, text);
      label.attr({
        "font-family": "KaTeX_Main",
        "font-size": "12px",
        color: "#444"
      });
      set.push(label);
    }
  });
  const mouseTarget = graphie.mouselayer.path(GraphUtils.svgPath([leftBottom, [left, top], rightTop, [right, bottom], /* closed */true]));
  mouseTarget.attr({
    fill: "#000",
    opacity: 0,
    stroke: "#000",
    "stroke-width": 2
  });
  set.push(mouseTarget);

  // Prevent the page from scrolling when we grab and drag the ruler on a
  // mobile device.
  mouseTarget.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });
  const setNodes = $__default["default"].map(set, function (el) {
    return el.node;
  });
  $__default["default"](setNodes).css("cursor", "move");
  $__default["default"](setNodes).bind("vmousedown", function (event) {
    event.preventDefault();
    let startx =
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
    event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    let starty =
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
    event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    $__default["default"](document).bind("vmousemove.ruler", function (event) {
      let mouseX =
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
      event.pageX -
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
      $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
      let mouseY =
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
      event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
      // can't go beyond 10 pixels from the edge
      mouseX = Math.max(10, Math.min(graphie.xpixels - 10, mouseX));
      mouseY = Math.max(10, Math.min(graphie.ypixels - 10, mouseY));
      const dx = mouseX - startx;
      const dy = mouseY - starty;
      set.translate(dx, dy);
      leftBottomHandle.setCoord([leftBottomHandle.coord[0] + dx / graphie.scale[0], leftBottomHandle.coord[1] - dy / graphie.scale[1]]);
      rightBottomHandle.setCoord([rightBottomHandle.coord[0] + dx / graphie.scale[0], rightBottomHandle.coord[1] - dy / graphie.scale[1]]);
      startx = mouseX;
      starty = mouseY;
    });
    $__default["default"](document).one("vmouseup", function (event) {
      $__default["default"](document).unbind("vmousemove.ruler");
    });
  });
  const leftBottomHandle = graphie.addMovablePoint({
    coord: leftBottom,
    normalStyle: {
      fill: KhanColors.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function (x, y) {
      const dy = rightBottomHandle.coord[1] - y;
      const dx = rightBottomHandle.coord[0] - x;
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const center = kmath.vector.scale(kmath.vector.add([x, y], rightBottomHandle.coord), 0.5);
      const scaledCenter = graphie.scalePoint(center);
      const oldCenter = kmath.vector.scale(kmath.vector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      const scaledOldCenter = graphie.scalePoint(oldCenter);
      const diff = kmath.vector.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  });
  const rightBottomHandle = graphie.addMovablePoint({
    coord: [right, bottom],
    normalStyle: {
      fill: KhanColors.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function (x, y) {
      const dy = y - leftBottomHandle.coord[1];
      const dx = x - leftBottomHandle.coord[0];
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const center = kmath.vector.scale(kmath.vector.add([x, y], leftBottomHandle.coord), 0.5);
      const scaledCenter = graphie.scalePoint(center);
      const oldCenter = kmath.vector.scale(kmath.vector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      const scaledOldCenter = graphie.scalePoint(oldCenter);
      const diff = kmath.vector.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  });

  // Make each handle rotate the ruler about the other one
  leftBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  leftBottomHandle.constraints.fixedDistance.point = rightBottomHandle;
  rightBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  rightBottomHandle.constraints.fixedDistance.point = leftBottomHandle;

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.remove = function () {
    set.remove();
    leftBottomHandle.remove();
    rightBottomHandle.remove();
  };

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  return this;
}
function MovableAngle(graphie, options) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.graphie = graphie;

  // TODO(alex): Move standard colors from math.js to somewhere else
  // so that they are available when this file is first parsed
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, options);
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].defaults(this, {
    normalStyle: {
      stroke: KhanColors.INTERACTIVE,
      "stroke-width": 2,
      fill: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      stroke: KhanColors.INTERACTING,
      "stroke-width": 2,
      fill: KhanColors.INTERACTING
    },
    labelStyle: {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    },
    angleStyle: {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    },
    allowReflex: true // not on MovableAngle.prototype so that
    // it is not overridden by undefined
  });

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  if (!this.points || this.points.length !== 3) {
    throw new PerseusError("MovableAngle requires 3 points", Errors.InvalidInput);
  }

  // Handle coordinates that are not MovablePoints (i.e. [2, 4])
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.points = ___default["default"].map(options.points, function (point) {
    if (___default["default"].isArray(point)) {
      return graphie.addMovablePoint({
        coord: point,
        visible: false,
        constraints: {
          fixed: true
        },
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        normalStyle: this.normalStyle
      });
    }
    return point;
  },
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this);
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.coords = ___default["default"].pluck(this.points, "coord");
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  if (this.reflex == null) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    if (this.allowReflex) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.reflex = this._getClockwiseAngle(this.coords) > 180;
    } else {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.reflex = false;
    }
  }

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.rays = ___default["default"].map([0, 2], function (i) {
    return graphie.addMovableLineSegment({
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      pointA: this.points[1],
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      pointZ: this.points[i],
      fixed: true,
      extendRay: true
    });
  },
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this);

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.temp = [];
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.labeledAngle = graphie.label([0, 0], "", "center", this.labelStyle);

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  if (!this.fixed) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.addMoveHandlers();
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.addHighlightHandlers();
  }
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.update();
}
___default["default"].extend(MovableAngle.prototype, {
  points: [],
  snapDegrees: 0,
  snapOffsetDeg: 0,
  angleLabel: "",
  numArcs: 1,
  pushOut: 0,
  fixed: false,
  addMoveHandlers: function () {
    const graphie = this.graphie;
    function tooClose(point1, point2) {
      const safeDistance = 30;
      const distance = GraphUtils.getDistance(graphie.scalePoint(point1), graphie.scalePoint(point2));
      return distance < safeDistance;
    }
    const points = this.points;

    // Drag the vertex to move the entire angle
    points[1].onMove = function (x, y) {
      const oldVertex = points[1].coord;
      const newVertex = [x, y];
      const delta = addPoints(newVertex, reverseVector(oldVertex));
      let valid = true;
      const newPoints = {};
      ___default["default"].each([0, 2], function (i) {
        const oldPoint = points[i].coord;
        let newPoint = addPoints(oldPoint, delta);
        let angle = GraphUtils.findAngle(newVertex, newPoint);
        angle *= Math.PI / 180;
        newPoint = graphie.constrainToBoundsOnAngle(newPoint, 10, angle);
        newPoints[i] = newPoint;

        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'never[]'.
        if (tooClose(newVertex, newPoint)) {
          valid = false;
        }
      });

      // Only move points if all new positions are valid
      if (valid) {
        ___default["default"].each(newPoints, function (newPoint, i) {
          points[i].setCoord(newPoint);
        });
      }
      return valid;
    };
    const snap = this.snapDegrees;
    const snapOffset = this.snapOffsetDeg;

    // Drag ray control points to move each ray individually
    ___default["default"].each([0, 2], function (i) {
      points[i].onMove = function (x, y) {
        const newPoint = [x, y];
        const vertex = points[1].coord;

        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'never[]'.
        if (tooClose(vertex, newPoint)) {
          return false;
        }
        if (snap) {
          let angle = GraphUtils.findAngle(newPoint, vertex);
          angle = Math.round((angle - snapOffset) / snap) * snap + snapOffset;
          const distance = GraphUtils.getDistance(newPoint, vertex);
          return addPoints(vertex, graphie.polar(distance, angle));
        }
        return true;
      };
    });

    // Expose only a single move event
    $__default["default"](points).on("move", function () {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.update();
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      $__default["default"](this).trigger("move");
    }.bind(this));
  },
  addHighlightHandlers: function () {
    const vertex = this.points[1];
    vertex.onHighlight = function () {
      ___default["default"].each(
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.points, function (point) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        point.visibleShape.animate(this.highlightStyle, 50);
      },
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this);
      ___default["default"].each(
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.rays, function (ray) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ray.visibleLine.animate(this.highlightStyle, 50);
        ray.arrowStyle = ___default["default"].extend({}, ray.arrowStyle, {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          color: this.highlightStyle.stroke,
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          stroke: this.highlightStyle.stroke
        });
      },
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this);

      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.angleStyle = ___default["default"].extend({}, this.angleStyle, {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        color: this.highlightStyle.stroke,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        stroke: this.highlightStyle.stroke
      });
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.update();
    }.bind(this);
    vertex.onUnhighlight = function () {
      ___default["default"].each(
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.points, function (point) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        point.visibleShape.animate(this.normalStyle, 50);
      },
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this);
      ___default["default"].each(
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.rays, function (ray) {
        ray.visibleLine.animate(ray.normalStyle, 50);
        ray.arrowStyle = ___default["default"].extend({}, ray.arrowStyle, {
          color: ray.normalStyle.stroke,
          stroke: ray.normalStyle.stroke
        });
      },
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this);

      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.angleStyle = ___default["default"].extend({}, this.angleStyle, {
        color: KhanColors.DYNAMIC,
        stroke: KhanColors.DYNAMIC
      });
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.update();
    }.bind(this);
  },
  /**
   * Returns the angle in [0, 360) degrees created by the
   * coords when interpreted in a clockwise direction.
   */
  _getClockwiseAngle: function (coords) {
    const rawAngle = GraphUtils.findAngle(
    // The order of these is "weird" to match what a clockwise
    // order is in graphie.labelAngle
    coords[2],
    // from the second point
    coords[0],
    // clockwise to the first point
    coords[1] // the vertex parameter is last
    );

    const clockwiseAngle = rawAngle + 360 % 360;
    return clockwiseAngle;
  },
  isReflex: function () {
    return this.reflex;
  },
  isClockwise: function () {
    const clockwiseReflexive = this._getClockwiseAngle(this.coords) > 180;
    return clockwiseReflexive === this.reflex;
  },
  getClockwiseCoords: function () {
    if (this.isClockwise()) {
      return ___default["default"].clone(this.coords);
    }
    return ___default["default"].clone(this.coords).reverse();
  },
  update: function (shouldChangeReflexivity) {
    const prevCoords = this.coords;
    this.coords = ___default["default"].pluck(this.points, "coord");

    // Update lines
    ___default["default"].invoke(this.points, "updateLineEnds");
    const prevAngle = this._getClockwiseAngle(prevCoords);
    const angle = this._getClockwiseAngle(this.coords);
    const prevClockwiseReflexive = prevAngle > 180;
    const clockwiseReflexive = angle > 180;
    if (this.allowReflex) {
      if (shouldChangeReflexivity == null) {
        shouldChangeReflexivity = prevClockwiseReflexive !== clockwiseReflexive && Math.abs(angle - prevAngle) < 180;
      }
      if (shouldChangeReflexivity) {
        this.reflex = !this.reflex;
      }
    }
    ___default["default"].invoke(this.temp, "remove");
    this.temp = this.graphie.labelAngle({
      point1: this.coords[0],
      vertex: this.coords[1],
      point3: this.coords[2],
      label: this.labeledAngle,
      text: this.angleLabel,
      numArcs: this.numArcs,
      pushOut: this.pushOut,
      clockwise: this.reflex === clockwiseReflexive,
      style: this.angleStyle
    });
  },
  remove: function () {
    ___default["default"].invoke(this.rays, "remove");
    ___default["default"].invoke(this.temp, "remove");
    this.labeledAngle.remove();
  }
});

/* eslint-disable @babel/no-invalid-this */
const nestedMap$1 = Util.nestedMap;
const deepEq$4 = Util.deepEq;

/**
 * A base class for all Graphie Movables
 *
 * Used for checking that all Graphie children are, in fact,
 * GraphieMovables
 */
function GraphieMovable$1(descriptor) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, descriptor);
}
const abstractMethod = function () {
  throw new PerseusError("Abstract method! Must be implemented by Graphie Movable" +
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.constructor.displayName, Errors.NotAllowed);
};
___default["default"].extend(GraphieMovable$1.prototype, {
  movableProps: [],
  add: abstractMethod,
  modify: abstractMethod,
  remove: abstractMethod,
  toFront: function () {
    /* no op */
  },
  componentDidMount: function () {
    /* no op */
    // Note: this method is here to trick react-hot-loader into thinking
    // components built from extending GraphieMovable are recognized as
    // class base React components so that they get wrapped correctly.
    // See https://github.com/gaearon/react-hot-loader/blob/master/src/internal/reactUtils.js#L14-L26
    // for details of how react-hot-loader determines whether something is
    // a React class (component).
  }
});

/**
 * returns cloned props modified with `children: childrenArray`
 */
const rewriteProps = function (props, childrenArray) {
  // Clone the props and add `children:`
  // childrenArray is always an array here because this is only called
  // from createClass, which initializes childrenArray as _.rest(arguments)
  return ___default["default"].extend({}, props, {
    children: ___default["default"].filter(___default["default"].flatten(childrenArray), ___default["default"].identity)
  });
};

/**
 * Create a custom GraphieMovable class
 */
const createClass = function (spec) {
  const GraphieClass = function (props) {
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    if (!(this instanceof GraphieClass)) {
      throw new PerseusError("Use createElement or JSX with graphie movables", Errors.NotAllowed);
    }
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    this.props = rewriteProps(props, props.children || []);
    // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
    return this;
  };
  spec.displayName = spec.displayName || ___default["default"].uniqueId("GraphieClass");

  // Add the displayName to the constructor for compatibility with
  // React's myDescriptor.constructor.displayName
  GraphieClass.displayName = spec.displayName;
  GraphieClass.prototype = new GraphieMovable$1(spec);
  GraphieClass.prototype.constructor = GraphieClass;
  return GraphieClass;
};

/**
 * Create a GraphieMovable class from a function that describes
 * how to add said class to a graphie, and returns an array of
 * `.remove()`able elements to be used when a remove() or
 * modify() is called.
 *
 * This convenience method creates an inefficient class, although
 * it does check for a difference in this.props and prevProps before
 * removing and re-adding itself.
 *
 * The primary benefit of this is being able to very easily create
 * a wrapper for old graphie code to make it interface with <Graphie>
 *
 * Commonly used elements should use the fully-fledged createClass
 * and implement an efficient modify() operation.
 */
const createSimpleClass = function (addFunction) {
  return createClass({
    displayName: addFunction.name || ___default["default"].uniqueId("GraphieSimpleClass"),
    movableProps: ["children"],
    add: function (graphie) {
      this._elements = addFunction(graphie, this.props);
      this._prevProps = this.props;
    },
    modify: function (graphie) {
      if (!deepEq$4(this.props, this._prevProps)) {
        this.remove();
        this.add(graphie);
        this._prevProps = this.props;
        return "reordered";
      }
    },
    remove: function () {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 3 arguments, but got 2.
      nestedMap$1(this._elements, elem => {
        if (elem) {
          elem.remove();
        }
      });
      this._elements = null;
      this._prevProps = null;
    },
    toFront: function () {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 3 arguments, but got 2.
      nestedMap$1(this._elements, elem => {
        if (___default["default"].isFunction(elem.toFront)) {
          elem.toFront();
        }
      });
    }
  });
};
var GraphieClasses = {
  GraphieMovable: GraphieMovable$1,
  createClass: createClass,
  createSimpleClass: createSimpleClass
};

/**
 * Movable
 *
 * A Movable Something, that sends onMove events based on the
 * mouse coordinate (graphie unscaled, non-pixel-value) of the
 * move.
 *
 * Other MovableThings should generally have a Movable field, and
 * let this class handle all of the virtual mouse events, and then
 * take appropriate action in onMoveStart, onMove, onMoveEnd
 */
const normalizeOptions$3 = InteractiveUtil.normalizeOptions;
const assert$9 = InteractiveUtil.assert;

// state parameters that should be converted into an array of
// functions
const FUNCTION_ARRAY_OPTIONS$3 = ["add", "modify", "draw", "remove", "onMoveStart", "onMove", "onMoveEnd", "onClick"];

// Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.isHovering() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the movable should be on "state".
const DEFAULT_PROPS$3 = {
  cursor: null
};
const DEFAULT_STATE$3 = {
  added: false,
  isHovering: false,
  isMouseOver: false,
  isDragging: false,
  mouseTarget: null
};

// @ts-expect-error [FEI-5003] - TS2355 - A function whose declared type is neither 'void' nor 'any' must return a value.
const Movable = function (graphie, options) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie: graphie,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movable")
    }
  });

  // We only set DEFAULT_STATE once, here
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.modify(___default["default"].extend({}, DEFAULT_STATE$3, options));
};
InteractiveUtil.createGettersFor(Movable, ___default["default"].extend({}, DEFAULT_PROPS$3, DEFAULT_STATE$3));
InteractiveUtil.addMovableHelperMethodsTo(Movable);
___default["default"].extend(Movable.prototype, {
  cloneState: function () {
    return ___default["default"].clone(this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id,
      add: [],
      modify: [],
      draw: [],
      remove: [],
      onMoveStart: [],
      onMove: [],
      onMoveEnd: [],
      onClick: []

      // We only update props here, because we want things on state to
      // be persistent, and updated appropriately in modify()
    }, DEFAULT_PROPS$3);
  },
  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. The only state maintained is `state.id`
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend({}, this._createDefaultState(), options));
  },
  /**
   * Simulates a mouse grab event on the movable object.
   */
  grab: function (coord) {
    assert$9(kmath.point.is(coord));
    const self = this;
    const graphie = self.graphie;
    const state = self.state;
    state.isHovering = true;
    state.isDragging = true;
    graphie.isDragging = true;
    const startMouseCoord = coord;
    let prevMouseCoord = startMouseCoord;
    self._fireEvent(state.onMoveStart, startMouseCoord, startMouseCoord);
    const moveHandler = function (e) {
      e.preventDefault();
      const mouseCoord = graphie.getMouseCoord(e);
      self._fireEvent(state.onMove, mouseCoord, prevMouseCoord);
      self.draw();
      prevMouseCoord = mouseCoord;
    };
    const upHandler = function (e) {
      $__default["default"](document).unbind("vmousemove", moveHandler);
      $__default["default"](document).unbind("vmouseup", upHandler);
      if (state.isHovering) {
        self._fireEvent(state.onClick, prevMouseCoord, startMouseCoord);
      }
      state.isHovering = self.state.isMouseOver;
      state.isDragging = false;
      graphie.isDragging = false;
      self._fireEvent(state.onMoveEnd, prevMouseCoord, startMouseCoord);
      self.draw();
    };
    $__default["default"](document).bind("vmousemove", moveHandler);
    $__default["default"](document).bind("vmouseup", upHandler);
  },
  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;
    const prevState = self.cloneState();
    const state = ___default["default"].extend(self.state, normalizeOptions$3(FUNCTION_ARRAY_OPTIONS$3, options));

    // the invisible shape in front of the point that gets mouse events
    if (state.mouseTarget && !prevState.mouseTarget) {
      let $mouseTarget;
      if (state.mouseTarget.getMouseTarget) {
        $mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        $mouseTarget = $__default["default"](state.mouseTarget[0]);
      }
      const isMouse = !("ontouchstart" in window);
      if (isMouse) {
        $mouseTarget.on("vmouseover", function () {
          state.isMouseOver = true;
          if (!graphie.isDragging) {
            state.isHovering = true;
          }
          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
        $mouseTarget.on("vmouseout", function () {
          state.isMouseOver = false;
          if (!state.isDragging) {
            state.isHovering = false;
          }
          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
      }

      // Prevent the page from scrolling when we grab and drag the
      // movable object on a mobile device.
      $mouseTarget[0].addEventListener("touchstart", function (event) {
        event.preventDefault();
      }, {
        passive: false
      });
      $mouseTarget.on("vmousedown", function (e) {
        if (e.which !== 0 && e.which !== 1) {
          return;
        }
        e.preventDefault();
        const mouseCoord = graphie.getMouseCoord(e);
        self.grab(mouseCoord);
      });
    }
    if (state.mouseTarget && state.cursor !== undefined) {
      let $mouseTarget;
      if (state.mouseTarget.getMouseTarget) {
        $mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        $mouseTarget = $__default["default"](state.mouseTarget[0]);
      }

      // "" removes the css cursor if state.cursor is null
      $mouseTarget.css("cursor", state.cursor || "");
    }

    // Trigger an add event if this hasn't been added before
    if (!state.added) {
      self._fireEvent(state.modify, self.cloneState(), {});
      state.added = true;

      // Update the state for `added` and in case the add event
      // changed it
      self.prevState = self.cloneState();
    }

    // Trigger a modify event
    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function () {
    this.state.added = false;
    this._fireEvent(this.state.remove);
    if (this.state.mouseTarget) {
      $__default["default"](this.state.mouseTarget).off();
      this.state.mouseTarget.remove();
      this.state.mouseTarget = null;
    }
  },
  // Change z-order to back
  toBack: function () {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toFront();
    }
  }
});

/* eslint-disable @babel/no-invalid-this */
/**
 * Helper functions
 */
const getScaledAngle = function (line) {
  const scaledA = line.graphie.scalePoint(line.coord(0));
  const scaledZ = line.graphie.scalePoint(line.coord(1));
  return kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledZ, scaledA))[1];
};

// Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.
const getClipPoint = function (graph, coord, angle) {
  // Actually put the arrowheads 4px from the edge so they have
  // a bit of room
  const xExtent = graph.range[0][1] - graph.range[0][0];
  const yExtent = graph.range[1][1] - graph.range[1][0];

  // shoot a point off into the distance ...
  const distance = xExtent + yExtent;
  // we need to scale the point according to the scale of the axes
  const angleVec = graph.unscaleVector(kmath.vector.cartFromPolarDeg(1, angle));
  const distVec = kmath.vector.scale(kmath.vector.normalize(angleVec), distance);
  const farCoord = kmath.vector.add(coord, distVec);
  const scaledAngle = kmath.vector.polarDegFromCart(angleVec)[1];
  // ... and then bring it back
  const clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
  return clipPoint;
};

// Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.
const createArrow = function (graph, style) {
  // Points that define the arrowhead
  const center = [0.75, 0];
  let points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]];

  // Scale points by 1.4 around (0.75, 0)
  const scale = 1.4;
  points = ___default["default"].map(points, function (point) {
    const pv = kmath.vector.subtract(point, center);
    const pvScaled = kmath.vector.scale(pv, scale);
    return kmath.vector.add(center, pvScaled);
  });

  // We can't just pass in a path to `graph.fixedPath` as we need to modify
  // the points in some way, so instead we provide a function for creating
  // the path once the points have been transformed
  const createCubicPath = function (points) {
    let path = "M" + points[0][0] + " " + points[0][1];
    for (let i = 1; i < points.length; i += 3) {
      path += "C" + points[i][0] + " " + points[i][1] + " " + points[i + 1][0] + " " + points[i + 1][1] + " " + points[i + 2][0] + " " + points[i + 2][1];
    }
    return path;
  };

  // Create arrowhead
  const unscaledPoints = ___default["default"].map(points, graph.unscalePoint);
  const options = {
    center: graph.unscalePoint(center),
    createPath: createCubicPath
  };
  const arrowHead = new WrappedPath(graph, unscaledPoints, options);
  arrowHead.attr(___default["default"].extend({
    "stroke-linejoin": "round",
    "stroke-linecap": "round",
    "stroke-dasharray": ""
  }, style));

  // Add custom function for transforming arrowheads that accounts for
  // center, scaling, etc.
  arrowHead.toCoordAtAngle = function (coord, angle) {
    const clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
    arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + "translateZ(0) " + "rotate(" + (360 - KhanMath.bound(angle)) + "deg)");
  };
  return arrowHead;
};

/**
 * MovableLine option functions
 */
const add$2 = {
  // We do this in add as well as in standard so that we can call
  // pointsToFront after the first draw (which adds `this.visibleShape`)
  draw: function () {
    this.draw();
  },
  pointsToFront: function (state) {
    ___default["default"].invoke(state.points, "toFront");
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly draw: () => void; readonly pointsToFront: (state: any) => void; }'.
add$2.standard = [add$2.draw, add$2.pointsToFront];
const modify$2 = {
  draw: function () {
    this.draw();
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly draw: () => void; }'.
modify$2.standard = [modify$2.draw];
const draw$3 = {
  basic: function (state) {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const graphie = this.graphie;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'coord' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    let start = this.coord(0);
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'coord' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    let end = this.coord(1);

    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (!this.state.visibleShape) {
      const options = {
        thickness: 10
      };
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape = new WrappedLine(graphie, start, end, options);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.attr(this.normalStyle());
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.toFront();

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      if (this.mouseTarget()) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        this.mouseTarget().toFront();
      }
    }

    // Compute angle
    const angle = getScaledAngle(this);

    // Extend start, end if necessary (i.e., if not a line segment)
    if (state.extendLine) {
      start = getClipPoint(graphie, start, 360 - angle);
      end = getClipPoint(graphie, end, (540 - angle) % 360);
    } else if (state.extendRay) {
      end = getClipPoint(graphie, end, 360 - angle);
    }

    // Move elements
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const elements = [this.state.visibleShape];

    // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (this.mouseTarget()) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      elements.push(this.mouseTarget());
    }
    ___default["default"].each(elements, function (element) {
      element.moveTo(start, end);
    });
  },
  arrows: function (state) {
    // Create arrows, if not yet created
    // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
    if (this._arrows == null) {
      // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
      this._arrows = [];
      if (state.extendLine) {
        // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
        this._arrows.push(
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        createArrow(this.graphie, this.normalStyle()));
        // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
        this._arrows.push(
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        createArrow(this.graphie, this.normalStyle()));
      } else if (state.extendRay) {
        // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
        this._arrows.push(
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        createArrow(this.graphie, this.normalStyle()));
      }
    }

    // Transform arrows
    const angle = getScaledAngle(this);
    const angleForArrow = [360 - angle, (540 - angle) % 360];
    ___default["default"].each(
    // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. Did you mean 'arrows'?
    this._arrows, function (arrow, i) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      arrow.toCoordAtAngle(this.coord(i), angleForArrow[i]);
    }, this);
  },
  highlight: function (state, prevState) {
    // TODO(jack): Figure out a way to highlight the points attached to
    // the line. Maybe this means an additional isHovering: []
    // function to state of movable/movablepoint to define [additional?]
    // times it should be highlighted
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(state.highlightStyle, 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(state.normalStyle, 50);
    }
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: (state: any) => void; readonly arrows: (state: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
draw$3.standard = [draw$3.basic, draw$3.arrows, draw$3.highlight];
const remove$2 = {
  basic: function () {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'.
    if (this.state.visibleShape) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'.
      this.state.visibleShape.remove();
    }
  },
  arrows: function () {
    // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'. Did you mean 'arrows'?
    if (this._arrows != null) {
      // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'. Did you mean 'arrows'?
      ___default["default"].invoke(this._arrows, "remove");
    }
    // @ts-expect-error [FEI-5003] - TS2551 - Property '_arrows' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'. Did you mean 'arrows'?
    this._arrows = null;
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: () => void; readonly arrows: () => void; }'.
remove$2.standard = [remove$2.basic, remove$2.arrows];
const constraints$2 = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord, prevCoord) {
      if (snap === null) {
        return true;
      }
      let delta = kmath.vector.subtract(coord, prevCoord);
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      snap = snap || this.graphie.snap;
      delta = kmath.point.roundTo(delta, snap);
      return kmath.vector.add(prevCoord, delta);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }
    return function (coord, prevCoord) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const graphie = this.graphie;
      const delta = kmath.vector.subtract(coord, prevCoord);
      range = range || graphie.range;
      // A null snap means no snap; an undefined snap means
      // default to graphie's
      if (snap === undefined) {
        snap = graphie.snap;
      }

      // Calculate the bounds for both points
      let absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);
      if (snap) {
        absoluteLower = kmath.point.ceilTo(absoluteLower, snap);
        absoluteUpper = kmath.point.floorTo(absoluteUpper, snap);
      }

      // Calculate the bounds for the delta.
      const deltaBounds = ___default["default"].map(
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.coords(), function (coord, i) {
        const max = kmath.vector.subtract(absoluteUpper, coord);
        const min = kmath.vector.subtract(absoluteLower, coord);
        return [min, max];
      });

      // bound the delta by the calculated bounds
      const boundedDelta = ___default["default"].reduce(deltaBounds, function (delta, bound) {
        const lower = bound[0];
        const upper = bound[1];
        const deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        const deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);
      return kmath.vector.add(prevCoord, boundedDelta);
    };
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly fixed: () => () => boolean; readonly snap: (snap: any) => (arg1: Coord, arg2: Coord) => any; readonly bound: (range: any, snap: any, paddingPx: number) => (arg1: any, arg2: any) => any; }'.
constraints$2.standard = null;
const onMove$1 = {
  updatePoints: function (coord, prevCoord) {
    const actualDelta = kmath.vector.subtract(coord, prevCoord);
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly updatePoints: (coord: Coord, prevCoord: Coord) => void; }'.
    ___default["default"].each(this.state.points, function (point) {
      point.setCoord(kmath.vector.add(point.coord(), actualDelta));
    });
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly updatePoints: (coord: Coord, prevCoord: Coord) => void; }'.
onMove$1.standard = null;
var MovableLineOptions = {
  add: add$2,
  modify: modify$2,
  draw: draw$3,
  remove: remove$2,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$2,
  onMove: onMove$1,
  onMoveEnd: {
    standard: null
  }
};

/**
 * MovableLine
 */
const assert$8 = InteractiveUtil.assert;
const normalizeOptions$2 = InteractiveUtil.normalizeOptions;
const FUNCTION_ARRAY_OPTIONS$2 = ["add", "draw", "remove", "onMoveStart", "constraints", "onMove", "onMoveEnd"];

// Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.cursor() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".
const DEFAULT_PROPS$2 = {
  points: null,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  extendLine: false,
  extendRay: false
};
const DEFAULT_STATE$2 = {
  visibleShape: null,
  mouseTarget: null
};
const MovableLine$4 = function (graphie, movable, options) {
  assert$8(graphie != null);
  assert$8(options != null);

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movableLine")
    }
  });

  // We only set DEFAULT_STATE once, here
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.modify(___default["default"].extend({}, DEFAULT_STATE$2, options));
};
___default["default"].extend(MovableLine$4, MovableLineOptions);
InteractiveUtil.createGettersFor(MovableLine$4, ___default["default"].extend({}, DEFAULT_PROPS$2, DEFAULT_STATE$2));
InteractiveUtil.addMovableHelperMethodsTo(MovableLine$4);
___default["default"].extend(MovableLine$4.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), {
      coords: this.coords()
    }, this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2,
    // Defaults are copied from MovableLineOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovableLineOptions, "standard")), DEFAULT_PROPS$2);
  },
  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },
  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = this.graphie;
    const state = self.state = ___default["default"].extend(self.state, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2, options));

    // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPERTIES!)
    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({
      stroke: normalColor,
      "stroke-width": 2
    }, state.normalStyle);
    state.highlightStyle = ___default["default"].extend({
      stroke: KhanColors.INTERACTING,
      "stroke-width": 3
    }, state.highlightStyle);
    if (!state.static) {
      // the invisible shape in front of the line that gets mouse events
      if (!state.mouseTarget) {
        const options = {
          thickness: 30,
          mouselayer: true,
          interactiveKindForTesting: "movable-line"
        };
        state.mouseTarget = new WrappedLine(graphie, this.coord(0), this.coord(1), options);
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
    }
    if (state.static && state.mouseTarget) {
      // state.static was specified, remove any previously
      // existing mousetarget (from a previous modify)
      state.mouseTarget.remove();
      state.mouseTarget = null;
    }

    // The movable that handles mouse events for us
    self.movable.modify(___default["default"].extend({}, state, {
      mouseTarget: state.mouseTarget,
      // We null out the add/modify/remove to avoid propagating our
      // state.add... to the movable, so that we can fire those
      // events ourselves, rather than letting the movable handle
      // them
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function () {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];
        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function (mouseCoord, prevMouseCoord) {
        const delta = kmath.vector.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kmath.vector.add(self._totalDelta, delta);
        let refCoord = kmath.vector.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord);
        if (refCoord === false) {
          return;
        }
        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);
        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function () {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    }));

    // Trigger an add event if this hasn't been added before
    if (!state.added) {
      self.prevState = {};
      self._fireEvent(state.add, self.cloneState(), self.prevState);
      state.added = true;

      // Update the line with the points' movement
      ___default["default"].invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self));

      // Update the state for `added` and in case the add event
      // changed it
      self.prevState = self.cloneState();
    }

    // Trigger a modify event
    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  coords: function () {
    return ___default["default"].invoke(this.state.points, "coord");
  },
  point: function (index) {
    return this.state.points[index];
  },
  coord: function (index) {
    return this.point(index).coord();
  },
  remove: function () {
    this.state.added = false;
    this._fireEvent(this.state.remove);
    if (this.points) {
      ___default["default"].invoke(this.points, "unlisten", "onMove", this.state.id);
    }
    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    }
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();
    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }
    this.movable.toFront();
  },
  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  }
});

/* eslint-disable @babel/no-invalid-this */
const add$1 = {
  constrain: function () {
    this.constrain();
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly constrain: () => void; }'.
add$1.standard = [add$1.constrain];
const modify$1 = {
  draw: function () {
    this.draw();
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly draw: () => void; }'.
modify$1.standard = [modify$1.draw];
const draw$2 = {
  basic: function (state, prevState) {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const graphie = this.graphie;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (!this.state.visibleShape) {
      const radii = [
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'pointSize' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.pointSize() / graphie.scale[0],
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'pointSize' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.pointSize() / graphie.scale[1]];
      const options = {
        maxScale: Math.max(
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'highlightStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        this.highlightStyle().scale,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        this.normalStyle().scale),
        // Add in 10px of padding to avoid clipping at the edges.
        padding: 10,
        shadow: state.shadow
      };
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape = new WrappedEllipse(graphie,
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'coord' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.coord(),
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type '[number, number]'.
      radii, options);

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.attr(___default["default"].omit(this.normalStyle(), "scale"));
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.toFront();

      // Keep mouseTarget in front of visible shape
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      if (this.mouseTarget()) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        this.mouseTarget().toFront();
      }
    }
    if (state.normalStyle !== prevState.normalStyle && !___default["default"].isEqual(state.normalStyle, prevState.normalStyle)) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.attr(this.normalStyle());
    }

    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'coord' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    this.state.visibleShape.moveTo(this.coord());
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (this.mouseTarget()) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'coord' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.mouseTarget().moveTo(this.coord());
    }
  },
  highlight: function (state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'highlightStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
draw$2.standard = [draw$2.basic, draw$2.highlight];
const remove$1 = {
  basic: function () {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; }'.
    if (this.state.visibleShape) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; }'.
      this.state.visibleShape.remove();
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; }'.
      this.state.visibleShape = null;
    }
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: () => void; }'.
remove$1.standard = remove$1.basic;
const constraints$1 = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord) {
      if (snap === null) {
        // NOTE(kevinb): this should probably return the original point
        return true;
      }
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      snap = snap || this.graphie.snap;
      return kmath.point.roundTo(coord, snap);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }
    return function (coord, prev, options) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const graphie = this.graphie;
      range = range || graphie.range;
      if (snap === undefined) {
        snap = graphie.snap;
      }
      let lower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let upper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);
      if (snap) {
        lower = kmath.point.ceilTo(lower, snap);
        upper = kmath.point.floorTo(upper, snap);
      }
      if (!!options && !!options.onOutOfBounds) {
        if (coord[0] > upper[0] || coord[0] < lower[0] || coord[1] > upper[1] || coord[1] < lower[1]) {
          options.onSkipRemaining();
          options.onOutOfBounds();
        }
        return coord;
      }
      const coordX = Math.max(lower[0], Math.min(upper[0], coord[0]));
      const coordY = Math.max(lower[1], Math.min(upper[1], coord[1]));
      return [coordX, coordY];
    };
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly fixed: () => () => boolean; readonly snap: (snap: any) => (arg1: Coord) => unknown; readonly bound: (range: any, snap: any, paddingPx: number) => (arg1: Coord, arg2: Coord, arg3: any) => Coord; }'.
constraints$1.standard = null;
var MovablePointOptions = {
  add: add$1,
  modify: modify$1,
  draw: draw$2,
  remove: remove$1,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$1,
  onMove: {
    standard: null
  },
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};

const assert$7 = InteractiveUtil.assert;
const normalizeOptions$1 = InteractiveUtil.normalizeOptions;
const {
  processMath
} = Tex$1;

// State parameters that should be converted into an array of
// functions
const FUNCTION_ARRAY_OPTIONS$1 = ___default["default"].keys(MovablePointOptions);

// Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.coord() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".
const DEFAULT_PROPS$1 = {
  coord: [0, 0],
  pointSize: 4,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  shadow: false,
  tooltip: false
};
const DEFAULT_STATE$1 = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  outOfBounds: false,
  mouseTarget: null,
  touchOffset: null
};
const tooltipResetFunctions = [];
const MovablePoint$5 = function (graphie, movable, options) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie,
    movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movablePoint")
    }
  });

  // We only set DEFAULT_STATE once, here
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.modify(___default["default"].extend({}, DEFAULT_STATE$1, options));
};
___default["default"].extend(MovablePoint$5, MovablePointOptions);
InteractiveUtil.createGettersFor(MovablePoint$5, ___default["default"].extend({}, DEFAULT_PROPS$1, DEFAULT_STATE$1));
InteractiveUtil.addMovableHelperMethodsTo(MovablePoint$5);
___default["default"].extend(MovablePoint$5.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1,
    // Defaults are copied from MovablePointOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovablePointOptions, "standard")

    // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS$1);
  },
  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },
  /**
   * Displays a tooltip above the point, replacing any previous contents. If
   * there is no tooltip initialized, adds the tooltip.
   *
   * If the type of contents is string, the contents will be rendered with
   * KaTeX. Otherwise, the content will be assumed to be a DOM node and will
   * be appended inside the tooltip.
   */
  _showTooltip: function (contents) {
    if (!this._tooltip) {
      this._tooltip = document.createElement("div");
      this._tooltip.className = "tooltip-content";
      this.state.visibleShape.wrapper.className = "tooltip";
      this.state.visibleShape.wrapper.appendChild(this._tooltip);

      // Only one tooltip should be displayed at a time, so store a list
      // of all the tooltips initialized.
      tooltipResetFunctions.push(() => {
        if (this.state.added) {
          this._hideTooltip();
        }
      });
    }
    if (this._tooltip.firstChild) {
      this._tooltip.removeChild(this._tooltip.firstChild);
    }
    this.state.visibleShape.wrapper.className = "tooltip visible";
    this._tooltip.appendChild(document.createElement("span"));
    if (typeof contents === "string") {
      processMath(this._tooltip.firstChild, contents, false);
    } else if (typeof contents === "function") {
      contents(this._tooltip.firstChild);
    } else {
      this._tooltip.firstChild.appendChild(contents);
    }
  },
  _hideTooltip: function () {
    if (this._tooltip) {
      // Without the visible class, tooltips have display: none set
      this.state.visibleShape.wrapper.className = "tooltip";
    }
  },
  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;
    const state = ___default["default"].extend(self.state, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1, options));
    assert$7(kmath.point.is(state.coord));

    // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)
    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({
      fill: normalColor,
      stroke: normalColor,
      scale: 1
    }, state.normalStyle);
    state.highlightStyle = ___default["default"].extend({
      fill: KhanColors.INTERACTING,
      stroke: KhanColors.INTERACTING,
      scale: 2
    }, state.highlightStyle);
    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        const center = self.state.coord;
        const radii = graphie.unscaleVector(24);
        const options = {
          mouselayer: true,
          padding: 0,
          interactiveKindForTesting: "movable-point"
        };
        state.mouseTarget = new WrappedEllipse(graphie, center, radii, options);
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
    }
    const showTrashTooltip = () => {
      this._showTooltip(container => {
        render( /*#__PURE__*/React__namespace.createElement("span", {
          style: {
            fontSize: "2em"
          }
        }, /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconTrash, {
          style: {
            position: "static",
            color: KhanColors.INTERACTIVE,
            marginLeft: 9,
            marginRight: 9
          }
        }))), container);
      });
    };

    // The starting coord of any move, sent to onMoveEnd as the previous
    // value
    let startCoord = state.coord;

    // The Movable representing this movablePoint's representation
    // This handles mouse events for us, which we propagate in
    // onMove
    self.movable.modify(___default["default"].extend({}, state, {
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: startMouseCoord => {
        state.hasMoved = false;
        startCoord = state.coord;

        // Save the offset between the cursor and the initial coordinate
        // of the point. This is tracked so as to avoid locking the
        // moving point to the user's finger on touch devices, which
        // would obscure it, no matter how large we made the touch
        // target. Instead, we respect the offset at which the point was
        // grabbed for the entirety of the gesture, if it's a
        // touch-based interaction.
        if (state.touchOffset == null) {
          const isMouse = !("ontouchstart" in window);
          state.touchOffset = isMouse ? [0, 0] : kmath.vector.subtract(startCoord, startMouseCoord);
        }
        const svgElem = state.visibleShape.wrapper;
        if (state.shadow) {
          const filter = "none";
          svgElem.style.filter = filter;
        }
        if (state.showHairlines) {
          state.showHairlines(state.coord);
        }
        tooltipResetFunctions.forEach(f => f());
        if (state.tooltip) {
          if (state.xOnlyTooltip) {
            this._showTooltip("".concat(state.coord[0]));
          } else {
            this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
          }
          if (state.shadow) {
            const content = svgElem.getElementsByClassName("tooltip-content")[0];
            const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
            content.style.filter = filter;
          }
        }
        self._fireEvent(state.onMoveStart, startCoord, startCoord);
        self.draw();
      },
      onMove: (mouseCoord, prevMouseCoord) => {
        const transformedCoord = kmath.vector.add(mouseCoord, state.touchOffset);
        self.moveTo(transformedCoord);
        if (state.showHairlines) {
          if (!this.state.outOfBounds) {
            state.showHairlines(state.coord);
          } else {
            state.hideHairlines();
          }
        }
        if (state.tooltip) {
          if (!this.state.outOfBounds) {
            if (state.xOnlyTooltip) {
              this._showTooltip("".concat(state.coord[0]));
            } else {
              this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
            }
          }
        }
        if (state.onRemove && this.state.outOfBounds) {
          showTrashTooltip();
        }
      },
      onMoveEnd: () => {
        if (self.isHovering() && !state.hasMoved) {
          self._fireEvent(state.onClick, state.coord, startCoord);
        }
        const svgElem = state.visibleShape.wrapper;
        if (state.shadow) {
          const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
          svgElem.style.filter = filter;
        }
        if (state.hideHairlines) {
          state.hideHairlines();
        }
        if (state.hasMoved) {
          this._hideTooltip();
        } else if (state.onRemove) {
          // If we haven't moved and we should be displaying trash
          // tooltips.
          showTrashTooltip();
          const content = svgElem.getElementsByClassName("tooltip-content")[0];
          content.style.filter = "none";
          this._tooltip.firstChild.addEventListener("touchstart", e => {
            // Prevent creation of a new point when the event is
            // propagated up the DOM.
            e.stopPropagation();
          }, true);
          this._tooltip.firstChild.addEventListener("touchend", e => {
            // Remove the point and prevent creation of a
            // new point.
            state.onRemove();
            e.stopPropagation();
          }, true);
        } else if (state.tooltip) {
          this._hideTooltip();
        }
        if (state.outOfBounds) {
          state.onRemove();
        }
        self._fireEvent(state.onMoveEnd, state.coord, startCoord);
        state.hasMoved = false;
        state.touchOffset = null;
        self.draw();
      }
    }));

    // Trigger an add event if this hasn't been added before
    if (!state.added) {
      self.prevState = {};
      self._fireEvent(state.add, self.cloneState(), self.prevState);
      state.added = true;

      // Update the state for `added` and in case the add event
      // changed it
      self.prevState = self.cloneState();
    }

    // Trigger a modify event
    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function () {
    this.state.added = false;
    this._fireEvent(this.state.remove);
    if (this.movable) {
      this.movable.remove();
    }
    // TODO(jack): This should really be moved off of
    // movablePoint.state and only kept on movable.state
    this.state.mouseTarget = null;
  },
  constrain: function () {
    const result = this._applyConstraints(this.coord(), this.coord());
    if (kmath.point.is(result)) {
      this.setCoord(result);
    }
    return result !== false;
  },
  setCoord: function (coord) {
    assert$7(kmath.point.is(coord, 2));
    this.state.coord = ___default["default"].clone(coord);
    this.draw();
  },
  setCoordConstrained: function (coord) {
    assert$7(kmath.point.is(coord, 2));
    const result = this._applyConstraints(coord, this.coord());
    if (result !== false) {
      this.state.coord = ___default["default"].clone(result);
      this.draw();
    }
  },
  moveTo: function (coord) {
    // The caller has the option of adding an onMove() method to the
    // movablePoint object we return as a sort of event handler
    // By returning false from onMove(), the move can be vetoed,
    // providing custom constraints on where the point can be moved.
    // By returning array [x, y], the move can be overridden

    const state = this.state;
    this.state.outOfBounds = false;
    const result = this._applyConstraints(coord, state.coord, state.onRemove ? {
      onOutOfBounds: () => {
        this.state.outOfBounds = true;
      }
    } : {});
    if (result === false) {
      return;
    }
    if (kmath.point.is(result)) {
      coord = result;
    }
    if (!kmath.point.equal(coord, state.coord)) {
      const prevCoord = state.coord;
      state.coord = coord;
      state.hasMoved = true;
      this._fireEvent(state.onMove, state.coord, prevCoord);
      this.draw();
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function () {
    return ___default["default"].clone(this.state.normalStyle);
  },
  highlightStyle: function () {
    return ___default["default"].clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();
    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }
    this.movable.toFront();
  },
  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  },
  grab: function (coord) {
    // Provide an explicit touchOffset override, so that we track the user's
    // finger when a point has been grabbed.
    this.state.touchOffset = [0, 0];
    this.movable.grab(coord);
    this.moveTo(coord);
  }
});

/* eslint-disable @babel/no-invalid-this */
function sum(array) {
  return ___default["default"].reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}
function clockwise(points) {
  const segments = ___default["default"].zip(points, points.slice(1).concat(points.slice(0, 1)));
  const areas = ___default["default"].map(segments, function (segment) {
    const p1 = segment[0];
    const p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });
  return sum(areas) > 0;
}
const add = {
  constrain: function () {
    this.constrain();
  },
  pointsToFront: function (state) {
    ___default["default"].invoke(state.points, "toFront");
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly constrain: () => void; readonly pointsToFront: (state: any) => void; }'.
add.standard = [add.constrain, add.pointsToFront];
const modify = {
  draw: function () {
    this.draw();
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly draw: () => void; }'.
modify.standard = [modify.draw];
const draw$1 = {
  basic: function (state, prevState) {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const graphie = this.graphie;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'path' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const path = this.path(state);

    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (!this.state.visibleShape) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape = graphie.raphael.path(path);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.attr(this.normalStyle());
    }
    if (state.normalStyle !== prevState.normalStyle && !___default["default"].isEqual(state.normalStyle, prevState.normalStyle)) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.state.visibleShape.attr(this.normalStyle());
    }
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    this.state.visibleShape.attr({
      path: path
    });
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (this.mouseTarget()) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'mouseTarget' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      this.mouseTarget().attr({
        path: path
      });
    }
  },
  /* Labels are handled primarily by label objects, but sometimes require
   * extra movables, e.g., for the arcs drawn at labeled angles. These extra
   * movables are stored in the label cache. */
  labels: function (state, prevState) {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    const graphie = this.graphie;
    const self = this;
    const coords = ___default["default"].invoke(state.points, "coord");
    const isClockwise = clockwise(coords);
    const n = coords.length;

    // graphie.labelAngle and similar methods attempt to re-use the label
    // provided, which will have been stored on state._labeledAngles.
    // If they cannot re-use the label, they make a new one, which will
    // get stored on state._labelCache. These will all be cleared out when
    // we remove the polygon.
    // (This logic is borrowed from graphie:addMovablePolygon.)
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    if (self.state._labelCache != null) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      ___default["default"].invoke(self.state._labelCache, "remove");
    }
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    self.state._labelCache = [];

    // Update angle labels
    if (state.angleLabels.length || state.showRightAngleMarkers.length) {
      // Generate labels
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      if (self.state._labeledAngles == null) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labeledAngles = ___default["default"].times(Math.max(state.angleLabels.length, state.showRightAngleMarkers.length), function () {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      ___default["default"].each(self.state._labeledAngles, function (label, i) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labelCache.push(graphie.labelAngle({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.angleLabels[i],
          showRightAngleMarker: state.showRightAngleMarkers[i],
          numArcs: state.numArcs[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    }

    // Update side labels
    if (state.sideLabels.length) {
      // Generate labels
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      if (self.state._labeledSides == null) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labeledSides = ___default["default"].map(state.sideLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      ___default["default"].each(self.state._labeledSides, function (label, i) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labelCache.push(graphie.labelSide({
          point1: coords[i],
          point2: coords[(i + 1) % n],
          label: label,
          text: state.sideLabels[i],
          numArrows: state.numArrows[i],
          numTicks: state.numTicks[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    }

    // Update vertex labels
    if (state.vertexLabels.length) {
      // Generate labels
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      if (self.state._labeledVertices == null) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labeledVertices = ___default["default"].map(state.vertexLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      ___default["default"].each(self.state._labeledVertices, function (label, i) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
        self.state._labelCache.push(graphie.labelVertex({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.vertexLabels[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    }

    // graphie.labelVertex and its peer methods return an array of movables
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'. | TS2339 - Property 'state' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
    self.state._labelCache = ___default["default"].flatten(self.state._labelCache);
  },
  highlight: function (state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'highlightStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'normalStyle' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: (state: any, prevState: any) => void; readonly labels: (state: any, prevState: any) => void; readonly highlight: (state: any, prevState: any) => void; }'.
draw$1.standard = [draw$1.basic, draw$1.labels, draw$1.highlight];
const remove = {
  basic: function () {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
    if (this.state.visibleShape) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
      this.state.visibleShape.remove();
    }
  },
  labels: function () {
    const labels = [
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
    this.state._labeledSides,
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
    this.state._labeledVertices,
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
    this.state._labeledAngles,
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
    this.state._labelCache];
    ___default["default"].each(labels, function (labelType) {
      if (labelType != null && labelType.length) {
        ___default["default"].invoke(labelType, "remove");
      }
    });
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly basic: () => void; readonly labels: () => void; }'.
remove.standard = [remove.basic, remove.labels];
const constraints = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord) {
      if (snap === null) {
        // NOTE(kevin): this should probably return the original point
        return true;
      }
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      snap = snap || this.graphie.snap;
      return kmath.point.roundTo(coord, snap);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }
    return function (coord, prevCoord) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const graphie = this.graphie;
      const delta = kmath.vector.subtract(coord, prevCoord);
      range = range || graphie.range;
      // A null snap means no snap; an undefined snap means
      // default to graphie's
      if (snap === undefined) {
        snap = graphie.snap;
      }

      // Calculate the bounds for both points
      let absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);
      if (snap) {
        absoluteLower = kmath.point.ceilTo(absoluteLower, snap);
        absoluteUpper = kmath.point.floorTo(absoluteUpper, snap);
      }

      // Calculate the bounds for the delta.
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const deltaBounds = ___default["default"].map(this.coords(), function (coord, i) {
        const max = kmath.vector.subtract(absoluteUpper, coord);
        const min = kmath.vector.subtract(absoluteLower, coord);
        return [min, max];
      });

      // bound the delta by the calculated bounds
      const boundedDelta = ___default["default"].reduce(deltaBounds, function (delta, bound) {
        const lower = bound[0];
        const upper = bound[1];
        const deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        const deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);

      // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[]' is not assignable to type 'Coord'.
      return kmath.vector.add(prevCoord, boundedDelta);
    };
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly fixed: () => () => boolean; readonly snap: (snap: any) => (arg1: Coord) => unknown; readonly bound: (range: any, snap: any, paddingPx: number) => (arg1: Coord, arg2: Coord) => Coord; }'.
constraints.standard = null;
const onMove = {
  // @ts-expect-error [FEI-5003] - TS2355 - A function whose declared type is neither 'void' nor 'any' must return a value.
  updatePoints: function (coord, prevCoord) {
    const actualDelta = kmath.vector.subtract(coord, prevCoord);
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly updatePoints: (coord: Coord, prevCoord: Coord) => undefined; }'.
    ___default["default"].each(this.state.points, function (point) {
      point.setCoord(kmath.vector.add(point.coord(), actualDelta));
    });
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'standard' does not exist on type '{ readonly updatePoints: (coord: Coord, prevCoord: Coord) => undefined; }'.
onMove.standard = null;
var MovablePolygonOptions = {
  add: add,
  modify: modify,
  draw: draw$1,
  remove: remove,
  onMoveStart: {
    standard: null
  },
  constraints: constraints,
  onMove: onMove,
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};

/**
 * Creates and adds a polygon to the graph that can be dragged around.
 * It allows constraints on its movement and draws when moves happen.
 */
const assert$6 = InteractiveUtil.assert;
const normalizeOptions = InteractiveUtil.normalizeOptions;

// State parameters that should be converted into an array of
// functions
const FUNCTION_ARRAY_OPTIONS = ___default["default"].keys(MovablePolygonOptions);

// Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.points() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".
const DEFAULT_PROPS = {
  points: null,
  angleLabels: [],
  showRightAngleMarkers: [],
  sideLabels: [],
  vertexLabels: [],
  numArcs: [],
  numArrows: [],
  numTicks: [],
  closed: true,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  labelStyle: null // likewise
};

const DEFAULT_STATE = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  mouseTarget: null
};
const MovablePolygon = function (graphie, movable, options) {
  assert$6(graphie != null);
  assert$6(options != null);

  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  ___default["default"].extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movablePolygon")
    }
  });

  // We only set DEFAULT_STATE once, here
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.modify(___default["default"].extend({}, DEFAULT_STATE, options));
};
___default["default"].extend(MovablePolygon, MovablePolygonOptions);
InteractiveUtil.createGettersFor(MovablePolygon, ___default["default"].extend({}, DEFAULT_PROPS, DEFAULT_STATE));
InteractiveUtil.addMovableHelperMethodsTo(MovablePolygon);
___default["default"].extend(MovablePolygon.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions(FUNCTION_ARRAY_OPTIONS,
    // Defaults are copied from MovablePolygonOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovablePolygonOptions, "standard")

    // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS);
  },
  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },
  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;
    const state = ___default["default"].extend(self.state, normalizeOptions(FUNCTION_ARRAY_OPTIONS, options));

    // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)
    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({}, state.normalStyle, {
      "stroke-width": 2,
      "fill-opacity": 0,
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle);
    state.highlightStyle = ___default["default"].extend({}, {
      stroke: KhanColors.INTERACTING,
      "stroke-width": 2,
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.05
    }, state.highlightStyle);
    state.labelStyle = ___default["default"].extend({}, {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    }, state.labelStyle);
    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        state.mouseTarget = graphie.mouselayer.path(this.path());
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0,
          cursor: "move"
        });
      }
    }

    // The Movable representing this MovablePolygon's representation
    // This handles mouse events for us, which we propagate in
    // onMove. The onMoveStart-onMove-onMoveEnd logic is borrowed from
    // movable-line.js.
    self.movable.modify(___default["default"].extend({}, state, {
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function () {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];
        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function (mouseCoord, prevMouseCoord) {
        const delta = kmath.vector.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kmath.vector.add(self._totalDelta, delta);
        let refCoord = kmath.vector.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord);
        if (refCoord === false) {
          return;
        }
        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);
        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function () {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    }));

    // Update the polygon with the points' movement
    ___default["default"].invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self));

    // Trigger an add event if this hasn't been added before
    if (!state.added) {
      self.prevState = {};
      self._fireEvent(state.add, self.cloneState(), self.prevState);
      state.added = true;

      // Update the state for `added` and in case the add event
      // changed it
      self.prevState = self.cloneState();
    }

    // Trigger a modify event
    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  path: function (state) {
    const graphie = this.graphie;
    state = state || this.state;
    let coords = ___default["default"].map(state.points, function (point) {
      return graphie.scalePoint(point.coord());
    });

    // Create path
    if (state.closed) {
      coords.push(true);
    } else {
      // For open polygons, concatenate a reverse of the path,
      // to remove the inside area of the path, which would
      // otherwise be clickable (even if the closing line segment
      // wasn't drawn
      coords = coords.concat(___default["default"].clone(coords).reverse());
    }
    return GraphUtils.unscaledSvgPath(coords);
  },
  coords: function () {
    return ___default["default"].invoke(this.state.points, "coord");
  },
  point: function (index) {
    return this.state.points[index];
  },
  coord: function (index) {
    return this.point(index).coord();
  },
  remove: function () {
    this.state.added = false;
    this._fireEvent(this.state.remove);
    if (this.state.points) {
      ___default["default"].invoke(this.state.points, "unlisten", "onMove", this.state.id);
    }
    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    }

    // TODO(jack): This should really be moved off of
    // movablePolygon.state and only kept on movable.state
    this.state.mouseTarget = null;
  },
  constrain: function () {
    if (this.points == null || this.points.length === 0) {
      return;
    }
    const prevRefCoord = this.coord(0);
    const refCoord = this._applyConstraints(prevRefCoord, prevRefCoord);
    if (refCoord !== false) {
      this._fireEvent(this.state.onMove, refCoord, prevRefCoord);
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function () {
    return ___default["default"].clone(this.state.normalStyle);
  },
  highlightStyle: function () {
    return ___default["default"].clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();
    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }
    this.movable.toFront();
  },
  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  }
});

const Interactive2 = {
  MovablePoint: MovablePoint$5,
  addMovablePoint: function (graphie, options) {
    // @ts-expect-error [FEI-5003] - TS2350 - Only a void function can be called with the 'new' keyword.
    const movable = new Movable(graphie, {});
    return new MovablePoint$5(graphie, movable, options);
  },
  MovableLine: MovableLine$4,
  addMovableLine: function (graphie, options) {
    // @ts-expect-error [FEI-5003] - TS2350 - Only a void function can be called with the 'new' keyword.
    const movable = new Movable(graphie, {});
    return new MovableLine$4(graphie, movable, options);
  },
  MovablePolygon: MovablePolygon,
  addMovablePolygon: function (graphie, options) {
    // @ts-expect-error [FEI-5003] - TS2350 - Only a void function can be called with the 'new' keyword.
    const movable = new Movable(graphie, {});
    return new MovablePolygon(graphie, movable, options);
  },
  addMaybeMobileMovablePoint: function (widget, extraProps) {
    const isMobile = widget.props.apiOptions.isMobile;
    const commonStyle = isMobile ? {
      stroke: "#ffffff",
      "stroke-width": 3,
      fill: KhanColors.INTERACTIVE
    } : {
      stroke: KhanColors.INTERACTIVE,
      fill: KhanColors.INTERACTIVE
    };
    const normalStyle = Object.assign(commonStyle, extraProps.normalStyle);
    const highlightStyle = Object.assign(isMobile ? {
      ...commonStyle,
      "stroke-width": 0,
      scale: 0.75
    } : {}, extraProps.highlightStyle);
    const props = Object.assign({
      normalStyle: normalStyle,
      highlightStyle: highlightStyle,
      shadow: isMobile,
      tooltip: isMobile && widget.props.showTooltips,
      showHairlines: widget.showHairlines,
      hideHairlines: widget.hideHairlines
    }, isMobile ? {
      pointSize: 7
    } : {});
    return Interactive2.addMovablePoint(widget.graphie, Object.assign(extraProps, props));
  }
};

const MovablePoint$4 = GraphieClasses.createClass({
  displayName: "MovablePoint",
  movableProps: ["children"],
  _getProps: function () {
    if (this.props.isMobile) {
      const isMobile = this.props.isMobile;

      // TODO(kevinb) precompute commonStyle and commonMobileStyle
      const commonStyle = isMobile ? {
        stroke: "#ffffff",
        "stroke-width": 3,
        fill: KhanColors.INTERACTIVE
      } : {
        stroke: KhanColors.INTERACTIVE,
        fill: KhanColors.INTERACTIVE
      };

      // TODO(kevinb) precompute normalStyle and normalMobileStyle
      const normalStyle = isMobile ? Object.assign(commonStyle, this.props.mobileStyleOverride || {}) : Object.assign(commonStyle, this.props.normalStyle);

      // TODO(kevinb) precompute highlightStyle and highlightMobileStyle
      const highlightStyle = isMobile ? {
        ...commonStyle,
        "stroke-width": 0,
        scale: 0.75
      } : this.props.highlightStyle;
      /* eslint-enable indent */

      const addedProps = Object.assign({
        normalStyle: normalStyle,
        highlightStyle: highlightStyle,
        shadow: isMobile,
        tooltip: isMobile && this.props.showTooltips
      }, isMobile ? {
        pointSize: 7
      } : {});
      return Object.assign(this.props, addedProps);
    }
    return this.props;
  },
  add: function (graphie) {
    this.point = Interactive2.addMovablePoint(graphie, this._getProps());
  },
  modify: function () {
    this.point.modify(this._getProps());
  },
  remove: function () {
    this.point.remove();
  },
  toFront: function () {
    this.point.toFront();
  },
  grab: function (coord) {
    this.point.grab(coord);
  }
});

// Include helper methods, such as MovablePoint.constrain.snap()
___default["default"].extend(MovablePoint$4, Interactive2.MovablePoint);
const MovableLine$3 = GraphieClasses.createClass({
  displayName: "MovableLine",
  movableProps: ["children"],
  add: function (graphie) {
    // Add MovablePoint children
    const points = ___default["default"].pluck(this.props.children, "point");
    const props = ___default["default"].extend({}, this.props, {
      points: points
    });
    this.line = Interactive2.addMovableLine(graphie, props);
  },
  modify: function () {
    // Add MovablePoint children
    const points = ___default["default"].pluck(this.props.children, "point");
    const props = ___default["default"].extend({}, this.props, {
      points: points
    });
    this.line.modify(props);
  },
  remove: function () {
    this.line.remove();
  },
  toFront: function () {
    this.line.toFront();
  }
});

// Include helper methods, such as MovableLine.constrain.snap()
___default["default"].extend(MovableLine$3, Interactive2.MovableLine);
const Label$2 = GraphieClasses.createSimpleClass((graphie, props) => {
  let coord = props.coord;
  if (props.unscaled) {
    coord = graphie.unscalePoint(coord);
  }
  let elem = null;
  // If the label is rendered for a locale other than "en", push the label
  // element to an array. This array is used to lookup the label element
  // and processed with jipt('just in place translation', crowdin specific
  // program) to replace the passed in crowdin string with the translated
  // string. For "en" locale, the jipt processing is skipped.
  if (getDependencies().JIPT.useJIPT) {
    elem = graphie.label(coord, props.text, props.direction, false, props.style);
    getDependencies().graphieMovablesJiptLabels.addLabel(elem, props.tex);
  } else {
    elem = graphie.label(coord, props.text, props.direction, props.tex, props.style);
  }
  return elem;
});
const Line$3 = GraphieClasses.createClass({
  displayName: "Line",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.line = this.graphie.line(props.start, props.end, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgPath([props.start, props.end]);
    this.line.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.line.remove();
  },
  toFront: function () {
    this.line.toFront();
  }
});
const Parabola = GraphieClasses.createClass({
  displayName: "Parabola",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.parabola = this.graphie.parabola(props.a, props.b, props.c, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgParabolaPath(props.a, props.b, props.c);
    this.parabola.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.parabola.remove();
  },
  toFront: function () {
    this.parabola.toFront();
  }
});
const Sinusoid$1 = GraphieClasses.createClass({
  displayName: "Sinusoid",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.sinusoid = this.graphie.sinusoid(props.a, props.b, props.c, props.d, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgSinusoidPath(props.a, props.b, props.c, props.d);
    this.sinusoid.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.sinusoid.remove();
  },
  toFront: function () {
    this.sinusoid.toFront();
  }
});
const Plot$2 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.plot(props.fn, props.range, props.style);
});
const PlotParametric$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.plotParametric(props.fn, props.range, props.style);
});
const Point$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.ellipse(props.coord, graphie.unscaleVector([4, 4]), {
    fill: props.color || KhanColors.BLACK,
    stroke: props.color || KhanColors.BLACK
  });
});
const Path$1 = GraphieClasses.createClass({
  displayName: "Path",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.path = this.graphie.path(props.coords, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgPath(props.coords);
    this.path.attr({
      path: path
    });
  },
  remove: function () {
    this.path.remove();
  },
  toFront: function () {
    this.path.toFront();
  }
});
const Arc$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  let center = props.center;
  let radius = props.radius;
  if (props.unscaled) {
    center = graphie.unscalePoint(center);
    radius = graphie.unscaleVector(radius);
  }
  return graphie.arc(center, radius, props.startAngle, props.endAngle, props.sector, props.style);
});
const Circle$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.circle(props.center, props.radius, props.style);
});
const Rect$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.rect(props.x, props.y, props.width, props.height, props.style);
});
var Movables = {
  Arc: Arc$1,
  Circle: Circle$1,
  Label: Label$2,
  Line: Line$3,
  MovableLine: MovableLine$3,
  MovablePoint: MovablePoint$4,
  Parabola: Parabola,
  Path: Path$1,
  Plot: Plot$2,
  PlotParametric: PlotParametric$1,
  Point: Point$1,
  Sinusoid: Sinusoid$1,
  Rect: Rect$1
};

const GraphieMovable = GraphieClasses.GraphieMovable;
const createGraphie = GraphUtils.createGraphie;
const {
  deepEq: deepEq$3,
  nestedMap
} = Util;
const {
  assert: assert$5
} = InteractiveUtil;
class Graphie extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "graphieDivRef", /*#__PURE__*/React__namespace.createRef());
    _defineProperty(this, "getGraphie", () => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_graphie' does not exist on type 'Graphie'.
      return this._graphie;
    });
    _defineProperty(this, "_range", () => {
      const boundsCheckRange = range => {
        if (range[0] >= range[1]) {
          return [-10, 10];
        }
        return range;
      };
      return [boundsCheckRange(this.props.range[0]), boundsCheckRange(this.props.range[1])];
    });
    _defineProperty(this, "_box", () => {
      const ensureMinSize = pixelDim => {
        // 340 = default size in the editor. exact value
        // is arbitrary; this is just a safety check.
        return pixelDim > 0 ? pixelDim : 340;
      };
      return [ensureMinSize(this.props.box[0]), ensureMinSize(this.props.box[1])];
    });
    _defineProperty(this, "_scale", () => {
      const box = this._box();
      const range = this._range();
      return ___default["default"].map(box, (pixelDim, i) => {
        const unitDim = range[i][1] - range[i][0];
        return pixelDim / unitDim;
      });
    });
    _defineProperty(this, "_setupGraphie", () => {
      this._removeMovables();
      const graphieDiv = ReactDOM__default["default"].findDOMNode(this.graphieDivRef.current);
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'empty' does not exist on type 'JQueryStatic'.
      $__default["default"](graphieDiv).empty();
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_graphie' does not exist on type 'Graphie'.
      const graphie = this._graphie = createGraphie(graphieDiv);

      // This has to be called before addMouseLayer. You can re-init
      // with graphInit later if you prefer
      graphie.init({
        range: this._range(),
        scale: this._scale(),
        isMobile: this.props.isMobile
      });
      // Only add the mouselayer if we actually want one.
      if (this.props.addMouseLayer) {
        graphie.addMouseLayer({
          onClick: this.props.onClick,
          onMouseDown: this.props.onMouseDown,
          onMouseUp: this.props.onMouseUp,
          onMouseMove: this.props.onMouseMove,
          setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
        });
      }
      graphie.snap = this.props.options.snapStep || [1, 1];
      if (this.props.responsive) {
        // Overwrite fixed styles set in init()
        // TODO(alex): Either make this component always responsive by
        // itself, or always wrap it in other components so that it is.
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2554 - Expected 2 arguments, but got 1.
        $__default["default"](graphieDiv).css({
          width: "100%",
          height: "100%"
        });
        graphie.raphael.setSize("100%", "100%");
      }
      this.props.setup(graphie, ___default["default"].extend({
        range: this._range(),
        scale: this._scale()
      }, this.props.options));
    });
    _defineProperty(this, "_removeMovables", () => {
      // _.invoke works even when this._movables is undefined
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_movables' does not exist on type 'Graphie'.
      ___default["default"].invoke(this._movables, "remove");
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_movables' does not exist on type 'Graphie'.
      this._movables = {};
    });
    _defineProperty(this, "_renderMovables", (children, options) => {
      // Each leaf of `children` is a movable descriptor created by a call to
      // some `GraphieMovable`, such as `MovablePoint`.
      //
      // This function takes these descriptors and renders them into
      // on-screen movables, or updates on-screen movables for
      // descriptors when possible.
      //
      // If there is no movable with that key already, this descriptor is
      // stored in this._movables and promoted to an on-screen movable by
      // calling `child.add(graphie)`.
      //
      // If a movable of the same type with the same key exists already,
      // we take `child.props` and give them to the already-existing
      // on-screen movable, and call `movable.modify()`

      const graphie = options.graphie;
      const oldMovables = options.oldMovables;
      const newMovables = options.newMovables; /* output parameter */

      const renderChildren = elem => {
        ___default["default"].each(elem.movableProps, prop => {
          // Render the children, and save the results of that
          // render to the appropriate props
          elem.props[prop] = this._renderMovables(elem.props[prop], options);
        });
      };

      // Add/modify movables

      // We want to keep track of whether we have added a new svg element,
      // because if we have, then we need to call .toFront() on any svg
      // elements occurring afterwards. If this happens, we set
      // `areMovablesOutOfOrder` to true:
      let areMovablesOutOfOrder = false;
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 3 arguments, but got 2.
      return nestedMap(children, childDescriptor => {
        if (!childDescriptor) {
          // Still increment the key to avoid cascading key changes
          // on hiding/unhiding children, i.e. by using
          // {someBoolean && <MovablePoint />}
          options.nextKey++;
          // preserve the null/undefined in the resulting array
          return childDescriptor;
        }

        // Instantiate the descriptor to turn it into a real Movable
        const child = new childDescriptor.type(childDescriptor.props);
        assert$5(child instanceof GraphieMovable, "All children of a Graphie component must be Graphie " + "movables");

        // Give each child a key
        const keyProp = childDescriptor.key;
        const key = keyProp == null ? "_no_id_" + options.nextKey : keyProp;
        options.nextKey++;
        const ref = childDescriptor.ref;

        // We render our children first. This allows us to replace any
        // `movableProps` on our child with the on-screen movables
        // corresponding with those descriptors.
        renderChildren(child);
        const prevMovable = oldMovables[key];
        if (!prevMovable) {
          // We're creating a new child
          child.add(graphie);
          areMovablesOutOfOrder = true;
          newMovables[key] = child;
        } else if (child.constructor === prevMovable.constructor) {
          // We're updating an old child
          prevMovable.props = child.props;
          const modifyResult = prevMovable.modify(graphie);
          if (modifyResult === "reordered") {
            areMovablesOutOfOrder = true;
          }
          newMovables[key] = prevMovable;
        } else {
          // We're destroying an old child and replacing it
          // with a new child of a different type

          // This generally is a bad idea, so warn about it if this
          // is being caused by implicit keys
          if (keyProp == null) {
            Log.error("Replacing a <Graphie> child with a " + "child of a different type. Please add keys " + "to your <Graphie> children", Errors.Internal);
          }
          prevMovable.remove();
          child.add(graphie);
          areMovablesOutOfOrder = true;
          newMovables[key] = child;
        }
        if (areMovablesOutOfOrder) {
          newMovables[key].toFront();
        }
        if (ref) {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'movables' does not exist on type 'Graphie'.
          this.movables[ref] = newMovables[key];
        }
        return newMovables[key];
      });
    });
    _defineProperty(this, "_updateMovables", () => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_graphie' does not exist on type 'Graphie'.
      const graphie = this._graphie;

      // @ts-expect-error [FEI-5003] - TS2339 - Property '_movables' does not exist on type 'Graphie'.
      const oldMovables = this._movables;
      const newMovables = {};
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_movables' does not exist on type 'Graphie'.
      this._movables = newMovables;
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'movables' does not exist on type 'Graphie'.
      this.movables = {};

      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'ReactNode' is not assignable to parameter of type 'readonly any[]'.
      this._renderMovables(this.props.children, {
        nextKey: 1,
        graphie: graphie,
        oldMovables: oldMovables,
        newMovables: newMovables
      });

      // Remove any movables that no longer exist in the child array
      ___default["default"].each(oldMovables, (oldMovable, key) => {
        if (!newMovables[key]) {
          oldMovable.remove();
        }
      });
    });
  }
  componentDidMount() {
    this._setupGraphie();
    this._updateMovables();
  }
  shouldComponentUpdate(nextProps) {
    // NOTE(jeresig): Prior to the React 16 upgrade this was using deepEq
    // However it started to throw errors. I switched to use Underscore's
    // isEqual method instead, hopefully having a similar effect.
    return !___default["default"].isEqual(this.props, nextProps);
  }
  componentDidUpdate(prevProps) {
    // If someone changes the setup function passed in, we should
    // technically setup graphie again. But that's definitely an
    // anti-pattern, since it is most-likely caused by passing in an
    // anonymous function rather than a "real" change, and re-rendering
    // in that case would cause us to constantly re-setup graphie, which
    // would have horrible performance implications. In order to avoid
    // those, we just warn here.
    if (this.props.setup !== prevProps.setup) {
      Log.error("<Graphie> was given a new setup function. " + "This is a bad idea; please refactor your code to give " + "the same setup function reference to <Graphie> on " + "every render.", Errors.Internal);
    }
    if (!deepEq$3(this.props.options, prevProps.options) || !deepEq$3(this.props.box, prevProps.box) || !deepEq$3(this.props.range, prevProps.range)) {
      this._setupGraphie();
    }
    this._updateMovables();
  }

  /**
   * Allow parents of the <Graphie> component to grab a reference to the
   * underlying graphie object using
   * `this.refs.graphieComponent.getGraphie()`
   *
   * This shouldn't be necessary for 90% of cases, but the power is there.
   * Use it for good and not evil.
   */

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: this.graphieDivRef
    }));
  }
}

// Attach Graphie.createClass and Graphie.createSimpleClass
_defineProperty(Graphie, "defaultProps", {
  range: [[-10, 10], [-10, 10]],
  options: {},
  responsive: false,
  addMouseLayer: true
});
___default["default"].extend(Graphie, GraphieClasses);
// Attach the Movable react components for easy reference
___default["default"].extend(Graphie, Movables);

const Status = {
  PENDING: "pending",
  LOADING: "loading",
  LOADED: "loaded",
  FAILED: "failed"
};
class ImageLoader extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "img", void 0);
    _defineProperty(this, "createLoader", () => {
      this.destroyLoader(); // We can only have one loader at a time.

      this.img = new Image();
      this.img.onload = this.handleLoad;
      this.img.onerror = this.handleError;
      this.img.src = this.props.src;
    });
    _defineProperty(this, "destroyLoader", () => {
      if (this.img) {
        this.img.onload = null;
        this.img.onerror = null;
        this.img = null;
      }
    });
    _defineProperty(this, "handleLoad", event => {
      this.destroyLoader();
      this.setState({
        status: Status.LOADED
      });
      if (this.props.onLoad) {
        this.props.onLoad(event);
      }
    });
    _defineProperty(this, "handleError", error => {
      this.destroyLoader();
      this.setState({
        status: Status.FAILED
      });
      if (this.props.onError) {
        this.props.onError(error);
      }
    });
    _defineProperty(this, "renderImg", () => {
      const {
        src,
        imgProps
      } = this.props;
      let onKeyUp = null;
      let onKeyDown = null;
      if (imgProps.onClick != null) {
        // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: React.KeyboardEvent) => void' is not assignable to type 'null'.
        onKeyUp = e => {
          // 13 is enter key, 32 is space key
          if (e.keyCode === 13 || e.keyCode === 32) {
            imgProps.onClick && imgProps.onClick(e);
          }
        };
        // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: React.KeyboardEvent) => void' is not assignable to type 'null'.
        onKeyDown = e => {
          // 32 is space key
          if (e.keyCode === 32) {
            // don't scroll on space when the image is focused
            e.preventDefault();
          }
        };
      }
      const staticUrl = getDependencies().staticUrl;
      return /*#__PURE__*/React__namespace.createElement("img", _extends({
        src: staticUrl(src)
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'KeyboardEventHandler<HTMLImageElement> | undefined'.
        ,
        onKeyUp: onKeyUp
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'KeyboardEventHandler<HTMLImageElement> | undefined'.
        ,
        onKeyDown: onKeyDown
      }, imgProps));
    });
    this.state = {
      status: props.src ? Status.LOADING : Status.PENDING
    };
  }
  componentDidMount() {
    if (this.state.status === Status.LOADING) {
      this.createLoader();
    }
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        status: nextProps.src ? Status.LOADING : Status.PENDING
      });
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.state.status === Status.LOADING && !this.img) {
      this.createLoader();
    }
    if (prevState.status !== this.state.status) {
      this.props.onUpdate(this.state.status);
    }
  }
  componentWillUnmount() {
    this.destroyLoader();
  }
  render() {
    switch (this.state.status) {
      case Status.LOADED:
        return this.renderImg();
      case Status.FAILED:
        if (this.props.children) {
          return this.props.children;
        }
        break;
      default:
        if (this.props.preloader) {
          return this.props.preloader();
        }
    }
    return null;
  }
}

// Minimum image width to make an image appear as zoomable.
const ZOOMABLE_THRESHOLD = 700;

// The global cache of label data. Its format is:
// {
//   hash (e.g. "c21435944d2cf0c8f39d9059cb35836aa701d04a"): {
//     loaded: a boolean of whether the data has been loaded or not
//     dataCallbacks: a list of callbacks to call with the data when the data
//                    is loaded
//     data: the other data for this hash
//   },
//   ...
// }
const labelDataCache = {};

// Write our own JSONP handler because all the other ones don't do things we
// need.
const doJSONP = function (url, options) {
  options = {
    callbackName: "callback",
    success: $__default["default"].noop,
    error: $__default["default"].noop,
    ...options
  };

  // Create the script
  const script = document.createElement("script");
  script.setAttribute("async", "");
  script.setAttribute("src", url);

  // A cleanup function to run when we're done.
  function cleanup() {
    document.head && document.head.removeChild(script);
    delete window[options.callbackName];
  }

  // Add the global callback.
  // @ts-expect-error [FEI-5003] - TS2740 - Type '() => void' is missing the following properties from type 'Window': clientInformation, closed, customElements, devicePixelRatio, and 206 more.
  window[options.callbackName] = function () {
    cleanup();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    options.success.apply(null, args);
  };

  // Add the error handler.
  script.addEventListener("error", function () {
    cleanup();
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    options.error.apply(null, args);
  });

  // Insert the script to start the download.
  document.head && document.head.appendChild(script);
};

// For offline exercises in the mobile app, we download the graphie data
// (svgs and localized data files) and serve them from the local file
// system (with file://). We replace urls that start with `web+graphie`
// in the perseus json with this `file+graphie` prefix to indicate that
// they should have the `file://` protocol instead of `https://`.
const svgLocalLabelsRegex = /^file\+graphie\:/;
const hashRegex = /\/([^/]+)$/;
function isImageProbablyPhotograph(imageUrl) {
  // TODO(david): Do an inventory to refine this heuristic. For example, what
  //     % of .png images are illustrations?
  return /\.(jpg|jpeg)$/i.test(imageUrl);
}
function getLocale() {
  const {
    JIPT,
    kaLocale
  } = getDependencies();
  return JIPT.useJIPT ? "en-pt" : kaLocale;
}
function shouldUseLocalizedData() {
  return getLocale() !== "en";
}

// A regex to split at the last / of a URL, separating the base part from the
// hash. This is used to create the localized label data URLs.
const splitHashRegex = /\/(?=[^/]+$)/;
function getLocalizedDataUrl(url) {
  // For local (cached) graphie images, they are already localized.
  if (svgLocalLabelsRegex.test(url)) {
    return Util.getDataUrl(url);
  }
  const [base, hash] = Util.getBaseUrl(url).split(splitHashRegex);
  return "".concat(base, "/").concat(getLocale(), "/").concat(hash, "-data.json");
}

// Get the hash from the url, which is just the filename
function getUrlHash(url) {
  const match = url.match(hashRegex);
  if (match == null) {
    throw new PerseusError("not a valid URL", Errors.InvalidInput);
  }
  return match && match[1];
}
function defaultPreloader(dimensions) {
  return /*#__PURE__*/React__namespace.createElement("span", {
    style: {
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      position: "absolute",
      minWidth: "20px",
      display: "flex",
      justifyContent: "center",
      alignContent: "center"
    }
  }, /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, {
    size: "medium"
  }));
}
class SvgImage extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_isMounted", void 0);
    _defineProperty(this, "onDataLoaded", (data, localized) => {
      if (this._isMounted && data.labels && data.range) {
        const labelsRendered = data.labels.reduce((dict, label) => ({
          ...dict,
          [label.content]: false
        }), {});
        this.setState({
          dataLoaded: true,
          labelDataIsLocalized: localized,
          labelsRendered,
          labels: data.labels,
          range: data.range
        });
      }
    });
    _defineProperty(this, "onImageLoad", () => {
      // Only need to do this if rendering a Graphie
      if (this.sizeProvided()) {
        // If width and height are provided, we don't need to calculate the
        // size ourselves
        this.setState({
          imageLoaded: true
        });
      } else {
        Util.getImageSize(this.props.src, (width, height) => {
          if (this._isMounted) {
            this.setState({
              imageLoaded: true,
              imageDimensions: [width, height]
            });
          }
        });
      }
    });
    _defineProperty(this, "setupGraphie", (graphie, options) => {
      ___default["default"].map(options.labels, labelData => {
        const {
          JIPT
        } = getDependencies();
        if (JIPT.useJIPT && this.state.labelDataIsLocalized) {
          // If we're using JIPT translation and we got proper JIPT tags,
          // render the labels as plain text (so JIPT can find them) and
          // add some extra properties to the element so we can properly
          // re-render the label once it is replaced with translated
          // text.
          const elem = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, false);
          getDependencies().svgImageJiptLabels.addLabel(elem, labelData.typesetAsMath);
        } else if (labelData.coordinates) {
          // Create labels from the data
          // TODO(charlie): Some erroneous labels are being sent down
          // without coordinates. They don't seem to have any content, so
          // it seems fine to just ignore them (rather than error), but
          // we should figure out why this is happening.
          const label = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, labelData.typesetAsMath, {
            "font-size": 100 * this.props.scale + "%"
          });

          // Convert absolute positioning css from pixels to percentages
          // TODO(alex): Dynamically resize font-size as well. This
          // almost certainly means listening to throttled window resize
          // events.
          const labelStyle = label[0].style;
          let labelTop = this._tryGetPixels(labelStyle.top);
          let labelLeft = this._tryGetPixels(labelStyle.left);
          if (labelTop === null || labelLeft === null) {
            // Graphie labels are supposed to have an explicit position,
            // but to be on the safe side, let's fall back to using
            // jQuery's position(). The reason we're not always using
            // this is that in the presence of CSS transforms, it will
            // give the rendered position, which may be scaled and
            // not equal to the explicitly specified one.
            const labelPosition = label.position();
            labelTop = labelPosition.top;
            labelLeft = labelPosition.left;
          }
          const svgHeight = (this.props.height || 0) * this.props.scale;
          const svgWidth = (this.props.width || 0) * this.props.scale;
          label.css({
            // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
            top: labelTop / svgHeight * 100 + "%",
            // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
            left: labelLeft / svgWidth * 100 + "%"
          });

          // Add back the styles to each of the labels
          ___default["default"].each(labelData.style, (styleValue, styleName) => {
            label.css(styleName, styleValue);
          });
        }
        this.setState({
          labelsRendered: {
            ...this.state.labelsRendered,
            [labelData.content]: true
          }
        });
      });
    });
    _defineProperty(this, "_handleZoomClick", e => {
      const $image = $__default["default"](e.target);

      // It's possible that the image is already displayed at its
      // full size, but we don't really know that until we get a chance
      // to measure it (just now, after the user clicks). We only zoom
      // if there's more image to be shown.
      //
      // TODO(kevindangoor) If the window is narrow and the image is
      // already displayed as wide as possible, we may want to do
      // nothing in that case as well. Figuring this out correctly
      // likely required accounting for the image alignment and margins.
      if (
      // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
      $image.width() < this.props.width || this.props.zoomToFullSizeOnMobile) {
        ZoomService.handleZoomClick(e, this.props.zoomToFullSizeOnMobile);
      }
      this.props.trackInteraction && this.props.trackInteraction();
    });
    _defineProperty(this, "handleUpdate", status => {
      this.props.onUpdate();
      // NOTE: Labeled SVG images use this.onImageLoad to set imageLoaded
      // to true and we only use the imageLoaded state when isLabeledSVG
      // is true setting imageLoaded true here shouldn't cause issues.
      if (!Util.isLabeledSVG(this.props.src) && status === "loaded") {
        this.setState({
          imageLoaded: true
        });
      }
    });
    props.setAssetStatus(props.src, false);
    this._isMounted = false;
    this.state = {
      imageLoaded: false,
      imageDimensions: null,
      dataLoaded: false,
      labelDataIsLocalized: false,
      labels: [],
      labelsRendered: {},
      range: [[0, 0], [0, 0]]
    };
  }
  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;
    if (Util.isLabeledSVG(this.props.src)) {
      this.loadResources();
    }
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        imageLoaded: false,
        dataLoaded: false
      });
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    // If the props changed, we definitely need to update
    if (!___default["default"].isEqual(this.props, nextProps)) {
      return true;
    }
    const wasLoaded = this.isLoadedInState(this.state);
    const nextLoaded = this.isLoadedInState(nextState);
    return wasLoaded !== nextLoaded;
  }
  componentDidUpdate(prevProps, prevState) {
    const wasLoaded = this.isLoadedInState(prevState);
    const isLoaded = this.isLoadedInState(this.state);
    if (Util.isLabeledSVG(this.props.src) && !isLoaded) {
      this.loadResources();
    }
    if (!wasLoaded && isLoaded) {
      this.props.setAssetStatus(this.props.src, true);
    }
  }
  componentWillUnmount() {
    this._isMounted = false;
  }

  // Check if all of the resources are loaded in a given state
  isLoadedInState(state) {
    return Util.isLabeledSVG(this.props.src) ? state.imageLoaded && state.dataLoaded : state.imageLoaded;
  }
  loadResources() {
    const hash = getUrlHash(this.props.src);

    // We can't make multiple jsonp calls to the same file because their
    // callbacks will collide with each other. Instead, we cache the data
    // and only make the jsonp calls once.
    if (labelDataCache[hash]) {
      if (labelDataCache[hash].loaded) {
        const {
          data,
          localized
        } = labelDataCache[hash];
        this.onDataLoaded(data, localized);
      } else {
        labelDataCache[hash].dataCallbacks.push(this.onDataLoaded);
      }
    } else {
      const cacheData = {
        loaded: false,
        dataCallbacks: [this.onDataLoaded],
        data: null,
        localized: shouldUseLocalizedData()
      };
      labelDataCache[hash] = cacheData;
      const retrieveData = (url, errorCallback) => {
        doJSONP(url, {
          callbackName: "svgData" + hash,
          success: data => {
            // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'data' because it is a read-only property.
            cacheData.data = data;
            // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'loaded' because it is a read-only property.
            cacheData.loaded = true;
            ___default["default"].each(cacheData.dataCallbacks, callback => {
              // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'null' is not assignable to parameter of type '{ labels: readonly any[]; range: readonly any[]; }'.
              callback(cacheData.data, cacheData.localized);
            });
          },
          error: errorCallback
        });
      };
      if (shouldUseLocalizedData()) {
        retrieveData(getLocalizedDataUrl(this.props.src), (x, status, error) => {
          // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'localized' because it is a read-only property.
          cacheData.localized = false;

          // If there is isn't any localized data, fall back to
          // the original, unlocalized data
          retrieveData(Util.getDataUrl(this.props.src), (x, status, error) => {
            Log.error("Data load failed for svg-image", Errors.Service, {
              cause: error,
              loggedMetadata: {
                dataUrl: Util.getDataUrl(this.props.src),
                status
              }
            });
          });
        });
      } else {
        retrieveData(Util.getDataUrl(this.props.src), (x, status, error) => {
          Log.error("Data load failed for svg-image", Errors.Service, {
            cause: error,
            loggedMetadata: {
              dataUrl: Util.getDataUrl(this.props.src),
              status
            }
          });
        });
      }
    }
  }
  sizeProvided() {
    return this.props.width != null && this.props.height != null;
  }
  // Try to parse a CSS value as pixels. Returns null if the parameter string
  // does not contain a number followed by "px".
  _tryGetPixels(value) {
    value = value || "";
    // While this doesn't check that there are no other alphabetical
    // characters prior to "px", that should be taken care of by the DOM,
    // which won't accept invalid units.
    if (!value.endsWith("px")) {
      return null;
    }
    // parseFloat() ignores trailing non-numerical characters.
    return parseFloat(value) || null;
  }
  render() {
    const imageSrc = this.props.src;

    // Props to send to all images
    const imageProps = {
      alt: this.props.alt,
      title: this.props.title,
      tabIndex: "0"
    };
    // If alt text is present, AND overrideAriaHidden is true,
    // include aria-hidden to avoid screen reader from crawling texts
    // both from the div meant for screen readers (see svg-image.jsx)
    // and alt attribute.
    if (this.props.alt && this.props.overrideAriaHidden) {
      imageProps["aria-hidden"] = true;
    }
    const width = this.props.width && this.props.width * this.props.scale;
    const height = this.props.height && this.props.height * this.props.scale;
    const dimensions = {
      width,
      height
    };

    // To make an image responsive, we need to know what its width and
    // height are in advance (before inserting it into the DOM) so that we
    // can ensure it doesn't grow past those limits. We don't always have
    // this information, especially in places where <Renderer /> is used
    // to render inline Markdown images within a widget. See Radio, Sorter,
    // Matcher, etc.
    // TODO(alex): Make all of those image rendering locations aware of
    // width+height so that they too can render responsively.
    const responsive = this.props.responsive && !!(width && height);

    // An additional <Graphie /> may be inserted after the image/graphie
    // pair. Only used by the image widget, for its legacy labels support.
    // Note that since the image widget always provides width and height
    // data, extraGraphie can be ignored for unresponsive images.
    // TODO(alex): Convert all existing uses of that to web+graphie. This
    // is tricky because web+graphie doesn't support labels on non-graphie
    // images.
    let extraGraphie;
    if (this.props.extraGraphie && this.props.extraGraphie.labels.length) {
      extraGraphie = /*#__PURE__*/React__namespace.createElement(Graphie, {
        box: this.props.extraGraphie.box,
        range: this.props.extraGraphie.range,
        options: {
          labels: this.props.extraGraphie.labels
        },
        responsive: true,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    }

    // If preloader is undefined, we use the default. If it's
    // null, there will be no preloader in use.
    const preloaderBaseFunc = this.props.preloader === undefined ? defaultPreloader : this.props.preloader;
    const preloader = preloaderBaseFunc ? () => preloaderBaseFunc(dimensions) : null;

    // Just use a normal image if a normal image is provided
    if (!Util.isLabeledSVG(imageSrc)) {
      if (responsive) {
        const wrapperClasses = classNames__default["default"]({
          zoomable: (width || 0) > ZOOMABLE_THRESHOLD,
          "svg-image": true
        });
        imageProps.onClick = this._handleZoomClick;
        return /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
          className: wrapperClasses,
          width: width,
          height: height,
          constrainHeight: this.props.constrainHeight,
          allowFullBleed: this.props.allowFullBleed && isImageProbablyPhotograph(imageSrc)
        }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
          src: imageSrc,
          imgProps: imageProps
          // @ts-expect-error [FEI-5003] - TS2322 - Type '(() => Element) | null' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>> | null | undefined'.
          ,
          preloader: preloader,
          onUpdate: this.handleUpdate
        }), extraGraphie);
      }
      imageProps.style = dimensions;
      return /*#__PURE__*/React__namespace.createElement(ImageLoader, {
        src: imageSrc
        // @ts-expect-error [FEI-5003] - TS2322 - Type '(() => Element) | null' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>> | null | undefined'.
        ,
        preloader: preloader,
        imgProps: imageProps,
        onUpdate: this.handleUpdate
      });
    }
    const imageUrl = Util.getSvgUrl(imageSrc);
    let graphie;
    // Since we only want to do the graphie setup once, we only render the
    // graphie once everything is loaded
    if (this.isLoadedInState(this.state)) {
      // Use the provided width and height to size the graphie if
      // possible, otherwise use our own calculated size
      let box;
      if (this.sizeProvided()) {
        box = [width, height];
      } else if (this.state.imageDimensions) {
        box = [this.state.imageDimensions[0] * this.props.scale, this.state.imageDimensions[1] * this.props.scale];
      } else {
        throw new PerseusError("svg-image has no dimensions", Errors.InvalidInput, {
          metadata: {
            src: this.props.src
          }
        });
      }

      // TODO: the "40" scale factor was introduced in D14974 but is not
      // documented where it came from.
      graphie = /*#__PURE__*/React__namespace.createElement(Graphie
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "graphie",
        box: box,
        scale: [40 * this.props.scale, 40 * this.props.scale],
        range: this.state.range,
        options: ___default["default"].pick(this.state, "labels"),
        responsive: responsive,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    }
    if (responsive) {
      return /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
        className: "svg-image",
        width: width,
        height: height,
        constrainHeight: this.props.constrainHeight
      }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
        src: imageUrl,
        onLoad: this.onImageLoad,
        onUpdate: this.handleUpdate
        // @ts-expect-error [FEI-5003] - TS2322 - Type '(() => Element) | null' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>> | null | undefined'.
        ,
        preloader: preloader,
        imgProps: imageProps
      }), graphie, extraGraphie);
    }
    imageProps.style = dimensions;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "unresponsive-svg-image",
      style: dimensions
    }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
      src: imageUrl,
      onLoad: this.onImageLoad,
      onUpdate: this.handleUpdate
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(() => Element) | null' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>> | null | undefined'.
      ,
      preloader: preloader,
      imgProps: imageProps
    }), graphie);
  }
}
_defineProperty(SvgImage, "defaultProps", {
  constrainHeight: false,
  onUpdate: () => {},
  responsive: true,
  src: "",
  scale: 1,
  zoomToFullSizeOnMobile: false,
  setAssetStatus: (src, status) => {}
});

class Tex extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_hasRendered", void 0);
    _defineProperty(this, "handleRender", () => {
      this.props.onRender();
      this.setState({
        rendered: true
      });
      this.props.onRender();

      // We can't use BaseTeX's onRender callback directly b/c it
      // can fire from BaseTeX's componentDidMount() method and we
      // need to wait for all of the constructors in the perseus
      // render tree to first first.
      if (!this._hasRendered) {
        this._hasRendered = true;
        this.props.setAssetStatus(this.props.children, true);
      }
    });
    this.props.setAssetStatus(this.props.children, false);
    this.state = {
      rendered: false
    };
    this._hasRendered = false;
  }
  render() {
    const {
      TeX: BaseTeX
    } = getDependencies();
    return /*#__PURE__*/React__namespace.createElement(BaseTeX, {
      onRender: this.handleRender
    }, this.props.children);
  }
}
_defineProperty(Tex, "defaultProps", {
  onRender: () => {},
  setAssetStatus: (src, status) => {}
});

class Zoomable extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_isMounted", void 0);
    _defineProperty(this, "_observer", void 0);
    _defineProperty(this, "_measuringInitialized", void 0);
    _defineProperty(this, "_originalWidth", void 0);
    _defineProperty(this, "_node", void 0);
    _defineProperty(this, "state", {
      visible: false,
      marginBottomPx: 0,
      zoomed: true
    });
    _defineProperty(this, "reset", () => {
      if (!this._isMounted) {
        return;
      }
      if (!this.state.visible) {
        return;
      }
      this._originalWidth = null;
      this.setState({
        visible: false,
        compactHeight: null,
        expandedHeight: null,
        zoomed: true
      }, () => {
        this.measureAndScaleChildToFit(false);
      });
    });
    _defineProperty(this, "stopPropagationIfZoomed", e => {
      if (!this.state.zoomed) {
        // We only allow touch events (which trigger interactive elements)
        // to be propagated to children if we are already zoomed.
        e.stopPropagation();
      }
    });
    _defineProperty(this, "handleClickIfZoomed", e => {
      if (!this.state.zoomed) {
        e.stopPropagation();
        this.handleClick();
      }
    });
    _defineProperty(this, "handleClick", () => {
      this.setState({
        zoomed: !this.state.zoomed
      });
    });
  }
  componentDidMount() {
    this._isMounted = true;
    this.maybeInitializeMeasuring();
  }
  componentDidUpdate() {
    this.maybeInitializeMeasuring();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.reset);
    if (this._observer) {
      this._observer.disconnect();
    }
    this._isMounted = false;
  }
  /**
   * Calls measureAndScaleChildToFit and sets up a MutationObserver
   * to call measureAndScaleChildToFit if Zoomable's children change.
   *
   * If the readyToMeasure prop isn't true or if measuring has already
   * been initialized this method does nothing.
   */
  maybeInitializeMeasuring() {
    const shouldInitialize = this.props.readyToMeasure && !this._measuringInitialized;
    if (this._isMounted && shouldInitialize) {
      this._measuringInitialized = true;
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Element | Text | null' is not assignable to type 'HTMLElement'.
      this._node = ReactDOM__default["default"].findDOMNode(this);

      // We call measureAndScaleChildToFit asynchronously so that the browser
      // can apply CSS styles so that we get an accurate measurement.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(() => this.measureAndScaleChildToFit(false), 0);
      if (window.MutationObserver) {
        this._observer = new MutationObserver(mutations => {
          if (this._isMounted) {
            for (const mutation of mutations) {
              if (mutation.target !== this._node) {
                // Only act on mutations of children
                this.measureAndScaleChildToFit(this.state.zoomed);
                break;
              }
            }
          }
        });
        this._observer.observe(this._node, {
          childList: true,
          subtree: true,
          attributes: true
        });
      }
      window.addEventListener("resize", this.reset);
    }
  }
  // TODO(benkomalo): call this on viewport width changes?
  // https://github.com/Khan/math-input/blob/master/src/components/math-keypad.js#L43
  measureAndScaleChildToFit(zoomed) {
    if (!this._isMounted) {
      return;
    }
    const parentBounds = {
      width: this._node.offsetWidth,
      height: this._node.offsetHeight
    };
    const childBounds = this.props.computeChildBounds(this._node, parentBounds);

    // The +1 is a fudge factor to make sure any border on the
    // content isn't clipped by the the container it's in.
    const childWidth = childBounds.width + 1;
    const childHeight = childBounds.height + 1;
    if (childWidth > parentBounds.width) {
      const scale = parentBounds.width / childWidth;
      this.setState({
        scale,
        zoomed,
        compactHeight: Math.ceil(scale * childHeight),
        expandedHeight: childHeight
      });

      // TODO(charlie): Do this as a callback to `setState`. Something is
      // going wrong with that approach in initial testing.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(() => {
        // Only show it after the next paint, to allow for CSS
        // transitions to fade it in.
        if (this._isMounted) {
          this.setState({
            visible: true
          });
        }
      });
    } else {
      this.setState({
        visible: true
      });
    }
  }
  render() {
    const {
      visible,
      scale,
      compactHeight,
      expandedHeight,
      zoomed
    } = this.state;
    const {
      animateHeight
    } = this.props;
    const property = animateHeight ? "opacity transform height" : "opacity transform";

    // Since we're not using aphrodite, we have to prefix ourselves.
    const transitionStyle = visible ? {
      transitionProperty: property,
      transitionDuration: "0.3s",
      transitionTimingFunction: "ease-out"
    } : {};

    // Do a fancy little slide as we fade the contents in the first time.
    const translateOffset = visible ? "" : " translate(0, 8px)";
    const scaleString = (scale !== null && scale !== void 0 ? scale : 1).toString();
    const transform = zoomed ? "scale(1, 1) ".concat(translateOffset) : "scale(".concat(scaleString, ", ").concat(scaleString, ") ").concat(translateOffset);
    const style = {
      display: "block",
      width: "100%",
      height: zoomed ? expandedHeight : compactHeight,
      transform: transform,
      transformOrigin: "0 0",
      opacity: visible ? 1 : 0,
      WebkitTapHighlightColor: "transparent",
      ...transitionStyle
    };
    return /*#__PURE__*/React__namespace.createElement("span", {
      onClick: this.handleClick,
      onClickCapture: this.handleClickIfZoomed,
      onTouchCancelCapture: this.stopPropagationIfZoomed,
      onTouchEndCapture: this.stopPropagationIfZoomed,
      onTouchStartCapture: this.stopPropagationIfZoomed
      // @ts-expect-error [FEI-5003] - TS2322 - Type '{ readonly transitionProperty: string; readonly transitionDuration: string; readonly transitionTimingFunction: string; readonly display: "block"; readonly width: "100%"; readonly height: number | ... 1 more ... | undefined; readonly transform: string; readonly transformOrigin: "0 0"; readonly opacity: 0 | 1; readonl...' is not assignable to type 'CSSProperties | undefined'.
      ,
      style: style
    }, this.props.children);
  }
}
_defineProperty(Zoomable, "defaultProps", {
  animateHeight: false,
  readyToMeasure: true,
  computeChildBounds: parentNode => {
    const firstChild = parentNode.firstElementChild;
    return {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'offsetWidth' does not exist on type 'Element'.
      width: firstChild.offsetWidth,
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'offsetHeight' does not exist on type 'Element'.
      height: firstChild.offsetHeight
    };
  }
});

const computeMathBounds = (parentNode, parentBounds) => {
  const textElement = parentNode.querySelector(".katex-html") || parentNode.querySelector(".MathJax");
  const textBounds = {
    // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'offsetWidth' does not exist on type 'Element'.
    width: textElement.offsetWidth,
    // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'offsetHeight' does not exist on type 'Element'.
    height: textElement.offsetHeight
  };

  // HACK(benkomalo): when measuring math content, note that
  // sometimes it actually peeks outside of the
  // container in some cases. Just be conservative and use
  // the maximum value of the text and the parent. :(
  return {
    width: Math.max(parentBounds.width, textBounds.width),
    height: Math.max(parentBounds.height, textBounds.height)
  };
};
class ZoomableTeX extends React__namespace.Component {
  constructor() {
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 1-2 arguments, but got 0.
    super();
    _defineProperty(this, "handleRender", () => {
      this.setState({
        isRendered: true
      });
    });
    this.state = {
      isRendered: false
    };
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(Zoomable, {
      readyToMeasure: this.state.isRendered,
      computeChildBounds: computeMathBounds
    }, /*#__PURE__*/React__namespace.createElement(context$2.Consumer, null, _ref => {
      let {
        setAssetStatus
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(Tex, {
        onRender: this.handleRender,
        setAssetStatus: setAssetStatus
      }, this.props.children);
    }));
  }
}

const defaultContext$1 = {
  activeDefinitionId: null,
  setActiveDefinitionId: () => {}
};
const DefinitionContext = /*#__PURE__*/React__namespace.createContext(defaultContext$1);
class DefinitionProvider extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      activeDefinitionId: null
    });
    _defineProperty(this, "setActiveDefinitionId", activeDefinitionId => {
      this.setState(prevState => ({
        activeDefinitionId
      }));
    });
  }
  render() {
    const {
      children
    } = this.props;
    const {
      activeDefinitionId
    } = this.state;
    const {
      setActiveDefinitionId
    } = this;
    return /*#__PURE__*/React__namespace.createElement(DefinitionContext.Provider, {
      value: {
        activeDefinitionId,
        setActiveDefinitionId
      }
    }, children);
  }
}
const DefinitionConsumer = DefinitionContext.Consumer;

class ErrorBoundary extends React__namespace.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: ""
    };
  }
  componentDidCatch(error, info) {
    this.setState({
      error: error.toString()
    });
    Log.error("Perseus error boundary caught error", Errors.Internal, {
      cause: error,
      loggedMetadata: {
        info: info.toString()
      }
    });
  }
  render() {
    if (this.state.error) {
      // TODO(djf): perhaps we should have one error boundary for
      // inline elements and one for block elements. This one uses
      // a <span> and effectively converts block elements with
      // errors into inline elements.
      // TODO(michaelpolyak): Link error icon to "Report a problem".
      return /*#__PURE__*/React__namespace.createElement("svg", {
        height: "16",
        width: "16",
        viewBox: "0 0 16 16"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        d: "m8 16c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-3c0.55 0 1-0.45 1-1s-0.45-1-1-1-1 0.45-1 1 0.45 1 1 1zm0-9c-0.55 0-1 0.45-1 1v4c0 0.55.45 1 1 1s1-0.45 1-1v-4c0-0.55-0.45-1-1-1z",
        fill: "#d92916",
        fillRule: "evenodd"
      }));
    }
    return this.props.children;
  }
}

/**
 * This alternate version of `.track` does nothing as an optimization.
 */
function _noop() {}

/**
 * Wrapper for the trackInteraction apiOption.
 */
class InteractionTracker {
  // @ts-expect-error [FEI-5003] - TS2564 - Property '_tracked' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'setting' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'widgetID' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'widgetType' has no initializer and is not definitely assigned in the constructor.

  constructor(trackApi,
  // original apiOptions.trackInteraction
  widgetType, widgetID, setting // "" means track once
  ) {
    _defineProperty(this, "_tracked", void 0);
    _defineProperty(this, "setting", void 0);
    _defineProperty(this, "track", void 0);
    _defineProperty(this, "trackApi", void 0);
    _defineProperty(this, "widgetID", void 0);
    _defineProperty(this, "widgetType", void 0);
    _defineProperty(this, "_track", extraData => {
      if (this._tracked && !this.setting) {
        return;
      }
      this._tracked = true;
      this.trackApi({
        type: this.widgetType,
        id: this.widgetID,
        // @ts-expect-error [FEI-5003] - TS2698 - Spread types may only be created from object types.
        ...extraData
      });
    });
    if (!trackApi) {
      this.track = _noop;
    } else {
      this._tracked = false;
      this.trackApi = trackApi;
      this.widgetType = widgetType;
      this.widgetID = widgetID;
      this.setting = setting;
      this.track = this._track;
    }
  }

  /**
   * Function that actually calls the API to mark the interaction. This is
   * private. The public version is just `.track` and is bound to this object
   * for easy use in other context.
   *
   * @param extraData Any extra data to track about the event.
   * @private
   */
}

/**
 * Paragraph parsing/splitting for article jipt i18n
 */
const arrayRules = {
  fence: {
    match: SimpleMarkdown__default["default"].defaultRules.fence.match,
    order: 1,
    parse: (capture, state, parse) => ({
      type: "codeBlock",
      lang: capture[2] || undefined,
      content: capture[3]
    })
  },
  paragraph: {
    match: SimpleMarkdown__default["default"].defaultRules.paragraph.match,
    order: 2,
    parse: (capture, state, parse) => ({
      content: capture[1]
    })
  }
};
const builtArrayParser = SimpleMarkdown__default["default"].parserFor(arrayRules);

// This should just return an array of strings! magick!
const parseToArray = source => {
  // Remove any leading newlines to avoid splitting weirdness
  // (simple-markdown has the `newline` rule for this, and i have
  // no idea how this will handle leading newlines without that rule),
  // and add \n\n to let it parse at a block/paragraph level
  const paragraphedSource = source.replace(/^\n\s*\n/, "") + "\n\n";
  return builtArrayParser(paragraphedSource, {
    inline: false
  }).map(c => {
    return c["content"];
  });
};
const joinFromArray = paragraphs => paragraphs.join("\n\n");
var JiptParagraphs = {
  parseToArray: parseToArray,
  joinFromArray: joinFromArray
};

const exclamationIcon = {
  path: "M6 11a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0-9a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1z",
  height: 12,
  width: 12
};
var Severity = /*#__PURE__*/function (Severity) {
  Severity[Severity["Error"] = 1] = "Error";
  Severity[Severity["Warning"] = 2] = "Warning";
  Severity[Severity["Recommendation"] = 3] = "Recommendation";
  Severity[Severity["OfflineReportingOnly"] = 4] = "OfflineReportingOnly";
  return Severity;
}(Severity || {});
/**
 * This component renders "lint" nodes in a markdown parse tree. Lint nodes
 * are inserted into the tree by the Perseus linter (see
 * perseus-linter/src/index).
 *
 * This component serves multiple purposes
 *
 * 1) It renders a small circle in the right margin to indicate that there
 * is lint on (or near) that line.
 *
 * 2) The area around the circle is hoverable: when the mouse moves over it
 * the linty content is highlighted and a tooltip is displayed that explains
 * what the problem is.
 *
 * 3) The hoverable area is also an HTML <a> tag. Clicking on it opens
 * a new tab and links to additional details about the specific lint rule.
 *
 * The CSS required to position the circles in the right margin is tricky
 * and it does not always work perfectly. When lint occurs on a block element
 * that has a right margin (like anything blockquoted) the circle will appear
 * to the left of where it belongs.  And if there is more
 **/
class Lint extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_positionTimeout", void 0);
    _defineProperty(this, "state", {
      tooltipAbove: true
    });
    _defineProperty(this, "getPosition", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'getBoundingClientRect' does not exist on type 'Element | Text'.
      const rect = ReactDOM__default["default"].findDOMNode(this).getBoundingClientRect();
      // TODO(scottgrant): This is a magic number! We don't know the size
      // of the tooltip at this point, so we're arbitrarily choosing a
      // point at which to flip the tooltip's position.
      this.setState({
        tooltipAbove: rect.top > 100
      });
    });
    _defineProperty(this, "renderLink", style => {
      const tooltipAbove = this.state.tooltipAbove;
      let severityStyle;
      let warningText;
      let warningTextStyle;
      if (this.props.severity === Severity.Error) {
        severityStyle = styles$A.indicatorError;
        warningText = "Error";
        warningTextStyle = styles$A.publishBlockingError;
      } else if (this.props.severity === Severity.Warning) {
        severityStyle = styles$A.indicatorWarning;
        warningText = "Warning";
        warningTextStyle = styles$A.warning;
      } else {
        severityStyle = styles$A.indicatorGuideline;
        warningText = "Recommendation";
        warningTextStyle = styles$A.warning;
      }
      return /*#__PURE__*/React__namespace.createElement("a", {
        href: "https://khanacademy.org/r/linter-rules#".concat(this.props.ruleName),
        target: "lint-help-window",
        className: aphrodite.css(style)
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$A.indicator, severityStyle)
      }, this.props.severity === 1 && /*#__PURE__*/React__namespace.createElement(InlineIcon, exclamationIcon)), /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$A.tooltip, tooltipAbove && styles$A.tooltipAbove)
      }, this.props.message.split("\n\n").map((m, i) => /*#__PURE__*/React__namespace.createElement("p", {
        key: i,
        className: aphrodite.css(styles$A.tooltipParagraph)
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(warningTextStyle)
      }, warningText, ":", " "), m)), /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$A.tail, tooltipAbove && styles$A.tailAbove)
      })));
    });
  }
  componentDidMount() {
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax
    this._positionTimeout = window.setTimeout(this.getPosition);
  }
  componentWillUnmount() {
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax
    window.clearTimeout(this._positionTimeout);
  }

  // We can't call setState in componentDidMount without risking a render
  // thrash, and we can't call getBoundingClientRect in render, so we
  // borrow a timeout approach from learnstorm-dashboard.jsx and set our
  // state once the component has mounted and we can get what we need.

  // The main render method surrounds linty content with a block or
  // inline container and the link element that displays the indicator
  // and holds the tooltip.
  render() {
    const {
      children,
      inline,
      blockHighlight,
      insideTable
    } = this.props;
    if (insideTable) {
      // If we're inside a table, then linty nodes just get
      // a simple wrapper that allows them to be highlighted
      if (inline) {
        return /*#__PURE__*/React__namespace.createElement("span", {
          "data-lint-inside-table": "true"
        }, children);
      }
      return /*#__PURE__*/React__namespace.createElement("div", {
        "data-lint-inside-table": "true"
      }, children);
    }
    if (blockHighlight) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$A.lintContainer, styles$A.lintContainerBlock)
      }, this.renderLink(styles$A.radioWidgetHoverTarget), /*#__PURE__*/React__namespace.createElement("span", null, children));
    }
    if (inline) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$A.lintContainer)
      }, this.renderLink(styles$A.inlineHoverTarget), /*#__PURE__*/React__namespace.createElement("span", null, children));
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$A.lintContainer)
    }, this.renderLink(styles$A.hoverTarget), /*#__PURE__*/React__namespace.createElement("div", null, children));
  }
}
const styles$A = aphrodite.StyleSheet.create({
  // This is the class of the outermost element.
  // We use relative positioning so that the lint indicator can be
  // positioned absolutely relative to the position of the linty container.
  lintContainer: {
    position: "relative"
  },
  // Some elements that might be inline with bad parent styling are treated
  // as block elements so they render and are visible.
  lintContainerBlock: {
    display: "block"
  },
  // This is the main class for block lint. It is applied to the link element
  // that is also the hover target.
  hoverTarget: {
    // Absolute positioning relative to the lintContainer element
    position: "absolute",
    // Top of the hover target is aligned with the top of the linty block
    top: 0,
    // We want the hover target in the right margin. It is 24px wide, but
    // we have to offset it another 16px because of margins in the
    // Perseus content. I'm not sure where the 16px margin is set
    // so if that changes, this number will also have to be changed.
    // This is the part of the CSS that doesn't work right when
    // applied to things like blockquotes that have different right
    // margins.
    right: -40,
    // The hover target is a 24x24 block element.
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <div> sibling that follows the
    // hover target. This style highlights it on hover. We do an outline
    // rather than a border so we don't affect the layout. We could also
    // set the background color, but we don't because we can't reliably
    // set the text color of this block element. We could use
    // filter: invert(100%) if we want more visual change on hover here.
    ":hover ~ div": {
      outline: "1px solid " + warningColor
    },
    // If the div sibling is a table, then we may be displaying
    // lint warnings about errors inside that table. In that case
    // we want to highlight any linty descendants of the table
    ":hover ~ div div[data-lint-inside-table]": {
      outline: "1px solid " + warningColor
    },
    ":hover ~ div span[data-lint-inside-table]": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  // This is how we position the hover target for inline lint.
  inlineHoverTarget: {
    // For inline lint we position the hover target with a float:right
    // We can't use absolute positioning as we do in the block case
    // because the horizontal position is not predictable in the
    // inline case.
    float: "right",
    // We still have to make the hover target relative so that the
    // tooltip can be positioned relative to it.
    position: "relative",
    // See the comment above about the extra 16px of offset needed here.
    marginRight: -40,
    // The hover target is a 24x24 block. Same as the block case
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover.
    // This is the same as the block case.
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover. This is the same as the block case.
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <span> sibling that follows the
    // hover target. This style highlights it on hover. In this case
    // we can just set the foreground and background color to really
    // draw attention to the linty content.
    ":hover ~ span": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  radioWidgetHoverTarget: {
    // These lint targets appear in radio checkboxes, and are not able to
    // position a lint icon in the right-most gutter thanks to a parent
    // overflow rule. We position these icons to the left of the block
    // where there is some room.
    position: "absolute",
    left: -40,
    // The hover target is a 24x24 block. Same as the block case
    display: "block",
    width: 24,
    height: 24,
    // By specifying a fixed minimum width, the tooltip will hover in a
    // readable position above and to the right.
    minWidth: 264,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover.
    // This is the same as the block case.
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover. This is the same as the block case.
    // We specify a fixed-width because of some parent styling.
    ":hover > div": {
      display: "block",
      padding: 8,
      width: 280
    },
    // Move the tooltip tail to an appropriate position relative to the
    // tooltip.
    ":hover > div > div": {
      left: 8
    },
    // The linty content is in a <span> sibling that follows the
    // hover target. This style highlights it on hover. In this case
    // we can just set the foreground and background color to really
    // draw attention to the linty content.
    ":hover ~ span": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  // This is the class for the lint indicator in the margin.
  indicator: {
    alignItems: "center",
    borderRadius: 4,
    color: "white",
    display: "flex",
    fontSize: 12,
    height: 8,
    justifyContent: "center",
    margin: 8,
    width: 8
  },
  indicatorError: {
    backgroundColor: "#be2612",
    borderRadius: 8,
    height: 16,
    width: 16
  },
  indicatorWarning: {
    backgroundColor: "#f86700"
  },
  indicatorGuideline: {
    backgroundColor: "#ffbe26"
  },
  // These are the styles for the tooltip
  tooltip: {
    // Absolute positioning relative to the lint indicator circle.
    position: "absolute",
    right: -12,
    // The tooltip is hidden by default; only displayed on hover
    display: "none",
    // When it is displayed, it goes on top!
    zIndex: 1000,
    // These styles control what the tooltip looks like
    color: white$1,
    backgroundColor: gray17,
    opacity: 0.9,
    fontFamily: baseFontFamily$1,
    fontSize: "12px",
    lineHeight: "15px",
    width: "320px",
    borderRadius: "4px"
  },
  // If we're going to render the tooltip above the warning circle, we use
  // the previous rules in tooltip, but change the position slightly.
  tooltipAbove: {
    bottom: 32
  },
  // We give the tooltip a little triangular "tail" that points down at
  // the lint indicator circle. This is inside the tooltip and positioned
  // relative to it. It also shares the opacity of the tooltip. We're using
  // the standard CSS trick for drawing triangles with a thick border.
  tail: {
    position: "absolute",
    top: -12,
    right: 16,
    width: 0,
    height: 0,
    // This is the CSS triangle trick
    borderLeft: "8px solid transparent",
    borderRight: "8px solid transparent",
    borderBottom: "12px solid " + gray17
  },
  tailAbove: {
    bottom: -12,
    borderBottom: "none",
    borderTop: "12px solid " + gray17,
    top: "auto"
  },
  // Each warning in the tooltip is its own <p>. They are 12 pixels from
  // the edges of the tooltip and 12 pixels from each other.
  tooltipParagraph: {
    margin: 12
  },
  // The text "Warning" inside the tooltip is highlighted like this
  warning: {
    color: warningColor,
    fontFamily: boldFontFamily
  },
  // The text "Publish-blocking error" instide the tooltip is highlighted
  // like this
  publishBlockingError: {
    color: publishBlockingErrorColor
  }
});

/* eslint-disable no-useless-escape, no-prototype-builtins */
const rules$1 = {
  ...pureMarkdown.pureMarkdownRules,
  // NOTE: basically ignored by JIPT. wraps everything at the outer layer
  columns: {
    ...pureMarkdown.pureMarkdownRules.columns,
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-two-columns",
        key: state.key
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column-content"
      }, output(node.col1, state))), /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column-content"
      }, output(node.col2, state))));
    }
  },
  // Match paragraphs consisting solely of crowdin IDs
  // (they look roughly like crwdns9238932:0), which means that
  // crowdin is going to take the DOM node that ID is rendered into
  // and count it as the top-level translation node. They mutate this
  // node, so we need to make sure it is an outer node, not an inner
  // span. So here we parse this separately and just output the
  // raw string, which becomes the body of the <QuestionParagraph>
  // created by the Renderer.
  // This currently (2015-09-01) affects only articles, since
  // for exercises the renderer just renders the crowdin id to the
  // renderer div.
  crowdinId: {
    ...pureMarkdown.pureMarkdownRules.crowdinId,
    react: (node, output, state) => node.id
  },
  // Ensure that the table is focusable in sequential keyboard navigation
  // when rendered on mobile in a modal. Specifically this is needed for
  // Android Talkback, to enable reading/navigating tables with the swipe
  // left/right gesture. Note, setting `tabindex` doesn't appear required for
  // iOS 14.4, in order for VoiceOver to work.
  table: {
    ...pureMarkdown.pureMarkdownRules.table,
    react: function (node, output, state) {
      const table = SimpleMarkdown__default["default"].defaultRules.table.react(node, output, state);
      if (!state.isMobile) {
        return table;
      }
      return /*#__PURE__*/React__namespace.cloneElement(table, {
        tabIndex: 0
      });
    }
  },
  // This is pretty much horrible, but we have a regex here to capture an
  // entire table + a title. capture[1] is the title. capture[2] of the
  // regex is a copy of the simple-markdown nptable regex. Then we turn
  // our capture[2] into tableCapture[0], and any further captures in
  // our table regex into tableCapture[1..], and we pass tableCapture to
  // our nptable regex
  titledTable: {
    ...pureMarkdown.pureMarkdownRules.titledTable,
    react: (node, output, state) => {
      let contents;
      if (!node.table) {
        contents = "//invalid table//";
      } else if (node.table.type === "lint") {
        var _node$table$content;
        // The `table` in this node is actually a `lint` node,
        // not the expected `table` node. This is due to the linter
        // implementation "reparenting" the `table` node, see
        // perseus-linter/src/index.js
        if (((_node$table$content = node.table.content) === null || _node$table$content === void 0 ? void 0 : _node$table$content.type) === "table") {
          // And the `content` of this lint node is the `table` node
          // which we actually want to render. Thus, we perform
          // surgery on the node to form the desired shape, so that
          // we can render a `lint` node which will then recursively
          // render the correctly shaped `titledTable` node.
          contents = rules$1.lint.react({
            ...node.table,
            content: {
              ...node,
              table: node.table.content
            }
          }, output, {
            ...state,
            // Recursively render the `titledTable` node without
            // the wrapper div, as we'll be wrapping `contents`
            // ourselves below.
            unwrapTitledTableContents: true
          });
        } else {
          // We know `node.table` is actually a `lint` node, but we
          // don't know how to handle its `content`. Let the lint
          // node renderer figure it out.
          contents = rules$1.lint.react(node.table, output, state);
        }
      } else {
        const tableOutput = SimpleMarkdown__default["default"].defaultRules.table.react(node.table, output, state);
        const caption = /*#__PURE__*/React__namespace.createElement("caption", {
          key: "caption",
          className: "perseus-table-title"
        }, output(node.title, state));

        // Splice the caption into the table's children with the
        // caption as the first child.
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        contents = /*#__PURE__*/React__namespace.cloneElement(tableOutput, null, [caption, ...tableOutput.props.children]);
      }
      if (state.unwrapTitledTableContents) {
        return contents;
      }

      // Note: if the DOM structure changes, edit the Zoomable wrapper
      // in src/renderer.jsx.
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-titled-table",
        key: state.key
      }, contents);
    }
  },
  widget: {
    ...pureMarkdown.pureMarkdownRules.widget,
    react: (node, output, state) => {
      // The actual output is handled in the renderer, where
      // we know the current widget props/state. This is
      // just a stub for testing.
      return /*#__PURE__*/React__namespace.createElement("em", {
        key: state.key
      }, i18n__namespace.doNotTranslate("[Widget: ", node.id, "]"));
    }
  },
  blockMath: {
    ...pureMarkdown.pureMarkdownRules.blockMath,
    react: (node, output, state) => {
      const {
        TeX
      } = getDependencies();
      // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.
      return /*#__PURE__*/React__namespace.createElement(TeX, {
        key: state.key
      }, node.content);
    }
  },
  math: {
    ...pureMarkdown.pureMarkdownRules.math,
    react: (node, output, state) => {
      const {
        TeX
      } = getDependencies();
      // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.
      return /*#__PURE__*/React__namespace.createElement(TeX, {
        key: state.key
      }, node.content);
    }
  },
  unescapedDollar: {
    ...pureMarkdown.pureMarkdownRules.unescapedDollar,
    react: (node, output, state) => {
      // Unescaped dollar signs render correctly, but result in
      // untranslatable text after the i18n python linter flags it
      return "$";
    }
  },
  // Extend the SimpleMarkdown link parser to make the link open in a new
  // window and handle reverse tabnapping phishing attacks
  link: {
    ...pureMarkdown.pureMarkdownRules.link,
    react: function (node, output, state) {
      const link = SimpleMarkdown__default["default"].defaultRules.link.react(node, output, state);
      const href = link.props.href;
      let rel = null;
      // The href prop should always be here, but just in case somehow the article's
      // link was not put together properly, let's make sure it's there so we
      // don't break the entire page.
      const isKAUrl = href ? href.match(/https?:\/\/[^\/]*khanacademy.org|^\//) : false;
      if (!isKAUrl) {
        // Prevents "reverse tabnabbing" phishing attacks
        // @ts-expect-error [FEI-5003] - TS2322 - Type '"noopener noreferrer"' is not assignable to type 'null'.
        rel = "noopener noreferrer";
      }
      const newProps = {
        ...link.props,
        target: "_blank",
        href,
        rel
      };
      if (state.baseElements && state.baseElements.Link) {
        return state.baseElements.Link(newProps);
      }
      return /*#__PURE__*/React__namespace.cloneElement(link, newProps);
    }
  },
  codeBlock: {
    ...pureMarkdown.pureMarkdownRules.codeBlock,
    react: (node, output, state) => {
      // ideally this should be a different rule, with only an
      // output function, but right now that breaks the parser.
      if (node.lang === "alt") {
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: state.key,
          className: "perseus-markdown-alt perseus-sr-only"
        }, output(node.content, state));
      }
      return SimpleMarkdown__default["default"].defaultRules.codeBlock.react(node, output, state);
    }
  },
  // The lint rule never actually matches anything.
  // We check for lint after parsing, and, if we find any, we
  // transform the tree to add lint nodes. This rule is here
  // just for the react() function
  lint: {
    ...pureMarkdown.pureMarkdownRules.lint,
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement(Lint, {
        message: node.message,
        ruleName: node.ruleName,
        inline: isInline(node.content),
        blockHighlight: node.blockHighlight,
        insideTable: node.insideTable,
        severity: node.severity
      }, output(node.content, state));
    }
  }
};

// Return true if the specified parse tree node represents inline content
// and false otherwise. We need this so that lint nodes can figure out whether
// they should behave as an inline wrapper or a block wrapper
function isInline(node) {
  // eslint-disable-next-line no-prototype-builtins
  return !!(node && node.type && inlineNodeTypes.hasOwnProperty(node.type));
}
const inlineNodeTypes = {
  text: true,
  math: true,
  unescapedDollar: true,
  link: true,
  img: true,
  strong: true,
  u: true,
  em: true,
  del: true,
  code: true
};

// @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ readonly columns: { readonly react: (node: any, output: any, state: any) => Element; readonly order: -2; readonly match: any; readonly parse: (capture: any, parse: any, state: any) => any; }; ... 35 more ...; readonly text: TextInOutRule; }' is not assignable to parameter of type 'ParserRules'.
const builtParser$1 = SimpleMarkdown__default["default"].parserFor(rules$1);
const parse$3 = (source, state) => {
  const paragraphedSource = source + "\n\n";
  return builtParser$1(paragraphedSource, {
    ...state,
    inline: false
  });
};
const inlineParser = (source, state) => {
  return builtParser$1(source, {
    ...state,
    inline: true
  });
};

/**
 * Traverse all of the nodes in the Perseus Markdown AST. The callback is
 * called for each node in the AST.
 */
const traverseContent = (ast, cb) => {
  if (___default["default"].isArray(ast)) {
    ___default["default"].each(ast, node => traverseContent(node, cb));
  } else if (___default["default"].isObject(ast)) {
    cb(ast);
    if (ast.type === "table") {
      traverseContent(ast.header, cb);
      traverseContent(ast.cells, cb);
    } else if (ast.type === "list") {
      traverseContent(ast.items, cb);
    } else if (ast.type === "titledTable") {
      traverseContent(ast.table, cb);
    } else if (ast.type === "columns") {
      traverseContent(ast.col1, cb);
      traverseContent(ast.col2, cb);
    } else if (___default["default"].isArray(ast.content)) {
      traverseContent(ast.content, cb);
    }
  }
};

/**
 * Pull out text content from a Perseus Markdown AST.
 * Returns an array of strings.
 */
const getContent = ast => {
  // Simplify logic by dealing with a single AST node at a time
  if (___default["default"].isArray(ast)) {
    return ___default["default"].flatten(___default["default"].map(ast, getContent));
  }

  // Base case: This is where we actually extract text content
  if (ast.content && ___default["default"].isString(ast.content)) {
    // Collapse whitespace within content unless it is code
    if (ast.type.toLowerCase().indexOf("code") !== -1) {
      // In case this is the sole child of a paragraph,
      // prevent whitespace from being trimmed later
      return ["", ast.content, ""];
    }
    return [ast.content.replace(/\s+/g, " ")];
  }

  // Recurse through child AST nodes
  // Assumptions made:
  // 1) Child AST nodes are either direct properties or inside
  //    arbitrarily nested lists that are direct properties.
  // 2) Only AST nodes have a 'type' property.
  const children = ___default["default"].chain(ast).values().flatten().filter(object => object != null && ___default["default"].has(object, "type")).value();
  if (!children.length) {
    return [];
  }
  const nestedContent = getContent(children);
  if (ast.type === "paragraph" && nestedContent.length) {
    // Trim whitespace before or after a paragraph
    nestedContent[0] = nestedContent[0].replace(/^\s+/, "");
    const last = nestedContent.length - 1;
    nestedContent[last] = nestedContent[last].replace(/\s+$/, "");
  }
  return nestedContent;
};

/**
 * Count the number of characters in Perseus Markdown source.
 * Markdown markup and widget references are ignored.
 */
const characterCount = source => {
  // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
  const ast = parse$3(source);
  const content = getContent(ast).join("");
  return content.length;
};
var PerseusMarkdown = {
  characterCount: characterCount,
  traverseContent: traverseContent,
  parse: parse$3,
  parseInline: inlineParser,
  reactFor: SimpleMarkdown__default["default"].reactFor,
  ruleOutput: SimpleMarkdown__default["default"].ruleOutput(rules$1, "react"),
  basicOutput: SimpleMarkdown__default["default"].reactFor(SimpleMarkdown__default["default"].ruleOutput(rules$1, "react")),
  sanitizeUrl: SimpleMarkdown__default["default"].sanitizeUrl
};

class QuestionParagraph extends React__namespace.Component {
  render() {
    const className = this.props.className ? "paragraph " + this.props.className : "paragraph";
    // For perseus-article just-in-place-translation (jipt), we need
    // to attach some metadata to top-level QuestionParagraphs:
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      "data-perseus-component-index": this.props.translationIndex,
      "data-perseus-paragraph-index": this.props.paragraphIndex
    }, this.props.children);
  }
}

/**
 * TranslationLinter asynchronously calls Khan Academy's poentry linter.
 *
 * The poentry linter checks for issues that prevent content from being
 * translated. This linter is KA-specific and so TranslationLinter does not do
 * anything in non-KA environments.
 */

// msec to wait before we actually call the linter after receiving the
// last call. The timer is reset if the lint is called during the wait.
const DEBOUNCE_TIMEOUT = 1000;
class TranslationLinter {
  constructor() {
    _defineProperty(this, "previousContent", null);
    _defineProperty(this, "runLinter", _.debounce((perseusStr, onLintErrorsGenerated) => {
      // TODO(FEI-5003): Do we still need to check for 'KA'?
      if (typeof KA === "undefined") {
        return;
      }
      if (perseusStr === this.previousContent) {
        return;
      }
      this.previousContent = perseusStr;
      if (perseusStr === "") {
        onLintErrorsGenerated([]);
        return;
      }
      fetch("/api/internal/translations/lint_poentry?preview=1&lang=en", {
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          // The poentry linter verifies that the translation from
          // the original text to the translated text is sane. We
          // want to ensure that the translation from English to
          // English is sane, so msgid === mstr.
          msgid: perseusStr,
          // msgid is the original text
          msgstr: perseusStr,
          // msgstr is the translated text
          format: "perseus_text",
          filename: ""
        }),
        method: "POST"
      }).then(response => {
        if (response.status >= 400) {
          return {
            status: "error",
            message: "Could not run i18n linter."
          };
        }
        return response.json();
      }, rejection => {
        return {
          status: "error",
          message: "Could not run i18n linter."
        };
      }).then(json => {
        if (json.status === "error") {
          onLintErrorsGenerated(["Some part of this text makes it untranslatable. " + "The specific message from the i18n linter was: " + json.message.replace(/\n/g, " ")]);
        } else {
          onLintErrorsGenerated([]);
        }
      });
    }, DEBOUNCE_TIMEOUT));
  }
  /**
   * Applies an array of errors generated by linters without position
   * information (TranslationLinter and the legacy getSaveWarnings()) to the
   * top of a Perseus tree.
   */
  applyLintErrors(parsedMarkdown, translationLintErrors) {
    // These lint errors do not have position data associated with
    // them, so we just plop them at the top.
    if (translationLintErrors.length) {
      const errorText = translationLintErrors.join("\n\n");
      parsedMarkdown.unshift({
        content: {
          type: "text",
          content: ""
        },
        insideTable: false,
        message: errorText,
        ruleName: "legacy-error",
        severity: PerseusLinter.Rule.Severity.ERROR,
        type: "lint"
      });
    }
  }
}

/**
 * Preprocess TeX code to convert things that KaTeX doesn't know how to handle
 * to things is does.
 */

var preprocessTex = (texCode => texCode
// Replace uses of \begin{align}...\end{align} which KaTeX doesn't
// support (yet) with \begin{aligned}...\end{aligned} which renders
// the same is supported by KaTeX.  It does the same for align*.
// TODO(kevinb) update content to use aligned instead of align.
.replace(/\{align[*]?\}/g, "{aligned}")
// Replace non-breaking spaces with regular spaces.
.replace(/[\u00a0]/g, " "));

const {
  interactiveSizes
} = constants$1;

// Note: these size cutoffs represent content-width cutoffs as specified in
// http://zpl.io/1mVmvU (broken link - we no longer use Zeplin)
// TODO(benkomalo): these values aren't used in JS outside of this file, but
// are coupled to the values in styles/articles.less - DRY it up at some point
const smMax = articleMaxWidthTableInPx;
const mdMax = articleMaxWidthInPx;
const containerSizeClass = {
  SMALL: "small",
  MEDIUM: "medium",
  LARGE: "large",
  XLARGE: "xlarge"
};
const getClassFromWidth = width => {
  if (!width) {
    return containerSizeClass.MEDIUM;
  }
  if (width <= smMax) {
    return containerSizeClass.SMALL;
  }
  if (width <= mdMax) {
    return containerSizeClass.MEDIUM;
  }
  return containerSizeClass.LARGE;
};
const getInteractiveBoxFromSizeClass = sizeClass => {
  if (sizeClass === containerSizeClass.SMALL) {
    return [interactiveSizes.defaultBoxSizeSmall, interactiveSizes.defaultBoxSizeSmall];
  }
  return [interactiveSizes.defaultBoxSize, interactiveSizes.defaultBoxSize];
};

var sizingUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    containerSizeClass: containerSizeClass,
    getClassFromWidth: getClassFromWidth,
    getInteractiveBoxFromSizeClass: getInteractiveBoxFromSizeClass
});

const DEFAULT_ALIGNMENT$1 = "block";
// NOTE(kevinb): "default" is not one in `validAlignments`.
const DEFAULT_SUPPORTED_ALIGNMENTS = ["default"];
const DEFAULT_STATIC = false;
const DEFAULT_TRACKING = "";
const DEFAULT_LINTABLE = false;
const widgets = {};
const editors = {};

// Widgets must be registered to avoid circular dependencies with the
// core Editor and Renderer components.
// TODO(jeremy): The widget name is already embedded in the WidgetExports type
// so could we drop the `name` parameter here?
const registerWidget = (name, widget) => {
  widgets[name] = widget;
};
const registerWidgets = widgets => {
  widgets.forEach(widget => {
    registerWidget(widget.name, widget);
  });
  validateAlignments();
};
const registerEditors = editorsToRegister => {
  editorsToRegister.forEach(editor => {
    if (!editor.widgetName) {
      throw new PerseusError("Editor ".concat(editor.displayName, " doesn't have a widgetName property"), Errors.Internal);
    }
    editors[editor.widgetName] = editor;
  });
};
const getWidget = name => {
  // TODO(alex): Consider referring to these as renderers to avoid
  // overloading "widget"
  if (!___default["default"].has(widgets, name)) {
    return null;
  }

  // Allow widgets to specify a widget directly or via a function
  if (widgets[name].getWidget) {
    // @ts-expect-error [FEI-5003] - TS2722 - Cannot invoke an object which is possibly 'undefined'.
    return widgets[name].getWidget();
  }
  return widgets[name].widget;
};
const getEditor = name => {
  return ___default["default"].has(editors, name) ? editors[name] : null;
};
const getTransform = name => {
  return ___default["default"].has(widgets, name) ? widgets[name].transform || ___default["default"].identity : null;
};
const getVersion = name => {
  const widgetInfo = widgets[name];
  if (widgetInfo) {
    return widgets[name].version || {
      major: 0,
      minor: 0
    };
  }
  return null;
};
const getVersionVector = () => {
  const version = {};
  ___default["default"].each(___default["default"].keys(widgets), function (name) {
    version[name] = getVersion(name);
  });
  return version;
};
const getPublicWidgets = () => {
  // TODO(alex): Update underscore.js so that _.pick can take a function.
  // @ts-expect-error [FEI-5003] - TS2740 - Type 'Pick<{ [key: string]: Readonly<{ name: string; displayName: string; getWidget?: (() => ComponentType<any>) | undefined; accessible?: boolean | ((props: any) => boolean) | undefined; hidden?: boolean | undefined; ... 10 more ...; widget: ComponentType<...>; }>; }, string>' is missing the following properties from type 'readonly Readonly<{ name: string; displayName: string; getWidget?: (() => ComponentType<any>) | undefined; accessible?: boolean | ((props: any) => boolean) | undefined; hidden?: boolean | undefined; ... 10 more ...; widget: ComponentType<...>; }>[]': length, concat, join, slice, and 18 more.
  return ___default["default"].pick(widgets,
  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(name: string) => boolean | undefined' is not assignable to parameter of type 'Iteratee<string[], boolean, string>'.
  ___default["default"].reject(___default["default"].keys(widgets), function (name) {
    return widgets[name].hidden;
  }));
};
const isAccessible = widgetInfo => {
  const accessible = widgets[widgetInfo.type].accessible;
  if (typeof accessible === "function") {
    return accessible(widgetInfo.options);
  }
  return !!accessible;
};
const getAllWidgetTypes = () => {
  return ___default["default"].keys(widgets);
};
const upgradeWidgetInfoToLatestVersion = oldWidgetInfo => {
  const type = oldWidgetInfo.type;
  // TODO(LP-10707): Remove unnecessary type checking (`type` is a string)
  if (!___default["default"].isString(type)) {
    throw new PerseusError("widget type must be a string, but was: " + type, Errors.Internal);
  }
  const widgetExports = widgets[type];
  if (widgetExports == null) {
    // If we have a widget that isn't registered, we can't upgrade it
    // TODO(aria): Figure out what the best thing to do here would be
    return oldWidgetInfo;
  }

  // Unversioned widgets (pre-July 2014) are all implicitly 0.0
  const initialVersion = oldWidgetInfo.version || {
    major: 0,
    minor: 0
  };
  const latestVersion = widgetExports.version || {
    major: 0,
    minor: 0
  };

  // If the widget version is later than what we understand (major
  // version is higher than latest, or major versions are equal and minor
  // version is higher than latest), don't perform any upgrades.
  if (initialVersion.major > latestVersion.major || initialVersion.major === latestVersion.major && initialVersion.minor > latestVersion.minor) {
    return oldWidgetInfo;
  }

  // We do a clone here so that it's safe to mutate the input parameter
  // in propUpgrades functions (which I will probably accidentally do at
  // some point, and we would like to not break when that happens).
  let newEditorProps = ___default["default"].clone(oldWidgetInfo.options) || {};
  const upgradePropsMap = widgetExports.propUpgrades || {};

  // Empty props usually mean a newly created widget by the editor,
  // and are always considerered up-to-date.
  // Mostly, we'd rather not run upgrade functions on props that are
  // not complete.
  if (___default["default"].keys(newEditorProps).length !== 0) {
    // We loop through all the versions after the current version of
    // the loaded widget, up to and including the latest version of the
    // loaded widget, and run the upgrade function to bring our loaded
    // widget's props up to that version.
    // There is a little subtlety here in that we call
    // upgradePropsMap[1] to upgrade *to* version 1,
    // (not from version 1).
    for (let nextVersion = initialVersion.major + 1; nextVersion <= latestVersion.major; nextVersion++) {
      if (upgradePropsMap[String(nextVersion)]) {
        newEditorProps = upgradePropsMap[String(nextVersion)](newEditorProps);
      } else {
        // This is a Log.error because it is unlikely to be hit in
        // local testing, and a Log.error is slightly less scary in
        // prod than a `throw new Error`
        Log.error("No upgrade found for widget. Cannot render.", Errors.Internal, {
          loggedMetadata: {
            type,
            fromMajorVersion: nextVersion - 1,
            toMajorVersion: nextVersion
          }
        });
        // But try to keep going anyways (yolo!)
        // (Throwing an error here would just break the page
        // silently anyways, so that doesn't seem much better
        // than a halfhearted attempt to continue, however
        // shallow...)
      }
    }
  }

  // Minor version upgrades (eg. new optional props) don't have
  // transform functions. Instead, we fill in the new props with their
  // defaults.
  const defaultProps = type in editors ? editors[type].defaultProps : {};
  newEditorProps = {
    ...defaultProps,
    ...newEditorProps
  };
  let alignment = oldWidgetInfo.alignment;

  // Widgets that support multiple alignments will "lock in" the
  // alignment to the alignment that would be listed first in the
  // select box. If the widget only supports one alignment, the
  // alignment value will likely just end up as "default".
  if (alignment == null || alignment === "default") {
    alignment = getSupportedAlignments(type)[0];
  }
  let widgetStatic = oldWidgetInfo.static;
  if (widgetStatic == null) {
    widgetStatic = DEFAULT_STATIC;
  }
  return ___default["default"].extend({}, oldWidgetInfo, {
    // maintain other info, like type
    // After upgrading we guarantee that the version is up-to-date
    version: latestVersion,
    // Default graded to true (so null/undefined becomes true):
    graded: oldWidgetInfo.graded != null ? oldWidgetInfo.graded : true,
    alignment: alignment,
    static: widgetStatic,
    options: newEditorProps
  });
};
const getRendererPropsForWidgetInfo = (widgetInfo, problemNum) => {
  const type = widgetInfo.type;
  const widgetExports = widgets[type];
  if (widgetExports == null) {
    // The widget is not a registered widget
    // It shouldn't matter what we return here, but for consistency
    // we return the untransformed options, as if the widget did
    // not have a transform defined.
    return widgetInfo.options;
  }
  let transform;
  if (widgetInfo.static) {
    // There aren't a lot of real places where we'll have to default to
    // _.identity, but it's theoretically possible if someone changes
    // the JSON manually / we have to back out static support for a
    // widget.
    transform = getStaticTransform(type) || ___default["default"].identity;
  } else {
    transform = widgetExports.transform || ___default["default"].identity;
  }
  // widgetInfo.options are the widgetEditor's props:
  return transform(widgetInfo.options, problemNum);
};
const traverseChildWidgets$4 = (widgetInfo, traverseRenderer) => {
  if (!traverseRenderer) {
    throw new PerseusError("traverseRenderer must be provided, but was not", Errors.Internal);
  }
  if (!widgetInfo || !widgetInfo.type || !widgets[widgetInfo.type]) {
    return widgetInfo;
  }
  const widgetExports = widgets[widgetInfo.type];
  const props = widgetInfo.options;
  if (widgetExports.traverseChildWidgets && props) {
    const newProps = widgetExports.traverseChildWidgets(props, traverseRenderer);
    return ___default["default"].extend({}, widgetInfo, {
      options: newProps
    });
  }
  return widgetInfo;
};

/**
 * Handling for the optional alignments for widgets
 * See widget-container.jsx for details on how alignments are implemented.
 */

/**
 * Returns the list of supported alignments for the given (string) widget
 * type. This is used primarily at editing time to display the choices
 * for the user.
 *
 * Supported alignments are given as an array of strings in the exports of
 * a widget's module.
 */
const getSupportedAlignments = type => {
  const widgetExport = widgets[type];
  // @ts-expect-error [FEI-5003] - TS2322 - Type 'string[] | readonly Alignment[]' is not assignable to type 'readonly Alignment[]'.
  return widgetExport && widgetExport.supportedAlignments || DEFAULT_SUPPORTED_ALIGNMENTS;
};

/**
 * For the given (string) widget type, determine the default alignment for
 * the widget. This is used at rendering time to go from "default" alignment
 * to the actual alignment displayed on the screen.
 *
 * The default alignment is given either as a string (called
 * `defaultAlignment`) or a function (called `getDefaultAlignment`) on
 * the exports of a widget's module.
 */
const getDefaultAlignment = type => {
  const widgetExports = widgets[type];
  let alignment;
  if (!widgetExports) {
    return DEFAULT_ALIGNMENT$1;
  }
  if (widgetExports.getDefaultAlignment) {
    alignment = widgetExports.getDefaultAlignment();
  } else {
    alignment = widgetExports.defaultAlignment;
  }
  return alignment || DEFAULT_ALIGNMENT$1;
};
const validAlignments = ["block", "inline-block", "inline", "float-left", "float-right", "full-width"];

/**
 * Used at startup to fail fast if an alignment given by a widget is
 * invalid.
 */
// TODO(alex): Change this to run as a testcase (vs. being run at runtime)
// TODO(LP-10707): I think this can be completely removed because our TypeScript types
// enforce this!
const validateAlignments = () => {
  ___default["default"].each(widgets, function (widgetInfo) {
    if (widgetInfo.defaultAlignment && !___default["default"].contains(validAlignments, widgetInfo.defaultAlignment)) {
      throw new PerseusError("Widget '" + widgetInfo.displayName + "' has an invalid defaultAlignment value: " + widgetInfo.defaultAlignment, Errors.InvalidInput);
    }
    if (widgetInfo.supportedAlignments) {
      const unknownAlignments = ___default["default"].difference(widgetInfo.supportedAlignments, validAlignments);
      if (unknownAlignments.length) {
        throw new PerseusError("Widget '" + widgetInfo.displayName + "' has an invalid value for supportedAlignments: " + unknownAlignments.join(" "), Errors.InvalidInput);
      }
    }
  });
};

/**
 * Handling for static mode for widgets that support it.
 */

/**
 * Returns true iff the widget supports static mode.
 * A widget implicitly supports static mode if it exports a
 * staticTransform function.
 */
const supportsStaticMode = type => {
  const widgetInfo = widgets[type];
  return widgetInfo && widgetInfo.staticTransform != null;
};

/**
 * Return the staticTransform function used to convert the editorProps to
 * the rendered widget state.
 */
const getStaticTransform = type => {
  const widgetInfo = widgets[type];
  return widgetInfo && widgetInfo.staticTransform;
};

/**
 * Returns the tracking option for the widget. The default is "",
 * which means simply to track interactions once. The other available
 * option is "all" which means to track all interactions.
 */
const getTracking = type => {
  const widgetExport = widgets[type];
  return widgetExport && widgetExport.tracking || DEFAULT_TRACKING;
};

/**
 * Returns true if this widget can include lintable markdown text
 * and supports a highlightLint prop, or false otherwise.
 */
const isLintable = type => {
  const widgetExports = widgets[type];
  return widgetExports && widgetExports.isLintable || DEFAULT_LINTABLE;
};

var widgets$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerWidget: registerWidget,
    registerWidgets: registerWidgets,
    registerEditors: registerEditors,
    getWidget: getWidget,
    getEditor: getEditor,
    getTransform: getTransform,
    getVersion: getVersion,
    getVersionVector: getVersionVector,
    getPublicWidgets: getPublicWidgets,
    isAccessible: isAccessible,
    getAllWidgetTypes: getAllWidgetTypes,
    upgradeWidgetInfoToLatestVersion: upgradeWidgetInfoToLatestVersion,
    getRendererPropsForWidgetInfo: getRendererPropsForWidgetInfo,
    traverseChildWidgets: traverseChildWidgets$4,
    getSupportedAlignments: getSupportedAlignments,
    getDefaultAlignment: getDefaultAlignment,
    validateAlignments: validateAlignments,
    supportsStaticMode: supportsStaticMode,
    getStaticTransform: getStaticTransform,
    getTracking: getTracking,
    isLintable: isLintable
});

class WidgetContainer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      // TODO(benkomalo): before we're mounted, we don't know how big
      // we're going to be, so just default to MEDIUM for now. :/ In the
      // future we can sniff with user-agents or something to get a
      // better approximation, to avoid flickers
      sizeClass: containerSizeClass.MEDIUM,
      widgetProps: this.props.initialProps
    });
    _defineProperty(this, "getWidget", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.widget;
    });
    _defineProperty(this, "replaceWidgetProps", newWidgetProps => {
      this.setState({
        widgetProps: newWidgetProps
      });
    });
  }
  componentDidMount() {
    // Only relay size class changes for mobile right now.  We may want to
    // this for desktop as well at some point in the future.
    if (this.state.widgetProps.apiOptions.isMobile) {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'offsetWidth' does not exist on type 'Element | Text'.
      const containerWidth = ReactDOM__default["default"].findDOMNode(this).offsetWidth;

      // NOTE(benkomalo): in the common case, this won't change anything.
      // Unfortunately, it will cause a flash and re-layout on mobile,
      // but until we have better SSR or a more drastic way change to our
      // APIs that hints at the available size, we do have to measure DOM
      // unfortunately.
      /* eslint-disable react/no-did-mount-set-state */
      this.setState({
        sizeClass: getClassFromWidth(containerWidth)
      });
      /* eslint-enable react/no-did-mount-set-state */
    }
  }

  render() {
    let className = classNames__default["default"]({
      "perseus-widget-container": true,
      "widget-highlight": this.props.shouldHighlight,
      "widget-nohighlight": !this.props.shouldHighlight,
      // HACK(matthewc): perseus-widget-container is setting a font-size
      // but we want the definition prompt to match the surrounding font
      // I'm sorry, but there's a time crunch
      "perseus-widget__definition": this.props.type === "definition"
    });
    const type = this.props.type;
    const WidgetType = getWidget(type);
    if (WidgetType == null) {
      // This is for the good of all people!!
      // eslint-disable-next-line no-console
      console.warn("Widget type '".concat(type, "' not found!"));
      // Just give up on invalid widget types
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: className
      });
    }
    let alignment = this.state.widgetProps.alignment;
    if (alignment === "default") {
      alignment = getDefaultAlignment(type);
    }
    className += " widget-" + alignment;
    const apiOptions = this.state.widgetProps.apiOptions;

    // Hack to prevent interaction with static widgets: we overlay a big
    // div on top of the widget and overflow: hidden the container.
    // Ideally widgets themselves should know how to prevent interaction.
    const isStatic = this.state.widgetProps.static || apiOptions.readOnly;
    const staticContainerStyles = {
      position: "relative",
      overflow: "visible"
    };
    const staticOverlayStyles = {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: 0,
      left: 0,
      zIndex: zIndexInteractiveComponent$1
    };

    // Some widgets may include strings of markdown that we may
    // want to run the linter on. So if the widget is lintable,
    // and we've been asked to highlight lint, pass that property
    // on to the widget, and if the content is not lintable, make sure
    // to default to false.
    // The linter context might be a constant object (and it isn't owned
    // by us anyway), so we copy it if we have to modify it.
    const linterContext = isLintable(type) ? this.props.linterContext : {
      ...this.props.linterContext,
      highlightLint: false
    };

    // Note: if you add more props here, please consider whether or not
    // it should be auto-serialized (e.g. used in scoreInput()). See
    // widget-jsonify-deprecated.jsx and widget-prop-denylist.jsx

    // We default to an empty object for style instead of null
    // because of a strange bug where the static styles aren't applied
    // after toggling static mode.
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      style: isStatic ? staticContainerStyles : {}
    }, /*#__PURE__*/React__namespace.createElement(WidgetType, _extends({}, this.state.widgetProps, {
      linterContext: linterContext,
      containerSizeClass: this.state.sizeClass
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "widget"
    })), isStatic && /*#__PURE__*/React__namespace.createElement("div", {
      style: staticOverlayStyles
    }));
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.type !== nextProps.type) {
      throw new Error("WidgetContainer can't change widget type; set a different " + "key instead to recreate the container.");
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    return this.props.shouldHighlight !== nextProps.shouldHighlight || this.props.type !== nextProps.type || this.state.widgetProps !== nextState.widgetProps || this.state.sizeClass !== nextState.sizeClass;
  }
}
_defineProperty(WidgetContainer, "defaultProps", {
  linterContext: PerseusLinter.linterContextDefault
});

const {
  mapObject: mapObject$2,
  mapObjectFromArray
} = objective_;
const rContainsNonWhitespace = /\S/;
const rImageURL = /(web\+graphie|https):\/\/[^\s]*/;
const noopOnRender = () => {};
const SHOULD_CLEAR_WIDGETS_PROP_LIST = ["content", "problemNum", "widgets"];

// Check if one focus path / id path is a prefix of another
// The focus path null will never be a prefix of any non-null
// path, since it represents no focus.
// Otherwise, prefix is calculated by whether every array
// element in the prefix is present in the same position in the
// wholeArray path.
const isIdPathPrefix = function (prefixArray, wholeArray) {
  if (prefixArray === null || wholeArray === null) {
    return prefixArray === wholeArray;
  }

  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly string[] | undefined' is not assignable to parameter of type 'Collection<any>'.
  return ___default["default"].every(prefixArray, (elem, i) => {
    if (wholeArray != null) {
      return ___default["default"].isEqual(elem, wholeArray[i]);
    }
  });
};
class Renderer extends React__namespace.Component {
  // @ts-expect-error [FEI-5003] - TS2564 - Property '_foundTextNodes' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property '_interactionTrackers' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property '_isMounted' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property '_isTwoColumn' has no initializer and is not definitely assigned in the constructor.

  // The i18n linter.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'reuseMarkdown' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'translationIndex' has no initializer and is not definitely assigned in the constructor.

  // @ts-expect-error [FEI-5003] - TS2564 - Property 'widgetIds' has no initializer and is not definitely assigned in the constructor.

  constructor(_props, context) {
    var _this;
    super(_props, context);
    _this = this;
    _defineProperty(this, "_currentFocus", void 0);
    _defineProperty(this, "_foundTextNodes", void 0);
    _defineProperty(this, "_interactionTrackers", void 0);
    _defineProperty(this, "_isMounted", void 0);
    _defineProperty(this, "_isTwoColumn", void 0);
    _defineProperty(this, "_translationLinter", void 0);
    _defineProperty(this, "lastRenderedMarkdown", void 0);
    _defineProperty(this, "reuseMarkdown", void 0);
    _defineProperty(this, "translationIndex", void 0);
    _defineProperty(this, "widgetIds", void 0);
    _defineProperty(this, "getApiOptions", () => {
      return {
        ...ApiOptions.defaults,
        ...this.props.apiOptions
      };
    });
    _defineProperty(this, "_getInitialWidgetState", props => {
      const allWidgetInfo = this._getAllWidgetsInfo(props);
      return {
        widgetInfo: allWidgetInfo,
        widgetProps: this._getAllWidgetsStartProps(allWidgetInfo, props)
      };
    });
    _defineProperty(this, "_getAllWidgetsInfo", props => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ [key: string]: PerseusWidget; }' is not assignable to parameter of type 'Partial<Record<string, CategorizerWidget>>'.
      return mapObject$2(props.widgets, (widgetInfo, widgetId) => {
        if (!widgetInfo.type || !widgetInfo.alignment) {
          const newValues = {};
          if (!widgetInfo.type) {
            newValues.type = widgetId.split(" ")[0];
          }
          if (!widgetInfo.alignment) {
            newValues.alignment = "default";
          }
          widgetInfo = ___default["default"].extend({}, widgetInfo, newValues);
        }
        return upgradeWidgetInfoToLatestVersion(widgetInfo);
      });
    });
    _defineProperty(this, "_getAllWidgetsStartProps", (allWidgetInfo, props) => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ [key: string]: PerseusWidget; }' is not assignable to parameter of type 'Partial<Record<string, CategorizerWidget>>'.
      return mapObject$2(allWidgetInfo, widgetInfo => {
        return getRendererPropsForWidgetInfo(widgetInfo, props.problemNum);
      });
    });
    _defineProperty(this, "_getDefaultWidgetInfo", widgetId => {
      const widgetIdParts = Util.rTypeFromWidgetId.exec(widgetId);
      if (widgetIdParts == null) {
        // We should probably return null here since there's no
        // widget with the given id.
        // NOTE(jeremy): Further, the widgetId we were given does not even
        // look like a widget ID (ie. `widget-type \d+`). I can't figure
        // out how to trigger this line of code though.
        /* c8 ignore next line */
        return {};
      }
      return {
        type: widgetIdParts[1],
        graded: true,
        options: {}
      };
    });
    _defineProperty(this, "_getWidgetInfo", widgetId => {
      return this.state.widgetInfo[widgetId] || this._getDefaultWidgetInfo(widgetId);
    });
    _defineProperty(this, "renderWidget", (impliedType, id, state) => {
      const widgetInfo = this.state.widgetInfo[id];
      if (widgetInfo && widgetInfo.alignment === "full-width") {
        state.foundFullWidth = true;
      }
      if (widgetInfo) {
        const type = widgetInfo && widgetInfo.type || impliedType;
        const shouldHighlight = ___default["default"].contains(
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly any[] | undefined' is not assignable to parameter of type 'Collection<any>'.
        this.props.highlightedWidgets, id);

        // By this point we should have no duplicates, which are
        // filtered out in this.render(), so we shouldn't have to
        // worry about using this widget key and ref:
        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: "container:" + id
        }, /*#__PURE__*/React__namespace.createElement(WidgetContainer, {
          ref: "container:" + id,
          type: type,
          initialProps: this.getWidgetProps(id),
          shouldHighlight: shouldHighlight,
          linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "widget")
        }));
      }
      return null;
    });
    _defineProperty(this, "getWidgetProps", id => {
      const apiOptions = this.getApiOptions();
      const widgetProps = this.state.widgetProps[id] || {};

      // The widget needs access to its "rubric" at all times when in review
      // mode (which is really just part of its widget info).
      let reviewModeRubric = null;
      const widgetInfo = this.state.widgetInfo[id];
      if (this.props.reviewMode && widgetInfo) {
        reviewModeRubric = widgetInfo.options;
      }
      if (!this._interactionTrackers) {
        this._interactionTrackers = {};
      }
      let interactionTracker = this._interactionTrackers[id];
      if (!interactionTracker) {
        interactionTracker = this._interactionTrackers[id] = new InteractionTracker(apiOptions.trackInteraction,
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | null | undefined' is not assignable to parameter of type 'string'.
        widgetInfo && widgetInfo.type, id,
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | null | undefined' is not assignable to parameter of type 'string'.
        getTracking(widgetInfo && widgetInfo.type));
      }
      return {
        ...widgetProps,
        ref: id,
        widgetId: id,
        alignment: widgetInfo && widgetInfo.alignment,
        // When determining if a widget is static, we verify that the widget is not an
        // exercise question by verifying that it has no problem number.
        static: widgetInfo && widgetInfo.static && !this.props.problemNum,
        problemNum: this.props.problemNum,
        apiOptions: this.getApiOptions(),
        keypadElement: this.props.keypadElement,
        questionCompleted: this.props.questionCompleted,
        onFocus: ___default["default"].partial(this._onWidgetFocus, id),
        onBlur: ___default["default"].partial(this._onWidgetBlur, id),
        findWidgets: this.findWidgets,
        reviewModeRubric: reviewModeRubric,
        onChange: function (newProps, cb) {
          let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          _this._setWidgetProps(id, newProps, cb, silent);
        },
        trackInteraction: interactionTracker.track,
        isLastUsedWidget: id === this.state.lastUsedWidgetId
      };
    });
    _defineProperty(this, "getSerializedState", widgetProps => {
      return mapObject$2(widgetProps || this.state.widgetProps, (props, widgetId) => {
        const widget = this.getWidgetInstance(widgetId);
        if (widget && widget.getSerializedState) {
          return widget.getSerializedState();
        }
        return props;
      });
    });
    _defineProperty(this, "restoreSerializedState", (serializedState, callback) => {
      // Do some basic validation on the serialized state (just make sure the
      // widget IDs are what we expect).
      const serializedWidgetIds = ___default["default"].keys(serializedState);
      const widgetPropIds = ___default["default"].keys(this.state.widgetProps);

      // If the two lists of IDs match (ignoring order)
      if (serializedWidgetIds.length !== widgetPropIds.length || ___default["default"].intersection(serializedWidgetIds, widgetPropIds).length !== serializedWidgetIds.length) {
        Log.error("Refusing to restore bad serialized state:", Errors.Internal, {
          loggedMetadata: {
            serializedState: JSON.stringify(serializedState),
            currentProps: JSON.stringify(this.state.widgetProps)
          }
        });
        return;
      }

      // We want to wait until any children widgets who have a
      // restoreSerializedState function also call their own callbacks before
      // we declare that the operation is finished.
      let numCallbacks = 1;
      const fireCallback = () => {
        --numCallbacks;
        if (callback && numCallbacks === 0) {
          callback();
        }
      };
      this.setState({
        widgetProps: mapObject$2(serializedState, (props, widgetId) => {
          const widget = this.getWidgetInstance(widgetId);
          if (widget && widget.restoreSerializedState) {
            // Note that we probably can't call
            // `this.change()/this.props.onChange()` in this
            // function, so we take the return value and use
            // that as props if necessary so that
            // `restoreSerializedState` in a widget can
            // change the props as well as state.
            // If a widget has no props to change, it can
            // safely return null.
            ++numCallbacks;
            const restoreResult = widget.restoreSerializedState(props, fireCallback);
            return ___default["default"].extend({}, this.state.widgetProps[widgetId], restoreResult);
          }
          return props;
        })
      }, () => {
        // Wait until all components have rendered. In React 16 setState
        // callback fires immediately after this componentDidUpdate, and
        // there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(fireCallback, 0);
      });
    });
    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", () => {
      Object.keys(this.props.widgets).forEach(widgetId => {
        const widget = this.getWidgetInstance(widgetId);
        if (widget && widget.showRationalesForCurrentlySelectedChoices) {
          widget.showRationalesForCurrentlySelectedChoices(this._getWidgetInfo(widgetId).options);
        }
      });
    });
    _defineProperty(this, "deselectIncorrectSelectedChoices", () => {
      // TODO(emily): this has the exact same structure as
      // showRationalesForCurrentlySelectedChoices above. Maybe DRY this up.
      Object.keys(this.props.widgets).forEach(widgetId => {
        const widget = this.getWidgetInstance(widgetId);
        if (widget && widget.deselectIncorrectSelectedChoices) {
          widget.deselectIncorrectSelectedChoices();
        }
      });
    });
    _defineProperty(this, "findInternalWidgets", filterCriterion => {
      let filterFunc;
      // Convenience filters:
      // "interactive-graph 3" will give you [[interactive-graph 3]]
      // "interactive-graph" will give you all interactive-graphs
      if (typeof filterCriterion === "string") {
        if (filterCriterion.indexOf(" ") !== -1) {
          const widgetId = filterCriterion;
          filterFunc = (id, widgetInfo, widget) => id === widgetId;
        } else {
          const widgetType = filterCriterion;
          filterFunc = (id, widgetInfo, widget) => {
            return widgetInfo.type === widgetType;
          };
        }
      } else {
        filterFunc = filterCriterion;
      }
      const results = this.widgetIds.filter(id => {
        const widgetInfo = this._getWidgetInfo(id);
        const widget = this.getWidgetInstance(id);
        return filterFunc(id, widgetInfo, widget);
      }).map(this.getWidgetInstance);
      return results;
    });
    _defineProperty(this, "findWidgets", filterCriterion => {
      return [...this.findInternalWidgets(filterCriterion), ...this.props.findExternalWidgets(filterCriterion)];
    });
    _defineProperty(this, "getWidgetInstance", id => {
      // eslint-disable-next-line react/no-string-refs
      const ref = this.refs["container:" + id];
      if (!ref) {
        return null;
      }
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getWidget' does not exist on type 'ReactInstance'.
      return ref.getWidget();
    });
    _defineProperty(this, "_onWidgetFocus", function (id) {
      let focusPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (!___default["default"].isArray(focusPath)) {
        throw new PerseusError("widget props.onFocus focusPath must be an Array, " + "but was" + JSON.stringify(focusPath), Errors.Internal);
      }
      _this._setCurrentFocus([id].concat(focusPath));
    });
    _defineProperty(this, "_onWidgetBlur", (id, blurPath) => {
      const blurringFocusPath = this._currentFocus;

      // Failsafe: abort if ID is different, because focus probably happened
      // before blur
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      const fullPath = [id].concat(blurPath);
      if (!___default["default"].isEqual(fullPath, blurringFocusPath)) {
        return;
      }

      // Wait until after any new focus events fire this tick before
      // declaring that nothing is focused.
      // If a different widget was focused, we'll see an onBlur event
      // now, but then an onFocus event on a different element before
      // this callback is executed
      ___default["default"].defer(() => {
        if (___default["default"].isEqual(this._currentFocus, blurringFocusPath)) {
          this._setCurrentFocus(null);
        }
      });
    });
    _defineProperty(this, "getContent", (props, state) => {
      return state.jiptContent || props.content;
    });
    _defineProperty(this, "shouldRenderJiptPlaceholder", (props, state) => {
      // TODO(aria): Pass this in via webapp as an apiOption
      return getDependencies().JIPT.useJIPT && state.jiptContent == null && props.content.indexOf("crwdns") !== -1;
    });
    _defineProperty(this, "replaceJiptContent", (content, paragraphIndex) => {
      if (paragraphIndex == null) {
        // we're not translating paragraph-wise; replace the whole content
        // (we could also theoretically check for apiOptions.isArticle
        // here, which is what causes paragraphIndex to not be null)
        this.setState({
          jiptContent: content
        });
      } else {
        // This is the same regex we use in perseus/translate.py to find
        // code blocks. We use it to count entire code blocks as
        // paragraphs.
        const codeFenceRegex = /^\s*(`{3,}|~{3,})\s*(\S+)?\s*\n([\s\S]+?)\s*\1\s*$/;
        if (codeFenceRegex.test(content)) ; else if (/\S\n\s*\n\S/.test(content)) {
          // Our "render the exact same QuestionParagraphs each time"
          // strategy will fail if we allow translating a paragraph
          // to more than one paragraph. This hack renders as a single
          // paragraph and lets the translator know to not use \n\n,
          // hopefully. We can't wait for linting because we can't
          // safely render the node.
          // TODO(aria): Check for the max number of backticks or tildes
          // in the content, and just render a red code block of the
          // content here instead?
          content = "$\\large{\\red{\\text{Please translate each " + "paragraph to a single paragraph.}}}$";
        } else if (/^\s*$/.test(content)) {
          // We similarly can't have an all-whitespace paragraph, or
          // we will parse it as the closing of the previous paragraph
          content = "$\\large{\\red{\\text{Translated paragraph is " + "currently empty}}}$";
        }
        // Split the paragraphs; we have to use getContent() in case
        // nothing has been translated yet (in which case we just have
        // this.props.content)
        const allContent = this.getContent(this.props, this.state);
        const paragraphs = JiptParagraphs.parseToArray(allContent);
        paragraphs[paragraphIndex] = content;
        this.setState({
          jiptContent: JiptParagraphs.joinFromArray(paragraphs)
        });
      }
    });
    _defineProperty(this, "outputMarkdown", (ast, state) => {
      if (___default["default"].isArray(ast)) {
        // This is duplicated from simple-markdown
        // TODO(aria): Don't duplicate this logic
        const oldKey = state.key;
        const result = [];

        // map nestedOutput over the ast, except group any text
        // nodes together into a single string output.
        // NOTE(aria): These are never strings--always QuestionParagraphs
        // TODO(aria): We probably don't need this string logic here.
        let lastWasString = false;
        for (let i = 0; i < ast.length; i++) {
          state.key = i;
          state.paragraphIndex = i;
          const nodeOut = this.outputMarkdown(ast[i], state);
          const isString = typeof nodeOut === "string";
          // NOTE(jeremy): As far as I can tell, this if is _never_
          // reached. As noted above, these are always QuestionParagraphs
          // now.
          /* c8 ignore if */
          if (typeof nodeOut === "string" && lastWasString) {
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'never'.
            result[result.length - 1] += nodeOut;
          } else {
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'ReactElement<any, string | JSXElementConstructor<any>>' is not assignable to parameter of type 'never'.
            result.push(nodeOut);
          }
          lastWasString = isString;
        }
        state.key = oldKey;
        return result;
      }
      // !!! WARNING: Mutative hacks! mutates `this._foundTextNodes`:
      // because I wrote a bad interface to simple-markdown.js' `output`
      this._foundTextNodes = false;
      state.foundFullWidth = false;
      const output = this.outputNested(ast, state);

      // In Jipt-land, we need to render the exact same outer
      // QuestionParagraph nodes always. This means the number of
      // paragraphs needs to stay the same, and we can't modify
      // the classnames on the QuestionParagraphs or we'll destroy
      // the crowdin classnames. So we just only use the
      // 'paragraph' classname from the QuestionParagraph.
      // If this becomes a problem it would be easy to fix by wrapping
      // the nodes in an extra layer (hopefully only for jipt) that
      // handles the jipt classnames, and let this layer handle the
      // dynamic classnames.
      // We can't render the classes the first time and leave them
      // the same because we don't know at the time of the first
      // render whether they are full-bleed or centered, since they
      // only contain crowdin IDs like `crwdns:972384209:0...`
      let className;
      if (this.translationIndex != null) {
        className = null;
      } else {
        className = classNames__default["default"]({
          "perseus-paragraph-centered": !this._foundTextNodes,
          // There is only one node being rendered,
          // and it's a full-width widget.
          "perseus-paragraph-full-width": state.foundFullWidth && ast.content.length === 1
        });
      }
      return /*#__PURE__*/React__namespace.createElement(QuestionParagraph, {
        key: state.key,
        className: className,
        translationIndex: this.translationIndex,
        paragraphIndex: state.paragraphIndex
      }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, output));
    });
    _defineProperty(this, "outputNested", (ast, state) => {
      if (___default["default"].isArray(ast)) {
        // This is duplicated from simple-markdown
        // TODO(aria): Don't duplicate this logic
        const oldKey = state.key;
        const result = [];

        // map nestedOutput over the ast, except group any text
        // nodes together into a single string output.
        let lastWasString = false;
        for (let i = 0; i < ast.length; i++) {
          state.key = i;
          const nodeOut = this.outputNested(ast[i], state);
          const isString = typeof nodeOut === "string";
          if (typeof nodeOut === "string" && lastWasString) {
            /**
             * We know that last was string, but TypeScript can't see this
             * refinement.
             */
            result[result.length - 1] += nodeOut;
          } else {
            result.push(nodeOut);
          }
          lastWasString = isString;
        }
        state.key = oldKey;
        return result;
      }
      return this.outputNode(ast, this.outputNested, state);
    });
    _defineProperty(this, "outputNode", (node, nestedOutput, state) => {
      const apiOptions = this.getApiOptions();
      const imagePlaceholder = apiOptions.imagePlaceholder;
      if (node.type === "widget") {
        const widgetPlaceholder = apiOptions.widgetPlaceholder;
        if (widgetPlaceholder) {
          return widgetPlaceholder;
        }
        // Widgets can contain text nodes, so we don't center them with
        // markdown magic here.
        // Instead, we center them with css magic in articles.less
        // /cry(aria)
        this._foundTextNodes = true;
        if (___default["default"].contains(this.widgetIds, node.id)) {
          // We don't want to render a duplicate widget key/ref,
          // as this causes problems with react (for obvious
          // reasons). Instead we just notify the
          // hopefully-content-creator that they need to change the
          // widget id.
          return /*#__PURE__*/React__namespace.createElement("span", {
            key: state.key,
            className: "renderer-widget-error"
          }, ["Widget [[", "☃", " ", node.id, "]] already exists."].join(""));
        }
        this.widgetIds.push(node.id);
        return this.renderWidget(node.widgetType, node.id, state);
      }
      if (node.type === "blockMath") {
        // We render math here instead of in perseus-markdown.jsx
        // because we need to pass it our onRender callback.
        const content = preprocessTex(node.content);
        const innerStyle = {
          // HACK(benkomalo): we only want horizontal scrolling, but
          // overflowX: 'auto' causes a vertical scrolling scrollbar
          // as well, despite the parent and child elements having
          // the exact same height. Force it to not scroll by
          // applying overflowY: 'hidden'
          overflowX: "auto",
          overflowY: "hidden",
          // HACK(kevinb): overflowY: 'hidden' inadvertently clips the
          // top and bottom of some fractions.  We add padding to the
          // top and bottom to avoid the clipping and then correct for
          // the padding by adding equal but opposite margins.
          paddingTop: 10,
          paddingBottom: 10,
          marginTop: -10,
          marginBottom: -10
        };
        if (apiOptions.isMobile) {
          // The style for the body of articles and exercises on mobile is
          // to have a 16px margin.  When a user taps to zoom math we'd
          // like the math to extend all the way to the edge of the page/
          // To achieve this affect we nest the Zoomable component in two
          // nested divs. The outer div has a negative margin to
          // counteract the margin on main perseus container.  The inner
          // div adds the margin back as padding so that when the math is
          // scaled out it's inset from the edge of the page.  When the
          // TeX component is full size it will extend to the edge of the
          // page if it's larger than the page.
          //
          // TODO(kevinb) automatically determine the margin size
          const margin = 16;
          const outerStyle = {
            marginLeft: -margin,
            marginRight: -margin
          };
          const horizontalPadding = {
            paddingLeft: margin,
            paddingRight: margin
          };
          const mobileInnerStyle = {
            ...innerStyle,
            ...styles$z.mobileZoomableParentFix
          };
          return /*#__PURE__*/React__namespace.createElement("div", {
            key: state.key,
            className: "perseus-block-math",
            style: outerStyle
          }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("div", {
            className: "perseus-block-math-inner",
            style: {
              ...mobileInnerStyle,
              ...horizontalPadding
            }
          }, /*#__PURE__*/React__namespace.createElement(ZoomableTeX, null, content))));
        }
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: state.key,
          className: "perseus-block-math"
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("div", {
          className: "perseus-block-math-inner",
          style: innerStyle
        }, /*#__PURE__*/React__namespace.createElement(context$2.Consumer, null, _ref => {
          let {
            setAssetStatus
          } = _ref;
          return /*#__PURE__*/React__namespace.createElement(Tex, {
            setAssetStatus: setAssetStatus
          }, content);
        }))));
      }
      if (node.type === "math") {
        // Replace uses of \begin{align}...\end{align} which KaTeX doesn't
        // support (yet) with \begin{aligned}...\end{aligned} which renders
        // the same is supported by KaTeX.  It does the same for align*.
        // TODO(kevinb) update content to use aligned instead of align.
        const tex = node.content.replace(/\{align[*]?\}/g, "{aligned}");

        // We render math here instead of in perseus-markdown.jsx
        // because we need to pass it our onRender callback.
        return /*#__PURE__*/React__namespace.createElement("span", {
          key: state.key,
          style: {
            // If math is directly next to text, don't let it
            // wrap to the next line
            whiteSpace: "nowrap"
          }
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("span", null), /*#__PURE__*/React__namespace.createElement(context$2.Consumer, null, _ref2 => {
          let {
            setAssetStatus
          } = _ref2;
          return /*#__PURE__*/React__namespace.createElement(Tex, {
            onRender: this.props.onRender,
            setAssetStatus: setAssetStatus
          }, tex);
        }), /*#__PURE__*/React__namespace.createElement("span", null)));
      }
      if (node.type === "image") {
        if (imagePlaceholder) {
          return imagePlaceholder;
        }

        // We need to add width and height to images from our
        // props.images mapping.

        // We do a _.has check here to avoid weird things like
        // 'toString' or '__proto__' as a url.
        const extraAttrs = ___default["default"].has(this.props.images, node.target) ? this.props.images[node.target] : null;

        // The width of a table column is determined by the widest table
        // cell within that column, but responsive images constrain
        // themselves to the width of their parent containers. Thus,
        // responsive images don't do very well within tables. To avoid
        // haphazard sizing, simply make images within tables unresponsive.
        // TODO(alex): Make tables themselves responsive.
        const responsive = !state.inTable;
        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: state.key
        }, /*#__PURE__*/React__namespace.createElement(context$2.Consumer, null, _ref3 => {
          let {
            setAssetStatus
          } = _ref3;
          return /*#__PURE__*/React__namespace.createElement(SvgImage, _extends({
            setAssetStatus: setAssetStatus
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'string | null | undefined' is not assignable to type 'string | undefined'.
            ,
            src: PerseusMarkdown.sanitizeUrl(node.target),
            alt: node.alt,
            title: node.title,
            responsive: responsive,
            onUpdate: this.props.onRender,
            zoomToFullSizeOnMobile: apiOptions.isMobile && apiOptions.isArticle
          }, extraAttrs));
        }));
      }
      if (node.type === "columns") {
        // Note that we have two columns. This is so we can put
        // a className on the outer renderer content for SAT.
        // TODO(aria): See if there is a better way we can do
        // things like this
        this._isTwoColumn = true;
        // but then render normally:
        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: state.key
        }, PerseusMarkdown.ruleOutput(node, nestedOutput, state));
      }
      if (node.type === "text") {
        if (rContainsNonWhitespace.test(node.content)) {
          this._foundTextNodes = true;
        }

        // Used by the translator portal to replace image URLs with
        // placeholders, see preprocessWidgets in manticore-utils.js
        // for more details.
        if (imagePlaceholder && rImageURL.test(node.content)) {
          return imagePlaceholder;
        }
        return node.content;
      }
      if (node.type === "table" || node.type === "titledTable") {
        const output = PerseusMarkdown.ruleOutput(node, nestedOutput, {
          ...state,
          isMobile: apiOptions.isMobile,
          inTable: true
        });
        if (!apiOptions.isMobile) {
          return output;
        }
        const margin = 16;
        const outerStyle = {
          marginLeft: -margin,
          marginRight: -margin
        };
        const innerStyle = {
          paddingLeft: 0,
          paddingRight: 0
        };
        const mobileInnerStyle = {
          ...innerStyle,
          ...styles$z.mobileZoomableParentFix
        };
        const wrappedOutput = /*#__PURE__*/React__namespace.createElement("div", {
          style: {
            ...mobileInnerStyle,
            overflowX: "auto"
          }
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement(Zoomable, {
          animateHeight: true
        }, output)));

        // TODO(benkomalo): how should we deal with tappable items inside
        // of tables?
        return /*#__PURE__*/React__namespace.createElement("div", {
          style: outerStyle
        }, wrappedOutput);
      }
      // If it's a "normal" or "simple" markdown node, just
      // output it using its output rule.
      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
        key: state.key
      }, PerseusMarkdown.ruleOutput(node, nestedOutput, state));
    });
    _defineProperty(this, "handleRender", prevProps => {
      const onRender = this.props.onRender;
      const oldOnRender = prevProps.onRender;

      // In the common case of no callback specified, avoid this work.
      if (onRender !== noopOnRender || oldOnRender !== noopOnRender) {
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'find' does not exist on type 'JQueryStatic'.
        const $images = $__default["default"](ReactDOM__default["default"].findDOMNode(this)).find("img");

        // Fire callback on image load...
        if (oldOnRender !== noopOnRender) {
          $images.off("load", oldOnRender);
        }
        if (onRender !== noopOnRender) {
          $images.on("load", onRender);
        }
      }

      // ...as well as right now (non-image, non-TeX or image from cache)
      onRender();
    });
    _defineProperty(this, "_setCurrentFocus", path => {
      const apiOptions = this.getApiOptions();

      // We don't do this when the new path is a prefix because
      // that prefix is already focused (we're just in a more specific
      // area of it). This makes it safe to call _setCurrentFocus
      // whenever a widget is interacted with--we won't wipe out
      // our focus state if we are already focused on a subpart
      // of that widget (i.e. a transformation NumberInput inside
      // of a transformer widget).
      if (!isIdPathPrefix(path, this._currentFocus)) {
        const prevFocus = this._currentFocus;
        if (prevFocus) {
          this.blurPath(prevFocus);
        }
        this._currentFocus = path;
        apiOptions.onFocusChange(this._currentFocus, prevFocus);
      }
    });
    _defineProperty(this, "focus", () => {
      let id;
      let focusResult;
      for (let i = 0; i < this.widgetIds.length; i++) {
        const widgetId = this.widgetIds[i];
        const widget = this.getWidgetInstance(widgetId);
        const widgetFocusResult = widget && widget.focus && widget.focus();
        if (widgetFocusResult) {
          id = widgetId;
          focusResult = widgetFocusResult;
          break;
        }
      }
      if (id) {
        // reconstruct a {path, element} focus object
        let path;
        if (typeof focusResult === "object") {
          // TODO(jeremy): I am 99% sure this path is no longer possible.
          // In D10274, focus management sometimes returned an object
          // with a `path` and `element` key. But later in D11387 and
          // D13664 things have been changed and seemingly removed the
          // object return value.
          // The result of focus was a {path, id} object itself
          path = [id].concat(focusResult.path || []);
          Log.error("Renderer received a focus result of type 'object' " + "instead of the expected type 'boolean'", Errors.Internal, {
            loggedMetadata: {
              focusResult: JSON.stringify(focusResult),
              currentProps: JSON.stringify(this.state.widgetProps)
            }
          });
        } else {
          // The result of focus was true or the like; just
          // construct a root focus object
          path = [id];
        }
        this._setCurrentFocus(path);
        return true;
      }
    });
    _defineProperty(this, "getDOMNodeForPath", path => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const widgetId = ___default["default"].first(path);
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const interWidgetPath = ___default["default"].rest(path);

      // Widget handles parsing of the interWidgetPath. If the path is empty
      // beyond the widgetID, as a special case we just return the widget's
      // DOM node.
      const widget = this.getWidgetInstance(widgetId);
      const getNode = widget && widget.getDOMNodeForPath;
      if (getNode) {
        return getNode(interWidgetPath);
      }
      if (interWidgetPath.length === 0) {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Widget | null | undefined' is not assignable to parameter of type 'ReactInstance | null | undefined'.
        return ReactDOM__default["default"].findDOMNode(widget);
      }
    });
    _defineProperty(this, "getGrammarTypeForPath", path => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const widgetId = ___default["default"].first(path);
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const interWidgetPath = ___default["default"].rest(path);
      const widget = this.getWidgetInstance(widgetId);
      if (widget && widget.getGrammarTypeForPath) {
        return widget.getGrammarTypeForPath(interWidgetPath);
      }
    });
    _defineProperty(this, "getInputPaths", () => {
      const inputPaths = [];
      ___default["default"].each(this.widgetIds, widgetId => {
        const widget = this.getWidgetInstance(widgetId);
        if (widget && widget.getInputPaths) {
          // Grab all input paths and add widgetID to the front
          const widgetInputPaths = widget.getInputPaths();
          // Prefix paths with their widgetID and add to collective
          // list of paths.
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(inputPath: string) => void' is not assignable to parameter of type 'CollectionIterator<FocusPath, void, readonly FocusPath[]>'.
          ___default["default"].each(widgetInputPaths, inputPath => {
            const relativeInputPath = [widgetId].concat(inputPath);
            inputPaths.push(relativeInputPath);
          });
        }
      });
      return inputPaths;
    });
    _defineProperty(this, "focusPath", path => {
      // No need to focus if it's already focused
      if (___default["default"].isEqual(this._currentFocus, path)) {
        return;
      }
      if (this._currentFocus) {
        // Unfocus old path, if exists
        this.blurPath(this._currentFocus);
      }

      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const widgetId = ___default["default"].first(path);
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const interWidgetPath = ___default["default"].rest(path);

      // Widget handles parsing of the interWidgetPath
      const focusWidget = this.getWidgetInstance(widgetId);
      if (focusWidget && focusWidget.focusInputPath) {
        focusWidget.focusInputPath(interWidgetPath);
      }
    });
    _defineProperty(this, "blurPath", path => {
      // No need to blur if it's not focused
      if (!___default["default"].isEqual(this._currentFocus, path)) {
        return;
      }

      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const widgetId = ___default["default"].first(path);
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const interWidgetPath = ___default["default"].rest(path);
      const widget = this.getWidgetInstance(widgetId);
      // We might be in the editor and blurring a widget that no
      // longer exists, so only blur if we actually found the widget
      if (widget) {
        const blurWidget = this.getWidgetInstance(widgetId);
        if (blurWidget && blurWidget.blurInputPath) {
          // Widget handles parsing of the interWidgetPath
          blurWidget.blurInputPath(interWidgetPath);
        }
      }
    });
    _defineProperty(this, "blur", () => {
      if (this._currentFocus) {
        this.blurPath(this._currentFocus);
      }
    });
    _defineProperty(this, "serialize", () => {
      const state = {};
      ___default["default"].each(this.state.widgetInfo, function (info, id) {
        // eslint-disable-next-line @babel/no-invalid-this
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        // eslint-disable-next-line @babel/no-invalid-this
        const widget = this.getWidgetInstance(id);
        const s = widget.serialize();
        if (!___default["default"].isEmpty(s)) {
          state[id] = s;
        }
      }, this);
      return state;
    });
    _defineProperty(this, "emptyWidgets", () => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(id: string) => boolean | undefined' is not assignable to parameter of type 'Iteratee<string[], boolean, string>'.
      return ___default["default"].filter(this.widgetIds, id => {
        const widgetInfo = this._getWidgetInfo(id);
        if (widgetInfo.static) {
          // Static widgets shouldn't count as empty
          return false;
        }
        const widget = this.getWidgetInstance(id);
        if (widget && widget.simpleValidate) {
          const score = widget.simpleValidate(widgetInfo.options,
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'null' is not assignable to parameter of type '((widgetId: any, value: string, message?: string | null | undefined) => unknown) | undefined'.
          null);
          return Util.scoreIsEmpty(score);
        }
      });
    });
    _defineProperty(this, "_setWidgetProps", (id, newProps, cb, silent) => {
      this.setState(prevState => {
        const widgetProps = {
          ...prevState.widgetProps,
          [id]: {
            ...prevState.widgetProps[id],
            ...newProps
          }
        };

        // Update the `lastUsedWidgetId` to this widget - unless we're
        // in silent mode. We only want to track the last widget that
        // was actually _used_, and silent updates generally don't come
        // from _usage_.
        const lastUsedWidgetId = silent ? prevState.lastUsedWidgetId : id;
        if (!silent) {
          this.props.onSerializedStateUpdated(this.getSerializedState(widgetProps));
        }
        return {
          lastUsedWidgetId,
          widgetProps
        };
      }, () => {
        // Wait until all components have rendered. In React 16 setState
        // callback fires immediately after this componentDidUpdate, and
        // there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          const cbResult = cb && cb();
          if (!silent) {
            this.props.onInteractWithWidget(id);
          }
          if (cbResult !== false) {
            // TODO(jack): For some reason, some widgets don't always
            // end up in refs here, which is repro-able if you make an
            // [[ orderer 1 ]] and copy-paste this, then change it to
            // be an [[ orderer 2 ]]. The resulting Renderer ends up
            // with an "orderer 2" ref but not an "orderer 1" ref.
            // @_@??
            // TODO(jack): Figure out why this is happening and fix it
            // As far as I can tell, this is only an issue in the
            // editor-page, so doing this shouldn't break clients
            // hopefully
            this._setCurrentFocus([id]);
          }
        }, 0);
      });
    });
    _defineProperty(this, "setInputValue", (path, newValue, focus) => {
      var _widget$setInputValue;
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const widgetId = ___default["default"].first(path);
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'FocusPath' is not assignable to parameter of type 'List<any>'.
      const interWidgetPath = ___default["default"].rest(path);
      const widget = this.getWidgetInstance(widgetId);

      // Widget handles parsing of the interWidgetPath.
      widget === null || widget === void 0 ? void 0 : (_widget$setInputValue = widget.setInputValue) === null || _widget$setInputValue === void 0 ? void 0 : _widget$setInputValue.call(widget, interWidgetPath, newValue, focus);
    });
    _defineProperty(this, "getUserInput", () => {
      return this.widgetIds.map(id => {
        const widget = this.getWidgetInstance(id);
        if (widget && widget.getUserInput) {
          // TODO(Jeremy): Add the widget ID in here so we can more
          // easily correlate it to the widget state.
          return widget.getUserInput();
        }
      });
    });
    _defineProperty(this, "getWidgetIds", () => {
      return this.widgetIds;
    });
    _defineProperty(this, "getUserInputForWidgets", () => {
      return mapObjectFromArray(this.widgetIds, id => {
        const widget = this.getWidgetInstance(id);
        if (widget && widget.getUserInput) {
          return widget.getUserInput();
        }
      });
    });
    _defineProperty(this, "scoreWidgets", () => {
      const widgetProps = this.state.widgetInfo;
      const onInputError = this.getApiOptions().onInputError;
      const gradedWidgetIds = ___default["default"].filter(this.widgetIds, id => {
        const props = widgetProps[id];
        const widgetIsGraded = (props === null || props === void 0 ? void 0 : props.graded) == null || props.graded;
        const widgetIsStatic = !!(props !== null && props !== void 0 && props.static);
        // Ungraded widgets or widgets set to static shouldn't be graded.
        return widgetIsGraded && !widgetIsStatic;
      });
      const widgetScores = {};
      ___default["default"].each(gradedWidgetIds, id => {
        const props = widgetProps[id];
        const widget = this.getWidgetInstance(id);
        // widget can be undefined if it hasn't yet been rendered
        if (widget && widget.simpleValidate) {
          widgetScores[id] = widget.simpleValidate(props === null || props === void 0 ? void 0 : props.options, onInputError);
        }
      });
      return widgetScores;
    });
    _defineProperty(this, "score", () => {
      return ___default["default"].reduce(this.scoreWidgets(), Util.combineScores, Util.noScore);
    });
    _defineProperty(this, "guessAndScore", () => {
      const totalGuess = this.getUserInput();
      const totalScore = this.score();
      return [totalGuess, totalScore];
    });
    _defineProperty(this, "examples", () => {
      const widgetIds = this.widgetIds;
      const examples = ___default["default"].compact(___default["default"].map(widgetIds, widgetId => {
        const widget = this.getWidgetInstance(widgetId);
        return widget != null && widget.examples ? widget.examples() : null;
      }));

      // no widgets with examples
      if (!examples.length) {
        return null;
      }
      const allEqual = ___default["default"].all(examples, function (example) {
        return ___default["default"].isEqual(examples[0], example);
      });

      // some widgets have different examples
      // TODO(alex): handle this better
      if (!allEqual) {
        return null;
      }
      return examples[0];
    });
    _defineProperty(this, "handletranslationLintErrors", lintErrors => {
      if (!this._isMounted) {
        return;
      }
      this.setState({
        translationLintErrors: lintErrors
      });
    });
    this._translationLinter = new TranslationLinter();
    this.state = {
      jiptContent: null,
      // TranslationLinter is async and currently does not contain a
      // location. This is a list of error strings TranslationLinter
      // detected on its last run.
      translationLintErrors: [],
      // The ID of the last widget the user interacted with. We'll
      // use this to set the `isLastUsedWidget` flag on the
      // corresponding widget.
      lastUsedWidgetId: null,
      ...this._getInitialWidgetState(_props)
    };
  }
  componentDidMount() {
    this._isMounted = true;

    // figure out why we're passing an empty object
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{}' is not assignable to parameter of type 'Props'.
    this.handleRender({});
    this._currentFocus = null;

    // TODO(emily): actually make the serializedState prop work like a
    // controlled prop, instead of manually calling .restoreSerializedState
    // at the right times.
    if (this.props.serializedState) {
      this.restoreSerializedState(this.props.serializedState);
    }
    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If there are lint errors,
      // this component will be rerendered.
      this._translationLinter.runLinter(this.props.content, this.handletranslationLintErrors);
    }
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!___default["default"].isEqual(___default["default"].pick(this.props, SHOULD_CLEAR_WIDGETS_PROP_LIST), ___default["default"].pick(nextProps, SHOULD_CLEAR_WIDGETS_PROP_LIST))) {
      this.setState(this._getInitialWidgetState(nextProps));
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    // QUESTION(jeremy): Shouldn't we look at `nextProps` here? Otherwise
    // we're always looking "one render behind".
    if (this.props.alwaysUpdate) {
      // TOTAL hacks so that findWidgets doesn't break
      // when one widget updates without the other.
      // See passage-refs inside radios, which was why
      // this was introduced.
      // I'm sorry!
      // TODO(aria): cry
      //
      // HACK(djf): I've also set this alwaysUpdate property from
      // async-renderer.jsx in the manticore-package. I'm doing this
      // to work around an infinite loop of some sort that started
      // happening in manticore after the React 16 update. After
      // clicking around in the manticore exercise editor (for example)
      // the UI would freeze up, and the debugger would show that
      // we were always deep in a recursion on the propsChanged line
      // below. There is some kind of timing issue causing some kind
      // of infinite loop, but by avoiding the time-consuming deep
      // equal comparisons on our props (which are often huge) I can
      // no longer reproduce the bug.
      // TODO(djf): Remove this comment
      // https://khanacademy.atlassian.net/browse/CP-834 is resolved.
      return true;
    }
    const stateChanged = !___default["default"].isEqual(this.state, nextState);
    const propsChanged = !___default["default"].isEqual(this.props, nextProps);
    return propsChanged || stateChanged;
  }
  UNSAFE_componentWillUpdate(nextProps, nextState) {
    const oldJipt = this.shouldRenderJiptPlaceholder(this.props, this.state);
    const newJipt = this.shouldRenderJiptPlaceholder(nextProps, nextState);
    const oldContent = this.getContent(this.props, this.state);
    const newContent = this.getContent(nextProps, nextState);
    const oldHighlightedWidgets = this.props.highlightedWidgets;
    const newHighlightedWidgets = nextProps.highlightedWidgets;

    // TODO(jared): This seems to be a perfect overlap with
    // "shouldComponentUpdate" -- can we just remove this
    // componentWillUpdate and the reuseMarkdown attr?
    this.reuseMarkdown = !oldJipt && !newJipt && oldContent === newContent && ___default["default"].isEqual(this.state.translationLintErrors, nextState.translationLintErrors) && (
    // If we are running the linter then we need to know when
    // widgets have changed because we need for force the linter to
    // run when that happens. Note: don't do identity comparison here:
    // it can cause frequent re-renders that break MathJax somehow
    !this.props.linterContext.highlightLint || ___default["default"].isEqual(this.props.widgets, nextProps.widgets)) &&
    // If the linter is turned on or off, we have to rerender
    this.props.linterContext.highlightLint === nextProps.linterContext.highlightLint &&
    // yes, this is identity array comparison, but these are passed
    // in from state in the item-renderer, so they should be
    // identity equal unless something changed, and it's expensive
    // to loop through them to look for differences.
    // Technically, we could reuse the markdown when this changes,
    // but to do that we'd have to do more expensive checking of
    // whether a widget should be highlighted in the common case
    // where this array hasn't changed, so we just redo the whole
    // render if this changed
    oldHighlightedWidgets === newHighlightedWidgets;
  }
  componentDidUpdate(prevProps, prevState) {
    this.handleRender(prevProps);
    // We even do this if we did reuse the markdown because
    // we might need to update the widget props on this render,
    // even though we have the same widgets.
    // WidgetContainers don't update their widgets' props when
    // they are re-rendered, so even if they've been
    // re-rendered we need to call these methods on them.
    ___default["default"].each(this.widgetIds, id => {
      // eslint-disable-next-line react/no-string-refs
      const container = this.refs["container:" + id];
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'replaceWidgetProps' does not exist on type 'ReactInstance'.
      container && container.replaceWidgetProps(this.getWidgetProps(id));
    });
    if (this.props.serializedState && !___default["default"].isEqual(this.props.serializedState, this.getSerializedState())) {
      this.restoreSerializedState(this.props.serializedState);
    }
    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If lint errors have changed
      // since the last run, this component will be rerendered.
      this._translationLinter.runLinter(this.props.content, this.handletranslationLintErrors);
    }
  }
  componentWillUnmount() {
    // Clean out the list of widgetIds when unmounting, as this list is
    // meant to be consistent with the refs controlled by the renderer, and
    // refs are also cleared out during unmounting.
    // (This may not be totally necessary, but mobile clients have been
    // seeing JS errors due to an inconsistency between the list of
    // widgetIds and the child refs of the renderer.
    // See: https://phabricator.khanacademy.org/D32420.)
    this.widgetIds = [];
    if (this.translationIndex != null) {
      // NOTE(jeremy): Since the translationIndex is simply the array
      // index of each renderer, we can't remove Renderers from this
      // list, rather, we simply null out the entry (which means that
      // this array's growth is unbounded until a page reload).
      getDependencies().rendererTranslationComponents.removeComponentAtIndex(this.translationIndex);
    }
    this._isMounted = false;
  }
  render() {
    const apiOptions = this.getApiOptions();
    if (this.reuseMarkdown) {
      return this.lastRenderedMarkdown;
    }
    const content = this.getContent(this.props, this.state);
    // `this.widgetIds` is appended to in `this.outputMarkdown`:
    this.widgetIds = [];
    if (this.shouldRenderJiptPlaceholder(this.props, this.state)) {
      // Crowdin's JIPT (Just in place translation) uses a fake language
      // with language tag "en-pt" where the value of the translations
      // look like: {crwdns2657085:0}{crwdne2657085:0} where it keeps the
      // {crowdinId:ngettext variant}. We detect whether the current
      // content matches this, so we can take over rendering of
      // the perseus content as the translators interact with jipt.
      // We search for only part of the tag that crowdin uses to guard
      // against them changing the format on us. The full tag it looks
      // for can be found in https://cdn.crowdin.net/jipt/jipt.js
      // globalPhrase var.

      // If we haven't already added this component to the registry do so
      // now. showHints() may cause this component to be rerendered
      // before jipt has a chance to replace its contents, so this check
      // will keep us from adding the component to the registry a second
      // time.
      if (!this.translationIndex) {
        this.translationIndex = getDependencies().rendererTranslationComponents.addComponent(this);
      }

      // For articles, we add jipt data to individual paragraphs. For
      // exercises, we add it to the renderer and let translators
      // translate the entire thing. For the article equivalent of
      // this if block, search this file for where we render a
      // QuestionParagraph, and see the `isJipt:` parameter sent to
      // PerseusMarkdown.parse()
      if (!apiOptions.isArticle) {
        // We now need to output this tag, as jipt looks for it to be
        // able to replace it with a translation that it runs an ajax
        // call to get.  We add a data attribute with the index to the
        // Persues.TranslationComponent registry so that when jipt
        // calls its before_dom_insert we can lookup this component by
        // this attribute and render the text with markdown.
        return /*#__PURE__*/React__namespace.createElement(DefinitionProvider, null, /*#__PURE__*/React__namespace.createElement("div", {
          "data-perseus-component-index": this.translationIndex
        }, content));
      }
    }

    // Hacks:
    // We use mutable state here to figure out whether the output
    // had two columns.
    // It is updated to true by `this.outputMarkdown` if a
    // column break is found
    // TODO(aria): We now have a state variable threaded through
    // simple-markdown output. We should mutate it instead of
    // state on this component to do this in a less hacky way.
    this._isTwoColumn = false;

    // Parse the string of markdown to a parse tree
    const parsedMarkdown = PerseusMarkdown.parse(content, {
      // Recognize crowdin IDs while translating articles
      // (This should never be hit by exercises, though if you
      // decide you want to add a check that this is an article,
      // go for it.)
      isJipt: this.translationIndex != null
    });

    // Optionally apply the linter to the parse tree
    if (this.props.linterContext.highlightLint) {
      // If highlightLint is true and lint is detected, this call
      // will modify the parse tree by adding lint nodes that will
      // serve to highlight the lint when rendered
      const context = {
        content: this.props.content,
        widgets: this.props.widgets,
        ...this.props.linterContext
      };
      PerseusLinter__namespace.runLinter(parsedMarkdown, context, true);

      // Apply the lint errors from the last TranslationLinter run.
      // TODO(joshuan): Support overlapping dots.
      this._translationLinter.applyLintErrors(parsedMarkdown, [...this.state.translationLintErrors, ...(this.props.legacyPerseusLint || [])]);
    }

    // Render the linted markdown parse tree with React components
    const markdownContents = this.outputMarkdown(parsedMarkdown, {
      baseElements: apiOptions.baseElements
    });
    const className = classNames__default["default"]({
      [ClassNames.RENDERER]: true,
      [ClassNames.RESPONSIVE_RENDERER]: true,
      [ClassNames.TWO_COLUMN_RENDERER]: this._isTwoColumn
    });
    this.lastRenderedMarkdown = /*#__PURE__*/React__namespace.createElement(DefinitionProvider, null, /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, markdownContents));
    return this.lastRenderedMarkdown;
  }
}
_defineProperty(Renderer, "defaultProps", {
  content: "",
  widgets: {},
  images: {},
  highlightedWidgets: [],
  questionCompleted: false,
  // onRender may be called multiple times per render, for example
  // if there are multiple images or TeX pieces within `content`.
  // It is a good idea to debounce any functions passed here.
  onRender: noopOnRender,
  onInteractWithWidget: function () {},
  findExternalWidgets: () => [],
  alwaysUpdate: false,
  reviewMode: false,
  serializedState: null,
  onSerializedStateUpdated: () => {},
  linterContext: PerseusLinter__namespace.linterContextDefault
});
const styles$z = {
  mobileZoomableParentFix: {
    // NOTE(abdul): There is an issue where transform animations will
    // cause the Zoomable component to disappear when running on the
    // native app on iPad (iOS 13). I found some answers online that recommend
    // transforming the parent in 3D space. Doing this forces hardware
    // acceleration, which causes the process to run on the GPU. It's not
    // clear to me why this fixes the issue, but it's suggested online
    // to people dealing with similar disappearance and flickering issues.
    transform: "translate3d(0,0,0)"
  }
};

/*
 * In this file, an `expression` is some portion of valid TeX enclosed in
 * curly brackets.
 */

/*
 * Find the index at which an expression ends, i.e., has an unmatched
 * closing curly bracket. This method assumes that we start with a non-open
 * bracket character and end when we've seen more left than right brackets
 * (rather than assuming that we start with a bracket character and wait for
 * bracket equality).
 */
function findEndpoint(tex, currentIndex) {
  let bracketDepth = 0;
  for (let i = currentIndex, len = tex.length; i < len; i++) {
    const c = tex[i];
    if (c === "{") {
      bracketDepth++;
    } else if (c === "}") {
      bracketDepth--;
    }
    if (bracketDepth < 0) {
      return i;
    }
  }
  // If we never see unbalanced curly brackets, default to the
  // entire string
  return tex.length;
}

/*
 * Parses an individual set of curly brackets into TeX.
 */
function parseNextExpression(tex, currentIndex, handler) {
  // Find the first '{' and grab subsequent TeX
  // Ex) tex: '{3}{7}', and we want the '3'
  const openBracketIndex = tex.indexOf("{", currentIndex);
  const nextExpIndex = openBracketIndex + 1;

  // Truncate to only contain remaining TeX
  const endpoint = findEndpoint(tex, nextExpIndex);
  const expressionTeX = tex.substring(nextExpIndex, endpoint);
  const parsedExp = walkTex(expressionTeX, handler);
  return {
    endpoint: endpoint,
    expression: parsedExp
  };
}
function getNextFracIndex(tex, currentIndex) {
  const dfrac = "\\dfrac";
  const frac = "\\frac";
  const nextFrac = tex.indexOf(frac, currentIndex);
  const nextDFrac = tex.indexOf(dfrac, currentIndex);
  if (nextFrac > -1 && nextDFrac > -1) {
    return Math.min(nextFrac, nextDFrac);
  }
  if (nextFrac > -1) {
    return nextFrac;
  }
  if (nextDFrac > -1) {
    return nextDFrac;
  }
  return -1;
}
function walkTex(tex, handler) {
  if (!tex) {
    return "";
  }

  // Ex) tex: '2 \dfrac {3}{7}'
  let parsedString = "";
  let currentIndex = 0;
  let nextFrac = getNextFracIndex(tex, currentIndex);

  // For each \dfrac, find the two expressions (wrapped in {}) and recur
  while (nextFrac > -1) {
    // Gather first fragment, preceding \dfrac
    // Ex) parsedString: '2 '
    parsedString += tex.substring(currentIndex, nextFrac);

    // Remove everything preceding \dfrac, which has been parsed
    currentIndex = nextFrac;

    // Parse first expression and move index past it
    // Ex) firstParsedExpression.expression: '3'
    const firstParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = firstParsedExpression.endpoint + 1;

    // Parse second expression
    // Ex) secondParsedExpression.expression: '7'
    const secondParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = secondParsedExpression.endpoint + 1;

    // Add expressions to running total of parsed expressions
    if (parsedString.length) {
      parsedString += " ";
    }

    // Apply a custom handler based on the parsed subexpressions
    parsedString += handler(firstParsedExpression.expression, secondParsedExpression.expression);

    // Find next DFrac, relative to currentIndex
    nextFrac = getNextFracIndex(tex, currentIndex);
  }

  // Add remaining TeX, which is \dfrac-free
  parsedString += tex.slice(currentIndex);
  return parsedString;
}

/*
 * Modify a TeX expression, returning another TeX expression. The resulting
 * expression will have its innermost fractions stubbed out with \fracs
 * (as opposed to \dfracs). All other content will remain untouched.
 */
function modifyTex(tex) {
  function isNestedFraction(tex) {
    return tex.indexOf("\\frac") > -1 || tex.indexOf("\\dfrac") > -1;
  }
  const handler = function (exp1, exp2) {
    let prefix;
    if (isNestedFraction(exp1) || isNestedFraction(exp2)) {
      prefix = "\\dfrac";
    } else {
      prefix = "\\frac";
    }
    return prefix + " {" + exp1 + "}{" + exp2 + "}";
  };
  return walkTex(tex, handler);
}

/*
 * Parse a TeX expression into something interpretable by input-number.
 * The process is concerned with: (1) parsing fractions, i.e., \dfracs; and
 * (2) removing backslash-escaping from certain characters (right now, only
 * percent signs).
 *
 * The basic algorithm for handling \dfracs splits on \dfracs and then recurs
 * on the subsequent "expressions", i.e., the {} pairs that follow \dfrac. The
 * recursion is to allow for nested \dfrac elements.
 *
 * Backslash-escapes are removed with a simple search-and-replace.
 */
function parseTex(tex) {
  const handler = function (exp1, exp2) {
    return exp1 + "/" + exp2;
  };
  const texWithoutFracs = walkTex(tex, handler);
  return texWithoutFracs.replace("\\%", "%");
}
var TexWrangler = {
  parseTex,
  modifyTex
};

const ModifyTex = TexWrangler.modifyTex;
class MathOutput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      focused: false,
      selectorNamespace: ___default["default"].uniqueId("math-output")
    });
    _defineProperty(this, "_getInputClassName", () => {
      let className = "math-output " + ClassNames.INPUT + " " + ClassNames.INTERACTIVE;
      if (this.state.focused) {
        className += " " + ClassNames.FOCUSED;
      }
      if (this.props.className) {
        className += " " + this.props.className;
      }
      return className;
    });
    _defineProperty(this, "_getDisplayValue", value => {
      // Cast from (potentially a) number to string
      let displayText;
      if (value != null) {
        displayText = "" + value;
      } else {
        displayText = "";
      }
      return ModifyTex(displayText);
    });
    _defineProperty(this, "getValue", () => {
      return this.props.value;
    });
    _defineProperty(this, "focus", () => {
      if (!this.state.focused) {
        this.props.onFocus();
        this._bindBlurHandler();
        this.setState({
          focused: true
        });
      }
    });
    _defineProperty(this, "blur", () => {
      if (this.state.focused) {
        this.props.onBlur();
        this._unbindBlurHandler();
        this.setState({
          focused: false
        });
      }
    });
    _defineProperty(this, "_bindBlurHandler", () => {
      $__default["default"](document).bind("vclick." + this.state.selectorNamespace, e => {
        // Detect whether the target has our React DOM node as a parent
        const $closestWidget = $__default["default"](e.target).closest(
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        ReactDOM__default["default"].findDOMNode(this));
        if (!$closestWidget.length) {
          this.blur();
        }
      });
    });
    _defineProperty(this, "_unbindBlurHandler", () => {
      $__default["default"](document).unbind("." + this.state.selectorNamespace);
    });
  }
  render() {
    const divStyle = {
      textAlign: "center"
    };
    const {
      TeX
    } = getDependencies();
    return /*#__PURE__*/React__namespace.createElement("span", {
      // eslint-disable-next-line react/no-string-refs
      ref: "input",
      className: this._getInputClassName(),
      "aria-label": this.props.labelText,
      onMouseDown: this.focus,
      onTouchStart: this.focus
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: divStyle
    }, /*#__PURE__*/React__namespace.createElement(TeX, null, this._getDisplayValue(this.props.value))));
  }
  componentWillUnmount() {
    this._unbindBlurHandler();
  }
}
_defineProperty(MathOutput, "defaultProps", {
  value: "",
  onFocus: function () {},
  onBlur: function () {}
});

let lastId = 0;
function uniqueIdForInput() {
  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "input-";
  lastId++;
  return "".concat(prefix).concat(lastId);
}
class TextInput extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "focus", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this).focus();
    });
    _defineProperty(this, "blur", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'blur' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this).blur();
    });
    _defineProperty(this, "getValue", () => {
      var _ReactDOM$findDOMNode;
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'value' does not exist on type 'Element | Text'.
      return (_ReactDOM$findDOMNode = ReactDOM__default["default"].findDOMNode(this)) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.value;
    });
    _defineProperty(this, "getStringValue", () => {
      var _ReactDOM$findDOMNode2;
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'value' does not exist on type 'Element | Text'.
      return (_ReactDOM$findDOMNode2 = ReactDOM__default["default"].findDOMNode(this)) === null || _ReactDOM$findDOMNode2 === void 0 ? void 0 : _ReactDOM$findDOMNode2.value.toString();
    });
    _defineProperty(this, "setSelectionRange", (selectionStart, selectionEnd) => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'setSelectionRange' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
    });
    _defineProperty(this, "getSelectionStart", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'selectionStart' does not exist on type 'Element | Text'.
      return ReactDOM__default["default"].findDOMNode(this).selectionStart;
    });
    _defineProperty(this, "getSelectionEnd", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'selectionEnd' does not exist on type 'Element | Text'.
      return ReactDOM__default["default"].findDOMNode(this).selectionEnd;
    });
    if (props.id) {
      this.id = props.id;
    } else {
      this.id = uniqueIdForInput();
    }
  }
  render() {
    const {
      labelText,
      value,
      onFocus,
      onBlur,
      disabled,
      placeholder,
      onKeyDown,
      style
    } = this.props;
    const formattedValue = value === null ? "" : value.toString();
    return (
      /*#__PURE__*/
      // $FlowIgnore
      React__namespace.createElement(wonderBlocksForm.TextField, {
        style: style,
        disabled: disabled,
        id: this.id,
        value: formattedValue,
        type: "text",
        "aria-label": labelText,
        onChange: value => this.props.onChange(value),
        placeholder: placeholder,
        onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown
        // @ts-expect-error [FEI-5003] - TS2322 - Type '{ style: StyleType; disabled: boolean | undefined; id: string; value: string; type: "text"; "aria-label": string | undefined; onChange: (value: string) => void; placeholder: string | undefined; ... 5 more ...; autoComplete: string; }' is not assignable to type 'IntrinsicAttributes & ExportProps & RefAttributes<HTMLInputElement>'.
        ,
        autoCorrect: "off",
        autoCapitalize: "off",
        autoComplete: "off"
      })
    );
  }
}
_defineProperty(TextInput, "defaultProps", {
  value: "",
  disabled: false
});

const {
  captureScratchpadTouchStart: captureScratchpadTouchStart$3
} = Util;
class InputWithExamples extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      focused: false,
      showExamples: false
    });
    _defineProperty(this, "_getUniqueId", () => {
      return "input-with-examples-".concat(btoa(this.props.id).replace(/=/g, ""));
    });
    _defineProperty(this, "_getInputClassName", () => {
      // <MathOutput> is a special component that manages its own class and
      // state, as it's a <span> that wants to act like an <input>.
      if (this.props.type === "tex") {
        return this.props.className;
      }

      // Otherwise, we need to add these INPUT and FOCUSED tags here.
      let className = ClassNames.INPUT + " " + ClassNames.INTERACTIVE;
      if (this.state.focused) {
        className += " " + ClassNames.FOCUSED;
      }
      if (this.props.className) {
        className += " " + this.props.className;
      }
      return className;
    });
    _defineProperty(this, "_getPropsForInputType", () => {
      // Minimal set of props, used by each input type
      const id = this._getUniqueId();
      const inputProps = {
        id: id,
        "aria-describedby": id,
        ref: "input",
        className: this._getInputClassName(),
        labelText: this.props.labelText,
        value: this.props.value,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur,
        disabled: this.props.disabled,
        style: this.props.style
      };
      if (this.props.type === "tex") {
        return inputProps;
      }

      // Add useful props required for MATH and TEXT modes
      ___default["default"].extend(inputProps, {
        onChange: this.props.onChange,
        onTouchStart: captureScratchpadTouchStart$3
      });

      // And add final props that are MATH- and TEXT-specific
      if (this.props.type === "math") {
        return ___default["default"].extend({
          buttonSet: this.props.buttonSet,
          buttonsVisible: this.props.buttonsVisible,
          convertDotToTimes: this.props.convertDotToTimes
        }, inputProps);
      }
      if (this.props.type === "text") {
        return ___default["default"].extend({
          autoCapitalize: "off",
          autoComplete: "off",
          autoCorrect: "off",
          spellCheck: "false"
        }, inputProps);
      }
    });
    _defineProperty(this, "_getComponentForInputType", () => {
      switch (this.props.type) {
        case "tex":
          return MathOutput;
        case "math":
          return MathInput;
        case "text":
          return TextInput;
        default:
          this.props.type;
          return null;
      }
    });
    _defineProperty(this, "_renderInput", () => {
      const inputProps = this._getPropsForInputType();
      const InputComponent = this._getComponentForInputType();
      return /*#__PURE__*/React__namespace.createElement(InputComponent, inputProps);
    });
    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus();
      this.setState({
        focused: true,
        showExamples: true
      });
    });
    _defineProperty(this, "show", () => {
      this.setState({
        showExamples: true
      });
    });
    _defineProperty(this, "hide", () => {
      this.setState({
        showExamples: false
      });
    });
    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur();
      this.setState({
        focused: false,
        showExamples: false
      });
    });
    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      this.refs.input.focus();
    });
    _defineProperty(this, "blur", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
      this.refs.input.blur();
    });
    _defineProperty(this, "handleChange", e => {
      this.props.onChange(e.target.value);
    });
  }
  render() {
    const input = this._renderInput();

    // Static rendering, which doesn't include the 'tooltip' logic that the
    // other types require, and is hence handled separately.
    if (this.props.type === "tex") {
      return input;
    }

    // Else, we need to be able to show examples
    const examplesContent = ___default["default"].map(this.props.examples, example => {
      return "- " + example;
    }).join("\n");
    const showExamples = this.props.shouldShowExamples && this.state.showExamples;
    return /*#__PURE__*/React__namespace.createElement(Tooltip
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "tooltip",
      className: "perseus-formats-tooltip preview-measure",
      horizontalPosition: HorizontalDirection.Left,
      horizontalAlign: HorizontalDirection.Left,
      verticalPosition: VerticalDirection.Bottom,
      arrowSize: 10,
      borderColor: "#ccc",
      show: showExamples
    }, input, /*#__PURE__*/React__namespace.createElement("div", {
      id: this._getUniqueId()
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: examplesContent,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "input-with-examples")
    })));
  }
}
_defineProperty(InputWithExamples, "defaultProps", {
  type: "text",
  shouldShowExamples: true,
  onFocus: function () {},
  onBlur: function () {},
  disabled: false,
  linterContext: PerseusLinter__namespace.linterContextDefault,
  className: ""
});

class SimpleKeypadInput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_isMounted", false);
  }
  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  focus() {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
    this.refs.input.focus(); // eslint-disable-line react/no-string-refs
  }

  blur() {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
    this.refs.input.blur(); // eslint-disable-line react/no-string-refs
  }

  getValue() {
    return this.props.value;
  }
  render() {
    const _this = this;
    // Intercept the `onFocus` prop, as we need to configure the keypad
    // before continuing with the default focus logic for Perseus inputs.
    // Intercept the `value` prop so as to map `null` to the empty string,
    // as the `KeypadInput` does not support `null` values.
    const {
      keypadElement,
      onFocus,
      value,
      ...rest
    } = _this.props;
    return (
      /*#__PURE__*/
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      React__namespace.createElement(mathInput.KeypadInput
      // eslint-disable-next-line react/no-string-refs
      , _extends({
        ref: "input",
        keypadElement: keypadElement,
        onFocus: () => {
          if (keypadElement) {
            keypadElement.configure({
              keypadType: mathInput.KeypadType.FRACTION
            }, () => {
              if (_this._isMounted) {
                onFocus && onFocus();
              }
            });
          } else {
            onFocus && onFocus();
          }
        },
        value: value == null ? "" : "" + value
      }, rest))
    );
  }
}

// @ts-expect-error [FEI-5003] - TS2339 - Property 'propTypes' does not exist on type 'typeof SimpleKeypadInput'.
SimpleKeypadInput.propTypes = {
  keypadElement: mathInput.keypadElementPropType,
  onFocus: PropTypes__default["default"].func,
  value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
};

const ParseTex$1 = TexWrangler.parseTex;
const answerTypes = {
  number: {
    name: "Numbers",
    forms: "integer, decimal, proper, improper, mixed"
  },
  decimal: {
    name: "Decimals",
    forms: "decimal"
  },
  integer: {
    name: "Integers",
    forms: "integer"
  },
  rational: {
    name: "Fractions and mixed numbers",
    forms: "integer, proper, improper, mixed"
  },
  improper: {
    name: "Improper numbers (no mixed)",
    forms: "integer, proper, improper"
  },
  mixed: {
    name: "Mixed numbers (no improper)",
    forms: "integer, proper, mixed"
  },
  percent: {
    name: "Numbers or percents",
    forms: "integer, decimal, proper, improper, mixed, percent"
  },
  pi: {
    name: "Numbers with pi",
    forms: "pi"
  }
};
const formExamples$1 = {
  integer: function (options) {
    return i18n__namespace._("an integer, like $6$");
  },
  proper: function (options) {
    if (options.simplify === "optional") {
      return i18n__namespace._("a *proper* fraction, like $1/2$ or $6/10$");
    }
    return i18n__namespace._("a *simplified proper* fraction, like $3/5$");
  },
  improper: function (options) {
    if (options.simplify === "optional") {
      return i18n__namespace._("an *improper* fraction, like $10/7$ or $14/8$");
    }
    return i18n__namespace._("a *simplified improper* fraction, like $7/4$");
  },
  mixed: function (options) {
    return i18n__namespace._("a mixed number, like $1\\ 3/4$");
  },
  decimal: function (options) {
    return i18n__namespace._("an *exact* decimal, like $0.75$");
  },
  percent: function (options) {
    return i18n__namespace._("a percent, like $12.34\\%$");
  },
  pi: function (options) {
    return i18n__namespace._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$");
  }
};
class InputNumber extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "shouldShowExamples", () => {
      return this.props.answerType !== "number";
    });
    _defineProperty(this, "handleChange", (newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });
    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus([]);
      // HACK(kevinb): We want to dismiss the feedback popover that webapp
      // displays as soon as a user clicks in in the input field so we call
      // interactionCallback directly.
      const {
        interactionCallback
      } = this.props.apiOptions;
      if (interactionCallback) {
        interactionCallback();
      }
    });
    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur([]);
    });
    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      this.refs.input.focus();
      return true;
    });
    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      this.refs.input.focus();
    });
    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
      this.refs.input.blur();
    });
    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.
      /* c8 ignore next */
      return [[]];
    });
    _defineProperty(this, "getGrammarTypeForPath", path => {
      /* c8 ignore next */
      return "number";
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });
    _defineProperty(this, "getUserInput", () => {
      return InputNumber.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {
      onInputError = onInputError || function () {};
      return InputNumber.validate(this.getUserInput(), rubric, onInputError);
    });
    _defineProperty(this, "examples", () => {
      const type = this.props.answerType;
      const forms = answerTypes[type].forms.split(/\s*,\s*/);
      const examples = ___default["default"].map(forms, function (form) {
        // eslint-disable-next-line @babel/no-invalid-this
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        // eslint-disable-next-line @babel/no-invalid-this
        return formExamples$1[form](this.props);
      }, this);
      return [i18n__namespace._("**Your answer should be** ")].concat(examples);
    });
  }
  render() {
    if (this.props.apiOptions.customKeypad) {
      // TODO(charlie): Support "Review Mode".
      const input = /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.currentValue,
        keypadElement: this.props.keypadElement,
        onChange: this.handleChange,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      });
      if (this.props.rightAlign) {
        return /*#__PURE__*/React__namespace.createElement("div", {
          className: "perseus-input-right-align"
        }, input);
      }
      return input;
    }
    // HACK(johnsullivan): Create a function with shared logic between
    // this and NumericInput.
    // TODO(jeremy): Deprecate this widget and prefer numeric-input.
    const rubric = this.props.reviewModeRubric;

    // Note: This is _very_ similar to what `numeric-input.jsx` does. If
    // you modify this, double-check if you also need to modify that
    // component.
    const inputStyles = [styles$y.default, this.props.size === "small" ? styles$y.small : null, this.props.rightAlign ? styles$y.rightAlign : styles$y.leftAlign];
    // Unanswered
    if (rubric && !this.props.currentValue) {
      inputStyles.push(styles$y.answerStateUnanswered);
    }
    return /*#__PURE__*/React__namespace.createElement(InputWithExamples
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "input",
      value: this.props.currentValue,
      onChange: this.handleChange,
      style: inputStyles,
      type: "text",
      examples: this.examples(),
      shouldShowExamples: this.shouldShowExamples(),
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      id: this.props.widgetId,
      disabled: this.props.apiOptions.readOnly,
      linterContext: this.props.linterContext
    });
  }
  static validate(state, rubric) {
    let onInputError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
    if (rubric.answerType == null) {
      rubric.answerType = "number";
    }

    // note(matthewc): this will get immediately parsed again by
    // `KhanAnswerTypes.number.convertToPredicate`, but a string is
    // expected here
    const stringValue = "".concat(rubric.value);
    const val = KhanAnswerTypes.number.createValidatorFunctional(stringValue, {
      simplify: rubric.simplify,
      inexact: rubric.inexact || undefined,
      maxError: rubric.maxError,
      forms: answerTypes[rubric.answerType].forms
    });

    // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.
    const currentValue = ParseTex$1(state.currentValue);
    const result = val(currentValue);

    // TODO(eater): Seems silly to translate result to this invalid/points
    // thing and immediately translate it back in ItemRenderer.scoreInput()
    if (result.empty) {
      // TODO(FEI-3867): remove null-check once we have APIOptionsInternal
      const apiResult = onInputError === null || onInputError === void 0 ? void 0 : onInputError(null,
      // reserved for some widget identifier
      state.currentValue, result.message);
      return {
        type: "invalid",
        message: apiResult === false ? null : result.message
      };
    }
    return {
      type: "points",
      earned: result.correct ? 1 : 0,
      total: 1,
      message: result.message
    };
  }
  static getUserInputFromProps(props) {
    return {
      currentValue: props.currentValue
    };
  }
  static getOneCorrectAnswerFromRubric(rubric) {
    if (rubric.value == null) {
      return;
    }
    let answerString = String(rubric.value);
    if (rubric.inexact && rubric.maxError) {
      answerString += " \u00B1 " + rubric.maxError;
    }
    return answerString;
  }
}
_defineProperty(InputNumber, "defaultProps", {
  currentValue: "",
  size: "normal",
  answerType: "number",
  rightAlign: false,
  // NOTE(kevinb): renderer.jsx should be provide this so we probably don't
  // need to include it in defaultProps.
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});
const styles$y = aphrodite.StyleSheet.create({
  default: {
    width: 80,
    height: "auto"
  },
  small: {
    width: 40
  },
  leftAlign: {
    paddingLeft: Spacing__default["default"].xxxSmall_4,
    paddingRight: 0
  },
  rightAlign: {
    textAlign: "right",
    paddingLeft: 0,
    paddingRight: Spacing__default["default"].xxxSmall_4
  },
  answerStateUnanswered: {
    backgroundColor: "#eee",
    border: "solid 1px #999"
  }
});
const propTransform$4 = widgetOptions => {
  const {
    simplify,
    size,
    answerType,
    rightAlign
  } = widgetOptions;
  return {
    simplify,
    size,
    answerType,
    rightAlign
  };
};
var InputNumber$1 = {
  name: "input-number",
  displayName: "Number text box (old)",
  defaultAlignment: "inline-block",
  hidden: true,
  widget: InputNumber,
  transform: propTransform$4,
  isLintable: true
};

const ParseTex = TexWrangler.parseTex;
const answerFormButtons = [{
  title: "Integers",
  value: "integer",
  content: "6"
}, {
  title: "Decimals",
  value: "decimal",
  content: "0.75"
}, {
  title: "Proper fractions",
  value: "proper",
  content: "\u2157"
}, {
  title: "Improper fractions",
  value: "improper",
  content: "\u2077\u2044\u2084"
}, {
  title: "Mixed numbers",
  value: "mixed",
  content: "1\u00BE"
}, {
  title: "Numbers with \u03C0",
  value: "pi",
  content: "\u03C0"
}];
const formExamples = {
  integer: () => i18n__namespace._("an integer, like $6$"),
  proper: form => form.simplify === "optional" ? i18n__namespace._("a *proper* fraction, like $1/2$ or $6/10$") : i18n__namespace._("a *simplified proper* fraction, like $3/5$"),
  improper: form => form.simplify === "optional" ? i18n__namespace._("an *improper* fraction, like $10/7$ or $14/8$") : i18n__namespace._("a *simplified improper* fraction, like $7/4$"),
  mixed: () => i18n__namespace._("a mixed number, like $1\\ 3/4$"),
  decimal: () => i18n__namespace._("an *exact* decimal, like $0.75$"),
  pi: () => i18n__namespace._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$")
};
class NumericInput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "inputRef", void 0);
    _defineProperty(this, "state", {
      // keeps track of the other set of values when switching
      // between 0 and finite solutions
      previousValues: [""]
    });
    _defineProperty(this, "examples", () => {
      var _this$props$answerFor;
      // if the set of specified forms are empty, allow all forms
      const forms = ((_this$props$answerFor = this.props.answerForms) === null || _this$props$answerFor === void 0 ? void 0 : _this$props$answerFor.length) !== 0 ? this.props.answerForms : Object.keys(formExamples).map(name => {
        return {
          name: name,
          simplify: "required"
        };
      });
      let examples = ___default["default"].map(forms, form => {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'PerseusNumericInputAnswerForm | { name: string; simplify: string; }' is not assignable to parameter of type 'PerseusNumericInputAnswerForm'.
        return formExamples[form.name](form);
      });
      // Ensure no duplicate tooltip text from simplified and unsimplified
      // versions of the same format
      examples = ___default["default"].uniq(examples);
      return [i18n__namespace._("**Your answer should be** ")].concat(examples);
    });
    _defineProperty(this, "shouldShowExamples", () => {
      var _this$props$answerFor2, _this$props$answerFor3;
      const noFormsAccepted = ((_this$props$answerFor2 = this.props.answerForms) === null || _this$props$answerFor2 === void 0 ? void 0 : _this$props$answerFor2.length) === 0;
      // To check if all answer forms are accepted, we must first
      // find the *names* of all accepted forms, and see if they are
      // all present, ignoring duplicates
      const answerFormNames = ___default["default"].uniq((_this$props$answerFor3 = this.props.answerForms) === null || _this$props$answerFor3 === void 0 ? void 0 : _this$props$answerFor3.map(form => form.name));
      const allFormsAccepted = answerFormNames.length >= Object.keys(formExamples).length;
      return !noFormsAccepted && !allFormsAccepted;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return NumericInput.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "focus", () => {
      var _this$inputRef;
      (_this$inputRef = this.inputRef) === null || _this$inputRef === void 0 ? void 0 : _this$inputRef.focus();
      return true;
    });
    _defineProperty(this, "focusInputPath", () => {
      var _this$inputRef2;
      (_this$inputRef2 = this.inputRef) === null || _this$inputRef2 === void 0 ? void 0 : _this$inputRef2.focus();
    });
    _defineProperty(this, "blurInputPath", () => {
      var _this$inputRef3;
      (_this$inputRef3 = this.inputRef) === null || _this$inputRef3 === void 0 ? void 0 : _this$inputRef3.blur();
    });
    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.
      /* c8 ignore next */
      return [[]];
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      /* c8 ignore next */
      return "number";
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      /* c8 ignore next */
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });
    _defineProperty(this, "getUserInput", () => {
      return NumericInput.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "handleChange", (newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
      this.props.trackInteraction();
    });
    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus([]);
      // HACK(kevinb): We want to dismiss the feedback popover that webapp
      // displays as soon as a user clicks in in the input field so we call
      // interactionCallback directly.
      const {
        interactionCallback
      } = this.props.apiOptions;
      if (interactionCallback) {
        interactionCallback();
      }
    });
    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur([]);
    });
  }
  static getUserInputFromProps(props) {
    return {
      currentValue: props.currentValue
    };
  }
  static getOneCorrectAnswerFromRubric(rubric) {
    const correctAnswers = rubric.answers.filter(answer => answer.status === "correct");
    const answerStrings = correctAnswers.map(answer => {
      // Figure out how this answer is supposed to be
      // displayed
      let format = "decimal";
      if (answer.answerForms && answer.answerForms[0]) {
        // NOTE(johnsullivan): This isn't exactly ideal, but
        // it does behave well for all the currently known
        // problems. See D14742 for some discussion on
        // alternate strategies.
        format = answer.answerForms[0];
      }

      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'MathFormat | undefined'.
      let answerString = KhanMath.toNumericString(answer.value, format);
      if (answer.maxError) {
        answerString += " \u00B1 " +
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'MathFormat | undefined'.
        KhanMath.toNumericString(answer.maxError, format);
      }
      return answerString;
    });
    if (answerStrings.length === 0) {
      return;
    }
    return answerStrings[0];
  }
  static validate(useInput, rubric) {
    const allAnswerForms = answerFormButtons.map(e => e["value"]);
    const createValidator = answer => {
      const stringAnswer = "".concat(answer.value);
      return KhanAnswerTypes.number.createValidatorFunctional(stringAnswer, {
        message: answer.message,
        simplify: answer.status === "correct" ? answer.simplify : "optional",
        inexact: true,
        // TODO(merlob) backfill / delete
        maxError: answer.maxError,
        forms: answer.strict && answer.answerForms && answer.answerForms.length !== 0 ? answer.answerForms : allAnswerForms
      });
    };

    // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.
    const currentValue = ParseTex(useInput.currentValue);
    const correctAnswers = rubric.answers.filter(answer => answer.status === "correct");
    const normalizedAnswerExpected = correctAnswers.every(answer => Math.abs(answer.value) <= 1);

    // Look through all correct answers for one that matches either
    // precisely or approximately and return the appropriate message:
    // - if precise, return the message that the answer came with
    // - if it needs to be simplified, etc., show that message
    let result = correctAnswers.map(answer => {
      // The coefficient is an attribute of the widget
      let localValue = currentValue;
      if (rubric.coefficient) {
        if (!localValue) {
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'string'.
          localValue = 1;
        } else if (localValue === "-") {
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'string'.
          localValue = -1;
        }
      }
      const validate = createValidator(answer);
      return validate(maybeParsePercentInput(localValue, normalizedAnswerExpected));
    }).find(match => match.correct || match.empty);
    if (!result) {
      // Otherwise, if the guess is not correct
      const otherAnswers = [].concat(
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      rubric.answers.filter(answer => answer.status === "ungraded"), rubric.answers.filter(answer => answer.status === "wrong"));

      // Look through all other answers and if one matches either
      // precisely or approximately return the answer's message
      const match = otherAnswers.find(answer => {
        const validate = createValidator(answer);
        return validate(maybeParsePercentInput(currentValue, normalizedAnswerExpected)).correct;
      });
      result = {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'status' does not exist on type 'never'.
        empty: match ? match.status === "ungraded" : false,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'status' does not exist on type 'never'.
        correct: match ? match.status === "correct" : false,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'message' does not exist on type 'never'.
        message: match ? match.message : null,
        guess: currentValue
      };
    }

    // TODO(eater): Seems silly to translate result to this
    // invalid/points thing and immediately translate it
    // back in ItemRenderer.scoreInput()
    if (result.empty) {
      return {
        type: "invalid",
        message: result.message
      };
    }
    return {
      type: "points",
      earned: result.correct ? 1 : 0,
      total: 1,
      message: result.message
    };
  }
  render() {
    let labelText = this.props.labelText;
    if (labelText == null || labelText === "") {
      labelText = i18n__namespace._("Your answer:");
    }

    // To right align a custom keypad we need to wrap it.
    const maybeRightAlignKeypadInput = keypadInput => {
      return this.props.rightAlign ? /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-input-right-align"
      }, keypadInput) : keypadInput;
    };
    if (this.props.apiOptions.customKeypad) {
      // TODO(charlie): Support "Review Mode".
      return maybeRightAlignKeypadInput( /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput, {
        ref: ref => this.inputRef = ref,
        value: this.props.currentValue,
        keypadElement: this.props.keypadElement,
        onChange: this.handleChange,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      }));
    }

    // Note: This is _very_ similar to what `input-number.jsx` does. If
    // you modify this, double-check if you also need to modify that
    // component.
    const styles = aphrodite.StyleSheet.create({
      input: {
        textAlign: this.props.rightAlign ? "right" : "left",
        width: this.props.size === "small" ? 40 : 80,
        padding: 0,
        height: "auto"
      }
    });
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(InputWithExamples, {
      ref: ref => this.inputRef = ref,
      value: this.props.currentValue,
      onChange: this.handleChange,
      labelText: labelText,
      type: "text",
      examples: this.examples(),
      shouldShowExamples: this.shouldShowExamples(),
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      id: this.props.widgetId,
      disabled: this.props.apiOptions.readOnly,
      style: styles.input
    }));
  }
}

// TODO(thomas): Currently we receive a list of lists of acceptable answer types
// and union them down into a single set. It's worth considering whether it
// wouldn't make more sense to have a single set of acceptable answer types for
// a given *problem* rather than for each possible [correct/wrong] *answer*.
// When should two answers to a problem take different answer types?
// See D27790 for more discussion.
_defineProperty(NumericInput, "defaultProps", {
  currentValue: "",
  size: "normal",
  rightAlign: false,
  apiOptions: ApiOptions.defaults,
  coefficient: false,
  answerForms: [],
  labelText: "",
  linterContext: PerseusLinter.linterContextDefault
});
const unionAnswerForms = function (answerFormsList) {
  // Takes a list of lists of answer forms, and returns a list of the forms
  // in each of these lists in the same order that they're listed in the
  // `formExamples` forms from above.

  // uniqueBy takes a list of elements and a function which compares whether
  // two elements are equal, and returns a list of unique elements. This is
  // just a helper function here, but works generally.
  const uniqueBy = function (list, iteratee) {
    // @ts-expect-error [FEI-5003] - TS2347 - Untyped function calls may not accept type arguments.
    return list.reduce((uniqueList, element) => {
      // For each element, decide whether it's already in the list of
      // unique items.
      const inList = ___default["default"].find(uniqueList, iteratee.bind(null, element));
      if (inList) {
        return uniqueList;
      }
      return uniqueList.concat([element]);
    }, []);
  };

  // Pull out all of the forms from the different lists.
  const allForms = answerFormsList.flat();
  // Pull out the unique forms using uniqueBy.
  const uniqueForms = uniqueBy(allForms, ___default["default"].isEqual);
  // Sort them by the order they appear in the `formExamples` list.
  const formExampleKeys = Object.keys(formExamples);
  return ___default["default"].sortBy(uniqueForms, form => {
    return formExampleKeys.indexOf(form.name);
  });
};
// This function checks if the user inputted a percent value, parsing
// it as a number (and maybe scaling) so that it can be graded.
// NOTE(michaelpolyak): Unlike `KhanAnswerTypes.number.percent()` which
// can accept several input forms with or without "%", the decision
// to parse based on the presence of "%" in the input, is so that we
// don't accidently scale the user typed value before grading, CP-930.
function maybeParsePercentInput(inputValue, normalizedAnswerExpected) {
  // If the input value is not a string ending with "%", then there's
  // nothing more to do. The value will be graded as inputted by user.
  if (!(typeof inputValue === "string" && inputValue.endsWith("%"))) {
    return inputValue;
  }
  const value = parseFloat(inputValue.slice(0, -1));
  // If the input value stripped of the "%" cannot be parsed as a
  // number (the slice is not really necessary for parseFloat to work
  // if the string starts with a number) then return the original
  // input for grading.
  if (isNaN(value)) {
    return inputValue;
  }

  // Next, if all correct answers are in the range of |0,1| then we
  // scale the user typed value. We assume this is the correct thing
  // to do since the input value ends with "%".
  if (normalizedAnswerExpected) {
    return value / 100;
  }

  // Otherwise, we return input valuåe (number) stripped of the "%".
  return value;
}
const propsTransform = function (widgetOptions) {
  const rendererProps = ___default["default"].extend(___default["default"].omit(widgetOptions, "answers"), {
    answerForms: unionAnswerForms(
    // Pull out the name of each form and whether that form has
    // required simplification.
    widgetOptions.answers.map(answer => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly MathFormat[] | undefined' is not assignable to parameter of type 'Collection<any>'.
      return ___default["default"].map(answer.answerForms, form => {
        return {
          simplify: answer.simplify,
          name: form
        };
      });
    }))
  });
  return rendererProps;
};
var NumericInput$1 = {
  name: "numeric-input",
  displayName: "Number text box",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: NumericInput,
  transform: propsTransform,
  isLintable: true
};

const EN_DASH$1 = "\u2013";
class PassageRef extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "displayName", "PassageRef");
    _defineProperty(this, "_isMounted", void 0);
    _defineProperty(this, "_throttledUpdateRange", void 0);
    _defineProperty(this, "state", {
      lineRange: null,
      content: null
    });
    _defineProperty(this, "getUserInput", () => {
      return removeDenylistProps(this.props);
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "_deferredUpdateRange", () => {
      ___default["default"].defer(this._updateRange);
    });
    _defineProperty(this, "_updateRange", () => {
      // Note(TB): findWidgets runs findInternal and findExternal;
      // findExternal runs findInternal for the renderers involved;
      // findInternal returns type $ReadOnlyArray<?Widget>
      const passage = this.props.findWidgets("passage " + this.props.passageNumber)[0];
      let refInfo = null;
      if (passage) {
        refInfo = passage.getReference(this.props.referenceNumber);
      }
      if (this._isMounted) {
        if (refInfo) {
          this.setState({
            lineRange: [refInfo.startLine, refInfo.endLine],
            content: refInfo.content
          });
        } else {
          this.setState({
            lineRange: null,
            content: null
          });
        }
      }
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return PassageRef.validate(this.getUserInput(), rubric);
    });
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !___default["default"].isEqual(this.props, nextProps) || !___default["default"].isEqual(this.state, nextState);
  }

  // TODO(tamarab): getUserInput needs to be updated to only return
  // props input by the user. Currently returns all the widget's props.

  render() {
    const lineRange = this.state.lineRange;
    let lineRangeOutput;
    if (!lineRange) {
      lineRangeOutput = i18n__namespace.$_("lines %(lineRange)s", {
        lineRange: "?".concat(EN_DASH$1, "?")
      });
    } else if (lineRange[0] === lineRange[1]) {
      lineRangeOutput = i18n__namespace.$_("line %(lineNumber)s", {
        lineNumber: lineRange[0]
      });
    } else {
      lineRangeOutput = i18n__namespace.$_("lines %(lineRange)s", {
        lineRange: lineRange[0] + EN_DASH$1 + lineRange[1]
      });
    }
    let summaryOutput;
    if (this.props.summaryText) {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
      const summaryTree = PerseusMarkdown.parseInline(this.props.summaryText);
      summaryOutput = /*#__PURE__*/React__namespace.createElement("span", {
        "aria-hidden": true
      }, " ", "(\u201C", PerseusMarkdown.basicOutput(summaryTree), "\u201D)");
    } else {
      summaryOutput = null;
    }
    return /*#__PURE__*/React__namespace.createElement("span", null, lineRangeOutput, summaryOutput, lineRange && /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sr-only"
    }, this.state.content));
  }
  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;
    this._deferredUpdateRange();
    this._throttledUpdateRange = ___default["default"].throttle(this._deferredUpdateRange, 500);
    window.addEventListener("resize", this._throttledUpdateRange);
  }
  componentDidUpdate() {
    this._deferredUpdateRange();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this._throttledUpdateRange);
    this._isMounted = false;
  }
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
}
_defineProperty(PassageRef, "defaultProps", {
  passageNumber: 1,
  referenceNumber: 1,
  summaryText: ""
});
var PassageRef$1 = {
  name: "passage-ref",
  displayName: "PassageRef (SAT only)",
  defaultAlignment: "inline",
  widget: PassageRef,
  transform: widgetOptions => ({
    passageNumber: widgetOptions.passageNumber,
    referenceNumber: widgetOptions.referenceNumber,
    summaryText: widgetOptions.summaryText
  }),
  version: {
    major: 0,
    minor: 1
  }
};

/**
 * A default set of media queries to use for different screen sizes. Based on
 * the breakpoints from purecss.
 *
 * Use like:
 *   StyleSheet.create({
 *       blah: {
 *           [mediaQueries.xs]: {
 *
 *           },
 *       },
 *   });
 */
const {
  pureXsMax: pureXsMax$1,
  pureSmMin: pureSmMin$1,
  pureSmMax: pureSmMax$1,
  pureMdMin: pureMdMin$1,
  pureMdMax: pureMdMax$1,
  pureLgMin: pureLgMin$1,
  pureLgMax: pureLgMax$1,
  pureXlMin: pureXlMin$1
} = constants$1;
var mediaQueries = {
  xs: "@media screen and (max-width: ".concat(pureXsMax$1, ")"),
  sm: "@media screen and (min-width: ".concat(pureSmMin$1, ") and ") + "(max-width: ".concat(pureSmMax$1, ")"),
  md: "@media screen and (min-width: ".concat(pureMdMin$1, ") and ") + "(max-width: ".concat(pureMdMax$1, ")"),
  lg: "@media screen and (min-width: ".concat(pureLgMin$1, ") and ") + "(max-width: ".concat(pureLgMax$1, ")"),
  xl: "@media screen and (min-width: ".concat(pureXlMin$1, ")"),
  xsOrSmaller: "@media screen and (max-width: ".concat(pureXsMax$1, ")"),
  smOrSmaller: "@media screen and (max-width: ".concat(pureSmMax$1, ")"),
  mdOrSmaller: "@media screen and (max-width: ".concat(pureMdMax$1, ")"),
  lgOrSmaller: "@media screen and (max-width: ".concat(pureLgMax$1, ")"),
  smOrLarger: "@media screen and (min-width: ".concat(pureSmMin$1, ")"),
  mdOrLarger: "@media screen and (min-width: ".concat(pureMdMin$1, ")"),
  lgOrLarger: "@media screen and (min-width: ".concat(pureLgMin$1, ")"),
  xlOrLarger: "@media screen and (min-width: ".concat(pureXlMin$1, ")")
};

const {
  zIndexAboveScratchpad,
  zIndexInteractiveComponent,
  radioBorderColor,
  checkedColor,
  circleSize,
  radioMarginWidth
} = constants$1;
var sharedStyles = aphrodite.StyleSheet.create({
  perseusInteractive: {
    zIndex: zIndexInteractiveComponent,
    position: "relative"
  },
  aboveScratchpad: {
    position: "relative",
    zIndex: zIndexAboveScratchpad
  },
  blankBackground: {
    // TODO(emily): Use KhanUtil._BACKGROUND?
    backgroundColor: "#FDFDFD"
  },
  perseusSrOnly: {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: 1,
    margin: -1,
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: 1
  },
  responsiveLabel: {
    // NOTE(charlie): The values used here should be kept in sync with the
    // caption text sizing in Perseus' articles.less.
    // TODO(charlie): Migrate the captions over to using this style.
    [mediaQueries.smOrSmaller]: {
      fontSize: 14,
      lineHeight: 1.3
    },
    [mediaQueries.md]: {
      fontSize: 17,
      lineHeight: 1.4
    },
    [mediaQueries.lgOrLarger]: {
      fontSize: 20,
      lineHeight: 1.4
    }
  },
  responsiveInput: {
    display: "inline-block",
    WebkitAppearance: "none",
    appearance: "none",
    "::-ms-check": {
      display: "none"
    },
    backgroundColor: "#fff",
    border: "2px solid #fff",
    boxShadow: "0 0px 0px 1px ".concat(radioBorderColor),
    outline: "none",
    boxSizing: "border-box",
    flexShrink: 0,
    marginBottom: 1,
    marginLeft: 1,
    marginRight: 1,
    marginTop: 1,
    height: circleSize - 2,
    width: circleSize - 2
  },
  responsiveRadioInput: {
    borderRadius: "50%",
    ":checked": {
      backgroundColor: checkedColor,
      border: "none",
      borderRadius: "50%",
      boxShadow: "inset 0px 0px 0px 2px white, " + "0 0px 0px 2px ".concat(checkedColor),
      marginTop: radioMarginWidth,
      marginBottom: radioMarginWidth,
      marginLeft: radioMarginWidth,
      marginRight: radioMarginWidth,
      height: circleSize - 2 * radioMarginWidth,
      width: circleSize - 2 * radioMarginWidth
    }
  },
  responsiveRadioInputActive: {
    backgroundColor: "#fff",
    border: "2px solid #fff",
    borderRadius: "50%",
    boxShadow: "0 0px 0px 2px ".concat(checkedColor),
    marginTop: radioMarginWidth,
    marginBottom: radioMarginWidth,
    marginLeft: radioMarginWidth,
    marginRight: radioMarginWidth,
    height: circleSize - 2 * radioMarginWidth,
    width: circleSize - 2 * radioMarginWidth,
    ":checked": {
      backgroundColor: "#fff"
    }
  },
  disableTextSelection: {
    userSelect: "none"
  }
});

/**
 * A small collection of useful scrolling utility functions.
 */

// Polyfill scrollTo if it doesn't exist
if (typeof HTMLElement !== "undefined" && !HTMLElement.prototype.scrollTo) {
  // @ts-expect-error [FEI-5003] - TS2322 - Type '(left: number, top: any) => void' is not assignable to type '{ (options?: ScrollToOptions | undefined): void; (x: number, y: number): void; }'.
  HTMLElement.prototype.scrollTo = function (left, top) {
    this.scrollLeft = left;
    this.scrollTop = top;
  };
}

/**
 * Handles applying a given scroll object to either the window object,
 * or an HTML element.
 * NOTE: SIDE EFFECTS. This method touches the DOM.
 */
const applyUniversalScrollOffset = (elementOrWindow, amount) => {
  // Window objects need to be scrolled by using the `.scrollTo()` function.
  // Elements in MODERN browsers also have this method, but a safer x-browser
  // solution is to use the `.scrollTop` property setter.
  if (typeof elementOrWindow.scrollTo === "function") {
    elementOrWindow.scrollTo(0, amount);
  } else if ("scrollTop" in elementOrWindow) {
    elementOrWindow.scrollTop = amount;
  }
};

/**
 * Smoothly scroll the given element to the given offset.
 *
 * This assumes that element.scrollHeight > element.clientHeight.
 */
const scrollElementToOffset = function (elementOrWindow, offset) {
  let duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let callback = arguments.length > 3 ? arguments[3] : undefined;
  const startPosition = elementOrWindow === window ? window.pageYOffset :
  // @ts-expect-error [FEI-5003] - TS2551 - Property 'scrollTop' does not exist on type 'HTMLElement | Window'. Did you mean 'scrollTo'?
  elementOrWindow.scrollTop;
  const endPosition = offset;
  const scrollDistance = endPosition - startPosition;

  // Aim for ~60 FPS
  const tickLength = 17;
  const numberOfSteps = duration / tickLength;
  let step = 0;

  // TODO (josh): Rewrite this using window.requestAnimationFrame
  // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
  // eslint-disable-next-line no-restricted-syntax
  const scrollInterval = setInterval(function () {
    if (step < numberOfSteps) {
      const x = step / numberOfSteps; // Domain: [0, 1]
      const y = (-Math.cos(Math.PI * x) + 1) / 2; // Range: [0, 1]

      const newPosition = startPosition + scrollDistance * y;
      applyUniversalScrollOffset(elementOrWindow, newPosition);
      step += 1;
    } else {
      // Account for non-integer numberOfSteps
      applyUniversalScrollOffset(elementOrWindow, endPosition);

      // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      clearInterval(scrollInterval);
      callback && callback();
    }
  }, tickLength);
};

/**
 * Returns the closest ancestor that is scrollable.
 *
 * If the container is document.body we return window b/c scrollTo() doesn't
 * work on document.body in some browsers.
 */
const getScrollContainer = element => {
  if (element === document.body) {
    return window;
  }
  if (element == null) {
    return window;
  }
  if (element.scrollHeight > element.clientHeight) {
    return element;
  }
  return getScrollContainer(element.parentElement);
};
const SCROLL_ANIMATION_DURATION = 750; // ms

/**
 * Scroll the given element into view.
 *
 * This works with elements inside scroll containers, but may fail in scenarios
 * involving multiple nested scroll containers.
 */
const scrollElementIntoView = (element, callback) => {
  // Often times we scroll an element into with in reaction to some change in
  // the DOM.  Since we need to measure things, we wait a tick for the DOM to
  // settle before computing the distance to scroll and beginning the scroll
  // animation.
  // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
  // eslint-disable-next-line no-restricted-syntax
  setTimeout(() => {
    const scrollContainer = getScrollContainer(element);
    const childBounds = element.getBoundingClientRect();
    const containerBounds = scrollContainer === window ? {
      top: 0,
      bottom: window.innerHeight
    } : scrollContainer.getBoundingClientRect();
    let offset = 0;
    const currentScrollTop = scrollContainer === window ? window.scrollY : scrollContainer.scrollTop;
    if (childBounds.bottom > containerBounds.bottom) {
      let distanceToScroll = childBounds.bottom - containerBounds.bottom;

      // Ensure that we see the top of the component we're scrolling.
      if (childBounds.top + distanceToScroll < containerBounds.top) {
        distanceToScroll = childBounds.top - containerBounds.top;
      }
      offset = currentScrollTop + distanceToScroll;
    } else if (childBounds.top < containerBounds.top) {
      const distanceToScroll = childBounds.top - containerBounds.top;
      offset = currentScrollTop + distanceToScroll;
    }
    scrollElementToOffset(scrollContainer, offset, SCROLL_ANIMATION_DURATION, callback);
  }, 0);
};

// WARNING: This determines the *viewport* width and height, so a change here
//          requires scaling the values of every SVG path passed in as a string
//          without corresponding `width` and `height` values.
const BASE_ICON_SIZE = 10;

// If you pass in an object you need to specify an SVG path to
// render along with the width and height of the path (to ensure
// that it gets scaled correctly).

class Icon extends React__namespace.Component {
  render() {
    const {
      color,
      pathClassName,
      className,
      title,
      style,
      alt
    } = this.props;
    let {
      icon,
      size
    } = this.props;
    let units = "";

    // If the raw path was passed in, wrap it in the format that we expect.
    if (typeof icon === "string") {
      icon = {
        path: icon,
        width: BASE_ICON_SIZE,
        height: BASE_ICON_SIZE
      };
    }

    // `size` defaults to 1em to mirror the behavior of Font Awesome.
    if (typeof size !== "number") {
      size = 1;
      units = "em";
    }
    const height = size;
    const width = height / icon.height * icon.width;

    // NOTE: We assume that the viewBox is cropped and aligned to (0, 0),
    //       but icons can be defined differently. At some point we might
    //       want to add these attributes to icon-paths.js, but for now
    //       this is a fairly safe assumption.
    const xMin = 0;
    const yMin = 0;
    const focusable = !!this.props.focusable;
    return /*#__PURE__*/React__namespace.createElement("svg", {
      role: "img",
      alt: alt,
      "aria-label": title,
      "aria-hidden": title ? null : true,
      className: className,
      style: style
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type '"auto" | Booleanish | undefined'.
      ,
      focusable: focusable.toString(),
      width: width + units,
      height: height + units,
      viewBox: "".concat(xMin, " ").concat(yMin, " ").concat(icon.width, " ").concat(icon.height)
    }, !!title && /*#__PURE__*/React__namespace.createElement("title", null, title), /*#__PURE__*/React__namespace.createElement("path", {
      className: pathClassName,
      fill: color,
      d: icon.path
    }));
  }
}
_defineProperty(Icon, "defaultProps", {
  color: "currentColor"
});

function getA11yText(letter, checked, correct, crossedOut, showCorrectness) {
  // There are two pieces of metadata we want to add to each a11yText:
  // whether the answer was checked/crossed-out/neither, and whether the
  // answer is correct/incorrect/not-yet-revealed.
  //
  // Translation is tricky for cross-product situations like this, so
  // we've just enumerated all 9 possibilities as separate strings.
  if (showCorrectness && correct) {
    if (checked) {
      return i18n__namespace._("(Choice %(letter)s, Checked, Correct)", {
        letter
      });
    }
    if (crossedOut) {
      return i18n__namespace._("(Choice %(letter)s, Crossed out, Correct)", {
        letter
      });
    }
    return i18n__namespace._("(Choice %(letter)s, Correct)", {
      letter
    });
  }
  if (showCorrectness && !correct) {
    if (checked) {
      return i18n__namespace._("(Choice %(letter)s, Checked, Incorrect)", {
        letter
      });
    }
    if (crossedOut) {
      return i18n__namespace._("(Choice %(letter)s, Crossed out, Incorrect)", {
        letter
      });
    }
    return i18n__namespace._("(Choice %(letter)s, Incorrect)", {
      letter
    });
  }
  if (checked) {
    return i18n__namespace._("(Choice %(letter)s, Checked)", {
      letter
    });
  }
  if (crossedOut) {
    return i18n__namespace._("(Choice %(letter)s, Crossed out)", {
      letter
    });
  }
  return i18n__namespace._("(Choice %(letter)s)", {
    letter
  });
}

/**
 * Renders a circular selection ring around the child.
 */
const FocusRing = function (props) {
  const {
    visible,
    color,
    children,
    multipleSelect
  } = props;
  const borderColor = visible ? color : "transparent";
  const borderRadius = multipleSelect ? 5 : "50%";
  const style = {
    borderColor,
    borderRadius
  };
  return /*#__PURE__*/React__namespace.createElement("span", {
    "data-test-id": "focus-ring",
    className: aphrodite.css(styles$x.ring),
    style: style
  }, children);
};
FocusRing.defaultProps = {
  visible: true,
  color: kaGreen$1,
  multipleSelect: false
};
const styles$x = aphrodite.StyleSheet.create({
  ring: {
    margin: "auto",
    display: "inline-block",
    borderWidth: 2,
    padding: 2,
    borderStyle: "solid"
  }
});

/**
 * Given a choice's position in the radio widget, return the corresponding
 * "choice letter". (For example, in English, `getChoiceLetter(0)` is "A",
 * `getChoiceLetter(1)` is "B", etc.)
 */
function getChoiceLetter(pos) {
  /* I18N: This is a list of single-character labels that will appear in
   * front of multiple-choice options. For instance, a multiple-choice
   * question with three options would display
   *  (A) first option
   *  (B) second option
   *  (C) third option
   * There must be spaces between each of the different characters. The
   * characters will show up next to options in the order that they are
   * listed here. Most multiple choice questions have 5 or fewer options.
   */
  const lettersString = i18n__namespace._("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
  const letters = lettersString.split(" ");
  if (pos < letters.length) {
    // If the position we need is listed in the localized string, use that.
    return letters[pos];
  }
  // If we're out of letters, give up and return a space.
  return " ";
}

const CHOICE_ICON_SIZE = 24;
const styles$w = aphrodite.StyleSheet.create({
  iconWrapper: {
    display: "inline-block",
    position: "relative"
  }
});

/* Component for rendering a letter icon in radio choice */

// The "cross-out line" SVG is a bit bigger than the choice icon, to provide
// extra space for the cute rounded line cap.
const CROSS_OUT_LINE_PADDING = 2;
const CROSS_OUT_LINE_SIZE = CHOICE_ICON_SIZE + CROSS_OUT_LINE_PADDING * 2;

/**
 * The "cross-out line" that appears over the icon when the choice has been
 * `crossedOut`.
 */
const CrossOutLine = function (props) {
  return /*#__PURE__*/React__namespace.createElement("svg", {
    width: CROSS_OUT_LINE_SIZE,
    height: CROSS_OUT_LINE_SIZE,
    viewBox: "0 0 ".concat(CROSS_OUT_LINE_SIZE, " ").concat(CROSS_OUT_LINE_SIZE),
    className: aphrodite.css(styles$v.crossOutLine),
    "data-test-id": "choice-icon__cross-out-line"
  }, /*#__PURE__*/React__namespace.createElement("line", {
    // The line stretches from the bottom-left to top-right.
    // We don't quite go to the _very_ corner, because the cute
    // rounded line cap needs to bleed into our padding.
    x1: CROSS_OUT_LINE_PADDING,
    x2: CROSS_OUT_LINE_SIZE - CROSS_OUT_LINE_PADDING,
    y1: CROSS_OUT_LINE_SIZE - CROSS_OUT_LINE_PADDING,
    y2: CROSS_OUT_LINE_PADDING,
    stroke: props.color,
    strokeWidth: "2",
    strokeLinecap: "round"
  }));
};
const styles$v = aphrodite.StyleSheet.create({
  crossOutLine: {
    // Center the icon within the container.
    position: "absolute",
    top: "0px",
    left: "0px"
  }
});

function ChoiceInner(props) {
  const {
    pos,
    showCorrectness,
    correct
  } = props;
  const letter = getChoiceLetter(pos);
  if (!showCorrectness) {
    return letter;
  }
  if (correct) {
    return /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconCheck, {
      style: {
        position: "relative",
        top: -1
      }
    }));
  }
  return /*#__PURE__*/React__namespace.createElement(InlineIcon, iconMinus);
}

// Handle dynamic styling of the multiple choice icon. Most
// MC icon styles are constant, but we do allow the caller
// to specify the selected color, and thus must control styles
// related to the selected state dynamically.
function getDynamicStyles(checked, showCorrectness, pressed, multipleSelect, correct) {
  let backgroundColor;
  let borderColor;
  let color;
  if (!showCorrectness && pressed) {
    borderColor = Color__default["default"].blue;
    color = Color__default["default"].blue;
    backgroundColor = "transparent";
  } else if (checked) {
    const bg = showCorrectness && correct ? Color__default["default"].green : Color__default["default"].blue;
    color = white$1;
    backgroundColor = bg;
    borderColor = bg;
  } else {
    borderColor = Color__default["default"].offBlack64;
    color = Color__default["default"].offBlack64;
  }

  // define shape
  let borderRadius;
  if (multipleSelect) {
    borderRadius = 3;
  } else {
    borderRadius = CHOICE_ICON_SIZE;
  }
  return {
    backgroundColor,
    borderColor,
    color,
    borderRadius
  };
}
const ChoiceIcon = function (props) {
  const {
    checked,
    crossedOut,
    showCorrectness,
    correct,
    focused,
    hovered,
    multipleSelect,
    pos,
    previouslyAnswered,
    pressed
  } = props;
  const dynamicStyles = getDynamicStyles(checked, showCorrectness, pressed, multipleSelect, correct);
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: aphrodite.css(styles$w.iconWrapper)
  }, /*#__PURE__*/React__namespace.createElement(FocusRing, {
    color: Color__default["default"].blue,
    visible: focused || hovered,
    multipleSelect: multipleSelect
  }, /*#__PURE__*/React__namespace.createElement("div", {
    // @ts-expect-error [FEI-5003] - TS2322 - Type '{ backgroundColor: string | null | undefined; borderColor: string; color: string; borderRadius: number; }' is not assignable to type 'Properties<string | number, string & {}>'.
    style: dynamicStyles,
    "data-test-id": "choice-icon__library-choice-icon",
    className: aphrodite.css(styles$u.circle, showCorrectness && correct && styles$u.circleCorrect, showCorrectness && !correct && styles$u.circleIncorrect, showCorrectness && !correct && (checked || previouslyAnswered) && styles$u.circleIncorrectAnswered)
    // used in BaseRadio editMode to check
    // if we actually clicked on the radio icon
    ,
    "data-is-radio-icon": true
  }, /*#__PURE__*/React__namespace.createElement("div", {
    className: aphrodite.css(styles$u.innerWrapper)
  }, /*#__PURE__*/React__namespace.createElement(ChoiceInner, {
    pos: pos,
    showCorrectness: showCorrectness,
    correct: correct
  })))), crossedOut && /*#__PURE__*/React__namespace.createElement(CrossOutLine, {
    color: dynamicStyles.borderColor
  }));
};
const styles$u = aphrodite.StyleSheet.create({
  innerWrapper: {
    width: CHOICE_ICON_SIZE,
    height: CHOICE_ICON_SIZE,
    // Center the contents of the icon.
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  circle: {
    // Make the circle
    width: CHOICE_ICON_SIZE,
    height: CHOICE_ICON_SIZE,
    boxSizing: "border-box",
    borderStyle: "solid",
    borderWidth: 2,
    // The default icons have letters in them. Style those letters.
    fontFamily: baseFontFamily$1,
    // NOTE(emily): We explicitly set the font weight instead of using the
    // "bold font family" so that characters which fall back to the default
    // font get bolded too.
    fontWeight: "bold",
    fontSize: 12,
    // Center the icon wrapper.
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // HACK(emily): I don't know why adding this line height makes the text
    // appear centered better than any other value, but it does. In
    // particular, at large zoom levels this line height does almost
    // nothing, but at the default size this shifts the letter down one
    // pixel so it is much better centered.
    lineHeight: "1px"
  },
  circleCorrect: {
    fontSize: CHOICE_ICON_SIZE
  },
  circleIncorrect: {
    fontSize: CHOICE_ICON_SIZE,
    borderColor: gray68,
    color: gray68
  },
  circleIncorrectAnswered: {
    backgroundColor: Color__default["default"].red,
    borderColor: Color__default["default"].red,
    color: Color__default["default"].white
  }
});

/**
 * Renders text indicating whether the choice was correct or
 * not and whether the choice was selected or not.
 * This information is redundant with that provided in the
 * ChoiceIcon visualizations but is meant to make the distinctions
 * between the states more immediately clear to users.
 */
function renderText(checked, correct, crossedOut) {
  if (correct) {
    // For correct answers, we surface checked _or_ crossedOut state,
    // because any interaction with the correct answer is noteworthy!
    if (checked) {
      return i18n__namespace._("Correct (selected)");
    }
    if (crossedOut) {
      return i18n__namespace._("Correct (but you crossed it out)");
    }
    return i18n__namespace._("Correct");
  }
  // But, for incorrect answers, we only surface checked state,
  // because crossing out an incorrect answer is not noteworthy.
  if (checked) {
    return i18n__namespace._("Incorrect (selected)");
  }
  return i18n__namespace._("Incorrect");
}
const OptionStatus = function (props) {
  const {
    checked,
    correct,
    crossedOut,
    previouslyAnswered,
    reviewMode
  } = props;

  // Option status is shown only in review mode, or for incorrectly
  // answered items.
  if (!reviewMode && !previouslyAnswered) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>>'.
    return null;
  }
  let textStyle;
  if (correct) {
    textStyle = styles$t.correct;
  } else {
    if (checked || previouslyAnswered) {
      textStyle = styles$t.incorrectAnswered;
    } else {
      textStyle = styles$t.incorrect;
    }
  }
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: aphrodite.css(styles$t.text, textStyle)
  }, renderText(checked, correct, crossedOut));
};
const styles$t = aphrodite.StyleSheet.create({
  text: {
    alignItems: "center",
    display: "flex",
    fontSize: 12,
    height: 32,
    textTransform: "uppercase"
  },
  correct: {
    color: Color__default["default"].green
  },
  incorrectAnswered: {
    color: Color__default["default"].red
  },
  incorrect: {
    color: Color__default["default"].offBlack64
  }
});

const intermediateCheckboxPadding = "16px 16px";
const intermediateCheckboxPaddingPhone = "12px 16px";
const ellipsisHorizontalIcon = {
  path: "M27.218 6.82l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836zm36.27 0l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836zm36.27 0l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836z",
  width: 100,
  height: 27.284
};
// Note(TB): Received errors when using useUniqueIdWithMock
// so created this workaround function. Will update when
// useUniqueIdWithMock is available.
// https://khanacademy.atlassian.net/browse/FEI-4861?atlOrigin=eyJpIjoiNDJlZWMwNjM1NWJhNDBkMWFjY2FmN2I0ZjcxZmQxOGUiLCJwIjoiaiJ9
let id = 0;
function uniqueId() {
  return "choice-".concat(id++);
}
const Choice = function (props) {
  const {
    disabled = false,
    checked = false,
    content,
    crossedOut,
    showCorrectness,
    multipleSelect,
    onChange = newValues => {},
    reviewMode,
    correct = false,
    apiOptions = ApiOptions.defaults,
    previouslyAnswered = false,
    pos = 0,
    showRationale = false,
    rationale,
    forwardedRef
  } = props;
  const [isInputFocused, setIsInputFocused] = React.useState(false);
  React.useEffect(() => {
    if (isInputFocused && disabled) {
      setIsInputFocused(false);
    }
  }, [disabled, isInputFocused, setIsInputFocused]);

  // Call `this.props.onChange` with the given values. Any keys that are not
  // specified will be filled in with the current value. (For example, if
  // `checked` is specified but `crossedOut` is not, then `crossedOut` will
  // be filled in with `this.props.crossedOut`.)
  //
  // This enables us to use shorthand inside this component, while
  // maintaining a consistent API for the parent.
  function sendChange(newValues) {
    var _newValues$checked, _newValues$crossedOut;
    const updatedChecked = (_newValues$checked = newValues.checked) !== null && _newValues$checked !== void 0 ? _newValues$checked : checked;
    const updatedCrossedOut = (_newValues$crossedOut = newValues.crossedOut) !== null && _newValues$crossedOut !== void 0 ? _newValues$crossedOut : crossedOut;
    onChange({
      checked: updatedChecked,
      crossedOut: updatedCrossedOut
    });
  }
  const descriptionClassName = classNames__default["default"]("description", aphrodite.css(styles$s.description));
  const rationaleClassName = classNames__default["default"]("perseus-radio-rationale-content", aphrodite.css(styles$s.rationale));

  // We want to show the choices as dimmed out when the choices are disabled.
  // However, we don't want to do this when we're in review mode in the
  // content library.
  const showDimmed = !reviewMode && apiOptions.readOnly || crossedOut;
  const letter = getChoiceLetter(pos);
  const a11yText = getA11yText(letter, checked, correct, crossedOut, showCorrectness);
  const choiceId = uniqueId();
  return /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      // @ts-expect-error [FEI-5003] - TS2322 - Type '{ dispay: string; flexDirection: "column"; color: string; }' is not assignable to type 'Properties<string | number, string & {}>'.
      dispay: "flex",
      flexDirection: "column",
      color: Color__default["default"].offBlack
    },
    className: descriptionClassName
  }, /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "row",
      opacity: showDimmed ? 0.5 : 1.0
    }
  }, /*#__PURE__*/React__namespace.createElement("div", {
    className: "perseus-sr-only"
  }, /*#__PURE__*/React__namespace.createElement("input", {
    type: multipleSelect ? "checkbox" : "radio",
    id: choiceId,
    checked: checked,
    onClick: () => {
      // If we're checking a crossed-out option, let's
      // also uncross it.
      sendChange({
        checked: !checked,
        crossedOut: false
      });
    },
    onChange: () => {},
    disabled: disabled || apiOptions.readOnly,
    tabIndex: -1,
    className: ClassNames.RADIO.OPTION_CONTENT
  }), /*#__PURE__*/React__namespace.createElement("label", {
    htmlFor: choiceId
  }, a11yText, " \xA0 ", content)), /*#__PURE__*/React__namespace.createElement(Clickable__default["default"], {
    onClick: () => {
      // If we're checking a crossed-out option, let's
      // also uncross it.
      sendChange({
        checked: !checked,
        crossedOut: false
      });
    },
    disabled: disabled || apiOptions.readOnly,
    style: {
      flex: 1,
      color: Color__default["default"].offBlack,
      userSelect: "text"
    },
    ref: forwardedRef,
    "aria-hidden": "true"
  }, _ref => {
    let {
      hovered,
      focused,
      pressed
    } = _ref;
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "flex",
        flexDirection: "row",
        justifyContent: "center",
        alignContent: "center",
        paddingTop: Spacing__default["default"].xSmall_8,
        paddingBottom: Spacing__default["default"].xSmall_8,
        paddingLeft: Spacing__default["default"].xSmall_8
      }
    }, /*#__PURE__*/React__namespace.createElement(ChoiceIcon, {
      pos: pos,
      correct: correct,
      crossedOut: crossedOut,
      pressed: pressed,
      focused: focused,
      checked: checked,
      hovered: hovered,
      showCorrectness: showCorrectness,
      multipleSelect: multipleSelect,
      reviewMode: reviewMode,
      previouslyAnswered: previouslyAnswered
    }), /*#__PURE__*/React__namespace.createElement("span", {
      style: {
        paddingLeft: Spacing__default["default"].small_12,
        textAlign: "left",
        flex: 1,
        paddingTop: 4
      }
    }, /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(OptionStatus, {
      checked: checked,
      correct: correct,
      crossedOut: crossedOut,
      previouslyAnswered: previouslyAnswered,
      reviewMode: reviewMode
    })), /*#__PURE__*/React__namespace.createElement("div", null, content)));
  }), apiOptions.crossOutEnabled && !reviewMode && /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
    dismissEnabled: true,
    content: _ref2 => {
      let {
        close
      } = _ref2;
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContent, {
        title: "Cross out",
        content: "Cross out option",
        closeButtonVisible: true,
        actions: /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, /*#__PURE__*/React__namespace.createElement(wonderBlocksLayout.Strut, {
          size: Spacing__default["default"].medium_16
        }), /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
          kind: "primary",
          "aria-label": "Cross out Choice ".concat(getChoiceLetter(pos)),
          disabled: apiOptions.readOnly || reviewMode,
          onClick: () => {
            if (!crossedOut) {
              // If we're crossing
              // out a checked
              // option, let's also
              // uncheck it.
              sendChange({
                checked: false,
                crossedOut: true
              });
            } else {
              sendChange({
                crossedOut: false
              });
            }
            close();
          }
        }, crossedOut ? "Bring back" : "Cross out"))
      });
    }
  }, _ref3 => {
    let {
      open
    } = _ref3;
    return /*#__PURE__*/React__namespace.createElement(Clickable__default["default"], {
      onClick: open,
      "aria-label": "Open menu for Choice ".concat(getChoiceLetter(pos)),
      style: {
        alignSelf: "center",
        padding: "5px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        marginLeft: "10px"
      }
    }, _ref4 => {
      return /*#__PURE__*/React__namespace.createElement(Icon, {
        icon: ellipsisHorizontalIcon,
        size: 3,
        color: Color__default["default"].offBlack64
      });
    });
  })), showRationale && /*#__PURE__*/React__namespace.createElement("div", {
    className: rationaleClassName,
    "data-test-id": "perseus-radio-rationale-content-".concat(pos)
  }, rationale));
};
const styles$s = aphrodite.StyleSheet.create({
  description: {
    display: "inline-block",
    width: "100%"
  },
  rationale: {
    display: "block",
    padding: intermediateCheckboxPadding,
    paddingTop: 0,
    marginLeft: 54,
    [mediaQueries.smOrSmaller]: {
      padding: intermediateCheckboxPaddingPhone,
      paddingTop: 0
    }
  }
});
var Choice$1 = /*#__PURE__*/React__namespace.forwardRef((props, ref) => /*#__PURE__*/React__namespace.createElement(Choice, _extends({}, props, {
  forwardedRef: ref
})));

const ChoiceNoneAbove = function (props) {
  const {
    showContent,
    content,
    forwardedRef,
    ...rest
  } = props;
  const choiceProps = {
    ...rest,
    content: showContent ? content :
    /*#__PURE__*/
    // We use a Renderer here because that is how
    // `this.props.content` is wrapped otherwise.
    // We pass in a key here so that we avoid a semi-spurious
    // react warning when we render this in the same place
    // as the previous choice content renderer.
    // Note this destroys state, but since all we're doing
    // is outputting "None of the above", that is okay.
    //
    // todo(matthewc): this seems like way overkill
    // just to render a string
    React__namespace.createElement(Renderer, {
      key: "noneOfTheAboveRenderer",
      content: i18n__namespace._("None of the above")
    })
  };
  return /*#__PURE__*/React__namespace.createElement(Choice$1, _extends({}, choiceProps, {
    ref: forwardedRef
  }));
};
ChoiceNoneAbove.defaultProps = {
  showContent: true
};
var ChoiceNoneAbove$1 = /*#__PURE__*/React__namespace.forwardRef((props, ref) => /*#__PURE__*/React__namespace.createElement(ChoiceNoneAbove, _extends({}, props, {
  forwardedRef: ref
})));

const {
  captureScratchpadTouchStart: captureScratchpadTouchStart$2
} = Util;

// exported for tests

function getInstructionsText(multipleSelect, countChoices, numCorrect) {
  if (multipleSelect) {
    if (countChoices) {
      return i18n__namespace._("Choose %(numCorrect)s answers:", {
        numCorrect: numCorrect
      });
    }
    return i18n__namespace._("Choose all answers that apply:");
  }
  return i18n__namespace._("Choose 1 answer:");
}
const BaseRadio = function (props) {
  const {
    apiOptions,
    reviewModeRubric,
    choices,
    editMode,
    multipleSelect,
    labelWrap,
    countChoices,
    numCorrect,
    isLastUsedWidget,
    registerFocusFunction
  } = props;

  // useEffect doesn't have previous props
  const prevReviewModeRubric = React.useRef();
  const choiceRefs = React.useRef([]);
  React.useEffect(() => {
    // Switching into review mode can sometimes cause the selected answer
    // to scroll out of view - for example, when we reveal all those tall
    // rationales. This can be disorienting for the user.
    //
    // So, if this widget just switched into review mode, ensure that the
    // checked choice (or first checked choice, if there are multiple) is
    // scrolled into view.
    //
    // This only happens if the `canScrollPage` API option is set (so that
    // call sites aren't surprised by scrolling), and if this widget was
    // the most recently used widget (because, if the user has since
    // touched something else, they're probably not trying to keep their
    // eye on this widget anymore).
    if (apiOptions.canScrollPage && isLastUsedWidget && reviewModeRubric && !prevReviewModeRubric.current) {
      const checkedIndex = choices.findIndex(c => c.checked);
      if (checkedIndex >= 0) {
        const ref = choiceRefs.current[checkedIndex];
        // note(matthew): we know this is only getting passed
        // to a WB Clickable button, so we force it to be of
        // type HTMLButtonElement
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'current' does not exist on type 'never'.
        const anyNode = ReactDOM__default["default"].findDOMNode(ref.current);
        const buttonNode = anyNode;
        if (buttonNode) {
          scrollElementIntoView(buttonNode);
        }
      }
    }

    // @ts-expect-error [FEI-5003] - TS2322 - Type 'PerseusRadioWidgetOptions | undefined' is not assignable to type 'undefined'.
    prevReviewModeRubric.current = reviewModeRubric;
  }, [apiOptions, choices, isLastUsedWidget, reviewModeRubric]);

  // When a particular choice's `onChange` handler is called, indicating a
  // change in a single choice's values, we need to call our `onChange`
  // handler in order to notify our parent. However, our API with our parent
  // is that we always provide *all* values for *all* choices, even if just
  // one choice's values changed. (This is because sometimes an interaction
  // with one choice can affect many choices, like how checking a new answer
  // will usually cause the old answer to become unchecked.)
  //
  // So, given the new values for a particular choice, compute the new values
  // for all choices, and pass them to `onChange`.
  //
  // `newValues` is an object with two keys: `checked` and `crossedOut`. Each
  // contains a boolean value specifying the new checked and crossed-out
  // value of this choice.
  function updateChoice(choiceIndex, newValues) {
    const {
      multipleSelect,
      choices,
      onChange
    } = props;

    // Get the baseline `checked` values. If we're checking a new answer
    // and multiple-select is not on, we should clear all choices to be
    // unchecked. Otherwise, we should copy the old checked values.
    let newCheckedList;
    if (newValues.checked && !multipleSelect) {
      newCheckedList = choices.map(_ => false);
    } else {
      newCheckedList = choices.map(c => c.checked);
    }

    // Get the baseline `crossedOut` values.
    const newCrossedOutList = choices.map(c => c.crossedOut);

    // Update this choice's `checked` and `crossedOut` values.
    newCheckedList[choiceIndex] = newValues.checked;
    newCrossedOutList[choiceIndex] = newValues.crossedOut;
    onChange({
      checked: newCheckedList,
      crossedOut: newCrossedOutList
    });
  }

  // register a callback with the parent that allows
  // the parent to focus an individual choice
  registerFocusFunction === null || registerFocusFunction === void 0 ? void 0 : registerFocusFunction(choiceIndex => {
    const ref = choiceRefs.current[choiceIndex || 0];
    // note(matthew): we know this is only getting passed
    // to a WB Clickable button, so we force it to be of
    // type HTMLButtonElement
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'current' does not exist on type 'never'.
    const anyNode = ReactDOM__default["default"].findDOMNode(ref.current);
    const buttonNode = anyNode;
    if (buttonNode) {
      buttonNode.focus();
    } else {
      return false;
    }
    return true;
  });

  // some commonly used shorthands
  const reviewMode = !!reviewModeRubric;
  const isMobile = apiOptions.isMobile;
  const firstChoiceHighlighted = choices[0].highlighted;
  const lastChoiceHighlighted = choices[choices.length - 1].highlighted;
  const className = classNames__default["default"]("perseus-widget-radio", !editMode && "perseus-rendered-radio", aphrodite.css(styles$r.radio, styles$r.responsiveRadioContainer, firstChoiceHighlighted && isMobile && styles$r.radioContainerFirstHighlighted, lastChoiceHighlighted && isMobile && styles$r.radioContainerLastHighlighted));
  const instructionsClassName = classNames__default["default"]("instructions", aphrodite.css(styles$r.instructions, isMobile && styles$r.instructionsMobile));
  const instructions = getInstructionsText(multipleSelect, countChoices, numCorrect);
  const responsiveClassName = aphrodite.css(styles$r.responsiveFieldset);
  const fieldset = /*#__PURE__*/React__namespace.createElement("fieldset", {
    className: "perseus-widget-radio-fieldset ".concat(responsiveClassName)
  }, /*#__PURE__*/React__namespace.createElement("legend", {
    className: "perseus-sr-only"
  }, instructions), /*#__PURE__*/React__namespace.createElement("div", {
    className: instructionsClassName,
    "aria-hidden": "true"
  }, instructions), /*#__PURE__*/React__namespace.createElement("ul", {
    className: className,
    style: {
      listStyle: "none"
    }
  }, choices.map((choice, i) => {
    let Element = Choice$1;
    const ref = /*#__PURE__*/React__namespace.createRef();
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'RefObject<unknown>' is not assignable to type 'never'.
    choiceRefs.current[i] = ref;
    const elementProps = {
      apiOptions: apiOptions,
      multipleSelect: multipleSelect,
      checked: choice.checked,
      crossedOut: choice.crossedOut,
      previouslyAnswered: choice.previouslyAnswered,
      reviewMode,
      correct: choice.correct,
      rationale: choice.rationale,
      content: choice.content,
      disabled: apiOptions.readOnly || choice.disabled,
      showCorrectness: reviewMode || !!choice.showCorrectness,
      showRationale: choice.hasRationale && (reviewMode || choice.showRationale),
      pos: i,
      onChange: newValues => {
        // editMode selection is handled in clickHandler
        if (editMode) {
          return;
        }
        updateChoice(i, newValues);
      }
    };
    if (choice.isNoneOfTheAbove) {
      Element = ChoiceNoneAbove$1;
      ___default["default"].extend(elementProps, {
        showContent: choice.revealNoneOfTheAbove
      });
    }
    const nextChoice = choices[i + 1];
    const nextChoiceHighlighted = !!nextChoice && nextChoice.highlighted;
    const aphroditeClassName = checked => {
      // Whether or not to show correctness borders
      // for this choice and the next choice.
      return aphrodite.css(sharedStyles.aboveScratchpad, styles$r.item, styles$r.responsiveItem, checked && styles$r.selectedItem, checked && choice.highlighted && styles$r.aboveBackdrop, checked && choice.highlighted && apiOptions.isMobile && styles$r.aboveBackdropMobile, nextChoiceHighlighted && apiOptions.isMobile && styles$r.nextHighlighted);
    };

    // HACK(abdulrahman): Preloads the selection-state
    // css because of a bug that causes iOS to lag
    // when selecting the button for the first time.
    aphroditeClassName(true);
    let correctnessClass;
    // reviewMode is only true if there's a rubric
    // but TypeScript doesn't understand that
    if (reviewMode && reviewModeRubric) {
      correctnessClass = reviewModeRubric.choices[i].correct ? ClassNames.CORRECT : ClassNames.INCORRECT;
    }
    const className = classNames__default["default"](aphroditeClassName(choice.checked),
    // TODO(aria): Make test case for these API
    // classNames
    ClassNames.RADIO.OPTION, choice.checked && ClassNames.RADIO.SELECTED, correctnessClass);

    // In edit mode, the Choice renders a Div in order to
    // allow for the contentEditable area to be selected
    // (label forces any clicks inside to select the input
    // element) We have to add some extra behavior to make
    // sure that we can still check the choice.
    let listElem = null;
    let clickHandler = null;
    if (editMode) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: any) => void' is not assignable to type 'null'.
      clickHandler = e => {
        // Traverse the parent nodes of the clicked
        // element.
        let elem = e.target;
        while (elem && elem !== listElem) {
          // If the clicked element is inside of the
          // radio icon, then we want to trigger the
          // check by flipping the choice of the icon.
          if (elem.getAttribute("data-is-radio-icon")) {
            updateChoice(i, {
              checked: !choice.checked,
              crossedOut: choice.crossedOut
            });
            return;
          }
          elem = elem.parentNode;
        }
      };
    }

    // TODO(mattdr): Index isn't a *good* choice of key
    // here; is there a better one? Can we use choice
    // content somehow? Would changing our choice of key
    // somehow break something happening inside a choice's
    // child Renderers, by changing when we mount/unmount?
    return /*#__PURE__*/React__namespace.createElement("li", {
      key: i
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'HTMLLIElement | null' is not assignable to type 'null'.
      ,
      ref: e => listElem = e
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly string[]' is not assignable to type 'string'.
      ,
      className: className
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'MouseEventHandler<HTMLLIElement> | undefined'.
      ,
      onClick: clickHandler
      // @ts-expect-error [FEI-5003] - TS2322 - Type '((e: TouchEvent) => void) | null' is not assignable to type 'TouchEventHandler<HTMLLIElement> | undefined'.
      ,
      onTouchStart: !labelWrap ? null : captureScratchpadTouchStart$2
    }, /*#__PURE__*/React__namespace.createElement(Element, _extends({}, elementProps, {
      ref: ref
    })));
  })));

  // Allow for horizontal scrolling if content is too wide, which may be
  // an issue especially on phones.
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: aphrodite.css(styles$r.responsiveContainer)
  }, fieldset);
};
BaseRadio.defaultProps = {
  editMode: false,
  multipleSelect: false
};
const styles$r = aphrodite.StyleSheet.create({
  instructions: {
    display: "block",
    color: gray17,
    fontSize: 14,
    lineHeight: 1.25,
    fontStyle: "normal",
    fontWeight: "bold",
    marginBottom: 16
  },
  instructionsMobile: {
    fontSize: 18,
    [mediaQueries.smOrSmaller]: {
      fontSize: 16
    },
    // TODO(emily): We want this to match choice text, which turns
    // to 20px at min-width 1200px, but this media query is
    // min-width 1280px because our media queries don't exactly
    // match pure. Make those match up.
    [mediaQueries.xl]: {
      fontSize: 20
    }
  },
  radio: {
    padding: 0
  },
  responsiveRadioContainer: {
    borderBottom: "1px solid ".concat(radioBorderColor$1),
    borderTop: "1px solid ".concat(radioBorderColor$1),
    width: "auto",
    [mediaQueries.smOrSmaller]: {
      marginLeft: negativePhoneMargin,
      marginRight: negativePhoneMargin
    }
  },
  radioContainerFirstHighlighted: {
    borderTop: "1px solid rgba(0, 0, 0, 0)"
  },
  radioContainerLastHighlighted: {
    borderBottom: "1px solid rgba(0, 0, 0, 0)"
  },
  item: {
    marginLeft: 20
  },
  responsiveItem: {
    marginLeft: 0,
    padding: 0,
    ":not(:last-child)": {
      borderBottom: "1px solid ".concat(radioBorderColor$1)
    }
  },
  selectedItem: {
    background: "white"
  },
  aboveBackdrop: {
    position: "relative",
    // HACK(emily): We want selected choices to show up above our
    // exercise backdrop, but below the exercise footer and
    // "feedback popover" that shows up. This z-index is carefully
    // coordinated between here and webapp. :(
    zIndex: 1062
  },
  aboveBackdropMobile: {
    boxShadow: "0 0 4px 0 rgba(0, 0, 0, 0.2)," + "0 0 2px 0 rgba(0, 0, 0, 0.1)",
    ":not(:last-child)": {
      borderBottom: "1px solid rgba(0, 0, 0, 0)"
    }
  },
  nextHighlighted: {
    ":not(:last-child)": {
      borderBottom: "1px solid rgba(0, 0, 0, 0)"
    }
  },
  responsiveContainer: {
    overflow: "auto",
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingLeft: phoneMargin
    // paddingRight is handled by responsiveFieldset
  },

  responsiveFieldset: {
    paddingRight: phoneMargin
  }
});

class Radio$1 extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "focusFunction", void 0);
    _defineProperty(this, "_renderRenderer", function () {
      let content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      let nextPassageRefId = 1;
      const widgets = {};
      const modContent = content.replace(/\{\{passage-ref (\d+) (\d+)(?: "([^"]*)")?\}\}/g, (match, passageNum, refNum, summaryText) => {
        const widgetId = "passage-ref " + nextPassageRefId;
        nextPassageRefId++;
        widgets[widgetId] = {
          type: "passage-ref",
          graded: false,
          options: {
            passageNumber: parseInt(passageNum),
            referenceNumber: parseInt(refNum),
            summaryText: summaryText
          },
          version: PassageRef$1.version
        };
        return "[[" + Util.snowman + " " + widgetId + "]]";
      });

      // alwaysUpdate={true} so that passage-refs findWidgets
      // get called when the outer passage updates the renderer
      // TODO(aria): This is really hacky
      // We pass in a key here so that we avoid a semi-spurious
      // react warning when the ChoiceNoneAbove renders a
      // different renderer in the same place. Note this destroys
      // state, but since all we're doing is outputting
      // "None of the above", that is okay.
      // TODO(mdr): Widgets inside this Renderer are not discoverable through
      //     the parent Renderer's `findWidgets` function.
      return /*#__PURE__*/React__namespace.createElement(Renderer, {
        key: "choiceContentRenderer",
        content: modContent,
        widgets: widgets,
        findExternalWidgets: _this.props.findWidgets,
        alwaysUpdate: true,
        linterContext: {
          ..._this.props.linterContext,
          // @ts-expect-error [FEI-5003] - TS2322 - Type '{ blockHighlight: true; contentType: string; highlightLint: boolean; paths: readonly string[]; stack: readonly string[]; }' is not assignable to type 'LinterContextProps'.
          blockHighlight: true
        }
      });
    });
    _defineProperty(this, "updateChoices", newValueLists => {
      const {
        choiceStates,
        choices
      } = this.props;

      // Construct the baseline `choiceStates` objects. If this is the user's
      // first interaction with the widget, we'll need to initialize them to
      // new objects with all fields set to the default values. Otherwise, we
      // should clone the old `choiceStates` objects, in preparation to
      // mutate them.
      const newChoiceStates = choiceStates ? choiceStates.map(state => ({
        ...state
      })) : choices.map(() => ({
        selected: false,
        crossedOut: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        previouslyAnswered: false,
        readOnly: false
      }));

      // Mutate the new `choiceState` objects, according to the new `checked`
      // and `crossedOut` values provided in `newValueLists`.
      newChoiceStates.forEach((choiceState, i) => {
        choiceState.selected = newValueLists.checked[i];
        choiceState.crossedOut = newValueLists.crossedOut[i];
      });
      this.props.onChange({
        choiceStates: newChoiceStates
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "getUserInput", () => {
      return Radio$1.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Radio$1.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", rubric => {
      const {
        choiceStates
      } = this.props;
      if (choiceStates) {
        const score = this.simpleValidate(rubric);
        const widgetCorrect = score.type === "points" && score.total === score.earned;
        const newStates = choiceStates.map(state => ({
          ...state,
          highlighted: state.selected,
          // If the choice is selected, show the rationale now
          rationaleShown: state.selected ||
          // If the choice already had a rationale, keep it shown
          state.rationaleShown ||
          // If the widget is correctly answered, show the rationale
          // for all the choices
          widgetCorrect,
          // We use the same behavior for the readOnly flag as for
          // rationaleShown, but we keep it separate in case other
          // behaviors want to disable choices without showing rationales.
          readOnly: state.selected || state.readOnly || widgetCorrect,
          correctnessShown: state.selected || state.correctnessShown,
          previouslyAnswered: state.previouslyAnswered || state.selected
        }));
        this.props.onChange({
          choiceStates: newStates
        },
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'null' is not assignable to parameter of type '(() => unknown) | undefined'.
        null,
        // cb
        true // silent
        );
      }
    });
    _defineProperty(this, "deselectIncorrectSelectedChoices", () => {
      if (this.props.choiceStates) {
        const newStates = this.props.choiceStates.map((state, i) => ({
          ...state,
          selected: state.selected && !!this.props.choices[i].correct,
          highlighted: false
        }));
        this.props.onChange({
          choiceStates: newStates
        },
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'null' is not assignable to parameter of type '(() => unknown) | undefined'.
        null,
        // cb
        false // silent
        );
      }
    });
  }
  static validate(userInput, rubric) {
    const numSelected = userInput.choicesSelected.reduce((sum, selected) => {
      return sum + (selected ? 1 : 0);
    }, 0);
    if (numSelected === 0) {
      return {
        type: "invalid",
        message: null
      };
    }
    if (userInput.numCorrect && userInput.numCorrect > 1 && numSelected !== userInput.numCorrect) {
      return {
        type: "invalid",
        message: i18n__namespace._("Please choose the correct number of answers.")
      };
      // If NOTA and some other answer are checked, ...
    }

    if (userInput.noneOfTheAboveSelected && numSelected > 1) {
      return {
        type: "invalid",
        message: i18n__namespace._("'None of the above' may not be selected " + "when other answers are selected.")
      };
    }
    const correct = userInput.choicesSelected.every((selected, i) => {
      let isCorrect;
      if (userInput.noneOfTheAboveIndex === i) {
        isCorrect = rubric.choices.every((choice, j) => {
          return i === j || !choice.correct;
        });
      } else {
        isCorrect = !!rubric.choices[i].correct;
      }
      return isCorrect === selected;
    });
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
  static getUserInputFromProps(props) {
    // Return checked inputs in the form {choicesSelected: [bool]}. (Dear
    // future timeline implementers: this used to be {value: i} before
    // multiple select was added)
    if (props.choiceStates) {
      let noneOfTheAboveIndex = null;
      let noneOfTheAboveSelected = false;
      const choiceStates = props.choiceStates;
      const choicesSelected = choiceStates.map(() => false);
      const countChoices = props.countChoices;
      const numCorrect = props.numCorrect;
      for (let i = 0; i < choicesSelected.length; i++) {
        const index = props.choices[i].originalIndex;
        choicesSelected[index] = choiceStates[i].selected;
        if (props.choices[i].isNoneOfTheAbove) {
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
          noneOfTheAboveIndex = index;
          if (choicesSelected[i]) {
            noneOfTheAboveSelected = true;
          }
        }
      }
      return {
        countChoices,
        choicesSelected,
        numCorrect,
        noneOfTheAboveIndex,
        noneOfTheAboveSelected
      };
      // Support legacy choiceState implementation
    }
    /* c8 ignore if - props.values is deprecated */
    const {
      values
    } = props;
    if (values) {
      let noneOfTheAboveIndex = null;
      let noneOfTheAboveSelected = false;
      const choicesSelected = [...values];
      const countChoices = props.countChoices;
      const numCorrect = props.numCorrect;
      const valuesLength = values.length;
      for (let i = 0; i < valuesLength; i++) {
        const index = props.choices[i].originalIndex;
        choicesSelected[index] = values[i];
        if (props.choices[i].isNoneOfTheAbove) {
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
          noneOfTheAboveIndex = index;
          if (choicesSelected[i]) {
            noneOfTheAboveSelected = true;
          }
        }
      }
      return {
        choicesSelected,
        noneOfTheAboveIndex,
        noneOfTheAboveSelected,
        countChoices,
        numCorrect
      };
    }
    // Nothing checked
    return {
      choicesSelected: props.choices.map(() => false)
    };
  }
  // TODO(LP-10672): I think this might be unused right now. I can't find anywhere
  // that we pass a value to `.focus()` and it seems to have been used for
  // adding hints when editing.
  // See: https://github.com/Khan/perseus/blame/e18582b4b69959270b90e237ef1813899711ddfa/src/widgets/radio.js#L169
  focus(choiceIndex) {
    if (this.focusFunction) {
      return this.focusFunction(choiceIndex);
    }
    return false;
  }

  // lets BaseRadio regiser a focus callback so widget
  // can focus an individual choice
  registerFocusFunction(fun) {
    this.focusFunction = fun;
  }

  // When `BaseRadio`'s `onChange` handler is called, indicating a change in
  // our choices' state, we need to call our `onChange` handler in order to
  // persist those changes in the item's Perseus state.
  //
  // So, given the new values for each choice, construct the new
  // `choiceStates` objects, and pass them to `this.props.onChange`.
  //
  // `newValueLists` is an object with two keys: `checked` and `crossedOut`.
  // Each contains an array of boolean values, specifying the new checked and
  // crossed-out value of each choice.
  //
  // NOTE(mdr): This method expects to be auto-bound. If this component is
  //     converted to an ES6 class, take care to auto-bind this method!

  render() {
    const {
      choices
    } = this.props;
    let choiceStates;
    if (this.props.static) {
      choiceStates = choices.map(choice => ({
        selected: !!choice.correct,
        crossedOut: false,
        readOnly: true,
        highlighted: false,
        rationaleShown: true,
        correctnessShown: true,
        previouslyAnswered: false
      }));
    } else if (this.props.choiceStates) {
      choiceStates = this.props.choiceStates;
    } else if (this.props.values) {
      // Support legacy choiceStates implementation
      /* c8 ignore next - props.values is deprecated */
      choiceStates = this.props.values.map(val => ({
        selected: val,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        previouslyAnswered: false
      }));
    } else {
      choiceStates = choices.map(() => ({
        selected: false,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        previouslyAnswered: false
      }));
    }
    const choicesProp = choices.map((choice, i) => {
      const content = choice.isNoneOfTheAbove && !choice.content ?
      // we use i18n._ instead of $_ here because the content
      // sent to a renderer needs to be a string, not a react
      // node (/renderable/fragment).
      i18n__namespace._("None of the above") : choice.content;
      const {
        selected,
        crossedOut,
        rationaleShown,
        correctnessShown,
        readOnly,
        highlighted,
        previouslyAnswered
      } = choiceStates[i];
      const reviewChoice = this.props.reviewModeRubric && this.props.reviewModeRubric.choices[i];
      return {
        content: this._renderRenderer(content),
        checked: selected,
        // Current versions of the radio widget always pass in the
        // "correct" value through the choices. Old serialized state
        // for radio widgets doesn't have this though, so we have to
        // pull the correctness out of the review mode rubric. This
        // only works because all of the places we use
        // `restoreSerializedState()` also turn on reviewMode, but is
        // fine for now.
        // TODO(emily): Come up with a more comprehensive way to solve
        // this sort of "serialized state breaks when internal
        // structure changes" problem.
        correct: choice.correct === undefined ? !!reviewChoice && !!reviewChoice.correct : choice.correct,
        disabled: readOnly,
        hasRationale: !!choice.clue,
        rationale: this._renderRenderer(choice.clue),
        showRationale: rationaleShown,
        showCorrectness: correctnessShown,
        isNoneOfTheAbove: !!choice.isNoneOfTheAbove,
        revealNoneOfTheAbove: !!(this.props.questionCompleted && selected),
        crossedOut,
        highlighted,
        previouslyAnswered: previouslyAnswered
      };
    });
    return /*#__PURE__*/React__namespace.createElement(BaseRadio, {
      labelWrap: true,
      multipleSelect: this.props.multipleSelect,
      countChoices: this.props.countChoices,
      numCorrect: this.props.numCorrect,
      choices: choicesProp,
      onChange: this.updateChoices,
      reviewModeRubric: this.props.reviewModeRubric,
      deselectEnabled: this.props.deselectEnabled,
      apiOptions: this.props.apiOptions,
      isLastUsedWidget: this.props.isLastUsedWidget,
      registerFocusFunction: i => this.registerFocusFunction(i)
    });
  }
}
_defineProperty(Radio$1, "defaultProps", {
  choices: [],
  multipleSelect: false,
  countChoices: false,
  deselectEnabled: false,
  linterContext: PerseusLinter.linterContextDefault
});

const {
  shuffle: shuffle$2,
  random
} = Util;

// Represents choices that we automatically re-order if encountered.
// Note: these are in the reversed (incorrect) order that we will swap, if
// found.
// Note 2: these are internationalized when compared later on.
const ReversedChoices = [[i18n__namespace._("False"), i18n__namespace._("True")], [i18n__namespace._("No"), i18n__namespace._("Yes")]];

// Transforms the choices for display.
const _choiceTransform = (widgetOptions, problemNum) => {
  const _maybeRandomize = function (array) {
    const randomSeed = problemNum === undefined ? random : problemNum;
    // NOTE: `problemNum` will only be set when the radio widget is
    // rendered at the root of an exercise question. It will be `undefined`
    // if it's rendered embedded in another widget, such as `graded-group`,
    // or if rendered within an article. This results in a predictable
    // shuffle order. To avoid this we use a random seed when `problemNum`
    // is `undefined`.
    return widgetOptions.randomize ? shuffle$2(array, randomSeed !== null && randomSeed !== void 0 ? randomSeed : 0) : array;
  };
  const _addNoneOfAbove = function (choices) {
    let noneOfTheAbove = null;
    const newChoices = choices.filter((choice, index) => {
      if (choice.isNoneOfTheAbove) {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'RadioChoiceWithMetadata' is not assignable to type 'null'.
        noneOfTheAbove = choice;
        return false;
      }
      return true;
    });

    // Place the "None of the above" options last
    if (noneOfTheAbove) {
      newChoices.push(noneOfTheAbove);
    }
    return newChoices;
  };
  const enforceOrdering = choices => {
    const content = choices.map(c => c.content);
    if (ReversedChoices.some(reversed => ___default["default"].isEqual(content, reversed))) {
      return [choices[1], choices[0]];
    }
    return choices;
  };

  // Add meta-information to choices
  const choices = widgetOptions.choices.map((choice, i) => {
    return {
      ...choice,
      originalIndex: i,
      correct: Boolean(choice.correct)
    };
  });

  // Apply all the transforms. Note that the order we call these is
  // important!
  // 3) finally add "None of the above" to the bottom
  return _addNoneOfAbove(
  // 2) then (potentially) enforce ordering (eg. False, True becomes
  //    True, False)
  enforceOrdering(
  // 1) we randomize the order first
  _maybeRandomize(choices)));
};
const transform = (widgetOptions, problemNum) => {
  const choices = _choiceTransform(widgetOptions, problemNum);
  const numCorrect = ___default["default"].reduce(widgetOptions.choices, function (memo, choice) {
    return choice.correct ? memo + 1 : memo;
  }, 0);
  const {
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    deselectEnabled
  } = widgetOptions;
  return {
    numCorrect,
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    deselectEnabled,
    choices,
    selectedChoices: ___default["default"].pluck(choices, "correct")
  };
};
const propUpgrades$1 = {
  "1": v0props => {
    let choices;
    let hasNoneOfTheAbove;
    if (!v0props.noneOfTheAbove) {
      choices = v0props.choices;
      hasNoneOfTheAbove = false;
    } else {
      throw new Error("radio widget v0 no longer supports auto noneOfTheAbove");
    }
    return ___default["default"].extend(___default["default"].omit(v0props, "noneOfTheAbove"), {
      choices: choices,
      hasNoneOfTheAbove: hasNoneOfTheAbove
    });
  }
};
var Radio = {
  name: "radio",
  displayName: "Multiple choice",
  accessible: true,
  widget: Radio$1,
  transform: transform,
  staticTransform: transform,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$1,
  isLintable: true
};

/* eslint-disable import/no-named-as-default */
var basicWidgets = [Radio, InputNumber$1, NumericInput$1, Expression$1];

/* Free implementation of getUserInput. This should be used sparingly, since it
 * just returns all the widget's props rather than picking out those which were
 * input by the user.
 */
const WidgetJsonifyDeprecated = {
  getUserInput: function () {
    // Omit props that get passed to all widgets
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly getUserInput: () => any; readonly getUserInputFromProps: (props: any) => any; }'.
    return ___default["default"].omit(this.props, denylist);
  },
  // Static version of `WidgetJsonifyDeprecated.getUserInput`
  getUserInputFromProps: function (props) {
    // Omit props that get passed to all widgets
    return ___default["default"].omit(props, denylist);
  }
};

class Categorizer extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      uniqueId: ___default["default"].uniqueId("perseus_radio_")
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "getUserInput", () => {
      return Categorizer.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "onChange", (itemNum, catNum) => {
      const values = [...this.props.values];
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'never'.
      values[itemNum] = catNum;
      this.change("values", values);
      this.props.trackInteraction();
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Categorizer.validate(this.getUserInput(), rubric);
    });
  }
  render() {
    const self = this;

    // In this context, isMobile is used to differentiate mobile from
    // desktop.
    const isMobile = this.props.apiOptions.isMobile;
    let indexedItems = this.props.items.map((item, n) => [item, n]);
    if (this.props.randomizeItems) {
      // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly (string | number)[][]' is 'readonly' and cannot be assigned to the mutable type '(string | number)[][]'. | TS2345 - Argument of type 'number | null | undefined' is not assignable to parameter of type 'number | RNG'.
      indexedItems = Util.shuffle(indexedItems, this.props.problemNum);
    }
    const table = /*#__PURE__*/React__namespace.createElement("table", {
      className: "categorizer-table " + aphrodite.css(styles$q.mobileTable)
    }, /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, /*#__PURE__*/React__namespace.createElement("td", {
      className: aphrodite.css(styles$q.emptyHeaderCell)
    }), this.props.categories.map((category, i) => {
      // Array index is the correct key here, as that's
      // how category grading actually works -- no way
      // to add or remove categories or items in the
      // middle. (If we later add that, this should be
      // fixed.)
      return /*#__PURE__*/React__namespace.createElement("th", {
        className: aphrodite.css(styles$q.header),
        key: i
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: category,
        linterContext: this.props.linterContext
      }));
    }))), /*#__PURE__*/React__namespace.createElement("tbody", null, indexedItems.map(indexedItem => {
      const item = indexedItem[0];
      const itemNum = indexedItem[1];
      const uniqueId = self.state.uniqueId + "_" + itemNum;
      return /*#__PURE__*/React__namespace.createElement("tr", {
        key: itemNum
      }, /*#__PURE__*/React__namespace.createElement("td", null, /*#__PURE__*/React__namespace.createElement(Renderer
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string | number' is not assignable to type 'string | undefined'.
      , {
        content: item,
        linterContext: this.props.linterContext
      })), self.props.categories.map((catName, catNum) => {
        const selected = self.props.values[itemNum] === catNum;
        return /*#__PURE__*/React__namespace.createElement("td", {
          className: "category " + aphrodite.css(styles$q.cell),
          key: catNum
        }, /*#__PURE__*/React__namespace.createElement("div", {
          className: ClassNames.INTERACTIVE,
          role: "button",
          "aria-label": catName
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onClick: this.onChange.bind(this, itemNum, catNum)
        }, isMobile && /*#__PURE__*/React__namespace.createElement("input", {
          type: "radio",
          name: uniqueId,
          className: aphrodite.css(sharedStyles.responsiveInput, sharedStyles.responsiveRadioInput),
          checked: selected
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.onChange.bind(this, itemNum, catNum),
          onClick: e => e.stopPropagation()
        }), !isMobile && /*#__PURE__*/React__namespace.createElement("span", {
          className: aphrodite.css(styles$q.radioSpan, selected && styles$q.checkedRadioSpan, this.props.static && selected && styles$q.staticCheckedRadioSpan)
        }, selected ? /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircle) : /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleThin))));
      }));
      /* eslint-enable max-len */
    })));

    // TODO(benkomalo): kill CSS-based styling and move everything to
    // aphrodite.
    const extraClassNames = classNames__default["default"]({
      "categorizer-container": true,
      "static-mode": this.props.static
    });
    const inlineStyles = this.props.apiOptions.isMobile ? [styles$q.fullBleedContainer] : [];
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: extraClassNames + " " + aphrodite.css(...inlineStyles)
    }, table);
  }
  static validate(userInput, rubric) {
    let completed = true;
    let allCorrect = true;
    ___default["default"].each(rubric.values, function (value, i) {
      if (userInput.values[i] == null) {
        completed = false;
      }
      if (userInput.values[i] !== value) {
        allCorrect = false;
      }
    });
    if (!completed) {
      return {
        type: "invalid",
        message: i18n__namespace._("Make sure you select something for every row.")
      };
    }
    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: null
    };
  }
  static getUserInputFromProps(props) {
    return WidgetJsonifyDeprecated.getUserInputFromProps(props);
  }
}

// TODO(benkomalo): inject page-margin into Perseus instead of hardcoding.
_defineProperty(Categorizer, "defaultProps", {
  items: [],
  categories: [],
  values: [],
  linterContext: PerseusLinter.linterContextDefault
});
const pageMargin = 16;

// Stylesheets aren't directly testable
/* c8 ignore next */
const styles$q = aphrodite.StyleSheet.create({
  mobileTable: {
    [mediaQueries.smOrSmaller]: {
      minWidth: "auto"
    }
  },
  fullBleedContainer: {
    [mediaQueries.mdOrSmaller]: {
      marginLeft: -pageMargin,
      marginRight: -pageMargin,
      overflowX: "auto"
    }
  },
  header: {
    textAlign: "center",
    verticalAlign: "bottom"
  },
  cell: {
    textAlign: "center",
    padding: 0,
    color: "#ccc",
    verticalAlign: "middle"
  },
  emptyHeaderCell: {
    backgroundColor: "inherit",
    borderBottom: "2px solid #ccc"
  },
  radioSpan: {
    fontSize: 30,
    paddingRight: 3,
    ":hover": {
      color: "#999"
    }
  },
  checkedRadioSpan: {
    color: "#333"
  },
  // .static-mode is applied by the Categorizer when the rendered
  // widget is static; in this case we gray out the choices to show
  // the user that the widget can't be interacted with.
  staticCheckedRadioSpan: {
    color: "#888"
  }
});
var Categorizer$1 = {
  name: "categorizer",
  displayName: "Categorizer",
  widget: Categorizer,
  transform: widgetOptions => {
    return ___default["default"].pick(widgetOptions, "items", "categories", "randomizeItems");
  },
  staticTransform: editorProps => {
    return ___default["default"].pick(editorProps, "items", "categories", "values", "randomizeItems");
  },
  isLintable: true
};

/**
 * Helps us detect that we are running in a mobile native environment for
 * any js that is bundled in the mobile app (e.g. Perseus).
 *
 * @param {*} protocol protocol portion of a URL. Generally: window.location.protocol
 */
const isFileProtocol = protocol => {
  if (protocol && protocol.toLowerCase() === "file:") {
    return true;
  }
  return false;
};

// We cache the client location as we want to only ever return the initial
// location that was used to render the page.
let _cachedClientLocation;

/**
 * Get the location.
 */
const location = () => {
  /**
   * We cache the result to ensure that on subsequent requests we always get
   * the first URL that was used to initially render the page.
   */
  if (!_cachedClientLocation) {
    // eslint-disable-next-line no-restricted-syntax
    _cachedClientLocation = window.location;
  }
  return _cachedClientLocation;
};

/**
 * Parses a URL using the browser's built-in new URL(). Is also able to handle
 * relative URLs.
 *
 * @param {string} url The URL to parse.
 */
const parseUrl = url => new URL(url, location().origin);

/**
 * Turns a URL into an absolute URL.
 *
 * @param {string} url The URL to turn into an absolute URL.
 */
const toAbsoluteUrl = url => parseUrl(url).href;

const {
  updateQueryString: updateQueryString$1
} = Util;
function getUrlFromProgramID(programID) {
  const {
    InitialRequestUrl
  } = getDependencies();
  const path = "/computer-programming/program/" + "".concat(programID, "/embedded?embed=yes&author=no");
  // When loading scratchpads in our native apps, the current URL will exist
  // as a `file://` URL. In this case, we want to reference `ka.org` instead
  // of defaulting to what we get from `toAbsoluteUrl`.
  if (isFileProtocol(InitialRequestUrl.protocol)) {
    return "https://khanacademy.org".concat(path);
  }
  return toAbsoluteUrl(path);
}

/* This renders the scratchpad in an iframe and handles validation via
 * window.postMessage */
class CSProgram extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "handleMessageEvent", e => {
      // We receive data from the iframe that contains {passed: true/false}
      //  and use that to set the status
      // It could also contain an optional message
      let data = {};
      try {
        data = JSON.parse(e.originalEvent.data);
      } catch (err) {
        return;
      }
      if (___default["default"].isUndefined(data.testsPassed)) {
        return;
      }
      const status = data.testsPassed ? "correct" : "incorrect";
      this.change({
        status: status,
        message: data.message
      });
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return CSProgram.validate({
        status: this.props.status,
        message: this.props.message
      }, rubric);
    });
  }
  // The widget's grading function
  static validate(state, rubric) {
    // The iframe can tell us whether it's correct or incorrect,
    //  and pass an optional message
    if (state.status === "correct") {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: state.message || null
      };
    }
    if (state.status === "incorrect") {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: state.message || null
      };
    }
    return {
      type: "invalid",
      message: "Keep going, you're not there yet!"
    };
  }
  componentDidMount() {
    $__default["default"](window).on("message", this.handleMessageEvent);
  }
  componentWillUnmount() {
    $__default["default"](window).off("message", this.handleMessageEvent);
  }
  render() {
    if (!this.props.programID) {
      return /*#__PURE__*/React__namespace.createElement("div", null);
    }
    let styleContainer = false;
    let url = getUrlFromProgramID(this.props.programID);
    let className;
    const style = {
      height: this.props.height,
      width: "100%"
    };
    if (this.props.showEditor) {
      url += "&editor=yes";
      className = "perseus-scratchpad-editor";
    } else {
      url += "&editor=no&width=".concat(articleMaxWidthInPx);
      className = "perseus-scratchpad";
      if (this.props.programType !== "webpage") {
        styleContainer = true;
      }
    }
    if (this.props.showButtons) {
      url += "&buttons=yes";
      // Matches templates/scratchpads/embed_script.js
      // Toolbar height is 66, border height is 1 pixel
      // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'height' because it is a read-only property.
      style.height += 67;
    } else {
      url += "&buttons=no";
    }

    // Turn array of [{name: "", value: ""}] into object
    if (this.props.settings) {
      const settings = {};
      ___default["default"].each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      });
      // This becomes available to programs as Program.settings()
      url = updateQueryString$1(url, "settings", JSON.stringify(settings));
    }
    const sandboxOptions = ["allow-popups", "allow-same-origin", "allow-scripts", "allow-top-navigation"].join(" ");

    // We sandbox the iframe so that we allowlist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.widthOverride, styleContainer && styles$p.container)
    }, /*#__PURE__*/React__namespace.createElement("iframe", {
      sandbox: sandboxOptions,
      src: url,
      style: style,
      className: className,
      allowFullScreen: true
    }));
  }
}
_defineProperty(CSProgram, "propTypes", {
  ...propTypes,
  programID: PropTypes__default["default"].string,
  programType: PropTypes__default["default"].oneOf(["pjs", "sql", "webpage"]),
  width: PropTypes__default["default"].number,
  height: PropTypes__default["default"].number,
  // eslint-disable-next-line react/forbid-prop-types
  settings: PropTypes__default["default"].array,
  showEditor: PropTypes__default["default"].bool,
  showButtons: PropTypes__default["default"].bool,
  status: PropTypes__default["default"].oneOf(["incomplete", "incorrect", "correct"]),
  message: PropTypes__default["default"].string
});
_defineProperty(CSProgram, "defaultProps", {
  showEditor: false,
  showButtons: false,
  status: "incomplete",
  // optional message
  message: null
});
const styles$p = aphrodite.StyleSheet.create({
  // Override the inherited width from the perseus paragraph class
  // 820 is minimum width for 420px editor and 400px canvas
  widthOverride: {
    width: 820
  },
  container: {
    margin: "auto"
  }
});
var CSProgram$1 = {
  name: "cs-program",
  displayName: "CS Program",
  supportedAlignments: ["block", "full-width"],
  widget: CSProgram,
  hidden: true
};

class Definition extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "getUserInput", () => {
      return {};
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Definition.validate(this.getUserInput(), rubric);
    });
  }
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(DefinitionConsumer, null, _ref => {
      let {
        activeDefinitionId,
        setActiveDefinitionId
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
        content: /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContentCore, {
          color: "white",
          style: styles$o.tooltipBody,
          closeButtonVisible: true
        }, /*#__PURE__*/React__namespace.createElement(Renderer, {
          apiOptions: this.props.apiOptions,
          content: this.props.definition,
          widgets: this.props.widgets
        })),
        opened: activeDefinitionId === this.props.widgetId,
        onClose: () => setActiveDefinitionId(null),
        placement: "top"
      }, /*#__PURE__*/React__namespace.createElement(Clickable__default["default"], {
        onClick: () => {
          this.props.trackInteraction();
          setActiveDefinitionId(this.props.widgetId);
        }
      }, _ref2 => {
        let {
          hovered,
          focused,
          pressed
        } = _ref2;
        return /*#__PURE__*/React__namespace.createElement("span", {
          style: {
            color: Color__default["default"].blue,
            borderBottom: hovered || focused || pressed ? "2px solid ".concat(Color__default["default"].blue) : "none"
          }
        }, this.props.togglePrompt);
      }));
    });
  }
}
_defineProperty(Definition, "defaultProps", {
  togglePrompt: "define me",
  definition: "definition goes here"
});
const styles$o = {
  tooltipBody: {
    color: Color__default["default"].offBlack,
    fontSize: 20,
    fontWeight: 500,
    lineHeight: "30px"
  }
};
var Definition$1 = {
  name: "definition",
  displayName: "Definition",
  accessible: true,
  defaultAlignment: "inline",
  widget: Definition,
  transform: x => x
};

class Dropdown extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "focus", () => {
      // TODO(LP-10797): This focus() call doesn't do anything because our
      // root element is a <div> and that cannot be focused without a
      // tabIndex.
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this).focus();
      return true;
    });
    _defineProperty(this, "_handleChangeEvent", e => {
      this._handleChange(parseInt(e.target.value));
    });
    _defineProperty(this, "_handleChange", selected => {
      this.props.trackInteraction();
      this.props.onChange({
        selected: selected
      });
    });
    _defineProperty(this, "getUserInput", () => {
      return {
        value: this.props.selected
      };
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Dropdown.validate(this.getUserInput(), rubric);
    });
  }
  static validate(userInput, rubric) {
    const selected = userInput.value;
    if (selected === 0) {
      return {
        type: "invalid",
        message: null
      };
    }
    const correct = rubric.choices[selected - 1].correct;
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
  render() {
    const children = [/*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.OptionItem, {
      key: "placeholder",
      value: "0",
      disabled: true,
      label: this.props.placeholder
    }), ...this.props.choices.map((choice, i) => /*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.OptionItem, {
      key: String(i + 1),
      value: String(i + 1),
      label: choice
    }))];
    return /*#__PURE__*/React__namespace.createElement("div", {
      // NOTE(jared): These are required to prevent weird behavior
      // When there's a dropdown in a zoomable table.
      onClick: e => {
        e.stopPropagation();
      },
      onTouchStart: e => {
        e.stopPropagation();
      }
    }, /*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.SingleSelect, {
      placeholder: "",
      onChange: value => this._handleChange(parseInt(value)),
      selectedValue: String(this.props.selected),
      disabled: this.props.apiOptions.readOnly
    }, children));
  }
}
_defineProperty(Dropdown, "defaultProps", {
  choices: [],
  selected: 0,
  placeholder: "",
  apiOptions: ApiOptions.defaults
});
const optionsTransform = widgetOptions => {
  return {
    placeholder: widgetOptions.placeholder,
    choices: widgetOptions.choices.map(choice => choice.content)
  };
};
var Dropdown$1 = {
  name: "dropdown",
  displayName: "Drop down",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: Dropdown,
  transform: optionsTransform
};

class Explanation extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      expanded: false
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "_onClick", () => {
      this.setState({
        expanded: !this.state.expanded
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "getUserInput", () => {
      return {};
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Explanation.validate(this.getUserInput(), rubric);
    });
  }
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  render() {
    const {
      Link
    } = this.props.apiOptions.baseElements;
    const {
      isArticle,
      isMobile
    } = this.props.apiOptions;
    const linkAnchor = this.state.expanded ? this.props.hidePrompt : this.props.showPrompt;
    let linkContainer;

    // TODO(diedra): This isn't a valid href;
    // change this to a button that looks like a link.
    const href = "javascript:void(0)";
    const onClick = this._onClick;
    if (isMobile) {
      linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$n.linkContainer)
      }, /*#__PURE__*/React__namespace.createElement("a", {
        className: aphrodite.css(styles$n.mobileExplanationLink),
        href: href,
        onClick: onClick,
        role: "button",
        "aria-expanded": this.state.expanded
      }, linkAnchor), this.state.expanded && /*#__PURE__*/React__namespace.createElement("svg", {
        className: aphrodite.css(styles$n.disclosureArrow)
      }, /*#__PURE__*/React__namespace.createElement("polygon", {
        style: {
          fill: backgroundColor
        },
        points: "0,".concat(arrowHeight, " ") + "".concat(arrowWidth, ",").concat(arrowHeight, " ") + "".concat(arrowWidth / 2, ",0")
      })));
    } else {
      if (isArticle) {
        // NOTE: For articles, the baseElements `Link` may is either be
        // an anchor tag (if rendered in a modal) or a Wonder Blocks
        // link component in lesson page, see: `article-page.jsx`.
        linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$n.linkContainer, styles$n.articleLink)
        }, /*#__PURE__*/React__namespace.createElement(Link, {
          className: aphrodite.css(styles$n.explanationLink)
          // HACK(michaelpolyak): WB Link doesn't passthrough
          // class name.
          ,
          style: styles$n.explanationLink,
          href: href,
          onClick: onClick,
          role: "button",
          "aria-expanded": this.state.expanded
        }, "[".concat(linkAnchor, "]")));
      } else {
        // NOTE: For exercises, the baseElements `Link` is an
        // anchor tag, see: `perseus-api.jsx`.
        linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$n.linkContainer, styles$n.exerciseLink)
        }, /*#__PURE__*/React__namespace.createElement(Link, {
          className: aphrodite.css(styles$n.explanationLink),
          href: href,
          onClick: onClick,
          role: "button",
          "aria-expanded": this.state.expanded
        }, "[".concat(linkAnchor, "]")));
      }
    }
    const expandedStyle = isMobile ? styles$n.contentExpandedMobile : styles$n.contentExpanded;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$n.container)
    }, linkContainer, this.state.expanded && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$n.content, isMobile && styles$n.contentMobile, this.state.expanded && expandedStyle)
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "content"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      apiOptions: this.props.apiOptions,
      content: this.props.explanation,
      widgets: this.props.widgets,
      linterContext: this.props.linterContext
    })));
  }
}
_defineProperty(Explanation, "defaultProps", {
  showPrompt: "Explain",
  hidePrompt: "Hide explanation",
  explanation: "explanation goes here\n\nmore explanation",
  widgets: {},
  linterContext: PerseusLinter.linterContextDefault
});
const leftBorderSpacing = 23;
const verticalContentPadding = 10;
const arrowWidth = 30;
const arrowHeight = 14;
const backgroundColor = gray95;
const styles$n = aphrodite.StyleSheet.create({
  container: {
    display: "inline",
    position: "relative"
  },
  linkContainer: {
    display: "inline-block"
  },
  explanationLink: {
    fontStyle: "italic",
    color: "#007d96"
  },
  articleLink: {
    // Copied from .body-text in articles.less
    fontSize: 20,
    lineHeight: "30px"
  },
  exerciseLink: {
    // Copied from .legacy-typography in util.less
    fontSize: 14,
    lineHeight: "19.6px"
  },
  mobileExplanationLink: {
    color: kaGreen$1,
    borderBottom: "dashed 1px ".concat(kaGreen$1),
    textDecoration: "none",
    // TODO(benkomalo): these should be pulled in from common typography
    // shared files so we have a single place where the type hierarchy is
    // defined; one off font sizes for individual components should be
    // avoided.
    [mediaQueries.xl]: {
      fontSize: 22,
      lineHeight: 1.4
    },
    [mediaQueries.lgOrSmaller]: {
      fontSize: 20,
      lineHeight: 1.5
    },
    [mediaQueries.smOrSmaller]: {
      fontSize: 18,
      lineHeight: 1.2
    }
  },
  content: {
    position: "relative",
    transition: "margin-top 0.1s"
  },
  contentExpanded: {
    borderLeft: "5px solid #ccc",
    marginLeft: -leftBorderSpacing,
    paddingLeft: leftBorderSpacing,
    paddingBottom: verticalContentPadding,
    // Note: we still use arrow height as the vertical margin, even on
    // desktop when there is no arrow, but it's good enough.
    marginBottom: arrowHeight,
    marginTop: arrowHeight
  },
  contentExpandedMobile: {
    boxSizing: "content-box",
    paddingTop: 32,
    paddingBottom: 32,
    marginTop: arrowHeight
  },
  contentMobile: {
    background: backgroundColor,
    // TODO(benkomalo): this is to "full bleed" the background.
    // The actual content padding differs depending on the host
    // container, so this needs to be fixed eventually.
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin
  },
  disclosureArrow: {
    // HACK - positioning at "bottom: 0", doesn't actually position it to
    // the real bottom, because the container is `inline-block`, and it
    // seems to position it to the baseline? We put in a generous
    // fudge factor to position it down to be flush with the content box
    // below it.
    bottom: -(arrowHeight + 5),
    height: arrowHeight,
    left: "50%",
    marginLeft: -(arrowWidth / 2),
    position: "absolute",
    width: arrowWidth
  }
});
var Explanation$1 = {
  name: "explanation",
  displayName: "Explanation",
  accessible: true,
  defaultAlignment: "inline",
  widget: Explanation,
  transform: ___default["default"].identity,
  isLintable: true
};

/*
 * A11y (Accessibility) style rules
 * These are used to mark up areas on the site that should only be readable
 * when using a screen reader.
 */
var a11y = aphrodite.StyleSheet.create({
  // Make content only visible to screen readers.
  // Both collegeboard.org and Bootstrap 3 use this exact implementation.
  srOnly: {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: 1,
    margin: -1,
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: 1
  }
});

class GradedGroupAnswerBar extends React__namespace.Component {
  render() {
    const {
      apiOptions,
      answerBarState,
      onCheckAnswer,
      onNextQuestion
    } = this.props;
    const answerBarStyle = {
      ...styles$m.answerBar,
      backgroundColor: answerBarState === "CORRECT" ? Color__default["default"].offWhite : "white",
      // Center the "Correct!" message only when there's no next question
      justifyContent: answerBarState === "CORRECT" && !onNextQuestion ? "center" : "space-between"
    };
    const message = answerBarState === "INCORRECT" ? /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$m.text
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$m.tryAgainIcon
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconTryAgain)), /*#__PURE__*/React__namespace.createElement("span", {
      style: {
        marginLeft: 8
      }
    }, i18n__namespace._("Keep trying"))) : /*#__PURE__*/React__namespace.createElement("span", null); // empty span keeps the button on the right side

    if (answerBarState !== "CORRECT") {
      const buttonLabel = answerBarState === "INCORRECT" ? i18n__namespace._("Try again") : i18n__namespace._("Check");
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: answerBarStyle
      }, message, /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
        disabled: apiOptions.readOnly || answerBarState !== "ACTIVE",
        onClick: onCheckAnswer
      }, buttonLabel));
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: answerBarStyle
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$m.text
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: {
        fontSize: 28,
        color: Color__default["default"].green
      }
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconStar, {
      style: {
        marginBottom: 5
      }
    }))), /*#__PURE__*/React__namespace.createElement("span", {
      role: "alert",
      "aria-label": i18n__namespace._("Correct!"),
      style: {
        marginLeft: 8
      }
    }, i18n__namespace._("Correct!"))), onNextQuestion && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      onClick: onNextQuestion
    }, i18n__namespace._("Next question")));
  }
}
const fontSize = 17;
const styles$m = {
  answerBar: {
    display: "flex",
    alignItems: "center",
    height: 68,
    // so that we don't have calculate the vertical padding
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    marginBottom: negativePhoneMargin,
    marginTop: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: 10,
    borderTop: "1px solid ".concat(Color__default["default"].offBlack50)
  },
  tryAgainIcon: {
    fontSize: 28,
    color: "#63D9EA",
    transform: "scale(-1,1) rotate(-268deg)"
  },
  text: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    fontWeight: "bold",
    fontSize: fontSize
  }
};

const GRADING_STATUSES = {
  ungraded: "ungraded",
  correct: "correct",
  incorrect: "incorrect",
  invalid: "invalid"
};

// Update answer bar state based on current state and whether the question is
// answerable (all parts have been filled out) or not.
const getNextState = (currentState, answerable) => {
  switch (currentState) {
    case "HIDDEN":
      return answerable ? "ACTIVE" : currentState;
    case "ACTIVE":
      return !answerable ? "INACTIVE" : currentState;
    case "INACTIVE":
      return answerable ? "ACTIVE" : currentState;
    case "INCORRECT":
      return answerable ? "ACTIVE" : "INACTIVE";
    default:
      return currentState;
  }
};

// Prepended to all invalid messages to make the widget messages a bit clearer
const INVALID_MESSAGE_PREFIX = i18n__namespace._("We couldn't grade your answer.");
const DEFAULT_INVALID_MESSAGE = i18n__namespace._("It looks like you left something blank or ") + i18n__namespace._("entered in an invalid answer.");
// A Graded Group is more or less a Group widget that displays a check
// answer button below the rendered content. When clicked, the widget grades
// the stuff inside and displays feedback about whether the inputted answer was
// correct or not.
class GradedGroup extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      status: GRADING_STATUSES.ungraded,
      showHint: false,
      message: "",
      answerBarState: "HIDDEN"
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "_onInteractWithWidget", id => {
      // Reset grading display when user changes answer
      this.setState({
        status: GRADING_STATUSES.ungraded,
        message: ""
      });

      // eslint-disable-next-line react/no-string-refs
      if (this.refs.renderer) {
        this.change("widgets", this.props.widgets);
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'emptyWidgets' does not exist on type 'ReactInstance'.
        const emptyWidgets = this.refs.renderer.emptyWidgets();
        const answerable = emptyWidgets.length === 0;
        const answerBarState = this.state.answerBarState;
        this.setState({
          answerBarState: getNextState(answerBarState, answerable)
        });
      }
    });
    _defineProperty(this, "_checkAnswer", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'showRationalesForCurrentlySelectedChoices' does not exist on type 'ReactInstance'.
      this.refs.renderer.showRationalesForCurrentlySelectedChoices();
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'score' does not exist on type 'ReactInstance'.
      const score = this.refs.renderer.score();
      const status = score.type === "points" ? score.total === score.earned ? GRADING_STATUSES.correct : GRADING_STATUSES.incorrect : GRADING_STATUSES.invalid;
      const message = score.type === "points" ? score.message || "" : score.message ? "".concat(INVALID_MESSAGE_PREFIX, " ").concat(score.message) : "".concat(INVALID_MESSAGE_PREFIX, " ").concat(DEFAULT_INVALID_MESSAGE);
      this.setState({
        status: status,
        message: message,
        // TODO(kevinb) handle 'invalid' status
        answerBarState: status === "correct" ? "CORRECT" : "INCORRECT"
      });
      this.props.trackInteraction({
        status: status
      });
    });
    _defineProperty(this, "getInputPaths", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getInputPaths' does not exist on type 'ReactInstance'.
      return this.refs.renderer.getInputPaths();
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'setInputValue' does not exist on type 'ReactInstance'.
      return this.refs.renderer.setInputValue(path, newValue, cb);
    });
    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      return this.refs.renderer.focus();
    });
    _defineProperty(this, "focusInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focusPath' does not exist on type 'ReactInstance'.
      this.refs.renderer.focusPath(path);
    });
    _defineProperty(this, "blurInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blurPath' does not exist on type 'ReactInstance'.
      this.refs.renderer.blurPath(path);
    });
  }
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }
  render() {
    const apiOptions = ___default["default"].extend({}, ApiOptions.defaults, this.props.apiOptions, {
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }
        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    });
    let gradeStatus = null;
    let icon = null;
    // Colors are 10% darker than the colors in graded-group.less
    if (this.state.status === GRADING_STATUSES.correct) {
      // TODO(jeremy): update to a WB colour
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Element' is not assignable to type 'null'.
      icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconOk, {
        style: {
          color: "#526f03"
        }
      }));
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      gradeStatus = i18n__namespace._("Correct");
    } else if (this.state.status === GRADING_STATUSES.incorrect) {
      // TODO(jeremy): update to a WB colour
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Element' is not assignable to type 'null'.
      icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconRemove, {
        style: {
          color: "#ff5454"
        }
      }));
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      gradeStatus = i18n__namespace._("Incorrect");
    }
    const mobileClass = this.props.inGradedGroupSet ? aphrodite.css(styles$l.gradedGroupInSet) : aphrodite.css(styles$l.gradedGroup);
    const classes = classNames__default["default"]({
      [mobileClass]: apiOptions.isMobile,
      "perseus-graded-group": true,
      "answer-correct": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.correct,
      "answer-incorrect": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.incorrect
    });
    const {
      answerBarState
    } = this.state;

    // Disabled widgets after the answer has been answered correctly to
    // prevent a situation where the answer has been marked correct but
    // looks incorrect because a user has modified it afterwards.
    const isCorrect = answerBarState === "CORRECT";
    const readOnly = apiOptions.readOnly || apiOptions.isMobile && isCorrect;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classes
    }, !!this.props.title && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$l.title)
    }, this.props.title), /*#__PURE__*/React__namespace.createElement(Renderer, _extends({}, this.props, {
      // eslint-disable-next-line react/no-string-refs
      ref: "renderer",
      apiOptions: {
        ...apiOptions,
        readOnly
      },
      onInteractWithWidget: this._onInteractWithWidget,
      linterContext: this.props.linterContext
    })), !apiOptions.isMobile && icon && /*#__PURE__*/React__namespace.createElement("div", {
      className: "group-icon"
    }, icon), !apiOptions.isMobile && gradeStatus && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(a11y.srOnly),
      role: "alert",
      "aria-label": gradeStatus
    }, gradeStatus), !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement("p", {
      role: "status",
      "aria-live": "polite"
    }, this.state.message), !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      kind: "secondary",
      disabled: this.props.apiOptions.readOnly,
      onClick: this._checkAnswer
    }, i18n__namespace._("Check")), !apiOptions.isMobile && isCorrect && this.props.onNextQuestion && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      kind: "secondary",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onNextQuestion,
      style: {
        marginLeft: 5
      }
    }, i18n__namespace._("Next question")), this.props.hint && this.props.hint.content && (this.state.showHint ? /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("button", {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'number | undefined'.
      tabIndex: "0",
      className: aphrodite.css(styles$l.explanationTitle),
      onClick: () => this.setState({
        showHint: false
      }),
      onKeyPress: e => {
        // preventDefault stops the screen from scrolling down on keypress
        e.preventDefault();
        this.setState({
          showHint: false
        });
      }
    }, i18n__namespace._("Hide explanation")), /*#__PURE__*/React__namespace.createElement(Renderer, _extends({}, this.props.hint, {
      // eslint-disable-next-line react/no-string-refs
      ref: "hints-renderer",
      apiOptions: apiOptions,
      linterContext: this.props.linterContext
    }))) :
    /*#__PURE__*/
    // Not using Button here bc the styles won't work.
    React__namespace.createElement("button", {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'number | undefined'.
      tabIndex: "0",
      onClick: () => this.setState({
        showHint: true
      }),
      onKeyPress: e => {
        // preventDefault stops the screen from scrolling down on keypress
        e.preventDefault();
        this.setState({
          showHint: true
        });
      },
      className: aphrodite.css(styles$l.showHintLink)
    }, i18n__namespace._("Explain"))), apiOptions.isMobile && answerBarState !== "HIDDEN" && /*#__PURE__*/React__namespace.createElement(GradedGroupAnswerBar, {
      apiOptions: apiOptions,
      answerBarState: answerBarState,
      onCheckAnswer: this._checkAnswer,
      onNextQuestion: this.props.onNextQuestion
    }));
  }
}
_defineProperty(GradedGroup, "defaultProps", {
  title: "",
  content: "",
  widgets: {},
  images: {},
  hint: null,
  hasHint: false,
  linterContext: PerseusLinter.linterContextDefault
});
const traverseChildWidgets$3 = function (props, traverseRenderer) {
  return ___default["default"].extend({}, props, traverseRenderer(props));
};
const styles$l = aphrodite.StyleSheet.create({
  gradedGroupInSet: {
    // Reset a few desktop-only styles that come from graded-group.less
    marginLeft: 0,
    paddingLeft: 0
  },
  gradedGroup: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent$1,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  },
  showHintLink: {
    backgroundColor: "unset",
    fontSize: 14,
    padding: 0,
    border: "none",
    marginTop: 20,
    color: Color__default["default"].blue,
    cursor: "pointer",
    display: "block",
    clear: "both"
  },
  explanationTitle: {
    backgroundColor: "unset",
    marginTop: 20,
    color: Color__default["default"].blue,
    marginBottom: 10,
    cursor: "pointer",
    fontSize: 14,
    padding: 0,
    border: "none",
    display: "block",
    clear: "both"
  },
  title: {
    fontSize: 12,
    color: gray68,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  }
});
var GradedGroup$1 = {
  name: "graded-group",
  displayName: "Graded group (articles only)",
  widget: GradedGroup,
  traverseChildWidgets: traverseChildWidgets$3,
  // TODO(aasmund): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};

class Indicators extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "handleKeyDown", (e, i) => {
      if (e.key === "Enter" || e.key === " ") {
        this.props.onChangeCurrentGroup(i);
      }
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("ul", {
      className: aphrodite.css(styles$k.indicatorContainer)
    }, this.props.gradedGroups.map((_ref, i) => {
      let {
        title
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement("li", {
        role: "button",
        "aria-label": i18n__namespace._("Skip to %(title)s", {
          title
        }),
        key: title,
        className: aphrodite.css(styles$k.indicator, i === this.props.currentGroup && styles$k.selectedIndicator),
        tabIndex: 0,
        onClick: () => this.props.onChangeCurrentGroup(i),
        onKeyDown: e => this.handleKeyDown(e, i)
      }, i === this.props.currentGroup && /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(a11y.srOnly)
      }, i18n__namespace._("Current")));
    }));
  }
}
// TODO(jared): find a better name for this :) and for GradedGroup; the names
// are currently a little confusing.
class GradedGroupSet extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_childGroup", void 0);
    _defineProperty(this, "state", {
      currentGroup: 0
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "getInputPaths", () => {
      return this._childGroup.getInputPaths();
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      return this._childGroup.setInputValue(path, newValue, cb);
    });
    _defineProperty(this, "focus", () => {
      return this._childGroup.focus();
    });
    _defineProperty(this, "focusInputPath", path => {
      this._childGroup.focusInputPath(path);
    });
    _defineProperty(this, "blurInputPath", path => {
      this._childGroup.blurInputPath(path);
    });
    _defineProperty(this, "handleNextQuestion", () => {
      const {
        currentGroup
      } = this.state;
      const numGroups = this.props.gradedGroups.length;
      if (currentGroup < numGroups - 1) {
        this.setState({
          currentGroup: currentGroup + 1
        });
      }
    });
  }
  shouldComponentUpdate(nextProps, nextState) {
    nextProps.gradedGroups;
    return nextProps !== this.props || nextState !== this.state;
  }
  render() {
    // When used in the context of TranslationEditor, render the
    // GradedGroup widget one below another instead of using an indicator
    // to click and switch between different graded groups. Translators
    // prefer to see all strings/labels on all GradedGroups readily visible
    // together instead of clicking on indicators to switch between them.
    const {
      JIPT
    } = getDependencies();
    if (JIPT.useJIPT && this.props.gradedGroups.length > 1) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$k.container)
      }, this.props.gradedGroups.map((gradedGroup, i) => {
        return (
          /*#__PURE__*/
          // TODO(jeremy): Don't spread this.props, instead
          // pass in all props GradedGroup needs explicilty
          // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
          React__namespace.createElement(GradedGroup, _extends({
            key: i
          }, this.props, gradedGroup, {
            inGradedGroupSet: false,
            linterContext: this.props.linterContext
          }))
        );
      }));
    }
    const currentGroup = this.props.gradedGroups[this.state.currentGroup];
    if (!currentGroup) {
      return /*#__PURE__*/React__namespace.createElement("span", null, i18n__namespace.doNotTranslate("No current group..."));
    }
    const numGroups = this.props.gradedGroups.length;
    const handleNextQuestion = this.state.currentGroup < numGroups - 1 ? this.handleNextQuestion : null;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.container)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.top)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.title)
    }, currentGroup.title), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.spacer)
    }), /*#__PURE__*/React__namespace.createElement(Indicators, {
      currentGroup: this.state.currentGroup,
      gradedGroups: this.props.gradedGroups,
      onChangeCurrentGroup: currentGroup => this.setState({
        currentGroup
      })
    })), /*#__PURE__*/React__namespace.createElement(GradedGroup, _extends({
      key: this.state.currentGroup
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'GradedGroup | null' is not assignable to type 'GradedGroup'.
      //  Type 'null' is not assignable to type 'GradedGroup'.
      ,
      ref: comp => this._childGroup = comp
      // We should pass in the set of props explicitly
    }, this.props, currentGroup, {
      inGradedGroupSet: true,
      title: null,
      onNextQuestion: handleNextQuestion,
      linterContext: this.props.linterContext
    })));
  }
}
_defineProperty(GradedGroupSet, "defaultProps", {
  gradedGroups: [],
  linterContext: PerseusLinter.linterContextDefault
});
const traverseChildWidgets$2 = function (props, traverseRenderer) {
  // NOTE(jared): I have no idea how this works
  return {
    groups: props.gradedGroups.map(traverseRenderer)
  };
};
var GradedGroupSet$1 = {
  name: "graded-group-set",
  displayName: "Graded group set (articles only)",
  widget: GradedGroupSet,
  traverseChildWidgets: traverseChildWidgets$2,
  // TODO(michaelpolyak): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};
const styles$k = aphrodite.StyleSheet.create({
  top: {
    display: "flex",
    flexDirection: "row"
  },
  spacer: {
    flex: 1
  },
  title: {
    fontSize: 12,
    color: Color__default["default"].offBlack64,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  },
  indicatorContainer: {
    display: "flex",
    flexDirection: "row",
    listStyle: "none",
    margin: "unset"
  },
  indicator: {
    width: 10,
    height: 10,
    borderRadius: "100%",
    border: "3px solid",
    borderColor: Color__default["default"].blue,
    marginLeft: 5,
    cursor: "pointer"
  },
  selectedIndicator: {
    backgroundColor: Color__default["default"].blue
  },
  container: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent$1,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  }
});

/**
 * ButtonGroup is an aesthetically pleasing group of buttons.
 */
class ButtonGroup extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "container", void 0);
  }
  componentWillUnmount() {
    this.container = null;
  }
  focus() {
    if (this.container) {
      this.container.focus();
      return true;
    }
  }
  toggleSelect(newValue) {
    const value = this.props.value;
    if (this.props.allowEmpty) {
      // Select the new button or unselect if it's already selected
      this.props.onChange(value !== newValue ? newValue : null);
    } else {
      this.props.onChange(newValue);
    }
  }
  render() {
    const value = this.props.value;
    const buttons = this.props.buttons.map((button, i) => {
      return /*#__PURE__*/React__namespace.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        ref: "button" + i,
        key: "" + i,
        className: aphrodite.css(styles$j.buttonStyle, button.value === value && styles$j.selectedStyle),
        onClick: () => this.toggleSelect(button.value)
      }, button.content || "" + button.value);
    });
    const outerStyle = {
      display: "inline-block"
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: outerStyle,
      ref: node => this.container = node
    }, buttons);
  }
}
_defineProperty(ButtonGroup, "defaultProps", {
  value: null,
  allowEmpty: true
});
const styles$j = aphrodite.StyleSheet.create({
  buttonStyle: {
    backgroundColor: "white",
    border: "1px solid #ccc",
    borderLeft: "0",
    cursor: "pointer",
    margin: "0",
    padding: "5px 10px",
    position: "relative",
    // for hover

    ":first-child": {
      borderLeft: "1px solid #ccc",
      borderTopLeftRadius: "3px",
      borderBottomLeftRadius: "3px"
    },
    ":last-child": {
      borderRight: "1px solid #ccc",
      borderTopRightRadius: "3px",
      borderBottomRightRadius: "3px"
    },
    ":hover": {
      backgroundColor: "#ccc"
    },
    ":focus": {
      zIndex: 2
    }
  },
  selectedStyle: {
    backgroundColor: "#ddd"
  }
});

/* eslint-disable one-var */
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Plot' does not exist on type 'typeof Graphie'.
const Plot$1 = Graphie.Plot;
const DEFAULT_BACKGROUND_IMAGE = {
  url: null
};

// TODO(charlie): These really need to go into a utility file as they're being
// used by both interactive-graph and now grapher.
function canonicalSineCoefficients$1(coeffs) {
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3];

  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }
  const period = 2 * Math.PI;
  // Guarantee b > 0
  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  }

  // Guarantee c is smallest possible positive value
  while (phase > 0) {
    phase -= period;
  }
  while (phase < 0) {
    phase += period;
  }
  return [amplitude, angularFrequency, phase, verticalOffset];
}
function canonicalTangentCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Tan(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3];

  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }
  const period = Math.PI;
  // Guarantee b > 0
  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  }

  // Guarantee c is smallest possible positive value
  while (phase > 0) {
    phase -= period;
  }
  while (phase < 0) {
    phase += period;
  }
  return [amplitude, angularFrequency, phase, verticalOffset];
}
const PlotDefaults = {
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(coeffs1, coeffs2);
  },
  Movable: Plot$1,
  getPropsForCoeffs: function (coeffs) {
    return {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getFunctionForCoeffs' does not exist on type '{ readonly areEqual: (coeffs1: any, coeffs2: any) => boolean; readonly Movable: any; readonly getPropsForCoeffs: (coeffs: any) => any; }'.
      fn: ___default["default"].partial(this.getFunctionForCoeffs, coeffs)
    };
  }
};
const Linear = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/67aaf581e6d9ef9038c10558a1f70ac21c11c9f8.png",
  defaultCoords: [[0.25, 0.75], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];
    if (denom === 0) {
      return;
    }
    const m = num / denom;
    const b = p2[1] - m * p2[0];
    return [m, b];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0],
      b = coeffs[1];
    return m * x + b;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0],
      b = coeffs[1];
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
});
const Quadratic = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/e23d36e6fc29ee37174e92c9daba2a66677128ab.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'Parabola' does not exist on type 'typeof Graphie'.
  Movable: Graphie.Parabola,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];

    // Parabola with vertex (h, k) has form: y = a * (h - k)^2 + k
    const h = p1[0];
    const k = p1[1];

    // Use these to calculate familiar a, b, c
    const a = (p2[1] - k) / ((p2[0] - h) * (p2[0] - h));
    const b = -2 * h * a;
    const c = a * h * h + k;
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return (a * x + b) * x + c;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return "y = " + a.toFixed(3) + "x^2 + " + b.toFixed(3) + "x + " + c.toFixed(3);
  }
});
const Sinusoid = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/3d68e7718498475f53b206c2ab285626baf8857e.png",
  defaultCoords: [[0.5, 0.5], [0.6, 0.6]],
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'Sinusoid' does not exist on type 'typeof Graphie'.
  Movable: Graphie.Sinusoid,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (2 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2],
      d = coeffs[3];
    return a * Math.sin(b * x - c) + d;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2],
      d: coeffs[3]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2],
      d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(canonicalSineCoefficients$1(coeffs1), canonicalSineCoefficients$1(coeffs2));
  }
});
const Tangent = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/7db80d23c35214f98659fe1cf0765811c1bbfbba.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (4 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2],
      d = coeffs[3];
    return a * Math.tan(b * x - c) + d;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2],
      d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(canonicalTangentCoefficients(coeffs1), canonicalTangentCoefficients(coeffs2));
  }
});
const Exponential = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/9cbfad55525e3ce755a31a631b074670a5dad611.png",
  defaultCoords: [[0.5, 0.55], [0.75, 0.75]],
  defaultAsymptote: [[0, 0.5], [1.0, 0.5]],
  /**
   * Add extra constraints for movement of the points or asymptote (below):
   *   newCoord: [x, y]
   *     The end position of the point or asymptote endpoint
   *   oldCoord: [x, y]
   *     The old position of the point or asymptote endpoint
   *   coords:
   *     An array of coordinates representing the proposed end configuration
   *     of the plot coordinates.
   *   asymptote:
   *     An array of coordinates representing the proposed end configuration
   *     of the asymptote.
   *
   * Return: either a coordinate (to be used as the resulting coordinate of
   * the move) or a boolean, where `true` uses newCoord as the resulting
   * coordinate, and `false` uses oldCoord as the resulting coordinate.
   */
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = ___default["default"].head(asymptote)[1];
    return ___default["default"].all(coords, coord => coord[1] !== y);
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = newCoord[1];
    const isValid = ___default["default"].all(coords, coord => coord[1] > y) || ___default["default"].all(coords, coord => coord[1] < y);
    if (isValid) {
      return [oldCoord[0], y];
    }
    // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region
    const oldY = oldCoord[1];
    const wasBelow = ___default["default"].all(coords, coord => coord[1] > oldY);
    if (wasBelow) {
      const bottomMost = ___default["default"].min(___default["default"].map(coords, coord => coord[1]));
      return [oldCoord[0], bottomMost - graph.snapStep[1]];
    }
    const topMost = ___default["default"].max(___default["default"].map(coords, coord => coord[1]));
    return [oldCoord[0], topMost + graph.snapStep[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    const p1 = coords[0];
    const p2 = coords[1];
    const c = ___default["default"].head(asymptote)[1];
    const b = Math.log((p1[1] - c) / (p2[1] - c)) / (p1[0] - p2[0]);
    const a = (p1[1] - c) / Math.exp(b * p1[0]);
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return a * Math.exp(b * x) + c;
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }
    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return "y = " + a.toFixed(3) + "e^(" + b.toFixed(3) + "x) + " + c.toFixed(3);
  }
});
const Logarithm = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/f6491e99d34af34d924bfe0231728ad912068dc3.png",
  defaultCoords: [[0.55, 0.5], [0.75, 0.75]],
  defaultAsymptote: [[0.5, 0], [0.5, 1.0]],
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = ___default["default"].head(asymptote)[0];
    return ___default["default"].all(coords, coord => coord[0] !== x) && coords[0][1] !== coords[1][1];
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = newCoord[0];
    const isValid = ___default["default"].all(coords, coord => coord[0] > x) || ___default["default"].all(coords, coord => coord[0] < x);
    if (isValid) {
      return [x, oldCoord[1]];
    }
    // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region
    const oldX = oldCoord[0];
    const wasLeft = ___default["default"].all(coords, coord => coord[0] > oldX);
    if (wasLeft) {
      const leftMost = ___default["default"].min(___default["default"].map(coords, coord => coord[0]));
      return [leftMost - graph.snapStep[0], oldCoord[1]];
    }
    const rightMost = ___default["default"].max(___default["default"].map(coords, coord => coord[0]));
    return [rightMost + graph.snapStep[0], oldCoord[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    // It's easiest to calculate the logarithm's coefficients by thinking
    // about it as the inverse of the exponential, so we flip x and y and
    // perform some algebra on the coefficients. This also unifies the
    // logic between the two 'models'.
    const flip = coord => [coord[1], coord[0]];
    const inverseCoeffs = Exponential.getCoefficients(___default["default"].map(coords, flip), ___default["default"].map(asymptote, flip));
    const c = -inverseCoeffs[2] / inverseCoeffs[0];
    const b = 1 / inverseCoeffs[0];
    const a = 1 / inverseCoeffs[1];
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x, asymptote) {
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return a * Math.log(b * x + c);
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }
    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0],
      b = coeffs[1],
      c = coeffs[2];
    return "y = ln(" + a.toFixed(3) + "x + " + b.toFixed(3) + ") + " + c.toFixed(3);
  }
});
const AbsoluteValue = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/8256a630175a0cb1d11de223d6de0266daf98721.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];
    if (denom === 0) {
      return;
    }
    let m = Math.abs(num / denom);
    if (p2[1] < p1[1]) {
      m *= -1;
    }
    const horizontalOffset = p1[0];
    const verticalOffset = p1[1];
    return [m, horizontalOffset, verticalOffset];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0],
      horizontalOffset = coeffs[1],
      verticalOffset = coeffs[2];
    return m * Math.abs(x - horizontalOffset) + verticalOffset;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0],
      horizontalOffset = coeffs[1],
      verticalOffset = coeffs[2];
    return "y = " + m.toFixed(3) + "| x - " + horizontalOffset.toFixed(3) + "| + " + verticalOffset.toFixed(3);
  }
});

/* Utility functions for dealing with graphing interfaces. */
const functionTypeMapping = {
  linear: Linear,
  quadratic: Quadratic,
  sinusoid: Sinusoid,
  tangent: Tangent,
  exponential: Exponential,
  logarithm: Logarithm,
  absolute_value: AbsoluteValue
};
const allTypes = ___default["default"].keys(functionTypeMapping);
function functionForType(
// TODO(jeremy): Actually `$Keys<typeof functionTypeMapping>` but that
// triggers TypeScript to require all of our Plot types to be fully typed which
// is a big amount of work/change.
type) {
  return functionTypeMapping[type];
}
const validate$2 = (state, rubric) => {
  if (state.type !== rubric.correct.type) {
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }

  // We haven't moved the coords
  if (state.coords == null) {
    return {
      type: "invalid",
      message: null
    };
  }

  // Get new function handler for grading
  const grader = functionForType(state.type);
  const guessCoeffs = grader.getCoefficients(state.coords, state.asymptote);
  const correctCoeffs = grader.getCoefficients(rubric.correct.coords, rubric.correct.asymptote);
  if (guessCoeffs == null || correctCoeffs == null) {
    return {
      type: "invalid",
      message: null
    };
  }
  if (grader.areEqual(guessCoeffs, correctCoeffs)) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }
  return {
    type: "points",
    earned: 0,
    total: 1,
    message: null
  };
};
const getEquationString = props => {
  const plot = props.plot;
  if (plot.type && plot.coords) {
    const handler = functionForType(plot.type);
    const result = handler.getEquationString(plot.coords, plot.asymptote);
    return result || "";
  }
  return "";
};
const pointsFromNormalized = (coordsList, range, step, snapStep) => {
  const numSteps = function (range, step) {
    return Math.floor((range[1] - range[0]) / step);
  };

  // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[][]' is not assignable to type 'readonly Coord[]'.
  return coordsList.map(coords => {
    const unsnappedPoint = coords.map((coord, i) => {
      const currRange = range[i];
      const currStep = step[i];
      const nSteps = numSteps(currRange, currStep);
      const tick = Math.round(coord * nSteps);
      return currRange[0] + currStep * tick;
    });
    // In some graphing widgets, e.g. interactive-graph, you can rely
    // on the Graphie to handle snapping. Here, we need the points
    // returned to already be snapped so that the plot that goes
    // through them is correct.
    return kmath.point.roundTo(unsnappedPoint, snapStep);
  });
};
const maybePointsFromNormalized = (coordsList, range, step, snapStep) => {
  if (coordsList) {
    return pointsFromNormalized(coordsList, range, step, snapStep);
  }
  return coordsList;
};

/* Given a plot type, return the appropriate default value for a grapher
 * widget's plot props: type, default coords, default asymptote. */
const defaultPlotProps = (type, graph) => {
  // The coords are null by default, to indicate that the user has not
  // moved them from the default position, and that this widget should
  // therefore be considered empty and ineligible for grading. The user
  // *can* move the coords from the default position and then back if
  // they really want to submit the default coords as their answer, but
  // we currently don't write questions that require this.
  //
  // We *do* write questions in which the asymptote should be left in
  // the default position. For this reason, we fill in the default
  // asymptote rather than leaving it null; if the user moves the coords
  // but not the asymptote, the widget is non-empty and eligible for
  // grading.
  //
  // TODO(mattdr): Consider an updated scoring function that marks the
  // default coords as empty *unless* they're the correct coords. This
  // would remove this default-coords-are-always-wrong constraints on
  // the questions we write, while still maintaining our kind behavior
  // when users forget to update a widget... but we'd also be revealing
  // extra information. It would be valid to always submit the default
  // widget before even reading the question; you can't lose, but you
  // might get a free win.
  const model = functionForType(type);
  const gridStep = [1, 1];
  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type '[number, number]'.
  const snapStep = Util.snapStepFromGridStep(gridStep);
  return {
    type,
    asymptote: maybePointsFromNormalized(model.defaultAsymptote, graph.range, graph.step, snapStep),
    coords: null
  };
};

/* Given a list of available types, choose which to use. */
const chooseType = ___default["default"].first;
const getGridAndSnapSteps = (options, boxSize) => {
  const gridStep = options.gridStep || Util.getGridStep(options.range, options.step, boxSize);
  const snapStep = options.snapStep || Util.snapStepFromGridStep(gridStep);
  return {
    gridStep: gridStep,
    snapStep: snapStep
  };
};
const defaultGraph = {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  backgroundImage: DEFAULT_BACKGROUND_IMAGE,
  markings: "graph",
  rulerLabel: "",
  rulerTicks: 10,
  valid: true,
  showTooltips: false
};
const defaultPlot = defaultPlotProps("linear", defaultGraph);
const DEFAULT_GRAPHER_PROPS = {
  graph: defaultGraph,
  plot: defaultPlot,
  availableTypes: [defaultPlot.type]
};
const typeToButton = type => {
  const capitalized = type.charAt(0).toUpperCase() + type.substring(1);
  const staticUrl = getDependencies().staticUrl;
  return {
    value: type,
    title: capitalized,
    content: /*#__PURE__*/React__namespace.createElement("img", {
      src: staticUrl(functionForType(type).url),
      alt: capitalized
    })
  };
};

var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_BACKGROUND_IMAGE: DEFAULT_BACKGROUND_IMAGE,
    allTypes: allTypes,
    functionForType: functionForType,
    validate: validate$2,
    getEquationString: getEquationString,
    pointsFromNormalized: pointsFromNormalized,
    maybePointsFromNormalized: maybePointsFromNormalized,
    defaultPlotProps: defaultPlotProps,
    chooseType: chooseType,
    getGridAndSnapSteps: getGridAndSnapSteps,
    DEFAULT_GRAPHER_PROPS: DEFAULT_GRAPHER_PROPS,
    typeToButton: typeToButton
});

// @ts-expect-error [FEI-5003] - TS2339 - Property 'MovablePoint' does not exist on type 'typeof Graphie'.
const MovablePoint$3 = Graphie.MovablePoint;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'MovableLine' does not exist on type 'typeof Graphie'.
const MovableLine$2 = Graphie.MovableLine;
function isFlipped(newCoord, oldCoord, line) {
  const CCW = (a, b, c) => {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
  };
  return CCW(line[0], line[1], oldCoord) > 0 !== CCW(line[0], line[1], newCoord) > 0;
}

/* Styles */
const typeSelectorStyle = {
  padding: "5px 5px"
};
/* Graphing interface. */
class FunctionGrapher extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_coords", () => {
      const props = this.props;
      const graph = props.graph;
      const defaultModelCoords = props.model && maybePointsFromNormalized(props.model.defaultCoords, graph.range, graph.step, graph.snapStep);
      return props.coords || defaultModelCoords || null;
    });
    _defineProperty(this, "_asymptote", () => {
      // Unlike coords, asymptotes are never null; see defaultPlotProps.
      return this.props.asymptote;
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "renderPlot", () => {
      const model = this.props.model;
      const xRange = this.props.graph.range[0];
      const style = {
        stroke: this.props.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
        ...(this.props.isMobile ? {
          "stroke-width": 3
        } : {})
      };
      const coeffs = model.getCoefficients(this._coords(), this._asymptote());
      if (!coeffs) {
        return;
      }
      const functionProps = model.getPropsForCoeffs(coeffs, xRange);
      return /*#__PURE__*/React__namespace.createElement(model.Movable, _extends({}, functionProps, {
        key: this.props.model.url,
        range: xRange,
        style: style
      }));
    });
    _defineProperty(this, "renderAsymptote", () => {
      const model = this.props.model;
      const graph = this.props.graph;
      const asymptote = this._asymptote();
      const dashed = {
        strokeDasharray: "- "
      };
      return asymptote && /*#__PURE__*/React__namespace.createElement(MovableLine$2, {
        onMove: (newCoord, oldCoord) => {
          // Calculate and apply displacement
          const delta = kmath.vector.subtract(newCoord, oldCoord);
          const newAsymptote = ___default["default"].map(this._asymptote(), coord => kmath.vector.add(coord, delta));
          this.props.onChange({
            asymptote: newAsymptote
          });
        },
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovableLine.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovableLine.constraints.snap(), (newCoord, oldCoord) => {
          // Calculate and apply proposed displacement
          const delta = kmath.vector.subtract(newCoord, oldCoord);
          const proposedAsymptote = ___default["default"].map(this._asymptote(), coord => kmath.vector.add(coord, delta));
          // Verify that resulting asymptote is valid for graph
          if (model.extraAsymptoteConstraint) {
            return model.extraAsymptoteConstraint(newCoord, oldCoord, this._coords(), proposedAsymptote, graph);
          }
          return true;
        }],
        normalStyle: dashed,
        highlightStyle: dashed
      }, ___default["default"].map(asymptote, (coord, i) => /*#__PURE__*/React__namespace.createElement(MovablePoint$3, {
        key: "asymptoteCoord-".concat(i),
        coord: coord,
        static: true,
        draw: null,
        extendLine: true,
        showHairlines: this.props.showHairlines,
        hideHairlines: this.props.hideHairlines,
        showTooltips: this.props.showTooltips,
        isMobile: this.props.isMobile
      })));
    });
  }
  render() {
    const pointForCoord = (coord, i) => {
      return /*#__PURE__*/React__namespace.createElement(MovablePoint$3, {
        key: i,
        coord: coord,
        static: this.props.static,
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          // Always enforce that this is a function
          const isFunction = ___default["default"].all(this._coords(), (otherCoord, j) => {
            return i === j || !otherCoord || !kmath.number.equal(coord[0], otherCoord[0]);
          });

          // Evaluate this criteria before per-point
          // constraints
          if (!isFunction) {
            return false;
          }

          // Specific functions have extra per-point
          // constraints
          if (this.props.model && this.props.model.extraCoordConstraint) {
            const extraConstraint = this.props.model.extraCoordConstraint;
            // Calculat resulting coords and verify that
            // they're valid for this graph
            const proposedCoords = ___default["default"].clone(this._coords());
            const oldCoord = ___default["default"].clone(proposedCoords[i]);
            proposedCoords[i] = coord;
            return extraConstraint(coord, oldCoord, proposedCoords, this._asymptote(), this.props.graph);
          }
          return isFunction;
        }],
        onMove: (newCoord, oldCoord) => {
          let coords;
          // Reflect over asymptote, if allowed
          const asymptote = this._asymptote();
          if (asymptote && this.props.model.allowReflectOverAsymptote && isFlipped(newCoord, oldCoord, asymptote)) {
            coords = ___default["default"].map(this._coords(), coord => {
              return kmath.point.reflectOverLine(coord, asymptote);
            });
          } else {
            coords = ___default["default"].clone(this._coords());
          }
          coords[i] = newCoord;
          this.props.onChange({
            coords: coords
          });
        },
        showHairlines: this.props.showHairlines,
        hideHairlines: this.props.hideHairlines,
        showTooltips: this.props.showTooltips,
        isMobile: this.props.isMobile
      });
    };
    const points = ___default["default"].map(this._coords(), pointForCoord);
    const box = this.props.graph.box;
    const imageDescription = this.props.graph.backgroundImage;
    let image = null;
    if (imageDescription.url) {
      const scale = box[0] / interactiveSizes$1.defaultBoxSize;
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Element' is not assignable to type 'null'.
      image =
      /*#__PURE__*/
      // @ts-expect-error [FEI-5003] - TS2741 - Property 'alt' is missing in type '{ src: any; width: any; height: any; scale: number; }' but required in type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "children" | "height" | "width" | "title" | "alt" | "trackInteraction" | "preloader" | "allowFullBleed" | "extraGraphie" | "overrideAriaHidden">'.
      React__namespace.createElement(SvgImage, {
        src: imageDescription.url,
        width: imageDescription.width,
        height: imageDescription.height,
        scale: scale
      });
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-grapher",
      style: {
        width: box[0],
        height: box[1],
        boxSizing: "initial"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: box[0],
        height: box[1]
      }
    }, image, /*#__PURE__*/React__namespace.createElement(Graphie, _extends({}, this.props.graph, {
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }), this.props.model && this.renderPlot(), this.props.model && this.renderAsymptote(), this.props.model && points)));
  }
}
_defineProperty(FunctionGrapher, "defaultProps", {
  graph: {
    range: [[-10, 10], [-10, 10]],
    step: [1, 1]
  },
  coords: null,
  asymptote: null,
  isMobile: false
});
/* Widget and editor. */
class Grapher extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "horizHairline", void 0);
    _defineProperty(this, "vertHairline", void 0);
    _defineProperty(this, "handlePlotChanges", newPlot => {
      const plot = ___default["default"].extend({}, this.props.plot, newPlot);
      this.props.onChange({
        plot: plot
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "handleActiveTypeChange", newType => {
      const graph = this.props.graph;
      const plot = ___default["default"].extend({}, this.props.plot, defaultPlotProps(newType, graph));
      this.props.onChange({
        plot: plot
      });
    });
    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      const isMobile = this.props.apiOptions.isMobile;
      if (options.markings === "graph") {
        graphie.graphInit({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale"),
          axisArrows: "<->",
          labelFormat: function (s) {
            return "\\small{" + s + "}";
          },
          gridStep: options.gridStep,
          snapStep: options.snapStep,
          tickStep: isMobile ? this._calculateMobileTickStep(options.gridStep, options.step, options.range) : ___default["default"].pluck(options.gridConfig, "tickStep"),
          labelStep: 1,
          unityLabels: ___default["default"].pluck(options.gridConfig, "unityLabel"),
          isMobile: isMobile
        });
        graphie.label([0, options.range[1][1]], options.labels[1], isMobile ? "below right" : "above");
        graphie.label([options.range[0][1], 0], options.labels[0], isMobile ? "above left" : "right");
      } else if (options.markings === "grid") {
        graphie.graphInit({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale"),
          gridStep: options.gridStep,
          axes: false,
          ticks: false,
          labels: false,
          isMobile: isMobile
        });
      } else if (options.markings === "none") {
        graphie.init({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale")
        });
      }
      if (this.props.apiOptions.isMobile) {
        const hairlineStyle = {
          normalStyle: {
            strokeWidth: 1
          }
        };
        this.horizHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.horizHairline.hide();
        this.vertHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
        this.vertHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.vertHairline.hide();
      }
    });
    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        this.horizHairline.moveTo([this.props.graph.range[0][0], point[1]], [this.props.graph.range[0][1], point[1]]);
        this.horizHairline.show();
        this.vertHairline.moveTo([point[0], this.props.graph.range[1][0]], [point[0], this.props.graph.range[1][1]]);
        this.vertHairline.show();
      }
    });
    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        this.horizHairline.hide();
        this.vertHairline.hide();
      }
    });
  }
  render() {
    const type = this.props.plot.type;
    const coords = this.props.plot.coords;
    const asymptote = this.props.plot.asymptote;
    const typeSelector = /*#__PURE__*/React__namespace.createElement("div", {
      style: typeSelectorStyle,
      className: "above-scratchpad"
    }, /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: type,
      allowEmpty: true,
      buttons: ___default["default"].map(this.props.availableTypes, typeToButton),
      onChange: this.handleActiveTypeChange
    }));
    const box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass);

    // Calculate additional graph properties so that the same values are
    // passed in to both FunctionGrapher and Graphie.
    const options = {
      ...this.props.graph,
      ...getGridAndSnapSteps(this.props.graph, box[0]),
      gridConfig: this._getGridConfig({
        ...this.props.graph,
        box: box,
        ...getGridAndSnapSteps(this.props.graph, box[0])
      })
    };

    // The `graph` prop will eventually be passed to the <Graphie>
    // component. In fact, if model is `null`, this is functionalliy
    // identical to a <Graphie>. Otherwise, some points and a plot will be
    // overlayed.
    const grapherProps = {
      graph: {
        box: box,
        range: options.range,
        step: options.step,
        snapStep: options.snapStep,
        backgroundImage: options.backgroundImage,
        options: options,
        setup: this._setupGraphie
      },
      onChange: this.handlePlotChanges,
      model: type && functionForType(type),
      coords: coords,
      asymptote: asymptote,
      static: this.props.static,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: this.props.apiOptions.isMobile,
      showTooltips: this.props.graph.showTooltips,
      showHairlines: this.showHairlines,
      hideHairlines: this.hideHairlines
    };
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(FunctionGrapher, grapherProps), this.props.availableTypes.length > 1 && typeSelector);
  }
  _getGridConfig(options) {
    return options.step.map((step, i) => {
      return Util.gridDimensionConfig(step, options.range[i], options.box[i], options.gridStep[i]);
    });
  }
  _calculateMobileTickStep(gridStep, step, ranges) {
    const tickStep = Util.constrainedTickStepsFromTickSteps(step, ranges);

    // According to the graphInit documentation in graphie.js, tickStep is
    // relative to the grid units so we need to adjust all values by the
    // grid step.
    tickStep[0] = tickStep[0] / gridStep[0];
    tickStep[1] = tickStep[1] / gridStep[1];
    return tickStep;
  }
  simpleValidate(rubric) {
    return validate$2(this.getUserInput(), rubric);
  }
  getUserInput() {
    return Grapher.getUserInputFromProps(this.props);
  }
  focus() {}
  static validate(state, rubric) {
    return validate$2(state, rubric);
  }
  static getUserInputFromProps(props) {
    return props.plot;
  }
}
_defineProperty(Grapher, "defaultProps", DEFAULT_GRAPHER_PROPS);
const propTransform$3 = editorProps => {
  const widgetProps = {
    availableTypes: editorProps.availableTypes,
    graph: editorProps.graph
  };

  // If there's only one type, the graph type is deterministic
  if (widgetProps.availableTypes.length === 1) {
    const graph = widgetProps.graph;
    const type = chooseType(widgetProps.availableTypes);
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
    widgetProps.plot = defaultPlotProps(type, graph);
  }
  return widgetProps;
};

// Note that in addition to the standard staticTransform, in static
// mode we set static=true for the graph's handles in FunctionGrapher.
const staticTransform$3 = editorProps => {
  return {
    ...propTransform$3(editorProps),
    // Don't display graph type choices if we're in static mode
    availableTypes: [editorProps.correct.type],
    // Display the same graph marked as correct in the widget editor.
    plot: editorProps.correct
  };
};
var Grapher$1 = {
  name: "grapher",
  displayName: "Grapher",
  widget: Grapher,
  transform: propTransform$3,
  staticTransform: staticTransform$3
};

class Group extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "rendererRef", void 0);
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "getUserInput", () => {
      var _this$rendererRef;
      return (_this$rendererRef = this.rendererRef) === null || _this$rendererRef === void 0 ? void 0 : _this$rendererRef.getUserInput();
    });
    _defineProperty(this, "getSerializedState", () => {
      var _this$rendererRef2;
      return (_this$rendererRef2 = this.rendererRef) === null || _this$rendererRef2 === void 0 ? void 0 : _this$rendererRef2.getSerializedState();
    });
    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      var _this$rendererRef3;
      (_this$rendererRef3 = this.rendererRef) === null || _this$rendererRef3 === void 0 ? void 0 : _this$rendererRef3.restoreSerializedState(state, callback);
      // Tell our renderer that we have no props to change
      // (all our changes were in state):
      return null;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      var _this$rendererRef4;
      return (_this$rendererRef4 = this.rendererRef) === null || _this$rendererRef4 === void 0 ? void 0 : _this$rendererRef4.score();
    });
    _defineProperty(this, "getInputPaths", () => {
      var _this$rendererRef5;
      return (_this$rendererRef5 = this.rendererRef) === null || _this$rendererRef5 === void 0 ? void 0 : _this$rendererRef5.getInputPaths();
    });
    _defineProperty(this, "setInputValue", (path, newValue, callback) => {
      var _this$rendererRef6;
      return (_this$rendererRef6 = this.rendererRef) === null || _this$rendererRef6 === void 0 ? void 0 : _this$rendererRef6.setInputValue(path, newValue, callback);
    });
    _defineProperty(this, "focus", () => {
      var _this$rendererRef7;
      return (_this$rendererRef7 = this.rendererRef) === null || _this$rendererRef7 === void 0 ? void 0 : _this$rendererRef7.focus();
    });
    _defineProperty(this, "focusInputPath", path => {
      var _this$rendererRef8;
      (_this$rendererRef8 = this.rendererRef) === null || _this$rendererRef8 === void 0 ? void 0 : _this$rendererRef8.focusPath(path);
    });
    _defineProperty(this, "blurInputPath", path => {
      var _this$rendererRef9;
      (_this$rendererRef9 = this.rendererRef) === null || _this$rendererRef9 === void 0 ? void 0 : _this$rendererRef9.blurPath(path);
    });
    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", () => {
      var _this$rendererRef10;
      (_this$rendererRef10 = this.rendererRef) === null || _this$rendererRef10 === void 0 ? void 0 : _this$rendererRef10.showRationalesForCurrentlySelectedChoices();
    });
  }
  componentDidMount() {
    // TODO(marcia): See comment in render method about our cyclical
    // numbering scheme. We force another render so that we can annotate
    // the group with the correct number.
    this.forceUpdate();
  }
  render() {
    var _this$rendererRef11;
    const apiOptions = {
      ...ApiOptions.defaults,
      ...this.props.apiOptions,
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }
        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    };

    // Allow a problem number annotation to be added.
    // This is cyclical and should probably be reconsidered. In order to
    // render the annotation ("Question 3 of 10"), we call findWidgets to
    // figure out our index in the list of all fellow group widgets. On
    // first render, though, we don't exist yet in this list, and so we
    // give ourselves number -1. To combat this, we forceUpdate in
    // componentDidMount so that we can number ourselves properly. But,
    // really we should have a more unidirectional flow. TODO(marcia): fix.
    const groupWidgets = this.props.findWidgets("group");
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'this' is not assignable to parameter of type 'Widget'.
    const number = groupWidgets.indexOf(this);
    const problemNumComponent = this.props.apiOptions.groupAnnotator(number, this.props.widgetId);

    // This is a little strange because the id of the widget that actually
    // changed is going to be lost in favor of the group widget's id. The
    // widgets prop also wasn't actually changed, and this only serves to
    // alert our renderer (our parent) of the fact that some interaction
    // has occurred.
    const onInteractWithWidget = id => {
      if (this.rendererRef) {
        this.change("widgets", this.rendererRef.props.widgets);
      }
    };
    const score = (_this$rendererRef11 = this.rendererRef) === null || _this$rendererRef11 === void 0 ? void 0 : _this$rendererRef11.score();
    const isValid = score && score.type !== "invalid";
    const isInvalid = score && score.type === "invalid";

    // TODO(mdr): Widgets inside this Renderer are not discoverable through
    //     the parent Renderer's `findWidgets` function.
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]({
        "perseus-group": true,
        "perseus-group-valid-answer": isValid,
        "perseus-group-invalid-answer": isInvalid
      })
    }, problemNumComponent, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.content,
      widgets: this.props.widgets,
      images: this.props.images,
      ref: ref => this.rendererRef = ref,
      apiOptions: apiOptions,
      findExternalWidgets: this.props.findWidgets,
      reviewMode: !!this.props.reviewModeRubric,
      onInteractWithWidget: onInteractWithWidget,
      linterContext: this.props.linterContext
    }), this.props.icon &&
    /*#__PURE__*/
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'icon' does not exist on type 'Readonly<Props> & Readonly<{ children?: ReactNode; }>'.
    React__namespace.createElement("div", {
      className: "group-icon"
    }, this.props.icon));
  }
}
_defineProperty(Group, "defaultProps", {
  content: "",
  widgets: {},
  images: {},
  linterContext: PerseusLinter.linterContextDefault
});
const traverseChildWidgets$1 = function (props, traverseRenderer) {
  return {
    ...props,
    ...traverseRenderer(props)
  };
};
var Group$1 = {
  name: "group",
  displayName: "Group (SAT only)",
  widget: Group,
  traverseChildWidgets: traverseChildWidgets$1,
  hidden: false,
  isLintable: true
};

const {
  updateQueryString
} = Util;

/* This renders the iframe and handles validation via window.postMessage */
class Iframe extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });
    _defineProperty(this, "handleMessageEvent", e => {
      // We receive data from the iframe that contains {passed: true/false}
      //  and use that to set the status
      // It could also contain an optional message
      let data = {};
      try {
        data = JSON.parse(e.originalEvent.data);
      } catch (err) {
        return;
      }
      if (___default["default"].isUndefined(data.testsPassed)) {
        return;
      }
      const status = data.testsPassed ? "correct" : "incorrect";
      this.change({
        status: status,
        message: data.message
      });
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Iframe'.
      return Iframe.validate(this.getUserInput(), rubric);
    });
  }
  componentDidMount() {
    $__default["default"](window).on("message", this.handleMessageEvent);
  }
  componentWillUnmount() {
    $__default["default"](window).off("message", this.handleMessageEvent);
  }
  render() {
    const style = {
      width: String(this.props.width),
      height: String(this.props.height)
    };
    const {
      InitialRequestUrl
    } = getDependencies();

    // Add "px" to unitless numbers
    Object.entries(style).forEach(_ref => {
      let [key, value] = _ref;
      if (!value.endsWith("%") && !value.endsWith("px")) {
        style[key] = value + "px";
      }
    });
    let url = this.props.url;

    // If the URL doesnt start with http, it must be a program ID
    if (url && url.length && url.indexOf("http") !== 0) {
      url = "https://www.khanacademy.org/computer-programming/program/" + url + "/embedded?buttons=no&embed=yes&editor=no&author=no";
      url = updateQueryString(url, "width", this.props.width);
      url = updateQueryString(url, "height", this.props.height);
      // Origin is used by output.js in deciding to send messages
      url = updateQueryString(url, "origin", InitialRequestUrl.origin);
    }

    // Turn array of [{name: "", value: ""}] into object
    if (this.props.settings) {
      const settings = {};
      ___default["default"].each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      });
      // This becomes available to programs as Program.settings()
      url = updateQueryString(url, "settings", JSON.stringify(settings));
    }
    let sandboxProperties = "allow-same-origin allow-scripts";
    // TODO(scottgrant): This line is an intentional hack to retain the
    // allow-top-navigation sandbox property. Once our LearnStorm articles
    // have this value checked and published, this line should be removed
    // and replaced with the conditional check below that is commented out.
    // We don't want to break LearnStorm badges, so this will be a two-part
    // deploy.
    sandboxProperties += " allow-top-navigation";
    // if (this.props.allowTopNavigation === true) {
    //     sandboxProperties += " allow-top-navigation";
    // }

    // We sandbox the iframe so that we allowlist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
    return /*#__PURE__*/React__namespace.createElement("iframe", {
      sandbox: sandboxProperties,
      style: style,
      src: url,
      allowFullScreen: this.props.allowFullScreen
    });
  }
}

/**
 * This is the widget's grading function
 */
_defineProperty(Iframe, "propTypes", {
  ...propTypes,
  width: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  height: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  url: PropTypes__default["default"].string,
  settings: PropTypes__default["default"].array,
  status: PropTypes__default["default"].oneOf(["incomplete", "incorrect", "correct"]),
  message: PropTypes__default["default"].string,
  allowFullScreen: PropTypes__default["default"].bool,
  allowTopNavigation: PropTypes__default["default"].bool
});
_defineProperty(Iframe, "defaultProps", {
  status: "incomplete",
  // optional message
  message: null,
  allowFullScreen: false,
  allowTopNavigation: false
});
___default["default"].extend(Iframe, {
  validate: function (state, rubric) {
    // The iframe can tell us whether it's correct or incorrect,
    //  and pass an optional message
    if (state.status === "correct") {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: state.message || null
      };
    }
    if (state.status === "incorrect") {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: state.message || null
      };
    }
    return {
      type: "invalid",
      message: "Keep going, you're not there yet!"
    };
  }
});
var Iframe$1 = {
  name: "iframe",
  displayName: "Iframe",
  widget: Iframe,
  // Let's not expose it to all content creators yet
  hidden: true
};

const defaultBoxSize$2 = 400;
const defaultRange = [0, 10];
const defaultBackgroundImage$3 = {
  url: null,
  width: 0,
  height: 0
};
const editorAlignments = ["block", "full-width"];
const DEFAULT_ALIGNMENT = "block";
class ImageWidget extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "getUserInput", () => {
      return null;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return ImageWidget.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "focus", () => {});
  }
  // no-op

  render() {
    let image;
    let alt;
    const {
      apiOptions
    } = this.props;
    const backgroundImage = this.props.backgroundImage;
    if (backgroundImage.url) {
      image = /*#__PURE__*/React__namespace.createElement(SvgImage, {
        src: backgroundImage.url,
        alt:
        /* alt text is formatted in a sr-only
               div next to the image in addition to
               the alt attribute.
               If there is no alt text at all,
               we don't put an alt attribute on
               the image, so that screen readers
               know there's something they can't
               read there :(.
               NOTE: React <=0.13 (maybe later)
               has a bug where it won't ever
               remove an attribute, so if this
               alt node is ever defined it's
               not removed. This is sort of
               dangerous, but we usually re-key
               new renderers so that they're
               rendered from scratch anyways,
               so this shouldn't be a problem
               in practice right now, although
               it will exhibit weird behaviour
               while editing. */
        this.props.alt,
        overrideAriaHidden: true,
        width: backgroundImage.width,
        height: backgroundImage.height,
        preloader: apiOptions.imagePreloader,
        extraGraphie: {
          box: this.props.box,
          range: this.props.range,
          labels: this.props.labels
        },
        trackInteraction: this.props.trackInteraction,
        zoomToFullSizeOnMobile: apiOptions.isMobile,
        constrainHeight: apiOptions.isMobile,
        allowFullBleed: apiOptions.isMobile
      });
    }
    if (this.props.alt) {
      alt = /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-sr-only"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.alt,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    }

    // For mobile we combine an image's title and caption.
    if (apiOptions.isMobile) {
      let titleAndCaption;
      if (this.props.title || this.props.caption) {
        let title = this.props.title;

        // Bold the title, and make it the first sentence of the
        // caption.
        if (title) {
          // We add a period to separate the title from the caption
          // (if it exists), unless the title already ends with a
          // punctuation symbol (whitespace ignored). Copied from
          // webapp: https://github.com/Khan/webapp/blob/6e930637edb65696d0749ea0f7558214aee32b4e/javascript/tutorial-shared-package/components/content-description.jsx#L80
          // TODO(charlie): Internationalize this check, and the
          // delimiter that is being inserted.
          if (this.props.caption && !/[.?!"']\s*$/.test(title)) {
            title += ".";
          }
          title = "**".concat(title, "** ");
        }
        const className = classNames__default["default"]({
          "perseus-image-caption": true,
          "has-title": !!title
        });

        // Caption is left-aligned within a container that's centered
        // below the image, with these width constraints:
        //
        // 1. Size caption to width of the image on-screen.
        // 2. ... but constrain its width to a range based on the
        //    device to optimize readability - e.g. [320px, 450px] for
        //    phones.
        // 3. ... unless the image is floated, in which case we don't
        //    want the caption to overflow the image size.
        //
        // TODO(david): If caption is only 1 line long, center-align
        //     the text.
        const alignment = this.props.alignment;
        const isImageFullWidth = alignment === "block" || alignment === "full-width";

        // This minWidth takes precedence over minWidth applied via
        // Aphrodite.
        const minWidth = isImageFullWidth ? null : "0 !important";
        titleAndCaption = /*#__PURE__*/React__namespace.createElement("div", {
          className: className
        }, /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$i.caption),
          style: {
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'string | null' is not assignable to type 'MinWidth<string | number> | undefined'.
            minWidth: minWidth
          }
        }, /*#__PURE__*/React__namespace.createElement(Renderer, {
          content: title + this.props.caption,
          apiOptions: apiOptions,
          linterContext: this.props.linterContext
        })));
      }
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-widget"
      }, image, alt, titleAndCaption);
    }
    let title;
    let caption;
    if (this.props.title) {
      title = /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-title"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.title,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    }
    if (this.props.caption) {
      caption = /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-caption"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.caption,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-image-widget"
    }, title, image, alt, caption);
  }
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
}
_defineProperty(ImageWidget, "defaultProps", {
  alignment: DEFAULT_ALIGNMENT,
  title: "",
  range: [defaultRange, defaultRange],
  box: [defaultBoxSize$2, defaultBoxSize$2],
  backgroundImage: defaultBackgroundImage$3,
  labels: [],
  alt: "",
  caption: "",
  linterContext: PerseusLinter.linterContextDefault
});
const styles$i = aphrodite.StyleSheet.create({
  caption: {
    display: "inline-block",
    marginTop: baseUnitPx,
    maxWidth: 640,
    [mediaQueries.lgOrSmaller]: {
      // TODO(david): This maxWidth is not being used because
      //     it's overriden by the 512px max-width we have on
      //     paragraphs.
      maxWidth: 540
    },
    [mediaQueries.smOrSmaller]: {
      maxWidth: 450
    }
  }
});
var Image$1 = {
  name: "image",
  // This widget's accessibility depends on its contents: if the image has
  // has a background but no alt text, it is not accessible
  accessible: widgetOptions => {
    const bgImage = widgetOptions.backgroundImage;
    return !(bgImage && bgImage.url && !widgetOptions.alt);
  },
  defaultAlignment: DEFAULT_ALIGNMENT,
  supportedAlignments: editorAlignments,
  displayName: "Image",
  widget: ImageWidget,
  isLintable: true
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'Label' does not exist on type 'typeof Graphie'.
const Label$1 = Graphie.Label;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Line' does not exist on type 'typeof Graphie'.
const Line$2 = Graphie.Line;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'MovablePoint' does not exist on type 'typeof Graphie'.
const MovablePoint$2 = Graphie.MovablePoint;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'MovableLine' does not exist on type 'typeof Graphie'.
const MovableLine$1 = Graphie.MovableLine;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Plot' does not exist on type 'typeof Graphie'.
const Plot = Graphie.Plot;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'PlotParametric' does not exist on type 'typeof Graphie'.
const PlotParametric = Graphie.PlotParametric;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Point' does not exist on type 'typeof Graphie'.
const Point = Graphie.Point;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Rect' does not exist on type 'typeof Graphie'.
const Rect = Graphie.Rect;
const {
  unescapeMathMode
} = Util;

// Memoize KAS parsing
const KAShashFunc = (expr, options) => {
  // @ts-expect-error [FEI-5003] - TS2322 - Type '{ ".decimal_separator": never; ".functions": never; } | { functions: any; } | {}' is not assignable to type '{ ".decimal_separator": never; ".functions": never; } | { functions: any; } | undefined'.
  options = options || {};
  // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2339 - Property 'decimal_separator' does not exist on type '{ ".decimal_separator": never; ".functions": never; } | { functions: any; }'.
  let result = expr + "||" + options.decimal_separator + "||";
  // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2339 - Property 'functions' does not exist on type '{ ".decimal_separator": never; ".functions": never; } | { functions: any; }'.
  const functions = options.functions;
  const functionsLength = functions ? functions.length : 0;
  for (let i = 0; i < functionsLength; i++) {
    result += functions[i] + "|";
  }
  return result;
};
const _parseCache = Object.create(null);
const KASparse = (expr, options) => {
  const hash = KAShashFunc(expr, options);
  let cached = _parseCache[hash];
  if (cached) {
    return cached;
  }
  cached = KAS__namespace.parse(expr, options);
  _parseCache[hash] = cached;
  return cached;
};
const _compileCache = Object.create(null);
const KAScompile = (expr, options) => {
  const hash = KAShashFunc(expr, options);
  let cached = _compileCache[hash];
  if (cached) {
    return cached;
  }
  const parsed = KAS__namespace.parse(expr, options).expr;
  cached = parsed ? parsed.compile() : function () {
    return 0;
  };
  _compileCache[hash] = cached;
  return cached;
};
class Interaction extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      variables: _getInitialVariables(this.props.elements),
      functions: _getInitialFunctions(this.props.elements)
    });
    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      graphie.graphInit(___default["default"].extend({}, options, {
        grid: ___default["default"].contains(["graph", "grid"], this.props.graph.markings),
        axes: ___default["default"].contains(["graph"], this.props.graph.markings),
        ticks: ___default["default"].contains(["graph"], this.props.graph.markings),
        labels: ___default["default"].contains(["graph"], this.props.graph.markings),
        labelFormat: function (s) {
          return "\\small{" + s + "}";
        },
        axisArrows: "<->",
        unityLabels: false
      }));
    });
    _defineProperty(this, "_updatePointLocation", (subscript, coord) => {
      const variables = ___default["default"].clone(this.state.variables);
      variables["x_" + subscript] = coord[0];
      variables["y_" + subscript] = coord[1];
      this.setState({
        variables: variables
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "_updateLineLocation", (options, startCoord) => {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
      const xDiff = this._eval("(" + options.endX + ")-(" + options.startX + ")");
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
      const yDiff = this._eval("(" + options.endY + ")-(" + options.startY + ")");
      const endCoord = kmath.vector.add(startCoord, [xDiff, yDiff]);
      const variables = ___default["default"].clone(this.state.variables);
      variables["x_" + options.startSubscript] = startCoord[0];
      variables["y_" + options.startSubscript] = startCoord[1];
      variables["x_" + options.endSubscript] = endCoord[0];
      variables["y_" + options.endSubscript] = endCoord[1];
      this.setState({
        variables: variables
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "_eval", (expression, variables) => {
      const func = KAScompile(expression, {
        functions: this.state.functions
      });
      const compiledVars = ___default["default"].extend({}, this.state.variables, variables);
      ___default["default"].each(___default["default"].keys(compiledVars), name => {
        if (___default["default"].isString(compiledVars[name])) {
          const func = KAScompile(compiledVars[name], {
            functions: this.state.functions
          });
          compiledVars[name] = function (x) {
            return func(___default["default"].extend({}, compiledVars, {
              x: x
            }));
          };
        }
      });
      // Default to 0 if the expression couldn't be parsed
      return func(compiledVars) || 0;
    });
    _defineProperty(this, "_extractVars", expr => {
      if (expr == null) {
        return [];
      }
      let vars = [];
      ___default["default"].each(expr.args(), function (arg) {
        if (arg && arg.constructor.name === "Expr") {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          vars = vars.concat(this._extractVars(arg));
        }
      }, this);
      if (expr.name() === "Var") {
        vars.push(expr.prettyPrint());
      }
      return vars;
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "getUserInput", () => {
      // TODO(eater): Perhaps we want to be able to record the state of the
      // user's interaction. Unfortunately sending all the props will
      // probably make the attempt payload too large. So for now, don't send
      // anything.
      return {};
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Interaction.validate(this.getUserInput(), rubric);
    });
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    // HACK(michaelpolyak): This widget is not wired to use the Perseus
    // `onChange` callback to save user changes. Perseus re-rendering of the
    // widget results in the loss of user changes, such as reseting the
    // positions of the movable points and lines to the initial positions
    // defined in the widget editor. The workaround here is to only reset
    // the state if there are changes to props. This workaround is only
    // possible because the widget is not designed to be graded. The correct
    // fix would be to transform `variables` to the shape of `elements` and
    // call `this.props.onChange({elements})` to preserve user changes using
    // the Perseus state saving mechanism.
    if (!___default["default"].isEqual(this.props.elements, nextProps.elements)) {
      this.setState({
        variables: _getInitialVariables(nextProps.elements),
        functions: _getInitialFunctions(nextProps.elements)
      });
    }
  }
  render() {
    const range = this.props.graph.range;
    let labels = this.props.graph.labels;
    if (this.props.graph.markings === "graph") {
      // Content creators may need to explicitly add the dollar signs so
      // the strings are picked up by our translation tools. However,
      // these math annotations are redundant because we already render
      // all graph labels in math mode. For example, a label value of
      // `$\text{Dollars}$` will be translatable, but we only want to
      // pass the string `\text{Dollars}` to the Graph widget.
      labels = this.props.graph.labels.map(label => label.startsWith("$") && label.endsWith("$") ? label.slice(1, -1) : label);
    }
    return /*#__PURE__*/React__namespace.createElement(Graphie, {
      box: this.props.graph.box,
      range: this.props.graph.range,
      options: this.props.graph,
      setup: this._setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }, this.props.graph.markings === "graph" && /*#__PURE__*/React__namespace.createElement(Label$1, {
      coord: [0, range[1][1]],
      text: labels[1],
      direction: "above"
    }), this.props.graph.markings === "graph" && /*#__PURE__*/React__namespace.createElement(Label$1, {
      coord: [range[0][1], 0],
      text: labels[0],
      direction: "right"
    }), ___default["default"].map(this.props.elements, function (element, n) {
      if (element.type === "point") {
        return /*#__PURE__*/React__namespace.createElement(Point, {
          key: element.key,
          coord: [
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.coordX),
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.coordY)],
          color: element.options.color
        });
      }
      if (element.type === "line") {
        const start = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.startX),
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.startY)];
        const end = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.endX),
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.endY)];
        return /*#__PURE__*/React__namespace.createElement(Line$2, {
          key: element.key,
          start: start,
          end: end,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            arrows: element.options.arrows
          }
        });
      }
      if (element.type === "movable-point") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        const constraints = [coord => {
          const coordX = Math.max(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintXMin), Math.min(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintXMax), coord[0]));
          const coordY = Math.max(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintYMin), Math.min(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];
        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$2.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0],
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        }

        // TODO(eater): foo_[xyz] are hacky non-props to
        // get the component to update when constraints
        // change
        return /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          key: element.key,
          coord: [
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.state.variables["x_" + element.options.varSubscript],
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.state.variables["y_" + element.options.varSubscript]],
          constraints: constraints,
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap,
          onMove: ___default["default"].partial(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._updatePointLocation, element.options.varSubscript)
        });
      }
      if (element.type === "movable-line") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        // TODO(eater): Don't duplicate this code from
        // movable-point above
        const constraints = [coord => {
          const coordX = Math.max(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintXMin), Math.min(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintXMax), coord[0]));
          const coordY = Math.max(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintYMin), Math.min(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];
        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$2.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0],
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        }
        const start = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables["x_" + element.options.startSubscript],
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables["y_" + element.options.startSubscript]];
        const end = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables["x_" + element.options.endSubscript],
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables["y_" + element.options.endSubscript]];
        return /*#__PURE__*/React__namespace.createElement(MovableLine$1, {
          key: element.key,
          constraints: constraints
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onMove: ___default["default"].bind(
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._updateLineLocation,
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this, element.options),
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap
        }, /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          coord: start,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }), /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          coord: end,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }));
      }
      if (element.type === "function") {
        const fn = x => {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          return this._eval(element.options.value, {
            x: x
          });
        };
        // find all the variables referenced by this
        // function
        const vars = ___default["default"].without(
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._extractVars(
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        KASparse(element.options.value).expr), "x");
        // and find their values, so we redraw if any
        // change
        const varValues = ___default["default"].object(vars,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ___default["default"].map(vars, v => this.state.variables[v]));
        const range = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.rangeMin,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables),
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.rangeMax,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables)];
        return /*#__PURE__*/React__namespace.createElement(Plot, {
          key: element.key,
          fn: fn,
          foo_fn: element.options.value,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?
          }
        });
      }

      if (element.type === "parametric") {
        const fn = t => {
          return [
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.x, {
            t: t
          }),
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.y, {
            t: t
          })];
        };
        // find all the variables referenced by this
        // function
        const vars = ___default["default"].without(
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._extractVars(
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        KASparse(element.options.x).expr).concat(
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._extractVars(
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        KASparse(element.options.y).expr)), "t");
        // and find their values, so we redraw if any change
        const varValues = ___default["default"].object(vars,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ___default["default"].map(vars, v => this.state.variables[v]));
        const range = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.rangeMin,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables),
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.rangeMax,
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.variables)];
        return /*#__PURE__*/React__namespace.createElement(PlotParametric, {
          key: element.key,
          fn: fn,
          foo_fnx: element.options.x,
          foo_fny: element.options.y,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?
          }
        });
      }

      if (element.type === "label") {
        const coord = [
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.coordX),
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this._eval(element.options.coordY)];
        return /*#__PURE__*/React__namespace.createElement(Label$1, {
          key: n + 1,
          coord: coord,
          text: unescapeMathMode(element.options.label),
          style: {
            color: element.options.color
          }
        });
      }
      if (element.type === "rectangle") {
        return /*#__PURE__*/React__namespace.createElement(Rect, {
          key: n + 1
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          x: this._eval(element.options.coordX)
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          y: this._eval(element.options.coordY),
          width: ___default["default"].max([
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.width), 0]),
          height: ___default["default"].max([
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this._eval(element.options.height), 0]),
          style: {
            stroke: "none",
            fill: element.options.color
          }
        });
      }
    }, this));
  }
  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
}
_defineProperty(Interaction, "defaultProps", {
  graph: {
    box: [400, 400],
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    tickStep: [1, 1],
    gridStep: [1, 1],
    markings: "graph"
  },
  elements: []
});
const _getInitialVariables = elements => {
  const variables = {};
  // TODO(eater): look at all this copypasta! refactor this!
  ___default["default"].each(___default["default"].where(elements, {
    type: "movable-point"
  }), element => {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'varSubscript' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const subscript = element.options.varSubscript;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'startX' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const startXExpr = KASparse(element.options.startX || "0").expr;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'startY' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const startYExpr = KASparse(element.options.startY || "0").expr;
    let startX = 0;
    let startY = 0;
    if (startXExpr) {
      startX = startXExpr.eval({}) || 0;
    }
    if (startYExpr) {
      startY = startYExpr.eval({}) || 0;
    }
    variables["x_" + subscript] = startX;
    variables["y_" + subscript] = startY;
  });
  ___default["default"].each(___default["default"].where(elements, {
    type: "movable-line"
  }), element => {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'startSubscript' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const startSubscript = element.options.startSubscript;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'endSubscript' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const endSubscript = element.options.endSubscript;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'startX' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const startXExpr = KASparse(element.options.startX || "0").expr;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'startY' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const startYExpr = KASparse(element.options.startY || "0").expr;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'endX' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const endXExpr = KASparse(element.options.endX || "0").expr;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1. | TS2339 - Property 'endY' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    const endYExpr = KASparse(element.options.endY || "0").expr;
    let startX = 0;
    let startY = 0;
    let endX = 0;
    let endY = 0;
    if (startXExpr) {
      startX = startXExpr.eval({}) || 0;
    }
    if (startYExpr) {
      startY = startYExpr.eval({}) || 0;
    }
    if (endXExpr) {
      endX = endXExpr.eval({}) || 0;
    }
    if (endYExpr) {
      endY = endYExpr.eval({}) || 0;
    }
    variables["x_" + startSubscript] = startX;
    variables["y_" + startSubscript] = startY;
    variables["x_" + endSubscript] = endX;
    variables["y_" + endSubscript] = endY;
  });
  ___default["default"].each(___default["default"].where(elements, {
    type: "function"
  }), element => {
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'funcName' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'. | TS2339 - Property 'value' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
    variables[element.options.funcName] = element.options.value;
  });
  return variables;
};
const _getInitialFunctions = elements => {
  return ___default["default"].map(___default["default"].where(elements, {
    type: "function"
  }),
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'funcName' does not exist on type 'PerseusInteractionFunctionElementOptions | PerseusInteractionLabelElementOptions | ... 5 more ... | PerseusInteractionRectangleElementOptions'.
  element => element.options.funcName);
};
var Interactive = {
  name: "interaction",
  displayName: "Interaction",
  widget: Interaction,
  transform: ___default["default"].identity,
  hidden: true
};

const defaultBackgroundImage$2 = {
  url: null
};

/* Style objects */
const defaultInstructionsStyle = {
  fontStyle: "italic",
  fontWeight: "bold",
  fontSize: "32px",
  width: "100%",
  height: "100%",
  textAlign: "center",
  backgroundColor: "white",
  position: "absolute",
  zIndex: 1,
  transition: "opacity .25s ease-in-out"
};
const instructionsTextStyle = {
  position: "relative",
  top: "25%"
};
function numSteps$1(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}
class Graph extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "protractor", void 0);
    _defineProperty(this, "ruler", void 0);
    _defineProperty(this, "_graphie", void 0);
    _defineProperty(this, "_hasSetupGraphieThisUpdate", void 0);
    _defineProperty(this, "_shouldSetupGraphie", void 0);
    _defineProperty(this, "reset", () => {
      this._setupGraphie(false);
    });
    _defineProperty(this, "graphie", () => {
      return this._graphie;
    });
    _defineProperty(this, "pointsFromNormalized", (coordsList, noSnap) => {
      const self = this;
      return ___default["default"].map(coordsList, function (coords) {
        return ___default["default"].map(coords, function (coord, i) {
          const range = self.props.range[i];
          if (noSnap) {
            return range[0] + (range[1] - range[0]) * coord;
          }
          const step = self.props.step[i];
          const nSteps = numSteps$1(range, step);
          const tick = Math.round(coord * nSteps);
          return range[0] + step * tick;
        });
      });
    });
    _defineProperty(this, "_setupGraphie", initialMount => {
      // Only setupGraphie once per componentDidUpdate().
      // This prevents this component from rendering graphie
      // and then immediately re-render graphie because its
      // parent component asked it to. This will happen when
      // props on the parent and props on this component both
      // require graphie to be re-rendered.
      if (this._hasSetupGraphieThisUpdate) {
        return;
      }

      // eslint-disable-next-line react/no-string-refs
      const graphieDiv = ReactDOM__default["default"].findDOMNode(this.refs.graphieDiv);
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'empty' does not exist on type 'JQueryStatic'.
      $__default["default"](graphieDiv).empty();

      // Content creators may need to explicitly add the dollar signs so the
      // strings are picked up by our translation tools. However, these math
      // annotations are redundant because we already render all graph labels
      // in math mode. For example, a label value of `$\text{Dollars}$` will
      // be translatable, but we only want to pass the string
      // `\text{Dollars}` to the Graph widget.
      const labels = this.props.labels.map(label => Util.unescapeMathMode(label));
      const range = this.props.range;
      const graphie = this._graphie = GraphUtils.createGraphie(graphieDiv);
      const gridConfig = this._getGridConfig();
      graphie.snap = this.props.snapStep;
      if (this.props.markings === "graph") {
        graphie.graphInit({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          axisArrows: "<->",
          labelFormat: function (s) {
            return "\\small{" + s + "}";
          },
          gridStep: this.props.gridStep,
          tickStep: ___default["default"].pluck(gridConfig, "tickStep"),
          labelStep: 1,
          unityLabels: ___default["default"].pluck(gridConfig, "unityLabel"),
          isMobile: this.props.isMobile
        });
        graphie.label([0, range[1][1]], labels[1], this.props.isMobile ? "below right" : "above");
        graphie.label([range[0][1], 0], labels[0], this.props.isMobile ? "above left" : "right");
      } else if (this.props.markings === "grid") {
        graphie.graphInit({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          gridStep: this.props.gridStep,
          axes: false,
          ticks: false,
          labels: false,
          isMobile: this.props.isMobile
        });
      } else if (this.props.markings === "none") {
        graphie.init({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          isMobile: this.props.isMobile
        });
      }

      // Add instructions just before mouse layer
      const visible = 0.5;
      const invisible = 0.0;
      let $instructionsWrapper;
      if (this.props.instructions) {
        $instructionsWrapper = $__default["default"]("<div/>");
        ___default["default"].each(defaultInstructionsStyle, function (value, key) {
          $instructionsWrapper.css(key, value);
        });
        $instructionsWrapper.css("opacity", visible);
        const $instructions = $__default["default"]("<span/>", {
          text: this.props.instructions
        });
        ___default["default"].each(instructionsTextStyle, function (value, key) {
          $instructions.css(key, value);
        });
        $instructionsWrapper.append($instructions);
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'append' does not exist on type 'JQueryStatic'.
        $__default["default"](graphieDiv).append($instructionsWrapper);
      } else {
        $instructionsWrapper = undefined;
      }

      // Add some handlers for instructions text (if necessary)
      const onMouseDown = $instructionsWrapper || this.props.onMouseDown ? ___default["default"].bind(function (coord) {
        if ($instructionsWrapper) {
          $instructionsWrapper.remove();
          $instructionsWrapper = null;
        }
        // eslint-disable-next-line @babel/no-invalid-this
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        // eslint-disable-next-line @babel/no-invalid-this
        this.props.onMouseDown(coord);
      }, this) : null;
      const onMouseOver = $instructionsWrapper ? function () {
        $instructionsWrapper && $instructionsWrapper.css("opacity", invisible);
      } : null;
      const onMouseOut = $instructionsWrapper ? function () {
        $instructionsWrapper && $instructionsWrapper.css("opacity", visible);
      } : null;
      /* eslint-enable indent */

      graphie.addMouseLayer({
        onClick: this.props.onClick,
        onMouseDown: onMouseDown,
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        onMouseUp: this.props.onMouseUp,
        onMouseMove: this.props.onMouseMove,
        allowScratchpad: true,
        setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
      });
      this._updateProtractor();
      this._updateRuler();

      // We set this flag before jumping into our callback
      // to avoid recursing if our callback calls reset() itself
      this._hasSetupGraphieThisUpdate = true;
      if (!initialMount && this.props.onGraphieUpdated) {
        // Calling a parent callback in componentDidMount is bad and
        // results in hard-to-reason-about lifecycle problems (esp. with
        // refs), so we do it only on update and rely on the parent to
        // query for the graphie object on initial mount
        this.props.onGraphieUpdated(graphie);
      }
    });
    _defineProperty(this, "_getGridConfig", () => {
      const self = this;
      return ___default["default"].map(self.props.step, function (step, i) {
        return Util.gridDimensionConfig(step, self.props.range[i], self.props.box[i], self.props.gridStep[i]);
      });
    });
    _defineProperty(this, "_updateProtractor", () => {
      if (this.protractor) {
        this.protractor.remove();
      }
      if (this.props.showProtractor) {
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        const coord = this.pointsFromNormalized([[0.5, 0.05]])[0];
        this.protractor = this._graphie.protractor(coord);
      }
    });
    _defineProperty(this, "_updateRuler", () => {
      if (this.ruler) {
        this.ruler.remove();
      }
      if (this.props.showRuler) {
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        const coord = this.pointsFromNormalized([[0.5, 0.25]])[0];
        const extent = this._graphie.range[0][1] - this._graphie.range[0][0];
        this.ruler = this._graphie.ruler({
          center: coord,
          label: this.props.rulerLabel,
          pixelsPerUnit: this._graphie.scale[0],
          ticksPerUnit: this.props.rulerTicks,
          units: Math.round(0.8 * extent)
        });
      }
    });
    _defineProperty(this, "toJSON", () => {
      return ___default["default"].pick(this.props, "range", "step", "markings", "labels", "backgroundImage", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep");
    });
  }
  componentDidMount() {
    this._setupGraphie(true);
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    const potentialChanges = ["labels", "range", "step", "markings", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep"];
    const self = this;
    ___default["default"].each(potentialChanges, function (prop) {
      if (!___default["default"].isEqual(self.props[prop], nextProps[prop])) {
        self._shouldSetupGraphie = true;
      }
    });
  }
  componentDidUpdate() {
    // Only setupGraphie once per componentDidUpdate().
    // See explanation in setupGraphie().
    this._hasSetupGraphieThisUpdate = false;
    if (this._shouldSetupGraphie) {
      this._setupGraphie(false);
      this._shouldSetupGraphie = false;
    }
  }

  /* Reset the graphie canvas to its initial state
   *
   * Use when re-rendering the parent component and you need a blank
   * graphie.
   */

  render() {
    let image;
    const imageData = this.props.backgroundImage;
    if (imageData.url) {
      const scale = this.props.box[0] / interactiveSizes$1.defaultBoxSize;
      image =
      /*#__PURE__*/
      // @ts-expect-error [FEI-5003] - TS2741 - Property 'alt' is missing in type '{ src: any; width: any; height: any; scale: number; responsive: false; }' but required in type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "children" | "height" | "width" | "title" | "alt" | "trackInteraction" | "preloader" | "allowFullBleed" | "extraGraphie" | "overrideAriaHidden">'.
      React__namespace.createElement(SvgImage, {
        src: imageData.url,
        width: imageData.width,
        height: imageData.height,
        scale: scale,
        responsive: false
      });
    } else {
      image = null;
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      }
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'onMouseOut' does not exist on type 'Graph'.
      ,
      onMouseOut: this.onMouseOut
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'onMouseOver' does not exist on type 'Graph'.
      ,
      onMouseOver: this.onMouseOver
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'onClick' does not exist on type 'Graph'.
      ,
      onClick: this.onClick
    }, image, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  }
}
_defineProperty(Graph, "defaultProps", {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  gridStep: [1, 1],
  snapStep: [0.5, 0.5],
  markings: "graph",
  backgroundImage: defaultBackgroundImage$2,
  showProtractor: false,
  showRuler: false,
  rulerLabel: "",
  rulerTicks: 10,
  isMobile: false
});

const {
  DeprecationMixin
} = Util;
const TRASH_ICON_URI = "https://ka-perseus-graphie.s3.amazonaws.com/b1452c0d79fd0f7ff4c3af9488474a0a0decb361.png";
const defaultBackgroundImage$1 = {
  url: null
};
const eq = Util.eq;
const deepEq$2 = Util.deepEq;
const UNLIMITED = "unlimited";

// Sample background image:
// https://ka-perseus-graphie.s3.amazonaws.com/29c1b0fcd17fe63df0f148fe357044d5d5c7d0bb.png

function ccw(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
}
function collinear(a, b, c) {
  return eq(ccw(a, b, c), 0);
}
function sign(val) {
  if (eq(val, 0)) {
    return 0;
  }
  return val > 0 ? 1 : -1;
}

// default to defaultValue if actual is null or undefined
function defaultVal(actual, defaultValue) {
  return actual == null ? defaultValue : actual;
}

// Given rect bounding points A and B, whether point C is inside the rect
function pointInRect(a, b, c) {
  return c[0] <= Math.max(a[0], b[0]) && c[0] >= Math.min(a[0], b[0]) && c[1] <= Math.max(a[1], b[1]) && c[1] >= Math.min(a[1], b[1]);
}

// Whether line segment AB intersects line segment CD
// http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
function intersects(ab, cd) {
  const triplets = [[ab[0], ab[1], cd[0]], [ab[0], ab[1], cd[1]], [cd[0], cd[1], ab[0]], [cd[0], cd[1], ab[1]]];
  const orientations = ___default["default"].map(triplets, function (triplet) {
    // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
    return sign(ccw(...triplet));
  });
  if (orientations[0] !== orientations[1] && orientations[2] !== orientations[3]) {
    return true;
  }
  for (let i = 0; i < 4; i++) {
    // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
    if (orientations[i] === 0 && pointInRect(...triplets[i])) {
      return true;
    }
  }
  return false;
}
function vector(a, b) {
  return ___default["default"].map(___default["default"].zip(a, b), function (pair) {
    return pair[0] - pair[1];
  });
}
function magnitude(v) {
  return Math.sqrt(___default["default"].reduce(v, function (memo, el) {
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Coord' is not assignable to parameter of type 'number'.
    return memo + Math.pow(el, 2);
  }, 0));
}
function dotProduct(a, b) {
  return ___default["default"].reduce(___default["default"].zip(a, b), function (memo, pair) {
    return memo + pair[0] * pair[1];
  }, 0);
}
function sideLengths(coords) {
  const segments = ___default["default"].zip(coords, rotate(coords));
  return segments.map(function (segment) {
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'. | TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
    return magnitude(vector(...segment));
  });
}

// Based on http://math.stackexchange.com/a/151149
function angleMeasures(coords) {
  const triplets = ___default["default"].zip(rotate(coords, -1), coords, rotate(coords, 1));
  const offsets = ___default["default"].map(triplets, function (triplet) {
    const p = vector(triplet[1], triplet[0]);
    const q = vector(triplet[2], triplet[1]);
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'Coord'. | TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'. | TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'.
    const raw = Math.acos(dotProduct(p, q) / (magnitude(p) * magnitude(q)));
    // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
    return sign(ccw(...triplet)) > 0 ? raw : -raw;
  });
  const sum = ___default["default"].reduce(offsets, function (memo, arg) {
    return memo + arg;
  }, 0);
  return ___default["default"].map(offsets, function (offset) {
    return sum > 0 ? Math.PI - offset : Math.PI + offset;
  });
}

// Whether two polygons are similar (or if specified, congruent)
function similar(coords1, coords2, tolerance) {
  if (coords1.length !== coords2.length) {
    return false;
  }
  const n = coords1.length;
  const angles1 = angleMeasures(coords1);
  const angles2 = angleMeasures(coords2);
  const sides1 = sideLengths(coords1);
  const sides2 = sideLengths(coords2);
  for (let i = 0; i < 2 * n; i++) {
    let angles = angles2.slice();
    let sides = sides2.slice();

    // Reverse angles and sides to allow matching reflected polygons
    if (i >= n) {
      angles.reverse();
      sides.reverse();
      // Since sides are calculated from two coordinates,
      // simply reversing results in an off by one error
      // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.
      sides = rotate(sides, 1);
    }

    // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.
    angles = rotate(angles, i);
    // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.
    sides = rotate(sides, i);
    if (deepEq$2(angles1, angles)) {
      const sidePairs = ___default["default"].zip(sides1, sides);
      const factors = ___default["default"].map(sidePairs, function (pair) {
        return pair[0] / pair[1];
      });
      const same = ___default["default"].all(factors, function (factor) {
        return eq(factors[0], factor);
      });
      const congruentEnough = ___default["default"].all(sidePairs, function (pair) {
        return kmath.number.equal(pair[0], pair[1], tolerance);
      });
      if (same && congruentEnough) {
        return true;
      }
    }
  }
  return false;
}

// Less than or approximately equal
function leq(a, b) {
  return a < b || eq(a, b);
}

// Given triangle with sides ABC return angle opposite side C in degrees
function lawOfCosines(a, b, c) {
  return Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI;
}
function canonicalSineCoefficients(_ref) {
  let [amplitude, angularFrequency, phase, verticalOffset] = _ref;
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.

  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }
  const period = 2 * Math.PI;
  // Guarantee b > 0
  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  }

  // Guarantee c is smallest possible positive value
  while (phase > 0) {
    phase -= period;
  }
  while (phase < 0) {
    phase += period;
  }
  return [amplitude, angularFrequency, phase, verticalOffset];
}

// e.g. rotate([1, 2, 3]) -> [2, 3, 1]
function rotate(array, n) {
  n = typeof n === "undefined" ? 1 : n % array.length;
  return array.slice(n).concat(array.slice(0, n));
}
function capitalize(str) {
  return str.replace(/(?:^|-)(.)/g, function (match, letter) {
    return letter.toUpperCase();
  });
}
function getLineEquation(first, second) {
  if (eq(first[0], second[0])) {
    return "x = " + first[0].toFixed(3);
  }
  const m = (second[1] - first[1]) / (second[0] - first[0]);
  const b = first[1] - m * first[0];
  return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
}

// Stolen from the wikipedia article
// http://en.wikipedia.org/wiki/Line-line_intersection
function getLineIntersection(
// TODO(LP-10725): update these to be 2-tuples
firstPoints, secondPoints) {
  const x1 = firstPoints[0][0];
  const y1 = firstPoints[0][1];
  const x2 = firstPoints[1][0];
  const y2 = firstPoints[1][1];
  const x3 = secondPoints[0][0];
  const y3 = secondPoints[0][1];
  const x4 = secondPoints[1][0];
  const y4 = secondPoints[1][1];
  const determinant = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (Math.abs(determinant) < 1e-9) {
    return "Lines are parallel";
  }
  const x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / determinant;
  const y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / determinant;
  return "Intersection: (" + x.toFixed(3) + ", " + y.toFixed(3) + ")";
}
function numSteps(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}
const deprecatedProps = {
  showGraph: function (props) {
    return {
      markings: props.showGraph ? "graph" : "none"
    };
  }
};
const _getShouldShowInstructions = props => {
  return _isClickToAddPoints(props) && (
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'. | TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
  props.graph.coords == null || props.graph.coords.length === 0);
};
const _isClickToAddPoints = props => {
  return props.graph.type === "point" && props.graph.numPoints === UNLIMITED || props.graph.type === "polygon" && props.graph.numSides === UNLIMITED;
};
const makeInvalidTypeError = (functionName, graphType) => {
  return new PerseusError("".concat(functionName, " called but current graph type is not a '").concat(graphType, "'"), Errors.NotAllowed, {
    metadata: {
      graphType
    }
  });
};
class InteractiveGraph extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "angle", void 0);
    _defineProperty(this, "circle", void 0);
    _defineProperty(this, "graphie", void 0);
    _defineProperty(this, "horizHairline", void 0);
    _defineProperty(this, "line", void 0);
    _defineProperty(this, "lines", void 0);
    _defineProperty(this, "parabola", void 0);
    _defineProperty(this, "pointA", void 0);
    _defineProperty(this, "pointB", void 0);
    _defineProperty(this, "pointC", void 0);
    _defineProperty(this, "points", void 0);
    _defineProperty(this, "polygon", void 0);
    _defineProperty(this, "shouldResetGraphie", void 0);
    _defineProperty(this, "sinusoid", void 0);
    _defineProperty(this, "trashCan", void 0);
    _defineProperty(this, "vertHairline", void 0);
    _defineProperty(this, "state", {
      shouldShowInstructions: _getShouldShowInstructions(this.props)
    });
    _defineProperty(this, "_getShouldShowInstructions", props => {
      props = props || this.props;
      return this.isClickToAddPoints(props) && (
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'. | TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
      props.graph.coords == null || props.graph.coords.length === 0);
    });
    _defineProperty(this, "deprecatedProps", deprecatedProps);
    _defineProperty(this, "setGraphie", newGraphie => {
      this.graphie = newGraphie;
      this.setupGraphie();
    });
    _defineProperty(this, "handleAddPointsMouseDown", coord => {
      // This function should only be called when this.isClickToAddPoints()
      // is true
      if (!this.isClickToAddPoints()) {
        throw new PerseusError("handleAddPointsClick should not be registered" + "when isClickToAddPoints() is false", Errors.NotAllowed);
      }
      if (!this.isCoordInTrash(coord)) {
        let point;
        if (this.props.graph.type === "point") {
          point = this.createPointForPointsType(coord, this.points.length);
          if (!point.constrain()) {
            point.remove();
            return;
          }
          this.points.push(point);

          // interactive2 allows us to grab the point
          const idx = this.points.length - 1;
          this.points[idx].grab(coord);
          this.updateCoordsFromPoints();
        } else if (this.props.graph.type === "polygon") {
          var _this$polygon;
          if ((_this$polygon = this.polygon) !== null && _this$polygon !== void 0 && _this$polygon.closed()) {
            return;
          }
          point = this.createPointForPolygonType(coord, this.points.length);
          this.points.push(point);
          const idx = this.points.length - 1;
          this.points[idx].grab(coord);

          // We don't call updateCoordsFromPoints for
          // polygons, since the polygon won't be
          // closed yet.
          this.updatePolygon();
        }
        this.setState({
          shouldShowInstructions: false
        });
      }
    });
    _defineProperty(this, "resetGraphie", () => {
      this.shouldResetGraphie = false;
      this.parabola = null;
      this.sinusoid = null;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'reset' does not exist on type 'ReactInstance'.
      this.refs.graph.reset();
    });
    _defineProperty(this, "setupGraphie", () => {
      this.setTrashCanVisibility(0);
      if (this.isClickToAddPoints()) {
        this.setTrashCanVisibility(0.5);
      }
      if (this.props.apiOptions.isMobile) {
        var _this$horizHairline, _this$vertHairline;
        this.horizHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        (_this$horizHairline = this.horizHairline) === null || _this$horizHairline === void 0 ? void 0 : _this$horizHairline.hide();
        this.vertHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.vertHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        (_this$vertHairline = this.vertHairline) === null || _this$vertHairline === void 0 ? void 0 : _this$vertHairline.hide();
      }
      const type = this.props.graph.type;
      this["add" + capitalize(type) + "Controls"]();
    });
    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        var _this$horizHairline2, _this$horizHairline3, _this$vertHairline2, _this$vertHairline3;
        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        (_this$horizHairline2 = this.horizHairline) === null || _this$horizHairline2 === void 0 ? void 0 : _this$horizHairline2.moveTo([this.props.range[0][0], point[1]], [this.props.range[0][1], point[1]]);
        (_this$horizHairline3 = this.horizHairline) === null || _this$horizHairline3 === void 0 ? void 0 : _this$horizHairline3.show();
        (_this$vertHairline2 = this.vertHairline) === null || _this$vertHairline2 === void 0 ? void 0 : _this$vertHairline2.moveTo([point[0], this.props.range[1][0]], [point[0], this.props.range[1][1]]);
        (_this$vertHairline3 = this.vertHairline) === null || _this$vertHairline3 === void 0 ? void 0 : _this$vertHairline3.show();
      }
    });
    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        var _this$horizHairline4, _this$vertHairline4;
        (_this$horizHairline4 = this.horizHairline) === null || _this$horizHairline4 === void 0 ? void 0 : _this$horizHairline4.hide();
        (_this$vertHairline4 = this.vertHairline) === null || _this$vertHairline4 === void 0 ? void 0 : _this$vertHairline4.hide();
      }
    });
    _defineProperty(this, "setTrashCanVisibility", opacity => {
      const graphie = this.graphie;
      if (kmath.number.equal(opacity, 0)) {
        if (this.trashCan) {
          this.trashCan.remove();
          this.trashCan = null;
        }
      } else if (!this.props.apiOptions.isMobile) {
        var _this$trashCan;
        // Only if trash tooltips are not being used, we initialize the old
        // trash can area.
        if (!this.trashCan) {
          var _graphie$raphael;
          this.trashCan = graphie === null || graphie === void 0 ? void 0 : (_graphie$raphael = graphie.raphael) === null || _graphie$raphael === void 0 ? void 0 : _graphie$raphael.image(TRASH_ICON_URI, graphie.xpixels - 40, graphie.ypixels - 40, 40, 40);
        }
        (_this$trashCan = this.trashCan) === null || _this$trashCan === void 0 ? void 0 : _this$trashCan.attr({
          opacity: opacity
        });
      }
    });
    _defineProperty(this, "isClickToAddPoints", props => {
      props = props || this.props;
      return _isClickToAddPoints(props);
    });
    _defineProperty(this, "_lineStroke", () => {
      // This should probably use: this.props.apiOptions.isMobile
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'isMobile' does not exist on type 'Readonly<Props> & Readonly<{ children?: ReactNode; }>'.
      return this.props.isMobile ? {
        "stroke-width": 3
      } : {};
    });
    _defineProperty(this, "addLine", type => {
      const self = this;
      const graphie = self.graphie;
      const coords = InteractiveGraph.getLineCoords(self.props.graph, self.props);
      const points = self.points = ___default["default"].map(coords, coord => {
        return Interactive2.addMaybeMobileMovablePoint(this, {
          coord: coord,
          constraints: [
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
          Interactive2.MovablePoint.constraints.bound(),
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
          Interactive2.MovablePoint.constraints.snap()],
          onMove: () => {
            const graph = ___default["default"].extend({}, self.props.graph, {
              coords: ___default["default"].invoke(points, "coord")
            });
            self.onChange({
              graph: graph
            });
          }
        });
      });
      const lineConfig = {
        points: points,
        static: true,
        normalStyle: {
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
          ...this._lineStroke()
        }
      };
      if (type === "line") {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'extendLine' does not exist on type '{ readonly points: any[]; readonly static: true; readonly normalStyle: { readonly "stroke-width"?: number | undefined; readonly stroke: "#71B307" | "#63D9EA"; }; }'.
        lineConfig.extendLine = true;
      } else if (type === "ray") {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'extendRay' does not exist on type '{ readonly points: any[]; readonly static: true; readonly normalStyle: { readonly "stroke-width"?: number | undefined; readonly stroke: "#71B307" | "#63D9EA"; }; }'.
        lineConfig.extendRay = true;
      }
      self.line = Interactive2.addMovableLine(graphie, lineConfig);

      // A and B can't be in the same place
      points[0].listen("constraints", "isLine", coord => {
        return !kmath.point.equal(coord, points[1].coord());
      });
      points[1].listen("constraints", "isLine", coord => {
        return !kmath.point.equal(coord, points[0].coord());
      });
    });
    _defineProperty(this, "removeLine", () => {
      var _this$line;
      ___default["default"].invoke(this.points, "remove");
      (_this$line = this.line) === null || _this$line === void 0 ? void 0 : _this$line.remove();
    });
    _defineProperty(this, "addLinearControls", () => {
      this.addLine("line");
    });
    _defineProperty(this, "removeLinearControls", () => {
      this.removeLine();
    });
    _defineProperty(this, "addQuadraticControls", () => {
      if (this.props.graph.type !== "quadratic") {
        throw makeInvalidTypeError("addQuadraticControls", "quadratic");
      }
      let coords = this.props.graph.coords;
      if (!coords) {
        coords = InteractiveGraph.defaultQuadraticCoords(this.props);
      }
      const onMoveHandler = () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2531 - Object is possibly 'null'. | TS2531 - Object is possibly 'null'.
          coords: [pointA.coord(), pointB.coord(), pointC.coord()]
        });
        this.onChange({
          graph
        });
        this.updateQuadratic();
      };

      // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.
      let pointA = null;
      pointA = this.pointA = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[0],
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointA ||
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointB.coord()[0] &&
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointC.coord()[0];
        }],
        onMove: onMoveHandler
      });

      // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.
      let pointB = null;
      pointB = this.pointB = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[1],
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointB ||
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointA.coord()[0] &&
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointC.coord()[0];
        }],
        onMove: onMoveHandler
      });

      // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.
      let pointC = null;
      pointC = this.pointC = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[2],
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointC ||
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointA.coord()[0] &&
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coord[0] !== pointB.coord()[0];
        }],
        onMove: onMoveHandler
      });
      this.updateQuadratic();
    });
    _defineProperty(this, "updateQuadratic", () => {
      const coeffs = InteractiveGraph.getCurrentQuadraticCoefficients(this.props);
      if (!coeffs) {
        return;
      }

      // Extract coefficients the parabola
      const a = coeffs[0];
      const b = coeffs[1];
      const c = coeffs[2];

      // Plot and style
      if (this.parabola) {
        var _this$graphie, _this$parabola;
        const path = (_this$graphie = this.graphie) === null || _this$graphie === void 0 ? void 0 : _this$graphie.svgParabolaPath(a, b, c);
        (_this$parabola = this.parabola) === null || _this$parabola === void 0 ? void 0 : _this$parabola.attr({
          path: path
        });
      } else {
        var _this$graphie2, _this$parabola2, _this$parabola3;
        this.parabola = (_this$graphie2 = this.graphie) === null || _this$graphie2 === void 0 ? void 0 : _this$graphie2.parabola(a, b, c);
        (_this$parabola2 = this.parabola) === null || _this$parabola2 === void 0 ? void 0 : _this$parabola2.attr({
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
          ...this._lineStroke()
        });
        (_this$parabola3 = this.parabola) === null || _this$parabola3 === void 0 ? void 0 : _this$parabola3.toBack();
      }
    });
    _defineProperty(this, "removeQuadraticControls", () => {
      var _this$pointA, _this$pointB, _this$pointC;
      (_this$pointA = this.pointA) === null || _this$pointA === void 0 ? void 0 : _this$pointA.remove();
      (_this$pointB = this.pointB) === null || _this$pointB === void 0 ? void 0 : _this$pointB.remove();
      (_this$pointC = this.pointC) === null || _this$pointC === void 0 ? void 0 : _this$pointC.remove();
      if (this.parabola) {
        this.parabola.remove();
        this.parabola = null;
      }
    });
    _defineProperty(this, "addSinusoidControls", () => {
      if (this.props.graph.type !== "sinusoid") {
        throw makeInvalidTypeError("addSinusoidControls", "sinusoid");
      }
      let coords = this.props.graph.coords;
      if (!coords) {
        coords = InteractiveGraph.defaultSinusoidCoords(this.props);
      }
      const onMoveHandler = () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          coords: [pointA.coord(), pointB.coord()]
        });
        this.onChange({
          graph: graph
        });
        this.updateSinusoid();
      };

      // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.
      let pointA = null;
      pointA = this.pointA = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[0],
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointA || coord[0] !== pointB.coord()[0];
        }],
        onMove: onMoveHandler
      });
      const pointB = this.pointB = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[1],
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), coord => {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'coord' does not exist on type 'never'.
          return !pointA || coord[0] !== pointA.coord()[0];
        }],
        onMove: onMoveHandler
      });
      this.updateSinusoid();
    });
    _defineProperty(this, "updateSinusoid", () => {
      const coeffs = InteractiveGraph.getCurrentSinusoidCoefficients(this.props);
      if (!coeffs) {
        return;
      }
      const a = coeffs[0];
      const b = coeffs[1];
      const c = coeffs[2];
      const d = coeffs[3];

      // Plot and style
      if (this.sinusoid) {
        var _this$graphie3, _this$sinusoid;
        const path = (_this$graphie3 = this.graphie) === null || _this$graphie3 === void 0 ? void 0 : _this$graphie3.svgSinusoidPath(a, b, c, d);
        (_this$sinusoid = this.sinusoid) === null || _this$sinusoid === void 0 ? void 0 : _this$sinusoid.attr({
          path: path
        });
      } else {
        var _this$graphie4, _this$sinusoid2, _this$sinusoid3;
        this.sinusoid = (_this$graphie4 = this.graphie) === null || _this$graphie4 === void 0 ? void 0 : _this$graphie4.sinusoid(a, b, c, d);
        (_this$sinusoid2 = this.sinusoid) === null || _this$sinusoid2 === void 0 ? void 0 : _this$sinusoid2.attr({
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
          ...this._lineStroke()
        });
        (_this$sinusoid3 = this.sinusoid) === null || _this$sinusoid3 === void 0 ? void 0 : _this$sinusoid3.toBack();
      }
    });
    _defineProperty(this, "removeSinusoidControls", () => {
      var _this$pointA2, _this$pointB2;
      (_this$pointA2 = this.pointA) === null || _this$pointA2 === void 0 ? void 0 : _this$pointA2.remove();
      (_this$pointB2 = this.pointB) === null || _this$pointB2 === void 0 ? void 0 : _this$pointB2.remove();
      if (this.sinusoid) {
        this.sinusoid.remove();
        this.sinusoid = null;
      }
    });
    _defineProperty(this, "addCircleControls", () => {
      const graphie = this.graphie;
      const minSnap = ___default["default"].min(graphie.snap);
      const circle = this.circle = graphie === null || graphie === void 0 ? void 0 : graphie.addCircleGraph({
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'center' does not exist on type 'PerseusGraphType'.
        center: this.props.graph.center || [0, 0],
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'radius' does not exist on type 'PerseusGraphType'.
        radius: this.props.graph.radius || ___default["default"].min(this.props.step),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        minRadius: minSnap,
        snapRadius: minSnap
      });
      $__default["default"](circle).on("move", () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          center: circle.center,
          radius: circle.radius
        });
        this.onChange({
          graph: graph
        });
      });
    });
    _defineProperty(this, "removeCircleControls", () => {
      var _this$circle;
      (_this$circle = this.circle) === null || _this$circle === void 0 ? void 0 : _this$circle.remove();
    });
    _defineProperty(this, "addLinearSystemControls", () => {
      const graphie = this.graphie;
      const coords = InteractiveGraph.getLinearSystemCoords(this.props.graph, this.props);
      const segmentColors = [KhanColors.INTERACTIVE, KhanColors.GREEN];
      const points = this.points = ___default["default"].map(coords, (segmentCoords, segmentIndex) => {
        // NOTE(jeresig): This code attempts to access the variable
        // while it's still being defined, it should be refactored!
        // The callbacks appear to be executed synchronously, which
        // causes this issue.
        const segmentPoints = [];
        for (let i = 0; i < segmentCoords.length; i += 1) {
          const coord = segmentCoords[i];
          segmentPoints.push(Interactive2.addMaybeMobileMovablePoint(this, {
            coord: coord,
            constraints: [
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
            Interactive2.MovablePoint.constraints.bound(),
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
            Interactive2.MovablePoint.constraints.snap(), coord => {
              const otherSegment = segmentPoints[1 - i];
              if (!otherSegment) {
                // segment hasn't been defined yet
                // because we're still creating them
                return;
              }
              return !kmath.point.equal(coord, otherSegment.coord());
            }],
            onMove: () => {
              const graph = ___default["default"].extend({}, this.props.graph, {
                coords: ___default["default"].map(this.points, segment => ___default["default"].invoke(segment, "coord"))
              });
              this.onChange({
                graph: graph
              });
            },
            normalStyle: {
              fill: segmentColors[segmentIndex]
            },
            highlightStyle: {
              fill: segmentColors[segmentIndex]
            }
          }));
        }
        return segmentPoints;
      });
      this.lines = ___default["default"].map(points, (segmentPoints, segmentIndex) => {
        return Interactive2.addMovableLine(graphie, {
          points: segmentPoints,
          static: true,
          extendLine: true,
          normalStyle: {
            stroke: segmentColors[segmentIndex]
          }
        });
      });
    });
    _defineProperty(this, "removeLinearSystemControls", () => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly (readonly Coord[])[] | null | undefined' is not assignable to parameter of type 'Collection<any>'.
      ___default["default"].invoke(this.lines, "remove");
      ___default["default"].map(this.points, segment => ___default["default"].invoke(segment, "remove"));
    });
    _defineProperty(this, "isCoordInTrash", coord => {
      if (this.props.apiOptions.isMobile) {
        return false;
      }
      const graphie = this.graphie;
      const screenPoint = graphie === null || graphie === void 0 ? void 0 : graphie.scalePoint(coord);
      return screenPoint[0] >= graphie.xpixels - 40 && screenPoint[1] >= graphie.ypixels - 40;
    });
    _defineProperty(this, "createPointForPointsType", (coord, i) => {
      const self = this;
      const remove = () => {
        self.points = ___default["default"].filter(self.points, function (pt) {
          return pt !== point;
        });
        // update the correct answer box
        self.updateCoordsFromPoints();

        // remove this movablePoint from graphie.
        // we wait to do this until we're not inside of
        // said point's onMoveEnd method so its state is
        // consistent throughout this method call
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
        setTimeout(point.remove.bind(point), 0); // eslint-disable-line no-restricted-syntax
      };

      // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.
      let point = null;
      point = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coord,
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap(), function (coord) {
          // TODO(jack): There ought to be a
          // MovablePoint.constraints.avoid
          // default that lets you do things like this
          return ___default["default"].all(self.points, function (pt) {
            return point === pt || !kmath.point.equal(coord, pt.coord());
          });
        }],
        onMoveStart: function () {
          if (self.isClickToAddPoints()) {
            self.setTrashCanVisibility(1);
          }
        },
        onMove: self.updateCoordsFromPoints,
        onMoveEnd: function (coord) {
          if (self.isClickToAddPoints()) {
            if (self.isCoordInTrash(coord)) {
              remove();
            }
            // In case we mouseup'd off the graphie and that
            // stopped the move (in which case, we might not
            // be in isCoordInTrash()
            self.setTrashCanVisibility(0.5);
          }
        },
        ...(this.props.apiOptions.isMobile && self.isClickToAddPoints() ? {
          onRemove: remove
        } : {})
      });
      return point;
    });
    _defineProperty(this, "removePoint", point => {
      let index = null;
      this.points = ___default["default"].filter(this.points, function (pt, i) {
        if (pt === point) {
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
          index = i;
          return false;
        }
        return true;
      });
      return index;
    });
    _defineProperty(this, "createPointForPolygonType", (coord, i) => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("createPointForPolygonType", "polygon");
      }

      // TODO(alex): check against "grid" instead, use constants
      const snapToGrid = !___default["default"].contains(["angles", "sides"], this.props.graph.snapTo);

      // Index relative to current point -> absolute index
      // NOTE: This does not work when isClickToAddPoints() == true,
      // as `i` can be changed by dragging a point to the trash
      // Currently this function is only called when !isClickToAddPoints()
      const rel = j => {
        return (i + j + this.points.length) % this.points.length;
      };
      const remove = () => {
        var _this$polygon2;
        // remove this point from points
        const index = this.removePoint(point);
        if ((_this$polygon2 = this.polygon) !== null && _this$polygon2 !== void 0 && _this$polygon2.closed()) {
          var _this$polygon3;
          // We should be checking if this.points is defined before rotating them.
          // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly any[]' is 'readonly' and cannot be assigned to the mutable type 'any[]'. | TS2345 - Argument of type 'number | null | undefined' is not assignable to parameter of type 'number | undefined'.
          this.points = rotate(this.points, index);
          (_this$polygon3 = this.polygon) === null || _this$polygon3 === void 0 ? void 0 : _this$polygon3.update({
            closed: false
          });
        }
        this.updatePolygon();
        // the polygon is now unclosed, so we need to
        // remove any points props
        this.clearCoords();

        // remove this movablePoint from graphie.
        // wait to do this until we're not inside of
        // said point's onMoveEnd method so state is
        // consistent throughout the method call
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(point.remove.bind(point), 0);
      };
      const setInitialMove = debounce__default["default"]((point, bool) => {
        point.state.isInitialMove = bool;
      }, 1000);
      const onMoveEndHandler = coord => {
        // If the user clicked and dragged a point over endpoint,
        // join the them
        const overlappedPoints = this.points.length > 1 && (point === this.points[0] && kmath.point.equal(coord, ___default["default"].last(this.points).coord()) || point === ___default["default"].last(this.points) && kmath.point.equal(coord, this.points[0].coord()));
        if (this.isClickToAddPoints()) {
          if (this.isCoordInTrash(coord)) {
            remove();
          } else if (overlappedPoints) {
            const pointToRemove = this.points.pop();
            if (this.points.length > 2) {
              var _this$polygon4;
              (_this$polygon4 = this.polygon) === null || _this$polygon4 === void 0 ? void 0 : _this$polygon4.update({
                closed: true
              });
              this.updateCoordsFromPoints();
            } else {
              var _this$polygon5;
              (_this$polygon5 = this.polygon) === null || _this$polygon5 === void 0 ? void 0 : _this$polygon5.update({
                closed: false
              });
              this.clearCoords();
            }
            this.updatePolygon();
            // remove this movablePoint from graphie.
            // wait to do this until we're not inside of
            // said point's onMoveEnd method so state is
            // consistent throughout the method call
            // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
            // eslint-disable-next-line no-restricted-syntax
            setTimeout(pointToRemove.remove.bind(pointToRemove), 0);
          } else {
            // If the user clicked and dragged a point over any other
            // existing point, fix shape
            const shouldRemove = ___default["default"].any(this.points, function (pt) {
              return pt !== point && kmath.point.equal(pt.coord(), coord);
            });
            if (shouldRemove) {
              var _this$polygon7;
              this.removePoint(point);
              if (this.points.length < 3) {
                var _this$polygon6;
                (_this$polygon6 = this.polygon) === null || _this$polygon6 === void 0 ? void 0 : _this$polygon6.update({
                  closed: false
                });
                this.clearCoords();
              } else if ((_this$polygon7 = this.polygon) !== null && _this$polygon7 !== void 0 && _this$polygon7.closed()) {
                this.updateCoordsFromPoints();
              }
              this.updatePolygon();
              // remove this movablePoint from graphie.
              // wait to do this until we're not inside
              // said point's onMoveEnd method so state
              // is consistent throughout the method call
              // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
              // eslint-disable-next-line no-restricted-syntax
              setTimeout(point.remove.bind(point), 0);
            } else {
              var _this$polygon8;
              // If this was
              //  * a click on the first or last point
              //  * and not a deletion
              //  * and not a drag,
              //  * and not a creation of a new point
              //    (see !point.state.isInitialMove, below),
              //  * and our polygon is not closed,
              //  * and we can close it (we need at least the same
              //    number of points as coordinates asked for in the
              //    question),
              // then close it
              const isFirstOrLastPoint = point === ___default["default"].head(this.points) || point === ___default["default"].last(this.points);
              const pointNotMoved = !point.hasMoved();
              // NOTE (jsatk): Currently different on mobile versus
              // destkop
              const notANewPoint = !point.state.isInitialMove;
              const polygonNotClosed = !((_this$polygon8 = this.polygon) !== null && _this$polygon8 !== void 0 && _this$polygon8.closed());
              const allPointsPlotted = this.points.length > 2;
              const canCloseUnclosedPolygon = isFirstOrLastPoint && pointNotMoved && notANewPoint && polygonNotClosed && allPointsPlotted;
              if (canCloseUnclosedPolygon) {
                var _this$polygon9;
                (_this$polygon9 = this.polygon) === null || _this$polygon9 === void 0 ? void 0 : _this$polygon9.update({
                  closed: true
                });
                this.updatePolygon();

                // We finally have a closed polygon, so save our
                // points to props
                this.updateCoordsFromPoints();
              }
            }
          }

          // In case we mouseup'd off the graphie and that
          // stopped the move
          this.setTrashCanVisibility(0.5);
        }
        setInitialMove(point, false);
      };
      const graphConstraint = coord => {
        // These constraints are all relative to the other points, so if
        // we're creating the initial points and haven't added any others
        // to the graph, we can't enforce them.
        if (this.points == null || this.points.length === 0) {
          return true;
        }
        const coords = ___default["default"].invoke(this.points, "coord");
        coords[i] = coord;

        // Check for invalid positioning, but only if we aren't adding
        // points one click at a time, since those added points could
        // have already violated these constraints
        if (!this.isClickToAddPoints()) {
          // Polygons can't have consecutive collinear points
          if (collinear(coords[rel(-2)], coords[rel(-1)], coords[i]) || collinear(coords[rel(-1)], coords[i], coords[rel(1)]) || collinear(coords[i], coords[rel(1)], coords[rel(2)])) {
            return false;
          }
          const segments = ___default["default"].zip(coords, rotate(coords));
          if (this.points.length > 3) {
            // Constrain to simple (non self-intersecting) polygon by
            // testing whether adjacent segments intersect any others
            for (let j = -1; j <= 0; j++) {
              const segment = segments[rel(j)];
              const others = ___default["default"].without(segments, segment, segments[rel(j - 1)], segments[rel(j + 1)]);
              for (let k = 0; k < others.length; k++) {
                const other = others[k];
                // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'Line'.
                if (intersects(segment, other)) {
                  return false;
                }
              }
            }
          }
        }
        if (
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'snapTo' does not exist on type 'PerseusGraphType'.
        this.props.graph.snapTo === "angles" && this.points.length > 2) {
          var _this$graphie5, _this$graphie6;
          // Snap to whole degree interior angles

          const angles = ___default["default"].map(angleMeasures(coords), function (rad) {
            return rad * 180 / Math.PI;
          });
          ___default["default"].each([-1, 1], function (j) {
            angles[rel(j)] = Math.round(angles[rel(j)]);
          });
          const getAngle = function (a, vertex, b) {
            const angle = GraphUtils.findAngle(coords[rel(a)], coords[rel(b)], coords[rel(vertex)]);
            return (angle + 360) % 360;
          };
          const innerAngles = [angles[rel(-1)] - getAngle(-2, -1, 1), angles[rel(1)] - getAngle(-1, 1, 2)];
          innerAngles[2] = 180 - (innerAngles[0] + innerAngles[1]);

          // Avoid degenerate triangles
          if (___default["default"].any(innerAngles, function (angle) {
            return leq(angle, 1);
          })) {
            return false;
          }
          const knownSide = magnitude(
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'.
          vector(coords[rel(-1)], coords[rel(1)]));
          const onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1;

          // Solve for side by using the law of sines
          const side = Math.sin(innerAngles[1] * Math.PI / 180) / Math.sin(innerAngles[2] * Math.PI / 180) * knownSide;
          const outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
          const offset = (_this$graphie5 = this.graphie) === null || _this$graphie5 === void 0 ? void 0 : _this$graphie5.polar(side, outerAngle + (onLeft ? 1 : -1) * innerAngles[0]);
          return (_this$graphie6 = this.graphie) === null || _this$graphie6 === void 0 ? void 0 : _this$graphie6.addPoints(coords[rel(-1)], offset);
        }
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'snapTo' does not exist on type 'PerseusGraphType'.
        if (this.props.graph.snapTo === "sides" && this.points.length > 1) {
          var _this$graphie7, _this$graphie8;
          // Snap to whole unit side measures

          const sides = ___default["default"].map([[coords[rel(-1)], coords[i]], [coords[i], coords[rel(1)]], [coords[rel(-1)], coords[rel(1)]]], function (coords) {
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'. | TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
            return magnitude(vector(...coords));
          });
          ___default["default"].each([0, 1], function (j) {
            sides[j] = Math.round(sides[j]);
          });

          // Avoid degenerate triangles
          if (leq(sides[1] + sides[2], sides[0]) || leq(sides[0] + sides[2], sides[1]) || leq(sides[0] + sides[1], sides[2])) {
            return false;
          }

          // Solve for angle by using the law of cosines
          const innerAngle = lawOfCosines(sides[0], sides[2], sides[1]);
          const outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
          const onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1;
          const offset = (_this$graphie7 = this.graphie) === null || _this$graphie7 === void 0 ? void 0 : _this$graphie7.polar(sides[0], outerAngle + (onLeft ? 1 : -1) * innerAngle);
          return (_this$graphie8 = this.graphie) === null || _this$graphie8 === void 0 ? void 0 : _this$graphie8.addPoints(coords[rel(-1)], offset);
        }
        // Snap to grid (already done)
        return true;
      };
      const point = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coord,
        constraints: [
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.bound(), snapToGrid ?
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
        Interactive2.MovablePoint.constraints.snap() : null, graphConstraint],
        onMoveStart: () => {
          if (this.isClickToAddPoints()) {
            this.setTrashCanVisibility(1);
          }
        },
        onMove: () => {
          var _this$polygon10;
          if ((_this$polygon10 = this.polygon) !== null && _this$polygon10 !== void 0 && _this$polygon10.closed()) {
            this.updateCoordsFromPoints();
          }
        },
        onMoveEnd: onMoveEndHandler,
        ...(this.props.apiOptions.isMobile && this.isClickToAddPoints() ? {
          onRemove: remove
        } : {})
      });
      point.state.isInitialMove = true;
      return point;
    });
    _defineProperty(this, "updateCoordsFromPoints", () => {
      const graph = ___default["default"].extend({}, this.props.graph, {
        // Handle old movable points with .coord, or
        // Interactive2.MovablePoint's with .coord()
        coords: ___default["default"].map(this.points, function (point) {
          return ___default["default"].result(point, "coord");
        })
      });
      this.onChange({
        graph: graph
      });
    });
    _defineProperty(this, "clearCoords", () => {
      const graph = ___default["default"].extend({}, this.props.graph, {
        coords: null
      });
      this.onChange({
        graph: graph
      });
    });
    _defineProperty(this, "onChange", data => {
      this.props.onChange(data);
      this.props.trackInteraction();
    });
    _defineProperty(this, "addPointControls", () => {
      if (this.props.graph.type !== "point") {
        throw makeInvalidTypeError("addPointControls", "point");
      }
      const coords = InteractiveGraph.getPointCoords(this.props.graph, this.props);
      // Clear out our old points so that newly added points don't
      // "collide" with them and reposition when being added
      // Without this, when added, each point checks whether it is on top
      // of a point in this.points, which (a) shouldn't matter since
      // we're clearing out this.points anyways, and (b) can cause problems
      // if each of this.points is a MovablePoint instead of an
      // Interactive2.MovablePoint, since one has a .coord and the other
      // has .coord()
      // TODO(jack): Figure out a better way to do this
      this.points = [];
      this.points = ___default["default"].map(coords, this.createPointForPointsType, this);
    });
    _defineProperty(this, "removePointControls", () => {
      ___default["default"].invoke(this.points, "remove");
    });
    _defineProperty(this, "addSegmentControls", () => {
      if (this.props.graph.type !== "segment") {
        throw makeInvalidTypeError("addSegmentControls", "segment");
      }
      const self = this;
      const graphie = this.graphie;
      const coords = InteractiveGraph.getSegmentCoords(this.props.graph, this.props);
      const createPoint = options => Interactive2.addMaybeMobileMovablePoint(this, options);
      this.points = [];
      this.lines = ___default["default"].map(coords, function (segment, i) {
        const updateCoordProps = function () {
          const graph = ___default["default"].extend({}, self.props.graph, {
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly (readonly Coord[])[] | null | undefined' is not assignable to parameter of type 'Collection<any>'.
            coords: ___default["default"].invoke(self.lines, "coords")
          });
          self.onChange({
            graph: graph
          });
        };

        // NOTE(jeresig): This code attempts to access the variable
        // while it's still being defined, it should be refactored!
        // The callbacks appear to be executed synchronously, which
        // causes this issue.
        const points = [];
        for (let i = 0; i < segment.length; i += 1) {
          const coord = segment[i];
          points.push(createPoint({
            coord: coord,
            constraints: [
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
            Interactive2.MovablePoint.constraints.bound(),
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
            Interactive2.MovablePoint.constraints.snap(), coord => {
              const otherPoint = points[1 - i];
              if (!otherPoint) {
                // point hasn't been defined yet
                // because we're still creating them
                // We return false as the points aren't
                // going to be in the same position at
                // this point.
                return false;
              }
              return !kmath.point.equal(coord, otherPoint.coord());
            }],
            onMove: updateCoordProps
          }));
        }
        self.points = self.points.concat(points);
        const line = Interactive2.addMovableLine(graphie, {
          points: points,
          static: false,
          constraints: [
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
          Interactive2.MovableLine.constraints.bound(),
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
          Interactive2.MovableLine.constraints.snap()],
          onMove: [
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'onMove' does not exist on type '(graphie: any, movable: any, options: any) => void'.
          Interactive2.MovableLine.onMove.updatePoints, updateCoordProps],
          normalStyle: {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            ...this._lineStroke()
          },
          highlightStyle: {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTING,
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            ...this._lineStroke()
          }
        });
        ___default["default"].invoke(points, "toFront");
        return line;
      }, this);
    });
    _defineProperty(this, "removeSegmentControls", () => {
      ___default["default"].invoke(this.points, "remove");
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly (readonly Coord[])[] | null | undefined' is not assignable to parameter of type 'Collection<any>'.
      ___default["default"].invoke(this.lines, "remove");
    });
    _defineProperty(this, "addRayControls", () => {
      this.addLine("ray");
    });
    _defineProperty(this, "removeRayControls", () => {
      this.removeLine();
    });
    _defineProperty(this, "addPolygonControls", () => {
      this.polygon = null;
      const coords = InteractiveGraph.getPolygonCoords(this.props.graph, this.props);
      // Clear out our old points so that newly added points don't
      // "collide", as in `addPointControls`
      this.points = [];
      this.points = ___default["default"].map(coords, this.createPointForPolygonType, this);
      this.updatePolygon();
    });
    _defineProperty(this, "updatePolygon", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("updatePolygon", "polygon");
      }
      let closed;
      if (this.polygon) {
        closed = this.polygon.closed();
      } else if (this.points.length >= 3) {
        closed = true;
      } else {
        // There will only be fewer than 3 points in click-to-add-vertices
        // mode, so we don't need to explicitly check for that here.
        closed = false;
      }
      const graphie = this.graphie;
      const n = this.points.length;

      // TODO(alex): check against "grid" instead, use constants
      const snapToGrid = !___default["default"].contains(["angles", "sides"], this.props.graph.snapTo);
      const angleLabels = ___default["default"].times(n, function (i) {
        if (
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        !this.props.graph.showAngles || !closed && (i === 0 || i === n - 1)) {
          return "";
        }
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        if (this.props.graph.snapTo === "angles") {
          return "$deg0";
        }
        return "$deg1";
      }, this);
      const showRightAngleMarkers = ___default["default"].times(n, function (i) {
        return closed || i !== 0 && i !== n - 1;
      }, this);
      const numArcs = ___default["default"].times(n, function (i) {
        if (
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.props.graph.showAngles && (closed || i !== 0 && i !== n - 1)) {
          return 1;
        }
        return 0;
      }, this);
      const sideLabels = ___default["default"].times(n, function (i) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        if (!this.props.graph.showSides || !closed && i === n - 1) {
          return "";
        }
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        if (this.props.graph.snapTo === "sides") {
          return "$len0";
        }
        return "$len1";
      }, this);
      if (this.polygon == null) {
        const self = this;
        self.polygon = Interactive2.addMovablePolygon(graphie, {
          constraints: [
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => undefined'.
          Interactive2.MovablePolygon.constraints.bound(), snapToGrid ?
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => undefined'.
          Interactive2.MovablePolygon.constraints.snap() : null],
          closed: closed,
          points: self.points,
          angleLabels: angleLabels,
          showRightAngleMarkers: showRightAngleMarkers,
          numArcs: numArcs,
          sideLabels: sideLabels,
          onMove: [
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'onMove' does not exist on type '(graphie: any, movable: any, options: any) => undefined'.
          Interactive2.MovablePolygon.onMove.updatePoints, function () {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            if (this.closed()) {
              self.updateCoordsFromPoints();
            }
          }],
          normalStyle: {
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
            ...this._lineStroke()
          }
        });
      } else {
        // We only need to pass in the properties that might've changed
        this.polygon.update({
          closed: closed,
          points: this.points,
          angleLabels: angleLabels,
          showRightAngleMarkers: showRightAngleMarkers,
          numArcs: numArcs,
          sideLabels: sideLabels
        });
      }
    });
    _defineProperty(this, "removePolygonControls", () => {
      var _this$polygon11;
      ___default["default"].invoke(this.points, "remove");
      (_this$polygon11 = this.polygon) === null || _this$polygon11 === void 0 ? void 0 : _this$polygon11.remove();
    });
    _defineProperty(this, "addAngleControls", () => {
      if (this.props.graph.type !== "angle") {
        throw makeInvalidTypeError("addAngleControls", "angle");
      }
      const graph = this.props.graph;
      const graphie = this.graphie;
      const coords = InteractiveGraph.getAngleCoords(this.props.graph, this.props);

      // The vertex snaps to the grid, but the rays don't...
      this.points = coords.map(function (coord, i) {
        return graphie === null || graphie === void 0 ? void 0 : graphie.addMovablePoint(___default["default"].extend({
          coord: coord,
          normalStyle: {
            stroke: KhanColors.INTERACTIVE,
            fill: KhanColors.INTERACTIVE
          }
        }, i === 1 ? {
          snapX: graphie.snap[0],
          snapY: graphie.snap[1]
        } : {}));
      });

      // ...they snap to whole-degree angles from the vertex.
      this.angle = graphie === null || graphie === void 0 ? void 0 : graphie.addMovableAngle({
        points: this.points,
        snapDegrees: graph.snapDegrees || 1,
        snapOffsetDeg: graph.angleOffsetDeg || 0,
        angleLabel: graph.showAngles ? "$deg0" : "",
        pushOut: 2,
        allowReflex: defaultVal(graph.allowReflexAngles, true)
      });
      $__default["default"](this.angle).on("move", () => {
        var _this$angle;
        this.onChange({
          graph: {
            ...graph,
            coords: (_this$angle = this.angle) === null || _this$angle === void 0 ? void 0 : _this$angle.getClockwiseCoords()
          }
        });
      });
    });
    _defineProperty(this, "removeAngleControls", () => {
      var _this$angle2;
      ___default["default"].invoke(this.points, "remove");
      (_this$angle2 = this.angle) === null || _this$angle2 === void 0 ? void 0 : _this$angle2.remove();
    });
    _defineProperty(this, "toggleShowAngles", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("toggleShowAngles", "polygon");
      }
      const graph = ___default["default"].extend({}, this.props.graph, {
        showAngles: !this.props.graph.showAngles
      });
      this.onChange({
        graph: graph
      });
    });
    _defineProperty(this, "toggleShowSides", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("toggleShowSides", "polygon");
      }
      const graph = ___default["default"].extend({}, this.props.graph, {
        showSides: !this.props.graph.showSides
      });
      this.onChange({
        graph: graph
      });
    });
    _defineProperty(this, "getUserInput", () => {
      return InteractiveGraph.getUserInputFromProps(this.props);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return InteractiveGraph.validate(this.getUserInput(), rubric, this);
    });
    _defineProperty(this, "focus", $__default["default"].noop);
  }
  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    DeprecationMixin.UNSAFE_componentWillMount.call(this);
  }
  componentDidMount() {
    // eslint-disable-next-line react/no-string-refs
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type 'ReactInstance'.
    this.setGraphie(this.refs.graph.graphie());
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    var _this$props$backgroun, _nextProps$background;
    if (this.isClickToAddPoints() !== this.isClickToAddPoints(nextProps)) {
      this.shouldResetGraphie = true;
      this.setState({
        shouldShowInstructions: _getShouldShowInstructions(nextProps)
      });
    }
    if (((_this$props$backgroun = this.props.backgroundImage) === null || _this$props$backgroun === void 0 ? void 0 : _this$props$backgroun.url) !== ((_nextProps$background = nextProps.backgroundImage) === null || _nextProps$background === void 0 ? void 0 : _nextProps$background.url) || this.props.backgroundImage !== nextProps.backgroundImage || this.props.containerSizeClass !== nextProps.containerSizeClass) {
      this.shouldResetGraphie = true;
    }
  }
  componentDidUpdate(prevProps, prevState) {
    // TODO(jeremy): This feels underspecified. For example, if the props
    // change the coords of a segment graph, but not the numSegments, we'd
    // not count that as an update.
    const oldType = prevProps.graph.type;
    const newType = this.props.graph.type;
    if (oldType !== newType || prevProps.graph.type === "angle" && this.props.graph.type === "angle" && this.areAngleGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "point" && this.props.graph.type === "point" && this.arePointGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "polygon" && this.props.graph.type === "polygon" && this.arePolygonGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "segment" && this.props.graph.type === "segment" && this.areSegmentGraphsEqual(prevProps.graph, this.props.graph)) {
      this["remove" + capitalize(oldType) + "Controls"]();
      this["add" + capitalize(newType) + "Controls"]();
    }
    if (this.shouldResetGraphie) {
      this.resetGraphie();
    }
  }
  areAngleGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.allowReflexAngles !== currentGraph.allowReflexAngles || prevGraph.angleOffsetDeg !== currentGraph.angleOffsetDeg || prevGraph.snapDegrees !== currentGraph.snapDegrees;
  }
  arePointGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numPoints !== currentGraph.numPoints;
  }
  arePolygonGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numSides !== currentGraph.numSides || prevGraph.showAngles !== currentGraph.showAngles || prevGraph.showSides !== currentGraph.showSides || prevGraph.snapTo !== currentGraph.snapTo;
  }
  areSegmentGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numSegments !== currentGraph.numSegments;
  }
  render() {
    const box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass);
    let instructions;
    if (this.isClickToAddPoints() && this.state.shouldShowInstructions) {
      if (this.props.graph.type === "point") {
        instructions = i18n__namespace._("Click to add points");
      } else if (this.props.graph.type === "polygon") {
        instructions = i18n__namespace._("Click to add vertices");
      }
    } else {
      instructions = undefined;
    }
    let onMouseDown;
    if (this.isClickToAddPoints()) {
      onMouseDown = this.handleAddPointsMouseDown;
    }
    const gridStep = this.props.gridStep || Util.getGridStep(this.props.range, this.props.step, box[0]);
    const snapStep = this.props.snapStep || Util.snapStepFromGridStep(gridStep);
    const isMobile = this.props.apiOptions.isMobile;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-graph",
      style: {
        width: box[0],
        height: box[1]
      }
    }, /*#__PURE__*/React__namespace.createElement(Graph, {
      instructions: instructions
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "graph",
      box: box,
      labels: this.props.labels,
      range: this.props.range,
      step: isMobile ? Util.constrainedTickStepsFromTickSteps(this.props.step, this.props.range) : this.props.step,
      gridStep: gridStep,
      snapStep: snapStep,
      markings: this.props.markings,
      backgroundImage: this.props.backgroundImage,
      showProtractor: this.props.showProtractor,
      showRuler: this.props.showRuler,
      rulerLabel: this.props.rulerLabel,
      rulerTicks: this.props.rulerTicks,
      onMouseDown: onMouseDown,
      onGraphieUpdated: this.setGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: isMobile
    }));
  }
  static getQuadraticCoefficients(coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const p3 = coords[2];
    const denom = (p1[0] - p2[0]) * (p1[0] - p3[0]) * (p2[0] - p3[0]);
    if (denom === 0) {
      // Many of the callers assume that the return value is always defined.
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'undefined' is not assignable to type 'QuadraticCoefficient'.
      return;
    }
    const a = (p3[0] * (p2[1] - p1[1]) + p2[0] * (p1[1] - p3[1]) + p1[0] * (p3[1] - p2[1])) / denom;
    const b = (p3[0] * p3[0] * (p1[1] - p2[1]) + p2[0] * p2[0] * (p3[1] - p1[1]) + p1[0] * p1[0] * (p2[1] - p3[1])) / denom;
    const c = (p2[0] * p3[0] * (p2[0] - p3[0]) * p1[1] + p3[0] * p1[0] * (p3[0] - p1[0]) * p2[1] + p1[0] * p2[0] * (p1[0] - p2[0]) * p3[1]) / denom;
    return [a, b, c];
  }
  static getSinusoidCoefficients(coords) {
    // It's assumed that p1 is the root and p2 is the first peak
    const p1 = coords[0];
    const p2 = coords[1];

    // Resulting coefficients are canonical for this sine curve
    const amplitude = p2[1] - p1[1];
    const angularFrequency = Math.PI / (2 * (p2[0] - p1[0]));
    const phase = p1[0] * angularFrequency;
    const verticalOffset = p1[1];
    return [amplitude, angularFrequency, phase, verticalOffset];
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getLineCoords(graph, props) {
    return (
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
      graph.coords || InteractiveGraph.pointsFromNormalized(props, [[0.25, 0.75], [0.75, 0.75]])
    );
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getPointCoords(graph, props) {
    const numPoints = graph.numPoints || 1;
    let coords = graph.coords;
    if (coords) {
      return coords;
    }
    switch (numPoints) {
      case 1:
        // Back in the day, one point's coords were in graph.coord
        coords = [graph.coord || [0, 0]];
        break;
      case 2:
        coords = [[-5, 0], [5, 0]];
        break;
      case 3:
        coords = [[-5, 0], [0, 0], [5, 0]];
        break;
      case 4:
        coords = [[-6, 0], [-2, 0], [2, 0], [6, 0]];
        break;
      case 5:
        coords = [[-6, 0], [-3, 0], [0, 0], [3, 0], [6, 0]];
        break;
      case 6:
        coords = [[-5, 0], [-3, 0], [-1, 0], [1, 0], [3, 0], [5, 0]];
        break;
      case UNLIMITED:
        coords = [];
        break;
    }
    // Transform coords from their -10 to 10 space to 0 to 1
    // because of the old graph.coord, and also it's easier.
    const range = [[-10, 10], [-10, 10]];
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly Coord[] | undefined' is not assignable to parameter of type 'readonly Coord[]'.
    const newCoords = InteractiveGraph.normalizeCoords(coords, range);
    return InteractiveGraph.pointsFromNormalized(props, newCoords);
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getLinearSystemCoords(graph, props) {
    return (
      // The callers assume that we're return an array of points
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
      graph.coords || ___default["default"].map([[[0.25, 0.75], [0.75, 0.75]], [[0.25, 0.25], [0.75, 0.25]]], coords => {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[][]' is not assignable to parameter of type 'readonly Coord[]'.
        return InteractiveGraph.pointsFromNormalized(props, coords);
      })
    );
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getPolygonCoords(graph, props) {
    if (graph.type !== "polygon") {
      throw makeInvalidTypeError("toggleShowSides", "polygon");
    }
    let coords = graph.coords;
    if (coords) {
      return coords;
    }
    const n = graph.numSides || 3;
    if (n === UNLIMITED) {
      coords = [];
    } else {
      const angle = 2 * Math.PI / n;
      const offset = (1 / n - 1 / 2) * Math.PI;

      // TODO(alex): Generalize this to more than just triangles so that
      // all polygons have whole number side lengths if snapping to sides
      const radius = graph.snapTo === "sides" ? Math.sqrt(3) / 3 * 7 : 4;

      // Generate coords of a regular polygon with n sides
      coords = ___default["default"].times(n, function (i) {
        return [radius * Math.cos(i * angle + offset), radius * Math.sin(i * angle + offset)];
      });
    }
    const ranges = [[-10, 10], [-10, 10]];
    coords = InteractiveGraph.normalizeCoords(coords, ranges);
    const snapToGrid = !___default["default"].contains(["angles", "sides"], graph.snapTo);
    coords = InteractiveGraph.pointsFromNormalized(props, coords, /* noSnap */!snapToGrid);
    return coords;
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getSegmentCoords(graph, props) {
    const coords = graph.coords;
    if (coords) {
      return coords;
    }
    const n = graph.numSegments || 1;
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[] | undefined' is not assignable to type 'readonly number[]'.
    const ys = {
      1: [5],
      2: [5, -5],
      3: [5, 0, -5],
      4: [6, 2, -2, -6],
      5: [6, 3, 0, -3, -6],
      6: [5, 3, 1, -1, -3, -5]
    }[n];
    const range = [[-10, 10], [-10, 10]];

    // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[][][]' is not assignable to type 'readonly (readonly Coord[])[]'.
    return ys.map(function (y) {
      let segment = [[-5, y], [5, y]];
      // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly Coord[]' is 'readonly' and cannot be assigned to the mutable type 'number[][]'. | TS2345 - Argument of type 'number[][]' is not assignable to parameter of type 'readonly Coord[]'.
      segment = InteractiveGraph.normalizeCoords(segment, range);
      // @ts-expect-error [FEI-5003] - TS4104 - The type 'readonly Coord[]' is 'readonly' and cannot be assigned to the mutable type 'number[][]'. | TS2345 - Argument of type 'number[][]' is not assignable to parameter of type 'readonly Coord[]'.
      segment = InteractiveGraph.pointsFromNormalized(props, segment);
      return segment;
    });
  }

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  static getAngleCoords(graph, props) {
    let coords = graph.coords;
    if (coords) {
      return coords;
    }
    const snap = graph.snapDegrees || 1;
    let angle = snap;
    while (angle < 20) {
      angle += snap;
    }
    angle = angle * Math.PI / 180;
    const offset = (graph.angleOffsetDeg || 0) * Math.PI / 180;
    coords = InteractiveGraph.pointsFromNormalized(props, [[0.85, 0.5], [0.5, 0.5]]);

    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[]' is not assignable to parameter of type 'readonly Coord[]'. | TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
    const radius = magnitude(vector(...coords));

    // Adjust the lower point by angleOffsetDeg degrees
    // @ts-expect-error [FEI-5003] - TS2542 - Index signature in type 'readonly Coord[]' only permits reading.
    coords[0] = [coords[1][0] + radius * Math.cos(offset), coords[1][1] + radius * Math.sin(offset)];
    // Position the upper point angle radians from the
    // lower point
    // @ts-expect-error [FEI-5003] - TS2542 - Index signature in type 'readonly Coord[]' only permits reading.
    coords[2] = [coords[1][0] + radius * Math.cos(angle + offset), coords[1][1] + radius * Math.sin(angle + offset)];
    return coords;
  }
  static normalizeCoords(coordsList, ranges) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[][]' is not assignable to type 'readonly Coord[]'.
    return ___default["default"].map(coordsList, function (coords) {
      return ___default["default"].map(coords, function (coord, i) {
        const extent = ranges[i][1] - ranges[i][0];
        return (coord + ranges[i][1]) / extent;
      });
    });
  }
  static getEquationString(props) {
    const type = props.graph.type;
    const funcName = "get" + capitalize(type) + "EquationString";
    return InteractiveGraph[funcName](props);
  }
  static pointsFromNormalized(props, coordsList, noSnap) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'number[][]' is not assignable to type 'readonly Coord[]'.
    return ___default["default"].map(coordsList, function (coords) {
      return ___default["default"].map(coords, function (coord, i) {
        const range = props.range[i];
        if (noSnap) {
          return range[0] + (range[1] - range[0]) * coord;
        }
        const step = props.step[i];
        const nSteps = numSteps(range, step);
        const tick = Math.round(coord * nSteps);
        return range[0] + step * tick;
      });
    });
  }
  static getLinearEquationString(props) {
    const coords = InteractiveGraph.getLineCoords(props.graph, props);
    if (eq(coords[0][0], coords[1][0])) {
      return "x = " + coords[0][0].toFixed(3);
    }
    const m = (coords[1][1] - coords[0][1]) / (coords[1][0] - coords[0][0]);
    const b = coords[0][1] - m * coords[0][0];
    if (eq(m, 0)) {
      return "y = " + b.toFixed(3);
    }
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
  static getCurrentQuadraticCoefficients(props) {
    // TODO(alpert): Don't duplicate
    const coords =
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
    props.graph.coords || InteractiveGraph.defaultQuadraticCoords(props);
    return InteractiveGraph.getQuadraticCoefficients(coords);
  }
  static defaultQuadraticCoords(props) {
    const coords = [[0.25, 0.75], [0.5, 0.25], [0.75, 0.75]];
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[][]' is not assignable to parameter of type 'readonly Coord[]'.
    return InteractiveGraph.pointsFromNormalized(props, coords);
  }
  static getQuadraticEquationString(props) {
    const coeffs = InteractiveGraph.getCurrentQuadraticCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "x^2 + " + coeffs[1].toFixed(3) + "x + " + coeffs[2].toFixed(3);
  }
  static getCurrentSinusoidCoefficients(props) {
    const coords =
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'.
    props.graph.coords || InteractiveGraph.defaultSinusoidCoords(props);
    return InteractiveGraph.getSinusoidCoefficients(coords);
  }
  static defaultSinusoidCoords(props) {
    const coords = [[0.5, 0.5], [0.65, 0.6]];
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number[][]' is not assignable to parameter of type 'readonly Coord[]'.
    return InteractiveGraph.pointsFromNormalized(props, coords);
  }
  static getSinusoidEquationString(props) {
    const coeffs = InteractiveGraph.getCurrentSinusoidCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "sin(" + coeffs[1].toFixed(3) + "x - " + coeffs[2].toFixed(3) + ") + " + coeffs[3].toFixed(3);
  }
  static getCircleEquationString(props) {
    const graph = props.graph;
    // TODO(alpert): Don't duplicate
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'center' does not exist on type 'PerseusGraphType'.
    const center = graph.center || [0, 0];
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'radius' does not exist on type 'PerseusGraphType'.
    const radius = graph.radius || 2;
    return "center (" + center[0] + ", " + center[1] + "), radius " + radius;
  }
  static getLinearSystemEquationString(props) {
    const coords = InteractiveGraph.getLinearSystemCoords(props.graph, props);
    return "\n" + getLineEquation(coords[0][0], coords[0][1]) + "\n" + getLineEquation(coords[1][0], coords[1][1]) + "\n" + getLineIntersection(coords[0], coords[1]);
  }
  static getPointEquationString(props) {
    if (props.graph.type !== "point") {
      throw makeInvalidTypeError("getPointEquationString", "point");
    }
    const coords = InteractiveGraph.getPointCoords(props.graph, props);
    return coords.map(function (coord) {
      return "(" + coord[0] + ", " + coord[1] + ")";
    }).join(", ");
  }
  static getSegmentEquationString(props) {
    if (props.graph.type !== "segment") {
      throw makeInvalidTypeError("getSegmentEquationString", "segment");
    }
    const segments = InteractiveGraph.getSegmentCoords(props.graph, props);
    return ___default["default"].map(segments, function (segment) {
      return "[" + ___default["default"].map(segment, function (coord) {
        return "(" + coord.join(", ") + ")";
      }).join(" ") + "]";
    }).join(" ");
  }
  static getRayEquationString(props) {
    if (props.graph.type !== "ray") {
      throw makeInvalidTypeError("createPointForPolygonType", "ray");
    }
    const coords = InteractiveGraph.getLineCoords(props.graph, props);
    const a = coords[0];
    const b = coords[1];
    let eq = InteractiveGraph.getLinearEquationString(props);
    if (a[0] > b[0]) {
      eq += " (for x <= " + a[0].toFixed(3) + ")";
    } else if (a[0] < b[0]) {
      eq += " (for x >= " + a[0].toFixed(3) + ")";
    } else if (a[1] > b[1]) {
      eq += " (for y <= " + a[1].toFixed(3) + ")";
    } else {
      eq += " (for y >= " + a[1].toFixed(3) + ")";
    }
    return eq;
  }
  static getPolygonEquationString(props) {
    if (props.graph.type !== "polygon") {
      throw makeInvalidTypeError("getPolygonEquationString", "polygon");
    }
    const coords = InteractiveGraph.getPolygonCoords(props.graph, props);
    return ___default["default"].map(coords, function (coord) {
      return "(" + coord.join(", ") + ")";
    }).join(" ");
  }
  static getAngleEquationString(props) {
    if (props.graph.type !== "angle") {
      throw makeInvalidTypeError("getAngleEquationString", "angle");
    }
    const coords = InteractiveGraph.getAngleCoords(props.graph, props);
    const angle = GraphUtils.findAngle(coords[2], coords[0], coords[1]);
    return angle.toFixed(0) + "\u00B0 angle" + " at (" + coords[1].join(", ") + ")";
  }
  static validate(
  // TODO(kevinb): rename state to userInput
  // state === userInput
  state, rubric, component) {
    // When nothing has moved, there will neither be coords nor the
    // circle's center/radius fields. When those fields are absent, skip
    // all these checks; just go mark the answer as empty.
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'coords' does not exist on type 'PerseusGraphType'. | TS2339 - Property 'center' does not exist on type 'PerseusGraphType'. | TS2339 - Property 'radius' does not exist on type 'PerseusGraphType'.
    const hasValue = !!(state.coords || state.center && state.radius);
    if (state.type === rubric.correct.type && hasValue) {
      if (state.type === "linear" && rubric.correct.type === "linear" && state.coords != null) {
        const guess = state.coords;
        const correct = rubric.correct.coords;

        // If both of the guess points are on the correct line, it's
        // correct.
        if (
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
        collinear(correct[0], correct[1], guess[0]) &&
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
        collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "linear-system" && rubric.correct.type === "linear-system" && state.coords != null) {
        const guess = state.coords;
        const correct = rubric.correct.coords;
        if (collinear(correct[0][0], correct[0][1], guess[0][0]) && collinear(correct[0][0], correct[0][1], guess[0][1]) && collinear(correct[1][0], correct[1][1], guess[1][0]) && collinear(correct[1][0], correct[1][1], guess[1][1]) || collinear(correct[0][0], correct[0][1], guess[1][0]) && collinear(correct[0][0], correct[0][1], guess[1][1]) && collinear(correct[1][0], correct[1][1], guess[0][0]) && collinear(correct[1][0], correct[1][1], guess[0][1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "quadratic" && rubric.correct.type === "quadratic" && state.coords != null) {
        // If the parabola coefficients match, it's correct.
        const guessCoeffs = this.getQuadraticCoefficients(state.coords);
        const correctCoeffs = this.getQuadraticCoefficients(
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly Coord[] | undefined' is not assignable to parameter of type 'readonly Coord[]'.
        rubric.correct.coords);
        if (deepEq$2(guessCoeffs, correctCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "sinusoid" && rubric.correct.type === "sinusoid" && state.coords != null) {
        const guessCoeffs = this.getSinusoidCoefficients(state.coords);
        const correctCoeffs = this.getSinusoidCoefficients(
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly Coord[] | undefined' is not assignable to parameter of type 'readonly Coord[]'.
        rubric.correct.coords);
        const canonicalGuessCoeffs = canonicalSineCoefficients(guessCoeffs);
        const canonicalCorrectCoeffs = canonicalSineCoefficients(correctCoeffs);
        // If the canonical coefficients match, it's correct.
        if (deepEq$2(canonicalGuessCoeffs, canonicalCorrectCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "circle" && rubric.correct.type === "circle") {
        if (deepEq$2(state.center, rubric.correct.center) && eq(state.radius, rubric.correct.radius)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "point" && rubric.correct.type === "point" && state.coords != null) {
        var _state$coords;
        let correct = InteractiveGraph.getPointCoords(rubric.correct, component);
        const guess = (_state$coords = state.coords) === null || _state$coords === void 0 ? void 0 : _state$coords.slice();
        correct = correct.slice();
        // Everything's already rounded so we shouldn't need to do an
        // eq() comparison but _.isEqual(0, -0) is false, so we'll use
        // eq() anyway. The sort should be fine because it'll stringify
        // it and -0 converted to a string is "0"
        guess === null || guess === void 0 ? void 0 : guess.sort();
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'sort' does not exist on type 'readonly Coord[]'.
        correct.sort();
        if (deepEq$2(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "polygon" && rubric.correct.type === "polygon" && state.coords != null) {
        var _state$coords2, _rubric$correct$coord;
        const guess = (_state$coords2 = state.coords) === null || _state$coords2 === void 0 ? void 0 : _state$coords2.slice();
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'Coord[] | undefined' is not assignable to type 'Coord[]'.
        const correct = (_rubric$correct$coord = rubric.correct.coords) === null || _rubric$correct$coord === void 0 ? void 0 : _rubric$correct$coord.slice();
        let match;
        if (rubric.correct.match === "similar") {
          match = similar(guess, correct, Number.POSITIVE_INFINITY);
        } else if (rubric.correct.match === "congruent") {
          match = similar(guess, correct, kmath.number.DEFAULT_TOLERANCE);
        } else if (rubric.correct.match === "approx") {
          match = similar(guess, correct, 0.1);
        } else {
          /* exact */
          guess.sort();
          correct.sort();
          match = deepEq$2(guess, correct);
        }
        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "segment" && rubric.correct.type === "segment" && state.coords != null) {
        var _rubric$correct$coord2;
        let guess = state.coords.slice();
        let correct = (_rubric$correct$coord2 = rubric.correct.coords) === null || _rubric$correct$coord2 === void 0 ? void 0 : _rubric$correct$coord2.slice();
        guess = ___default["default"].invoke(guess, "sort").sort();
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(readonly Coord[])[] | undefined' is not assignable to parameter of type 'Collection<any>'.
        correct = ___default["default"].invoke(correct, "sort").sort();
        if (deepEq$2(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "ray" && rubric.correct.type === "ray" && state.coords != null) {
        const guess = state.coords;
        const correct = rubric.correct.coords;
        if (
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
        deepEq$2(guess[0], correct[0]) &&
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
        collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "angle" && rubric.correct.type === "angle") {
        const guess = state.coords;
        const correct = rubric.correct.coords;
        let match;
        if (rubric.correct.match === "congruent") {
          const angles = ___default["default"].map([guess, correct], function (coords) {
            const angle = GraphUtils.findAngle(
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            coords[2],
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            coords[0],
            // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'.
            coords[1]);
            return (angle + 360) % 360;
          });
          // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
          match = eq(...angles);
        } else {
          /* exact */
          match =
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
          deepEq$2(guess[1], correct[1]) &&
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
          collinear(correct[1], correct[0], guess[0]) &&
          // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
          collinear(correct[1], correct[2], guess[2]);
        }
        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      }
    }

    // The input wasn't correct, so check if it's a blank input or if it's
    // actually just wrong
    if (!hasValue || ___default["default"].isEqual(state, rubric.graph)) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    }
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }
  static getUserInputFromProps(props) {
    return props.graph;
  }
}
_defineProperty(InteractiveGraph, "defaultProps", {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  backgroundImage: defaultBackgroundImage$1,
  markings: "graph",
  showTooltips: false,
  showProtractor: false,
  showRuler: false,
  rulerLabel: "",
  rulerTicks: 10,
  graph: {
    type: "linear"
  }
});
var InteractiveGraph$1 = {
  name: "interactive-graph",
  displayName: "Interactive graph",
  widget: InteractiveGraph
};

const black = "#000000";
const grayDarker = "#333333";
const grayDark = "#555555";
const gray = "#999999";
const grayLight = "#AAAAAA";
const grayLighter = "#DDDDDD";
const white = "#FFFFFF";
const blue = "#005A88";
const blueDark = "#2C3747";
const green = "#76A005";
const red = "#CF5044";
const yellow = "#FFC40D";
const orange = "#BF4F04";
const pink = "#C3325F";
const purple = "#7A43B6";
const bodyBackground = "#FFFFFF";
const textColor = "#444444";
const linkColor = "#005987";
const linkColorHover = "#678D00";
const sansFontFamily = "'Helvetica Neue',Helvetica,Arial,sans-serif";
const serifFontFamily = "Georgia,'Times New Roman',Times,serif";
const monoFontFamily = "Monaco,Menlo,Consolas,'Courier New',monospace";
const baseFontSize = "14px";
const baseFontFamily = "inherit";
const baseLineHeight = "20px";
const altFontFamily = "Georgia,'Times New Roman',Times,serif";
const headingsFontFamily = "inherit";
const headingsFontWeight = "bold";
const headingsColor = "inherit";
const fontSizeLarge = "18px";
const fontSizeSmall = "12px";
const fontSizeMini = "10.5px";
const paddingLarge = "11px 19px";
const paddingSmall = "2px 10px";
const paddingMini = "0 6px";
const baseBorderRadius = "4px";
const borderRadiusLarge = "6px";
const borderRadiusSmall = "3px";
const tableBackground = "#000000";
const tableBackgroundAccent = "#F9F9F9";
const tableBackgroundHover = "#F5F5F5";
const tableBorder = "#DDDDDD";
const btnBackground = "#FFFFFF";
const btnBackgroundHighlight = "rgb(230, 230, 230)";
const btnBorder = "#CCCCCC";
const btnPrimaryBackground = "#0088CC";
const btnPrimaryBackgroundHighlight = "rgb(0, 68, 204)";
const btnInfoBackground = "#5BC0DE";
const btnInfoBackgroundHighlight = "#2F96B4";
const btnSuccessBackground = "#62C462";
const btnSuccessBackgroundHighlight = "#51A351";
const btnWarningBackground = "rgb(251, 180, 81)";
const btnWarningBackgroundHighlight = "#F89406";
const btnDangerBackground = "#EE5F5B";
const btnDangerBackgroundHighlight = "#BD362F";
const btnInverseBackground = "#444444";
const btnInverseBackgroundHighlight = "#222222";
const inputBackground = "#FFFFFF";
const inputBorder = "#CCCCCC";
const inputBorderRadius = "4px";
const inputDisabledBackground = "#EEEEEE";
const formActionsBackground = "#F5F5F5";
const inputHeight = "30px";
const dropdownBackground = "#FFFFFF";
const dropdownBorder = "rgba(0, 0, 0, 0.2)";
const dropdownDividerTop = "#E5E5E5";
const dropdownDividerBottom = "#FFFFFF";
const dropdownLinkColor = "#333333";
const dropdownLinkColorHover = "#FFFFFF";
const dropdownLinkColorActive = "#FFFFFF";
const dropdownLinkBackgroundActive = "#0088CC";
const dropdownLinkBackgroundHover = "#0088CC";
const zindexDropdown = 1000;
const zindexPopover = 1010;
const zindexTooltip = 1030;
const zindexFixedNavbar = 1030;
const zindexHeader = 1060;
const zindexModalBackdrop = 1070;
const zindexModal = 1080;
const zindexAboveModal = 1090;
const iconSpritePath = "../img/glyphicons-halflings.png";
const iconWhiteSpritePath = "../img/glyphicons-halflings-white.png";
const placeholderText = "#999999";
const hrBorder = "#EEEEEE";
const horizontalComponentOffset = "180px";
const wellBackground = "#F5F5F5";
const navbarCollapseWidth = "979px";
const navbarCollapseDesktopWidth = "980px";
const navbarHeight = "40px";
const navbarBackgroundHighlight = "#FFFFFF";
const navbarBackground = "rgb(242, 242, 242)";
const navbarBorder = "rgb(212, 212, 212)";
const navbarText = "#777777";
const navbarLinkColor = "#777777";
const navbarLinkColorHover = "#333333";
const navbarLinkColorActive = "#555555";
const navbarLinkBackgroundHover = "#000000";
const navbarLinkBackgroundActive = "rgb(230, 230, 230)";
const navbarBrandColor = "#777777";
const navbarInverseBackground = "#111111";
const navbarInverseBackgroundHighlight = "#222222";
const navbarInverseBorder = "#252525";
const navbarInverseText = "#999999";
const navbarInverseLinkColor = "#999999";
const navbarInverseLinkColorHover = "#FFFFFF";
const navbarInverseLinkColorActive = "#FFFFFF";
const navbarInverseLinkBackgroundHover = "#000000";
const navbarInverseLinkBackgroundActive = "#111111";
const navbarInverseSearchBackground = "rgb(82, 82, 82)";
const navbarInverseSearchBackgroundFocus = "#FFFFFF";
const navbarInverseSearchBorder = "#111111";
const navbarInverseSearchPlaceholderColor = "#CCCCCC";
const navbarInverseBrandColor = "#999999";
const paginationBackground = "#FFFFFF";
const paginationBorder = "#DDDDDD";
const paginationActiveBackground = "#F5F5F5";
const heroUnitBackground = "#EEEEEE";
const heroUnitHeadingColor = "inherit";
const heroUnitLeadColor = "inherit";
const warningText = "#C09853";
const warningBackground = "#FCF8E3";
const warningBorder = "rgb(251, 239, 213)";
const errorText = "#B94A48";
const errorBackground = "#F2DEDE";
const errorBorder = "rgb(238, 211, 215)";
const successText = "#468847";
const successBackground = "#DFF0D8";
const successBorder = "rgb(212, 232, 197)";
const infoText = "#4A7C17";
const infoBackground = "#EDF2DF";
const infoBorder = "rgb(228, 232, 197)";
const tooltipColor = "#FFFFFF";
const tooltipBackground = "#000000";
const tooltipArrowWidth = "5px";
const tooltipArrowColor = "#000000";
const popoverBackground = "#FFFFFF";
const popoverArrowWidth = "10px";
const popoverArrowColor = "#FFFFFF";
const popoverTitleBackground = "rgb(247, 247, 247)";
const popoverArrowOuterWidth = "11px";
const popoverArrowOuterColor = "rgba(0, 0, 0, 0.25)";
const gridColumns = "12";
const gridColumnWidth = "60px";
const gridGutterWidth = "20px";
const gridRowWidth = "940px";
const gridColumnWidth1200 = "70px";
const gridGutterWidth1200 = "30px";
const gridRowWidth1200 = "1170px";
const gridColumnWidth768 = "42px";
const gridGutterWidth768 = "20px";
const gridRowWidth768 = "724px";
const fluidGridColumnWidth = "6.382978723404255%";
const fluidGridGutterWidth = "2.127659574468085%";
const fluidGridColumnWidth1200 = "5.982905982905983%";
const fluidGridGutterWidth1200 = "2.564102564102564%";
const fluidGridColumnWidth768 = "5.801104972375691%";
const fluidGridGutterWidth768 = "2.7624309392265194%";
const kaGreen = "#71B307";
const kaGreenLight = "#BED47A";
const kaBlue = "#314453";
const kaBlueLight = "#4D6779";
const grayExtraDark = "#111111";
const grayExtraLight = "#EEEEEE";
const graySuperLight = "#F7F7F7";
const whiteDark = "#FDFDFD";
const dark = "#21242C";
const blueDarkUnsaturated = "#3B414E";
const blueDarkSaturated = "#1F3043";
const blueLight = "#A9C0D1";
const greenLight = "#C6D1AD";
const greenDark = "#356700";
const yellowGreen = "#9DB63B";
const okGreen = "#A7CF5B";
const alertRed = "#C42420";
const coral = "#EE6666";
const grayBlue = "#9AB3B9";
const lightPageBackground = "#FDFDFD";
const yclaBlue = "#49BAD5";
const yclaTeal = "#56D0B3";
const yclaTealDark = "#50C1A7";
const yclaGreenDark = "#3D9A82";
const yclaGreen = "#81C262";
const learnstormBlue = "#4898FC";
const homepageBlue = "#46A8BF";
const backgroundBlue = "#00294A";
const teacherSignupBlue = "#335d7d";
const homepageGreen = "#2B8E7B";
const streakColor = "#F79734";
const facebookColor = "#1A60A2";
const blueGoogleColor = "#2CAFE2";
const redGoogleColor = "#BF4434";
const homepageColor = "#2D585E";
const lightTextColor = "#898989";
const fontSizeTiny = "11px";
const fontSizeNormal = "14px";
const fontSizeMedium = "16px";
const fontSizeExtraLarge = "24px";
const fontSizeHuge = "36px";
const fontSizeBakana = "48px";
const fontSizeBananas = "60px";
const fixedWidthFontFamily = "'Helvetica Neue',Helvetica,Arial,sans-serif";
const contentPadding = "20px";
const primaryButtonBackground = "#89B908";
const primaryButtonBorder = "#76A005";
const buttonTextColor = "rgb(122, 122, 122)";
const buttonBorderRadius = "3px";
const basicBorderColor = "#CCCCCC";
const minContainerWidth = "1000px";
const maxContainerWidth = "1200px";
const formHintColor = "#999999";
const guidelineExampleText = "#606060";
const hoverCardWidth = "450px";
const menuHighlightColor = "#96AB4F";
const menuHighlightBorderColor = "#76A005";
const menuActiveTextColor = "#FFFFFF";
const menuInactiveTextColor = "#444444";
const menuSubheaderTextColor = "rgb(120, 120, 120)";
const menuBorderColor = "#94A170";
const unreadBackgroundColor = "#ECEEF4";
const menuLineHeight = "18px";
const menuSubheaderLineHeight = "17px";
const menuSubheaderFontSize = "9px";
const notificationBarColor = "#4858A4";
const modalBodyTopPadding = "20px";
const modalDialogPadding = "15px";
const modalSectionPadding = "9px";
const mathDomain1 = "#11ACCD";
const mathDomain2 = "#63D9EA";
const mathDomain3 = "#027d97";
const mathDomain4 = "#085566";
const partnerContentDomain1 = "#01A995";
const partnerContentDomain2 = "#01D1C1";
const partnerContentDomain3 = "#208170";
const partnerContentDomain4 = "#144F44";
const csDomain1 = "#1FAB54";
const csDomain2 = "#74CF70";
const csDomain3 = "#0D923F";
const csDomain4 = "#085E29";
const economicsDomain1 = "#E07D10";
const economicsDomain2 = "#FFBE26";
const economicsDomain3 = "#A75A05";
const economicsDomain4 = "#953C02";
const collegeCareersMoreDomain1 = "#01A995";
const collegeCareersMoreDomain2 = "#01D1C1";
const collegeCareersMoreDomain3 = "#208170";
const collegeCareersMoreDomain4 = "#144F44";
const humanitiesDomain1 = "#E84D39";
const humanitiesDomain2 = "#FF8482";
const humanitiesDomain3 = "#BE2612";
const humanitiesDomain4 = "#8C1C0D";
const gtpDomain1 = "#1865F2";
const gtpDomain2 = "#1865F2";
const gtpDomain3 = "#1865F2";
const gtpDomain4 = "#1865F2";
const scienceDomain1 = "#CA337C";
const scienceDomain2 = "#FF92C6";
const scienceDomain3 = "#9E034E";
const scienceDomain4 = "#6B0235";
const testPrepDomain1 = "#1865F2";
const testPrepDomain2 = "#1865F2";
const testPrepDomain3 = "#1865F2";
const testPrepDomain4 = "#1865F2";
const defaultDomain1 = "#1865F2";
const defaultDomain2 = "#66afe9";
const defaultDomain3 = "#1152b0";
const defaultDomain4 = "#0d3d82";
const defaultDomainColor = "#314453";
const defaultSubjectColor = "#4D6779";
const defaultTopicColor = "#6A8DA6";
const defaultHoverColor = "#314453";
const defaultLinkColor = "#314453";
const defaultLinkHoverColor = "#6A8DA6";
const scienceDomainColor = "#94424F";
const scienceSubjectColor = "#9D4A5A";
const scienceTopicColor = "#C55F73";
const scienceHoverColor = "#94424F";
const scienceLinkColor = "#94424F";
const scienceLinkHoverColor = "#C55F73";
const humanitiesDomainColor = "#AD3434";
const humanitiesSubjectColor = "#C13B31";
const humanitiesTopicColor = "#D24A45";
const humanitiesHoverColor = "#AD3434";
const humanitiesLinkColor = "#AD3434";
const humanitiesLinkHoverColor = "#D24A45";
const economicsDomainColor = "#B77033";
const economicsSubjectColor = "#BF7B34";
const economicsTopicColor = "#D1933B";
const economicsHoverColor = "#B77033";
const economicsLinkColor = "#B77033";
const economicsLinkHoverColor = "#D1933B";
const csDomainColor = "#437A39";
const csSubjectColor = "#53893E";
const csTopicColor = "#689B51";
const csHoverColor = "#437A39";
const csLinkColor = "#437A39";
const csLinkHoverColor = "#689B51";
const partnerContentDomainColor = "#218270";
const partnerContentSubjectColor = "#2C8D7B";
const partnerContentTopicColor = "#329A86";
const partnerContentHoverColor = "#218270";
const partnerContentLinkColor = "#218270";
const partnerContentLinkHoverColor = "#329A86";
const essayDomainColor = "#0071B3";
const mathDomainColor = "#1C758A";
const mathSubjectColor = "#46A8BF";
const mathTopicColor = "#4FBAD4";
const mathHoverColor = "#1C758A";
const mathLinkColor = "#1C758A";
const mathLinkHoverColor = "#4FBAD4";
const testPrepDomainColor = "#644172";
const testPrepSubjectColor = "#7E5F8E";
const testPrepTopicColor = "#9A72AC";
const testPrepHoverColor = "#644172";
const testPrepLinkColor = "#644172";
const testPrepLinkHoverColor = "#9A72AC";
const collegeCareersMoreDomainColor = "#218270";
const collegeCareersMoreSubjectColor = "#2C8D7B";
const collegeCareersMoreTopicColor = "#329A86";
const collegeCareersMoreHoverColor = "#218270";
const collegeCareersMoreLinkColor = "#218270";
const collegeCareersMoreLinkHoverColor = "#329A86";
const colorProficient = "#1C758A";
const colorPracticed = "rgb(158, 221, 235)";
const colorMastery1 = "rgb(90, 197, 221)";
const colorMastery2 = "rgb(42, 174, 203)";
const colorMastery3 = "#1C758A";
const colorSuggested = "#73982C";
const colorReview = "#E35D04";
const colorNotStarted = "#CCCCCC";
const colorStarted = "#C7E5F7";
const colorStruggling = "#C30202";
const colorPersonal = "#00809C";
const colorPractice = "#96D9FF";
const colorEnergyPoints = "#005987";
const pureSmMin = "568px";
const pureMdMin = "768px";
const pureLgMin = "1024px";
const pureXlMin = "1200px";
const pureXsMax = "567px";
const pureSmMax = "767px";
const pureMdMax = "1023px";
const pureLgMax = "1199px";

var globalConstants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    black: black,
    grayDarker: grayDarker,
    grayDark: grayDark,
    gray: gray,
    grayLight: grayLight,
    grayLighter: grayLighter,
    white: white,
    blue: blue,
    blueDark: blueDark,
    green: green,
    red: red,
    yellow: yellow,
    orange: orange,
    pink: pink,
    purple: purple,
    bodyBackground: bodyBackground,
    textColor: textColor,
    linkColor: linkColor,
    linkColorHover: linkColorHover,
    sansFontFamily: sansFontFamily,
    serifFontFamily: serifFontFamily,
    monoFontFamily: monoFontFamily,
    baseFontSize: baseFontSize,
    baseFontFamily: baseFontFamily,
    baseLineHeight: baseLineHeight,
    altFontFamily: altFontFamily,
    headingsFontFamily: headingsFontFamily,
    headingsFontWeight: headingsFontWeight,
    headingsColor: headingsColor,
    fontSizeLarge: fontSizeLarge,
    fontSizeSmall: fontSizeSmall,
    fontSizeMini: fontSizeMini,
    paddingLarge: paddingLarge,
    paddingSmall: paddingSmall,
    paddingMini: paddingMini,
    baseBorderRadius: baseBorderRadius,
    borderRadiusLarge: borderRadiusLarge,
    borderRadiusSmall: borderRadiusSmall,
    tableBackground: tableBackground,
    tableBackgroundAccent: tableBackgroundAccent,
    tableBackgroundHover: tableBackgroundHover,
    tableBorder: tableBorder,
    btnBackground: btnBackground,
    btnBackgroundHighlight: btnBackgroundHighlight,
    btnBorder: btnBorder,
    btnPrimaryBackground: btnPrimaryBackground,
    btnPrimaryBackgroundHighlight: btnPrimaryBackgroundHighlight,
    btnInfoBackground: btnInfoBackground,
    btnInfoBackgroundHighlight: btnInfoBackgroundHighlight,
    btnSuccessBackground: btnSuccessBackground,
    btnSuccessBackgroundHighlight: btnSuccessBackgroundHighlight,
    btnWarningBackground: btnWarningBackground,
    btnWarningBackgroundHighlight: btnWarningBackgroundHighlight,
    btnDangerBackground: btnDangerBackground,
    btnDangerBackgroundHighlight: btnDangerBackgroundHighlight,
    btnInverseBackground: btnInverseBackground,
    btnInverseBackgroundHighlight: btnInverseBackgroundHighlight,
    inputBackground: inputBackground,
    inputBorder: inputBorder,
    inputBorderRadius: inputBorderRadius,
    inputDisabledBackground: inputDisabledBackground,
    formActionsBackground: formActionsBackground,
    inputHeight: inputHeight,
    dropdownBackground: dropdownBackground,
    dropdownBorder: dropdownBorder,
    dropdownDividerTop: dropdownDividerTop,
    dropdownDividerBottom: dropdownDividerBottom,
    dropdownLinkColor: dropdownLinkColor,
    dropdownLinkColorHover: dropdownLinkColorHover,
    dropdownLinkColorActive: dropdownLinkColorActive,
    dropdownLinkBackgroundActive: dropdownLinkBackgroundActive,
    dropdownLinkBackgroundHover: dropdownLinkBackgroundHover,
    zindexDropdown: zindexDropdown,
    zindexPopover: zindexPopover,
    zindexTooltip: zindexTooltip,
    zindexFixedNavbar: zindexFixedNavbar,
    zindexHeader: zindexHeader,
    zindexModalBackdrop: zindexModalBackdrop,
    zindexModal: zindexModal,
    zindexAboveModal: zindexAboveModal,
    iconSpritePath: iconSpritePath,
    iconWhiteSpritePath: iconWhiteSpritePath,
    placeholderText: placeholderText,
    hrBorder: hrBorder,
    horizontalComponentOffset: horizontalComponentOffset,
    wellBackground: wellBackground,
    navbarCollapseWidth: navbarCollapseWidth,
    navbarCollapseDesktopWidth: navbarCollapseDesktopWidth,
    navbarHeight: navbarHeight,
    navbarBackgroundHighlight: navbarBackgroundHighlight,
    navbarBackground: navbarBackground,
    navbarBorder: navbarBorder,
    navbarText: navbarText,
    navbarLinkColor: navbarLinkColor,
    navbarLinkColorHover: navbarLinkColorHover,
    navbarLinkColorActive: navbarLinkColorActive,
    navbarLinkBackgroundHover: navbarLinkBackgroundHover,
    navbarLinkBackgroundActive: navbarLinkBackgroundActive,
    navbarBrandColor: navbarBrandColor,
    navbarInverseBackground: navbarInverseBackground,
    navbarInverseBackgroundHighlight: navbarInverseBackgroundHighlight,
    navbarInverseBorder: navbarInverseBorder,
    navbarInverseText: navbarInverseText,
    navbarInverseLinkColor: navbarInverseLinkColor,
    navbarInverseLinkColorHover: navbarInverseLinkColorHover,
    navbarInverseLinkColorActive: navbarInverseLinkColorActive,
    navbarInverseLinkBackgroundHover: navbarInverseLinkBackgroundHover,
    navbarInverseLinkBackgroundActive: navbarInverseLinkBackgroundActive,
    navbarInverseSearchBackground: navbarInverseSearchBackground,
    navbarInverseSearchBackgroundFocus: navbarInverseSearchBackgroundFocus,
    navbarInverseSearchBorder: navbarInverseSearchBorder,
    navbarInverseSearchPlaceholderColor: navbarInverseSearchPlaceholderColor,
    navbarInverseBrandColor: navbarInverseBrandColor,
    paginationBackground: paginationBackground,
    paginationBorder: paginationBorder,
    paginationActiveBackground: paginationActiveBackground,
    heroUnitBackground: heroUnitBackground,
    heroUnitHeadingColor: heroUnitHeadingColor,
    heroUnitLeadColor: heroUnitLeadColor,
    warningText: warningText,
    warningBackground: warningBackground,
    warningBorder: warningBorder,
    errorText: errorText,
    errorBackground: errorBackground,
    errorBorder: errorBorder,
    successText: successText,
    successBackground: successBackground,
    successBorder: successBorder,
    infoText: infoText,
    infoBackground: infoBackground,
    infoBorder: infoBorder,
    tooltipColor: tooltipColor,
    tooltipBackground: tooltipBackground,
    tooltipArrowWidth: tooltipArrowWidth,
    tooltipArrowColor: tooltipArrowColor,
    popoverBackground: popoverBackground,
    popoverArrowWidth: popoverArrowWidth,
    popoverArrowColor: popoverArrowColor,
    popoverTitleBackground: popoverTitleBackground,
    popoverArrowOuterWidth: popoverArrowOuterWidth,
    popoverArrowOuterColor: popoverArrowOuterColor,
    gridColumns: gridColumns,
    gridColumnWidth: gridColumnWidth,
    gridGutterWidth: gridGutterWidth,
    gridRowWidth: gridRowWidth,
    gridColumnWidth1200: gridColumnWidth1200,
    gridGutterWidth1200: gridGutterWidth1200,
    gridRowWidth1200: gridRowWidth1200,
    gridColumnWidth768: gridColumnWidth768,
    gridGutterWidth768: gridGutterWidth768,
    gridRowWidth768: gridRowWidth768,
    fluidGridColumnWidth: fluidGridColumnWidth,
    fluidGridGutterWidth: fluidGridGutterWidth,
    fluidGridColumnWidth1200: fluidGridColumnWidth1200,
    fluidGridGutterWidth1200: fluidGridGutterWidth1200,
    fluidGridColumnWidth768: fluidGridColumnWidth768,
    fluidGridGutterWidth768: fluidGridGutterWidth768,
    kaGreen: kaGreen,
    kaGreenLight: kaGreenLight,
    kaBlue: kaBlue,
    kaBlueLight: kaBlueLight,
    grayExtraDark: grayExtraDark,
    grayExtraLight: grayExtraLight,
    graySuperLight: graySuperLight,
    whiteDark: whiteDark,
    dark: dark,
    blueDarkUnsaturated: blueDarkUnsaturated,
    blueDarkSaturated: blueDarkSaturated,
    blueLight: blueLight,
    greenLight: greenLight,
    greenDark: greenDark,
    yellowGreen: yellowGreen,
    okGreen: okGreen,
    alertRed: alertRed,
    coral: coral,
    grayBlue: grayBlue,
    lightPageBackground: lightPageBackground,
    yclaBlue: yclaBlue,
    yclaTeal: yclaTeal,
    yclaTealDark: yclaTealDark,
    yclaGreenDark: yclaGreenDark,
    yclaGreen: yclaGreen,
    learnstormBlue: learnstormBlue,
    homepageBlue: homepageBlue,
    backgroundBlue: backgroundBlue,
    teacherSignupBlue: teacherSignupBlue,
    homepageGreen: homepageGreen,
    streakColor: streakColor,
    facebookColor: facebookColor,
    blueGoogleColor: blueGoogleColor,
    redGoogleColor: redGoogleColor,
    homepageColor: homepageColor,
    lightTextColor: lightTextColor,
    fontSizeTiny: fontSizeTiny,
    fontSizeNormal: fontSizeNormal,
    fontSizeMedium: fontSizeMedium,
    fontSizeExtraLarge: fontSizeExtraLarge,
    fontSizeHuge: fontSizeHuge,
    fontSizeBakana: fontSizeBakana,
    fontSizeBananas: fontSizeBananas,
    fixedWidthFontFamily: fixedWidthFontFamily,
    contentPadding: contentPadding,
    primaryButtonBackground: primaryButtonBackground,
    primaryButtonBorder: primaryButtonBorder,
    buttonTextColor: buttonTextColor,
    buttonBorderRadius: buttonBorderRadius,
    basicBorderColor: basicBorderColor,
    minContainerWidth: minContainerWidth,
    maxContainerWidth: maxContainerWidth,
    formHintColor: formHintColor,
    guidelineExampleText: guidelineExampleText,
    hoverCardWidth: hoverCardWidth,
    menuHighlightColor: menuHighlightColor,
    menuHighlightBorderColor: menuHighlightBorderColor,
    menuActiveTextColor: menuActiveTextColor,
    menuInactiveTextColor: menuInactiveTextColor,
    menuSubheaderTextColor: menuSubheaderTextColor,
    menuBorderColor: menuBorderColor,
    unreadBackgroundColor: unreadBackgroundColor,
    menuLineHeight: menuLineHeight,
    menuSubheaderLineHeight: menuSubheaderLineHeight,
    menuSubheaderFontSize: menuSubheaderFontSize,
    notificationBarColor: notificationBarColor,
    modalBodyTopPadding: modalBodyTopPadding,
    modalDialogPadding: modalDialogPadding,
    modalSectionPadding: modalSectionPadding,
    mathDomain1: mathDomain1,
    mathDomain2: mathDomain2,
    mathDomain3: mathDomain3,
    mathDomain4: mathDomain4,
    partnerContentDomain1: partnerContentDomain1,
    partnerContentDomain2: partnerContentDomain2,
    partnerContentDomain3: partnerContentDomain3,
    partnerContentDomain4: partnerContentDomain4,
    csDomain1: csDomain1,
    csDomain2: csDomain2,
    csDomain3: csDomain3,
    csDomain4: csDomain4,
    economicsDomain1: economicsDomain1,
    economicsDomain2: economicsDomain2,
    economicsDomain3: economicsDomain3,
    economicsDomain4: economicsDomain4,
    collegeCareersMoreDomain1: collegeCareersMoreDomain1,
    collegeCareersMoreDomain2: collegeCareersMoreDomain2,
    collegeCareersMoreDomain3: collegeCareersMoreDomain3,
    collegeCareersMoreDomain4: collegeCareersMoreDomain4,
    humanitiesDomain1: humanitiesDomain1,
    humanitiesDomain2: humanitiesDomain2,
    humanitiesDomain3: humanitiesDomain3,
    humanitiesDomain4: humanitiesDomain4,
    gtpDomain1: gtpDomain1,
    gtpDomain2: gtpDomain2,
    gtpDomain3: gtpDomain3,
    gtpDomain4: gtpDomain4,
    scienceDomain1: scienceDomain1,
    scienceDomain2: scienceDomain2,
    scienceDomain3: scienceDomain3,
    scienceDomain4: scienceDomain4,
    testPrepDomain1: testPrepDomain1,
    testPrepDomain2: testPrepDomain2,
    testPrepDomain3: testPrepDomain3,
    testPrepDomain4: testPrepDomain4,
    defaultDomain1: defaultDomain1,
    defaultDomain2: defaultDomain2,
    defaultDomain3: defaultDomain3,
    defaultDomain4: defaultDomain4,
    defaultDomainColor: defaultDomainColor,
    defaultSubjectColor: defaultSubjectColor,
    defaultTopicColor: defaultTopicColor,
    defaultHoverColor: defaultHoverColor,
    defaultLinkColor: defaultLinkColor,
    defaultLinkHoverColor: defaultLinkHoverColor,
    scienceDomainColor: scienceDomainColor,
    scienceSubjectColor: scienceSubjectColor,
    scienceTopicColor: scienceTopicColor,
    scienceHoverColor: scienceHoverColor,
    scienceLinkColor: scienceLinkColor,
    scienceLinkHoverColor: scienceLinkHoverColor,
    humanitiesDomainColor: humanitiesDomainColor,
    humanitiesSubjectColor: humanitiesSubjectColor,
    humanitiesTopicColor: humanitiesTopicColor,
    humanitiesHoverColor: humanitiesHoverColor,
    humanitiesLinkColor: humanitiesLinkColor,
    humanitiesLinkHoverColor: humanitiesLinkHoverColor,
    economicsDomainColor: economicsDomainColor,
    economicsSubjectColor: economicsSubjectColor,
    economicsTopicColor: economicsTopicColor,
    economicsHoverColor: economicsHoverColor,
    economicsLinkColor: economicsLinkColor,
    economicsLinkHoverColor: economicsLinkHoverColor,
    csDomainColor: csDomainColor,
    csSubjectColor: csSubjectColor,
    csTopicColor: csTopicColor,
    csHoverColor: csHoverColor,
    csLinkColor: csLinkColor,
    csLinkHoverColor: csLinkHoverColor,
    partnerContentDomainColor: partnerContentDomainColor,
    partnerContentSubjectColor: partnerContentSubjectColor,
    partnerContentTopicColor: partnerContentTopicColor,
    partnerContentHoverColor: partnerContentHoverColor,
    partnerContentLinkColor: partnerContentLinkColor,
    partnerContentLinkHoverColor: partnerContentLinkHoverColor,
    essayDomainColor: essayDomainColor,
    mathDomainColor: mathDomainColor,
    mathSubjectColor: mathSubjectColor,
    mathTopicColor: mathTopicColor,
    mathHoverColor: mathHoverColor,
    mathLinkColor: mathLinkColor,
    mathLinkHoverColor: mathLinkHoverColor,
    testPrepDomainColor: testPrepDomainColor,
    testPrepSubjectColor: testPrepSubjectColor,
    testPrepTopicColor: testPrepTopicColor,
    testPrepHoverColor: testPrepHoverColor,
    testPrepLinkColor: testPrepLinkColor,
    testPrepLinkHoverColor: testPrepLinkHoverColor,
    collegeCareersMoreDomainColor: collegeCareersMoreDomainColor,
    collegeCareersMoreSubjectColor: collegeCareersMoreSubjectColor,
    collegeCareersMoreTopicColor: collegeCareersMoreTopicColor,
    collegeCareersMoreHoverColor: collegeCareersMoreHoverColor,
    collegeCareersMoreLinkColor: collegeCareersMoreLinkColor,
    collegeCareersMoreLinkHoverColor: collegeCareersMoreLinkHoverColor,
    colorProficient: colorProficient,
    colorPracticed: colorPracticed,
    colorMastery1: colorMastery1,
    colorMastery2: colorMastery2,
    colorMastery3: colorMastery3,
    colorSuggested: colorSuggested,
    colorReview: colorReview,
    colorNotStarted: colorNotStarted,
    colorStarted: colorStarted,
    colorStruggling: colorStruggling,
    colorPersonal: colorPersonal,
    colorPractice: colorPractice,
    colorEnergyPoints: colorEnergyPoints,
    pureSmMin: pureSmMin,
    pureMdMin: pureMdMin,
    pureLgMin: pureLgMin,
    pureXlMin: pureXlMin,
    pureXsMax: pureXsMax,
    pureSmMax: pureSmMax,
    pureMdMax: pureMdMax,
    pureLgMax: pureLgMax
});

const colors$1 = {
  white: "#FFFFFF",
  gray98: "#FAFAFA",
  gray97: "#F6F7F7",
  gray95: "#F0F1F2",
  gray90: "#E3E5E6",
  gray85: "#D6D8DA",
  gray76: "#BABEC2",
  gray72: "#999A9D",
  gray68: "#888D93",
  gray55: "#707378",
  gray41: "#626569",
  gray25: "#3B3E40",
  gray17: "#21242C",
  gray10: "#1499af",
  black: "#000000",
  // These colors are pulled out from constants.js, which is itself generated
  // from variables.less. We should probably avoid duplicating these here.
  alertRed,
  homepageBlue,
  kaBlue,
  kaBlueLight,
  kaGreen,
  kaGreenLight,
  learnstormBlue,
  backgroundBlue,
  adminGreen: "#78C008",
  kaBlueExtraLight: "#39c2db",
  kaBlueHover: "#0c7f99",
  kaGreenHover: "#518005",
  // Domain-agnostic colors related to the study guide experience in the
  // content library.
  skyDark: "#001f4d",
  recommendationGold: "#ffbe26",
  starAced: "#ff9c39",
  // We interploate the domain colors into this colors object for
  // historical reasons, but everyone using domain-specific colors
  // should switch to using the domainColors() function to look up
  // colors instead.
  //
  // TODO(davidflanagan): remove this line once everything is
  // working correctly with the domainColors() accessor.
  // ...domainToColorsMap,
  // mission: missionColors,

  // Colors for various OAuth providers
  google: "#C1432f",
  modernGoogle: "#be2612",
  modernGoogleHover: "#8c1c0d",
  facebook: "#4267B2",
  modernFacebook: "#4267B2",
  modernFacebookHover: "#00294a",
  wonderBlocksGold: "#FFB100",
  wonderBlocksLightBlue: "#37C5FD",
  // We're using rgba instead of opacity to avoid affecting the focus outline
  // when we just want to make the color transparent.
  breadcrumbs: "rgba(255, 255, 255, 0.7)"
};
const borderRadius = 4;
const breadcrumbStyles = {
  color: colors$1.breadcrumbs,
  fontFamily: "inherit",
  fontSize: 15,
  fontWeight: "bold",
  letterSpacing: 0.8,
  lineHeight: "19px",
  textTransform: "uppercase",
  // Disable subpixel antialiasing for OSX (improves light on dark text)
  MozOsxFontSmoothing: "grayscale",
  WebkitFontSmoothing: "antialiased"
};
const fonts = {
  // The body of the page is setup to use 'Helvetica' by default and
  // 'Lato' if/once it downloads. For your elements to follow this
  // pattern, all you need is to make the text in your element
  // inherit from the body using the "inherit" value.
  regular: "inherit"
};
const typography = {
  // For subject names
  subjectHeadingDesktop: {
    fontFamily: "inherit",
    fontSize: 50,
    fontWeight: "bold",
    lineHeight: "61px"
  },
  subjectHeadingMobile: {
    fontFamily: "inherit",
    fontSize: 35,
    fontWeight: "bold",
    lineHeight: "37px"
  },
  // For the most important thing on the page
  conceptHeadingDesktop: {
    fontFamily: "inherit",
    fontSize: 35,
    fontWeight: "bold",
    lineHeight: "37px"
  },
  conceptHeadingMobile: {
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  // For sections or modules
  subheadingDesktop: {
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  subheadingMobile: {
    fontFamily: "inherit",
    fontSize: 20,
    fontWeight: "bold",
    lineHeight: "24px"
  },
  smallSubheadingDesktop: {
    fontFamily: "inherit",
    fontSize: 20,
    lineHeight: 1.25
  },
  smallSubheadingMobile: {
    fontFamily: "inherit",
    fontSize: 15,
    lineHeight: 1.25
  },
  // For callouts
  smallHeading: {
    color: colors$1.gray25,
    fontFamily: "inherit",
    fontSize: 17,
    fontWeight: "bold",
    lineHeight: "23px"
  },
  smallHeadingMobile: {
    color: colors$1.gray25,
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "18px"
  },
  // Accent headings
  accentHeading: {
    color: colors$1.gray68,
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    letterSpacing: 0.8,
    lineHeight: "19px",
    textTransform: "uppercase"
  },
  bodyLarge: {
    // For articles with multiple paragraphs
    fontFamily: fonts.regular,
    fontSize: 20,
    lineHeight: "30px"
  },
  bodySmall: {
    // For small blocks of copy
    fontFamily: fonts.regular,
    fontSize: 17,
    fontWeight: "normal",
    lineHeight: "23px"
  },
  bodySmallBold: {
    // For small blocks of copy
    fontFamily: fonts.regular,
    fontSize: 17,
    fontWeight: "bold",
    lineHeight: "23px"
  },
  bodyXsmall: {
    // For metadata, descriptions, etc
    fontFamily: fonts.regular,
    fontSize: 15,
    lineHeight: "22px"
  },
  bodyXsmallBold: {
    // For emphasized metadata, descriptions, etc
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "22px"
  },
  breadcrumb: breadcrumbStyles,
  // For in-page tabs, breadcrumbs
  breadcrumbSmall: {
    // For in-page tabs and leaf page breadcrumbs
    ...breadcrumbStyles,
    fontSize: 12,
    lineHeight: "13px"
  },
  labelLarge: {
    // For chiclets and thumbnail titles
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  labelMedium: {
    // For chiclets and thumbnail titles
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "18px"
  },
  labelSmall: {
    // Generally used with labelLarge, for breadcrumbs in thumbnails
    fontFamily: fonts.regular,
    fontSize: 12,
    lineHeight: "14px"
  },
  caption: {
    // For image captions
    fontFamily: fonts.regular,
    fontSize: 14,
    fontStyle: "italic",
    lineHeight: "17px"
  },
  desktopScalingOnMobile: {
    // For when you need Mobile Safari and friends to stick to desktop
    // sizes
    MozTextSizeAdjust: "100%",
    MsTextSizeAdjust: "100%",
    WebkitTextSizeAdjust: "100%"
  },
  // TODO (josh): This should move to within <ModalHeader>
  modalSubtitle: {
    fontSize: 12,
    lineHeight: 1.65,
    // NOTE (josh): Font smoothing used here to create a 'medium' weight
    // font, between normal and bold, on webkit browsers.
    // This prop is an a11y risk when used on non-bold text, since it
    // makes text very thin, but it's fine on bold text.
    WebkitFontSmoothing: "antialiased",
    fontWeight: "bold"
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksHeader: {
    paddingLeft: 16,
    paddingRight: 16,
    paddingBottom: 24,
    paddingTop: 34,
    [mediaQueries.mdOrLarger]: {
      paddingBottom: 32
    }
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksTitle: {
    color: colors$1.white,
    fontWeight: 900,
    // "Black" weight
    fontSize: 28,
    lineHeight: "32px",
    margin: 0,
    [mediaQueries.mdOrLarger]: {
      fontSize: 36,
      lineHeight: "40px"
    }
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksLabelLarge: {
    fontSize: 16,
    lineHeight: "20px",
    fontWeight: 700 // Bold
  }
};

var globalStyles = /*#__PURE__*/Object.freeze({
    __proto__: null,
    colors: colors$1,
    borderRadius: borderRadius,
    fonts: fonts,
    typography: typography
});

class AnswerChoice extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_input", void 0);
    _defineProperty(this, "state", {
      isInputFocused: false
    });
  }
  focusInput() {
    if (this._input) {
      this._input.focus();
    }
  }
  handleClick(e) {
    const {
      checked,
      onChange
    } = this.props;
    e.preventDefault();

    // We manually handle clicks, setting focus on the input control.
    this.focusInput();

    // And toggling the answer selection state.
    onChange(!checked);
  }
  handleKeyDown(e) {
    const {
      onFocusPrevAnswer,
      onFocusNextAnswer
    } = this.props;

    // This may override built-in browser arrow key navigation for radio
    // group. Checkbox fieldset does not have such built-in capability,
    // thus we do this manually for both input types.
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        onFocusPrevAnswer();
        break;
      case "ArrowDown":
        e.preventDefault();
        onFocusNextAnswer();
        break;
    }
  }
  handleInputChange(e) {
    // Prevent answer selection from double-toggling, as `handleClick` is
    // handling changes to selection state.
    e.preventDefault();
  }
  handleInputFocus() {
    this.setState({
      isInputFocused: true
    });
  }
  handleInputBlur() {
    this.setState({
      isInputFocused: false
    });
  }
  renderCheckmark() {
    const {
      checked
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$h.checkmarkContainer)
    }, checked && /*#__PURE__*/React__namespace.createElement(Icon, {
      icon: iconCheckMedium,
      size: 16,
      color: Color__default["default"].offBlack
    }));
  }
  render() {
    const {
      content,
      checked,
      groupName,
      index,
      inputType
    } = this.props;
    const {
      isInputFocused
    } = this.state;
    const answerId = "".concat(groupName, "-").concat(index);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$h.answerChoice, isInputFocused && styles$h.answerFocused),
      onClick: e => this.handleClick(e),
      onKeyDown: e => this.handleKeyDown(e)
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$h.answerInputWrapper)
    }, /*#__PURE__*/React__namespace.createElement("input", {
      className: aphrodite.css(sharedStyles.perseusSrOnly),
      checked: checked,
      name: groupName,
      id: answerId,
      type: inputType,
      onChange: e => this.handleInputChange(e),
      onFocus: () => this.handleInputFocus(),
      onBlur: () => this.handleInputBlur(),
      ref: node => this._input = node
    }), this.renderCheckmark()), /*#__PURE__*/React__namespace.createElement("label", {
      htmlFor: answerId
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: content
    })));
  }
}
class AnswerChoices extends React__namespace.Component {
  // The rendered answers elements.

  constructor(props) {
    super(props);
    _defineProperty(this, "_choices", void 0);
    this._choices = [];
    this.state = {
      groupName: ___default["default"].uniqueId("answer_choices_")
    };
  }
  focusAnswer() {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const numChoices = this.props.choices.length;

    // Wrap the index if necessary.
    if (index < 0) {
      index += numChoices;
    } else if (index >= numChoices) {
      index -= numChoices;
    }
    const choice = this._choices[index];
    if (choice) {
      choice.focusInput();
    }
  }
  onAnswerChange(index, checked) {
    const {
      choices,
      multipleSelect,
      onChange
    } = this.props;
    const selection = [];

    // Compile the selection state of answer choices. In single selection
    // mode (radio input type), only 0 or 1 answer may be chosen.
    for (let i = 0; i < choices.length; i++) {
      selection.push(multipleSelect ? i === index ? checked : choices[i].checked : i === index ? checked : false);
    }
    onChange(selection);
  }
  onFocusAnswer(index) {
    this.focusAnswer(index);
  }
  render() {
    const {
      choices,
      multipleSelect
    } = this.props;
    const {
      groupName
    } = this.state;
    return /*#__PURE__*/React__namespace.createElement("fieldset", null, choices.map((choice, index) => /*#__PURE__*/React__namespace.createElement(AnswerChoice, _extends({}, choice, {
      key: choice.content,
      groupName: groupName,
      index: index,
      inputType: multipleSelect ? "checkbox" : "radio",
      onChange: checked => this.onAnswerChange(index, checked),
      onFocusPrevAnswer: () => this.onFocusAnswer(index - 1),
      onFocusNextAnswer: () => this.onFocusAnswer(index + 1),
      ref: node => this._choices[index] = node
    }))));
  }
}
const styles$h = aphrodite.StyleSheet.create({
  answerChoice: {
    display: "flex",
    alignItems: "center",
    userSelect: "none",
    padding: "10px 16px 10px 0px",
    fontWeight: "bold",
    border: "solid 2px transparent",
    borderRadius: 2,
    ":active": {
      backgroundColor: "rgba(33, 36, 44, 0.08)"
    }
  },
  answerFocused: {
    borderColor: "#1865f2",
    ":active": {
      borderColor: "transparent"
    }
  },
  answerInputWrapper: {
    marginRight: 8
  },
  checkmarkContainer: {
    display: "flex",
    position: "relative",
    width: 16,
    height: 16,
    marginLeft: 8
  }
});

class Marker extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_icon", void 0);
    _defineProperty(this, "state", {
      isFocused: false
    });
  }
  handleFocus() {
    this.setState({
      isFocused: true
    });
  }
  handleBlur() {
    this.setState({
      isFocused: false
    });
  }
  renderIcon() {
    const {
      selected,
      showCorrectness,
      showSelected,
      showPulsate
    } = this.props;
    const {
      isFocused
    } = this.state;

    // Only a single marker may be "selected" at a time.
    // `showSelected` is a controlled prop, that may be set to `true` for
    // one marker at a time.
    // `isFocused` is a controlled state, driven by focus events, and may
    // only be `true` when there's no answer choices popup visible, and
    // keyboard focus is given to the marker.
    const isSelected = showSelected || isFocused;
    let innerIcon;
    let iconStyles;
    if (showCorrectness) {
      innerIcon = /*#__PURE__*/React__namespace.createElement(Icon, {
        icon: showCorrectness === "correct" ? iconCheck : iconMinus,
        size: 24,
        color: Color__default["default"].white
      });
      if (showCorrectness === "correct") {
        iconStyles = [styles$g.markerCorrect, isSelected && styles$g.markerCorrectSelected];
      } else {
        iconStyles = [styles$g.markerIncorrect, isSelected && styles$g.markerIncorrectSelected];
      }
    } else if (selected && selected.length > 0) {
      iconStyles = [styles$g.markerFilled, isSelected && styles$g.markerFilledSelected];
    } else {
      iconStyles = [isSelected ? styles$g.markerUnfilledSelected : showPulsate && styles$g.markerUnfilledPulsate];
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$g.markerIcon, ...iconStyles),
      ref: node => this._icon = node
    }, innerIcon);
  }
  render() {
    const {
      label,
      x,
      y,
      showCorrectness
    } = this.props;

    // It should no longer be possible to interact with a marker after it
    // has been labeled (answered) correctly.
    const isDisabled = showCorrectness === "correct";
    return /*#__PURE__*/React__namespace.createElement("button", {
      "aria-label": label,
      className: aphrodite.css(styles$g.unstyledButton, styles$g.marker, isDisabled && styles$g.disabled),
      style: {
        left: "".concat(x, "%"),
        top: "".concat(y, "%")
      },
      tabIndex: isDisabled ? -1 : 0,
      onFocus: () => this.handleFocus(),
      onBlur: () => this.handleBlur()
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'MouseEvent<HTMLButtonElement, MouseEvent>' is not assignable to parameter of type 'MouseEvent'.
      ,
      onClick: e => this.props.onClick(e)
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'KeyboardEvent<HTMLButtonElement>' is not assignable to parameter of type 'KeyboardEvent'.
      ,
      onKeyDown: e => this.props.onKeyDown(e)
    }, this.renderIcon());
  }
}
_defineProperty(Marker, "defaultProps", {
  selected: []
});
const markerColor = "#1865f2";
const selectedColor = "#2552b0";
const activeColor = selectedColor;
const correctColor = "#00a60e";
const correctActiveColor = "#167b1f";
const incorrectColor = "#909195";
const incorrectActiveColor = "#6c6e73";
const markerShadowColor = "rgba(33, 36, 44, 0.32)";
const lightShadowColor = "rgba(33, 36, 44, 0.16)";
const styles$g = aphrodite.StyleSheet.create({
  unstyledButton: {
    padding: 0,
    overflow: "visible",
    color: "inherit",
    font: "inherit",
    lineHeight: "normal",
    background: "none",
    border: "none"
  },
  marker: {
    position: "absolute",
    // Center marker position based on it's maximum size.
    width: 30,
    height: 30,
    marginLeft: -15,
    marginTop: -15
  },
  disabled: {
    pointerEvents: "none"
  },
  // The base and unfilled marker style.
  markerIcon: {
    display: "flex",
    position: "relative",
    boxSizing: "content-box",
    width: 16,
    height: 16,
    // Center icon within marker.
    marginLeft: 5,
    cursor: "pointer",
    backgroundColor: markerColor,
    border: "solid 2px #ffffff",
    borderRadius: 16,
    boxShadow: "0 2px 6px 0 ".concat(markerShadowColor)
  },
  markerUnfilledPulsate: {
    animationName: {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(1.5)"
      }
    },
    animationDirection: "alternate",
    animationDuration: "0.8s",
    animationIterationCount: "infinite",
    animationTimingFunction: "ease-in",
    transformOrigin: "50% 50%"
  },
  markerUnfilledSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 20,
      height: 20,
      marginLeft: -4,
      marginTop: -4,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 20
    },
    ":active": {
      backgroundColor: activeColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerFilled: {
    width: 8,
    height: 8,
    // Center icon within marker.
    marginLeft: 9,
    borderRadius: 8,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerFilledSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 12,
      height: 12,
      marginLeft: -4,
      marginTop: -4,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 12
    },
    ":active": {
      backgroundColor: activeColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerCorrect: {
    width: 24,
    height: 24,
    marginLeft: 1,
    marginTop: 1,
    justifyContent: "center",
    alignItems: "center",
    background: correctColor,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerCorrectSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 28,
      height: 28,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 28
    },
    ":active": {
      backgroundColor: correctActiveColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerIncorrect: {
    width: 24,
    height: 24,
    marginLeft: 1,
    marginTop: 1,
    justifyContent: "center",
    alignItems: "center",
    background: incorrectColor,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerIncorrectSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 28,
      height: 28,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 28
    },
    ":active": {
      backgroundColor: incorrectActiveColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  }
});

class LabelImage extends React__namespace.Component {
  // The rendered markers on the question image for labeling.

  // The popup component containing the answer choices.

  // The rendered list of answer choices for the currently selected marker.

  static gradeMarker(marker) {
    const score = {
      hasAnswers: false,
      isCorrect: false
    };
    if (marker.selected && marker.selected.length > 0) {
      // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'hasAnswers' because it is a read-only property.
      score.hasAnswers = true;
    }
    if (marker.answers.length > 0) {
      if (marker.selected && marker.selected.length === marker.answers.length) {
        // All correct answers are selected by the user.
        // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'isCorrect' because it is a read-only property.
        score.isCorrect = marker.selected.every(choice => marker.answers.includes(choice));
      }
    } else if (!marker.selected || marker.selected.length === 0) {
      // Correct as no answers should be selected by the user.
      // @ts-expect-error [FEI-5003] - TS2540 - Cannot assign to 'isCorrect' because it is a read-only property.
      score.isCorrect = true;
    }
    return score;
  }
  static validate(state, rubric) {
    let numAnswered = 0;
    let numCorrect = 0;
    for (const marker of state.markers) {
      const score = LabelImage.gradeMarker(marker);
      if (score.hasAnswers) {
        numAnswered++;
      }
      if (score.isCorrect) {
        numCorrect++;
      }
    }

    // We expect all question markers to be answered before grading.
    if (numAnswered !== state.markers.length) {
      return {
        type: "invalid",
        message: null
      };
    }
    return {
      type: "points",
      // Markers with no expected answers are graded as correct if user
      // makes no answer selection.
      earned: numCorrect === state.markers.length ? 1 : 0,
      total: 1,
      message: null
    };
  }

  /**
   * Test whether point is contained within triangle.
   *
   * Implementation taken from: https://stackoverflow.com/a/2049593
   */
  static pointInTriangle(p, a, b, c) {
    const sign = (p1, p2, p3) => (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
    const b1 = sign(p, a, b) < 0;
    const b2 = sign(p, b, c) < 0;
    const b3 = sign(p, c, a) < 0;
    return b1 === b2 && b2 === b3;
  }

  /**
   * Determine the image side given a marker position (as percent of size).
   */
  static imageSideForMarkerPosition(x, y) {
    // Special handling for when marker is positioned near the horizontal
    // edges of the image. We want to ensure the returned side would not
    // result in a popup rendering that may overflow outside the page.
    if (x < 20) {
      return "left";
    }
    if (x > 80) {
      return "right";
    }

    // Points to define corners (and center) of a rectangle representing
    // the constrained area of the image for which we want to determine the
    // image side.
    const tl = {
      x: 20,
      y: 0
    };
    const tr = {
      x: 80,
      y: 0
    };
    const br = {
      x: 80,
      y: 100
    };
    const bl = {
      x: 20,
      y: 100
    };
    const cp = {
      x: 50,
      y: 50
    };

    // The triangles representing the sides to test.
    const triangles = {
      top: [tl, tr, cp],
      right: [cp, tr, br],
      bottom: [bl, cp, br],
      left: [tl, cp, bl]
    };
    const p = {
      x,
      y
    };

    // Test whether marker is positioned within one of the triangles
    // representing the sides.
    for (const side of Object.keys(triangles)) {
      const corners = triangles[side];

      // @ts-expect-error [FEI-5003] - TS2556 - A spread argument must either have a tuple type or be passed to a rest parameter.
      if (LabelImage.pointInTriangle(p, ...corners)) {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type '"left" | "top" | "center" | "right" | "bottom"'.
        return side;
      }
    }

    // Fallback, if side was not found for marker position.
    return "center";
  }

  /**
   * Calculate the next marker to navigate to, from the "this marker".
   *
   * Given a cardinal navigation direction (in the x or y axis), return the
   * next marker index to visit.
   */
  static navigateToMarkerIndex(navigateDirection, markers, thisIndex) {
    const thisMarker = markers[thisIndex];

    // Sort markers along the direction of navigation from "this" marker.
    const sortedMarkers = markers.map((otherMarker, index) => {
      // Calculate distance and (normalized) vector to the marker from
      // "this" marker.
      const x = otherMarker.x - thisMarker.x;
      const y = otherMarker.y - thisMarker.y;
      const dist = Math.sqrt(x ** 2 + y ** 2);
      return {
        index,
        dist,
        dir: {
          x: dist !== 0 ? x / dist : 0,
          y: dist !== 0 ? y / dist : 0
        }
      };
    }).filter(marker => {
      if (marker.index === thisIndex) {
        return false;
      }

      // Exclude any marker that has been answered correctly,
      // as it should no longer be interacted with by the user.
      return markers[marker.index].showCorrectness !== "correct";
    }).sort((a, b) => {
      // Project distances to the two markers being sorted (from the
      // "this" marker) along the direction of navigation. This will
      // order by the "closest" marker in the direction of navigation,
      // not the "absolute" closest marker to "this" marker.
      // We round the calculated distances so that if markers are
      // found to be positioned "close enough" to the "this" marker,
      // they will be treated as coplanar with it.
      const distA = Math.round(a.dist * (navigateDirection.x * a.dir.x + navigateDirection.y * a.dir.y));
      const distB = Math.round(b.dist * (navigateDirection.x * b.dir.x + navigateDirection.y * b.dir.y));
      let dirA;
      let dirB;
      // Determine whether the two markers lie ahead or behind the
      // "this" marker. A marker that lies in the same plane as the
      // "this" marker will be considered to be behind it.
      // Only navigation in the "x" or "y" axis is supported, no
      // diagonals.
      if (navigateDirection.x > 0) {
        dirA = a.dir.x > 0 && distA !== 0;
        dirB = b.dir.x > 0 && distB !== 0;
      } else if (navigateDirection.x < 0) {
        dirA = a.dir.x < 0 && distA !== 0;
        dirB = b.dir.x < 0 && distB !== 0;
      } else if (navigateDirection.y > 0) {
        dirA = a.dir.y > 0 && distA !== 0;
        dirB = b.dir.y > 0 && distB !== 0;
      } else if (navigateDirection.y < 0) {
        dirA = a.dir.y < 0 && distA !== 0;
        dirB = b.dir.y < 0 && distB !== 0;
      }

      // If one of the markers is positioned behind, sort the other
      // marker ahead of it in the order.
      if (dirA !== dirB) {
        if (dirA) {
          return -1;
        }
        return 1;
      }

      // Both markers are either positioned ahead or behind, sort the
      // closest (or furthest if behind, to "wrap" navigation) marker
      // ahead in the order.
      return distA - distB;
    });

    // Return the index in the provided markers array of the closest marker
    // found along the direction of navigation, or "this" index if no other
    // marker was found. This may happen if the user has answered all but
    // one ("this" marker) of the markers correctly in the question.
    return sortedMarkers.length > 0 ? sortedMarkers[0].index : thisIndex;
  }
  constructor(props) {
    super(props);
    _defineProperty(this, "_markers", void 0);
    _defineProperty(this, "_selectedMarkerPopup", void 0);
    _defineProperty(this, "_answerChoices", void 0);
    _defineProperty(this, "handleDocumentClick", e => {
      // Dismiss open popup with answer choices if user clicks outside it.
      if (this._selectedMarkerPopup && this._answerChoices) {
        const answerChoices = ReactDOM__namespace.findDOMNode(this._answerChoices);
        const targetElement = e.target;
        // HACK(michaelpolyak): We want to determine if the click target is
        // contained within the popup layer. As there's no public interface
        // to get this layer from the popup, we traverse several levels of
        // answer choices parents to test whether the click target is
        // contained within.
        const containsEventTarget = function (element) {
          let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
          return element && (element.contains(targetElement) || depth > 0 && containsEventTarget(element.parentElement, depth - 1));
        };
        if (!containsEventTarget(answerChoices)) {
          // Close popup and set focus back to the marker for which it was
          // open.
          this.dismissMarkerPopup();
        }
      }
    });
    _defineProperty(this, "handleDocumentKeyDown", e => {
      // Dismiss open popup with answer choices if user presses Escape key.
      if (this._selectedMarkerPopup && e.keyCode === 27) {
        // Ensure other listeners are not triggered on key down event that
        // closes the popup, as this will also dismiss the modal that the
        // widget may be rendered within.
        e.stopPropagation();

        // Close popup and set focus back to the marker for which it was
        // open.
        this.dismissMarkerPopup();
      }
    });
    this._markers = [];
    this.state = {
      selectedMarkerIndex: -1,
      markersInteracted: false
    };
  }
  componentDidMount() {
    document.addEventListener("click", this.handleDocumentClick, true);
    document.addEventListener("keydown", this.handleDocumentKeyDown, true);
  }
  componentWillUnmount() {
    document.removeEventListener("click", this.handleDocumentClick, true);
    document.removeEventListener("keydown", this.handleDocumentKeyDown, true);
  }
  simpleValidate(rubric) {
    return LabelImage.validate(this.getUserInput(), rubric);
  }
  getUserInput() {
    const {
      markers
    } = this.props;
    return {
      markers
    };
  }
  showRationalesForCurrentlySelectedChoices(rubric) {
    const {
      markers
    } = this.props;
    const {
      onChange
    } = this.props;
    const updatedMarkers = markers.map(marker => {
      const score = LabelImage.gradeMarker(marker);
      return {
        ...marker,
        // Reveal correctness state for markers with answers.
        showCorrectness: score.hasAnswers ? score.isCorrect ? "correct" : "incorrect" : undefined
      };
    });

    // Update Perseus widget state with user selected answers without
    // triggering interaction events for listeners.
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'null' is not assignable to parameter of type '(() => unknown) | undefined'.
    onChange({
      markers: updatedMarkers
    }, null, true);
  }
  dismissMarkerPopup() {
    const {
      selectedMarkerIndex: index
    } = this.state;

    // No popup should be open if there's no selected marker.
    if (index === -1) {
      return;
    }
    this.setState({
      selectedMarkerIndex: -1
    }, () => {
      const marker = this._markers[index];
      // Set focus on the just-deselected-marker, to enable to resume
      // navigating between the markers using the keyboard.
      if (marker) {
        ReactDOM__namespace.findDOMNode(marker).focus();
      }
    });
  }
  handleMarkerChange(index, marker) {
    const {
      markers,
      onChange
    } = this.props;

    // Replace marker with a changed version at the specified index.
    const updatedMarkers = [...markers.slice(0, index), {
      ...marker,
      // Do not show correctness state if user changes answer
      // selection for marker.
      showCorrectness: undefined
    }, ...markers.slice(index + 1)];

    // Update Perseus widget state with user selected answers.
    onChange({
      markers: updatedMarkers
    });
  }
  handleMarkerClick(index, e) {
    const {
      selectedMarkerIndex
    } = this.state;
    e.preventDefault();

    // Select the marker, revealing answer choices.
    if (selectedMarkerIndex !== index) {
      this.setState({
        selectedMarkerIndex: index,
        markersInteracted: true
      }, () => {
        // A delay is required to allow answer choices to first render
        // before trying to set focus on the first choice.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          if (this._answerChoices) {
            this._answerChoices.focusAnswer();
          }
        }, 100);
      });
    } else {
      // The answer choices are shown within a popup attached to the
      // selected marker. Close the popup and set focus back to the
      // marker.
      this.dismissMarkerPopup();
    }
  }
  handleMarkerKeyDown(index, e) {
    const {
      markers
    } = this.props;

    // One is the loneliest number.
    if (markers.length < 2) {
      return;
    }

    // Only navigation in the "x" or "y" axis is supported, no diagonals.
    const navigateDirection = {
      ArrowUp: {
        x: 0,
        y: -1
      },
      ArrowRight: {
        x: 1,
        y: 0
      },
      ArrowDown: {
        x: 0,
        y: 1
      },
      ArrowLeft: {
        x: -1,
        y: 0
      }
    }[e.key];
    if (!navigateDirection) {
      return;
    }
    e.preventDefault();

    // Focus on the closest marker along the direction of navigation.
    const marker = this._markers[LabelImage.navigateToMarkerIndex(
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ x: number; y: number; } | { x: number; y: number; } | { x: number; y: number; } | { x: number; y: number; }' is not assignable to parameter of type 'Direction'.
    navigateDirection, markers, index)];
    if (marker) {
      ReactDOM__namespace.findDOMNode(marker).focus();
    }
  }
  handleAnswerChoicesChangeForMarker(index, selection) {
    const {
      choices,
      markers,
      multipleAnswers
    } = this.props;

    // Compile the user selected answer choices.
    const selected = choices.filter((choice, index) => selection[index]);
    this.handleMarkerChange(index, {
      ...markers[index],
      selected
    });
    if (!multipleAnswers) {
      this.dismissMarkerPopup();
    }
  }
  renderAnswerChoicesForMarker(index, marker) {
    const {
      choices,
      multipleAnswers
    } = this.props;

    // The user selected answer choices.
    const selected = marker.selected;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]("perseus-label-image-widget-answer-choices", aphrodite.css(styles$f.scrollableChoices))
    }, /*#__PURE__*/React__namespace.createElement(AnswerChoices, {
      choices: choices.map(choice => ({
        content: choice,
        checked: selected ? selected.includes(choice) : false
      })),
      multipleSelect: multipleAnswers,
      onChange: selection => this.handleAnswerChoicesChangeForMarker(index, selection),
      ref: node => this._answerChoices = node
    }));
  }
  renderMarkers() {
    const {
      markers,
      questionCompleted
    } = this.props;
    const {
      selectedMarkerIndex,
      markersInteracted
    } = this.state;

    // Render all markers for widget.
    return markers.map((marker, index) => {
      const score = LabelImage.gradeMarker(marker);
      const element = /*#__PURE__*/React__namespace.createElement(Marker, _extends({}, marker, {
        // Once the question is answered, show markers
        // with correct answers, otherwise passthrough
        // the correctness state.
        showCorrectness: questionCompleted && score.hasAnswers && score.isCorrect ? "correct" : marker.showCorrectness,
        showSelected: index === selectedMarkerIndex,
        showPulsate: !markersInteracted,
        key: "".concat(marker.x, ".").concat(marker.y),
        onClick: e => this.handleMarkerClick(index, e),
        onKeyDown: e => this.handleMarkerKeyDown(index, e),
        ref: node => this._markers[index] = node
      }));

      // The user selected marker is wrapped with a popup that shows its
      // answer choices, otherwise it's returned as is.
      if (index !== selectedMarkerIndex) {
        return element;
      }

      // Determine whether page is rendered in a narrow browser window.
      const isNarrowPage = window.matchMedia(mediaQueries.xsOrSmaller.replace("@media ", "")).matches;
      let side;
      // Position popup closest to the center, preferring it renders
      // entirely within the image area.
      if (isNarrowPage) {
        side = marker.y > 50 ? "top" : "bottom";
      } else {
        // This mirrors the calculated side of where the marker is
        // located within the image, so that popup appears closer to
        // the image center.
        side = {
          left: "right",
          top: "bottom",
          right: "left",
          bottom: "top",
          center: "top"
        }[LabelImage.imageSideForMarkerPosition(marker.x, marker.y)];
      }

      // TODO(michaelpolyak): Ideally we would always render markers
      // wrapped in the popover. Setting `opened={false}` for those
      // markers that are unselected (to hide their popup), this would
      // keep the React tree more stable.
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
        content: () => /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContentCore, {
          style: styles$f.choicesPopover
        }, this.renderAnswerChoicesForMarker(index, marker)),
        placement: side,
        opened: true,
        key: "".concat(marker.x, ".").concat(marker.y),
        ref: node => this._selectedMarkerPopup = node
      }, element);
    });
  }
  renderInstructions() {
    const {
      apiOptions: {
        isMobile
      },
      choices,
      multipleAnswers,
      hideChoicesFromInstructions: hideChoices
    } = this.props;
    const promptString = isMobile ? multipleAnswers ? i18n__namespace._("Tap each dot on the image to select all answers that apply.") : i18n__namespace._("Tap each dot on the image to select an answer.") : multipleAnswers ? i18n__namespace._("Click each dot on the image to select all answers that apply.") : i18n__namespace._("Click each dot on the image to select an answer.");
    const choicesString = i18n__namespace._("Choices:");
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]("perseus-label-image-widget-instructions", aphrodite.css(styles$f.instructions))
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$f.instructionsCaption)
    }, promptString, " ", !hideChoices && choicesString), !hideChoices && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$f.instructionsChoices)
    }, choices.map((choice, index) => /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$f.instructionsChoice),
      key: index
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: choice
    })))));
  }
  render() {
    const {
      imageAlt,
      imageUrl,
      imageWidth,
      imageHeight
    } = this.props;
    const {
      selectedMarkerIndex
    } = this.state;
    return /*#__PURE__*/React__namespace.createElement("div", null, this.renderInstructions(), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$f.markersCanvas),
      style: {
        maxWidth: imageWidth,
        maxHeight: imageHeight
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$f.imageContainer,
      // Ensure image interaction is disabled while answer
      // choices popup is visible. This addresses specific
      // case where user may click on question image to
      // dismiss the popup. If the image is larger in size
      // than its rendered in the widget, this would
      // result in a zoom of the image.
      selectedMarkerIndex !== -1 && styles$f.imageInteractionDisabled)
    }, /*#__PURE__*/React__namespace.createElement(context$2.Consumer, null, _ref => {
      let {
        setAssetStatus
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(SvgImage, {
        alt: imageAlt,
        src: imageUrl,
        width: imageWidth,
        height: imageHeight,
        setAssetStatus: setAssetStatus
      });
    })), this.renderMarkers()));
  }
}
const styles$f = aphrodite.StyleSheet.create({
  instructions: {
    paddingBottom: 16
  },
  instructionsCaption: {
    ...typography.bodyXsmallBold,
    paddingBottom: 16
  },
  instructionsChoices: {
    display: "flex",
    flexWrap: "wrap",
    margin: "-8px 0"
  },
  instructionsChoice: {
    display: "flex",
    alignItems: "center",
    margin: "8px 0",
    ":not(:last-child)": {
      "::after": {
        content: "''",
        display: "inline-block",
        position: "relative",
        width: 2,
        height: 2,
        marginLeft: 5,
        marginRight: 5,
        background: "rgba(33, 36, 44, 0.32)",
        borderRadius: 2
      }
    }
  },
  markersCanvas: {
    position: "relative"
  },
  imageContainer: {
    // Remove the additional height added due to white-spacing, this ensures
    // markers canvas will have the same height as the question image.
    display: "flex"
  },
  imageInteractionDisabled: {
    pointerEvents: "none"
  },
  scrollableChoices: {
    paddingTop: 8,
    paddingBottom: 8,
    // Enable scroll for answer choices within popup on mobile phones.
    [mediaQueries.xsOrSmaller]: {
      maxHeight: 250,
      overflowY: "auto"
    }
  },
  choicesPopover: {
    padding: 0
  }
});
var LabelImage$1 = {
  name: "label-image",
  displayName: "Label Image",
  widget: LabelImage,
  accessible: true,
  isLintable: true
};

// Styling
const CELL_PADDING = 5;
const TABLE_STYLE = {
  display: "table",
  tableLayout: "fixed"
};
const ROW_STYLE = {
  display: "table-row"
};
const CELL_STYLE = {
  display: "table-cell",
  padding: CELL_PADDING
};
const BASE_TILE_STYLE = {
  borderRadius: 10,
  cursor: "pointer"
};
const MOVE_COUNT_STYLE = {
  padding: CELL_PADDING,
  display: "inline-block"
};
const RESET_BUTTON_STYLE = {
  float: "right",
  paddingRight: CELL_PADDING
};
const MAIN_TILE_SIZE = 50;
const PATTERNS = {
  plus: () => [[false, true, false], [true, true, true], [false, true, false]],
  x: () => [[true, false, true], [false, true, false], [true, false, true]],
  "plus/x": iter => {
    return iter % 2 ? PATTERNS.x() : PATTERNS.plus();
  }
};

// A single glowy cell
class Tile extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_flip", () => {
      this.props.onChange(!this.props.value);
    });
  }
  render() {
    const color = this.props.value ? "#55dd55" : "#115511";
    const style = ___default["default"].extend({}, BASE_TILE_STYLE, {
      width: this.props.size,
      height: this.props.size,
      backgroundColor: color
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: style,
      onClick: this._flip
    });
  }
}

// A grid of glowy cells
_defineProperty(Tile, "propTypes", {
  value: PropTypes__default["default"].bool.isRequired,
  size: PropTypes__default["default"].number.isRequired
});
class TileGrid extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: TABLE_STYLE,
      className: "no-select"
    }, ___default["default"].map(this.props.cells, (row, y) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        key: y,
        style: ROW_STYLE
      }, ___default["default"].map(row, (cell, x) => {
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: x,
          style: CELL_STYLE
        }, /*#__PURE__*/React__namespace.createElement(Tile, {
          value: cell,
          size: this.props.size,
          onChange: ___default["default"].partial(this.props.onChange, y, x)
        }));
      }));
    }));
  }
}

// Returns a copy of the tiles, with tiles flipped according to
// whether or not their y, x position satisfies the predicate
_defineProperty(TileGrid, "propTypes", {
  cells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)).isRequired,
  size: PropTypes__default["default"].number.isRequired
});
const flipTilesPredicate = (oldCells, predicate) => {
  return ___default["default"].map(oldCells, (row, y) => {
    return ___default["default"].map(row, (cell, x) => {
      return predicate(y, x) ? !cell : cell;
    });
  });
};
const flipTilesPattern = (oldCells, tileY, tileX, pattern) => {
  return flipTilesPredicate(oldCells, (y, x) => {
    const offsetY = y - tileY;
    const offsetX = x - tileX;
    if (Math.abs(offsetY) <= 1 && Math.abs(offsetX) <= 1) {
      return pattern[offsetY + 1][offsetX + 1];
    }
    return false;
  });
};

// The lights puzzle widget
class LightsPuzzle extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_currPattern", void 0);
    _defineProperty(this, "_nextPattern", void 0);
    _defineProperty(this, "_patternIndex", void 0);
    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "_width", () => {
      if (this.props.cells.length !== 0) {
        return this.props.cells[0].length;
      }
      return 0; // default to 0
    });
    _defineProperty(this, "_initNextPatterns", () => {
      this._currPattern = PATTERNS[this.props.flipPattern](0);
      this._nextPattern = PATTERNS[this.props.flipPattern](1);
      this._patternIndex = 2;
    });
    _defineProperty(this, "_shiftPatterns", () => {
      this._currPattern = this._nextPattern;
      this._nextPattern = PATTERNS[this.props.flipPattern](this._patternIndex);
      this._patternIndex++;
    });
    _defineProperty(this, "_flipTile", (tileY, tileX) => {
      const newCells = flipTilesPattern(this.props.cells, tileY, tileX, this._currPattern);
      this._shiftPatterns();
      this.change({
        cells: newCells,
        moveCount: this.props.moveCount + 1
      });
    });
    _defineProperty(this, "_reset", () => {
      this.change({
        cells: this.props.startCells,
        moveCount: 0
      });
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return validate$1(rubric, this.getUserInput());
    });
  }
  render() {
    const width = this._width();
    const tileSize = MAIN_TILE_SIZE;
    const pxWidth = width * (tileSize + 2 * CELL_PADDING);
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(TileGrid, {
      cells: this.props.cells,
      size: tileSize,
      onChange: this._flipTile
    }), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        width: pxWidth
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: MOVE_COUNT_STYLE
    }, i18n__namespace.ngettext("Moves: %(num)s", "Moves: %(num)s", this.props.moveCount)), /*#__PURE__*/React__namespace.createElement("div", {
      style: RESET_BUTTON_STYLE
    }, /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      value: "Reset",
      onClick: this._reset,
      className: "simple-button"
    }))), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clearfix"
    }));
  }
  componentDidMount() {
    this._initNextPatterns();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.flipPattern !== this.props.flipPattern) {
      this._initNextPatterns();
    }
  }
}

// grading function
_defineProperty(LightsPuzzle, "propTypes", {
  ...propTypes,
  cells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)),
  startCells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)),
  flipPattern: PropTypes__default["default"].string.isRequired,
  moveCount: PropTypes__default["default"].number.isRequired
});
_defineProperty(LightsPuzzle, "defaultProps", {
  cells: [[false, false, false], [false, false, false], [false, false, false]],
  startCells: [[false, false, false], [false, false, false], [false, false, false]],
  flipPattern: "plus",
  moveCount: 0
});
const validate$1 = function (rubric, state) {
  const empty = ___default["default"].all(state.cells, (row, y) => {
    return ___default["default"].all(row, (cell, x) => {
      return cell === rubric.startCells[y][x];
    });
  });
  if (empty) {
    return {
      type: "invalid",
      message: i18n__namespace._("Click on the tiles to change the lights.")
    };
  }
  const correct = ___default["default"].all(state.cells, row => {
    return ___default["default"].all(row, cell => {
      return cell;
    });
  });
  if (correct) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }
  if (rubric.gradeIncompleteAsWrong) {
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }
  return {
    type: "invalid",
    message: i18n__namespace._("You must turn on all of the lights to continue.")
  };
};

// The function run on the editor props to create the widget props
const transformProps = function (editorProps) {
  return {
    cells: editorProps.startCells,
    startCells: editorProps.startCells,
    flipPattern: editorProps.flipPattern
  };
};
var LightsPuzzle$1 = {
  name: "lights-puzzle",
  displayName: "Lights Puzzle",
  hidden: true,
  widget: LightsPuzzle,
  transform: transformProps
};

let Layout = /*#__PURE__*/function (Layout) {
  Layout["HORIZONTAL"] = "horizontal";
  Layout["VERTICAL"] = "vertical";
  return Layout;
}({});
var ItemState = /*#__PURE__*/function (ItemState) {
  ItemState["STATIC"] = "static";
  ItemState["DRAGGING"] = "dragging";
  ItemState["ANIMATING"] = "animating";
  ItemState["DISABLED"] = "disabled";
  return ItemState;
}(ItemState || {}); // Augment the given position with the scroll position of the offset parent.
const addOffsetParentScroll = ($el, position) => {
  // NOTE(slim): $(el).offsetParent() is NOT equivalent to $el[0].offsetParent.
  // Specifically, when `el` is not positioned, then the native HTMLElement.offsetParent
  // returns the closest table element, which in this case is the <td> rendered by the
  // Perseus Matcher widget.
  // Conversely, jQuery's offsetParent() always returns the closest positioned ancestor,
  // even when the element is not positioned.
  const $offsetParent = $el.offsetParent();
  return {
    top: position.top + $offsetParent.scrollTop(),
    left: position.left + $offsetParent.scrollLeft()
  };
};
// A placeholder that appears in the sortable whenever an item is dragged.
class Placeholder extends React__namespace.Component {
  render() {
    const {
      layout
    } = this.props;
    const className = aphrodite.css(styles$e.card, styles$e.placeholder, layout === Layout.HORIZONTAL && styles$e.horizontalCard);
    const style = {
      width: this.props.width,
      height: this.props.height
    };
    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }
    return /*#__PURE__*/React__namespace.createElement("li", {
      className: className,
      style: style
    });
  }
}
// A draggable item in the sortable. Can be in one of four states:
//     Static:    The item is not being interacted with.
//     Dragging:  The item is being dragged.
//     Animating: The item has been released, and is moving to its destination.
//     Disabled:  The item cannot be interacted with.
//
// Usual flow:      Static -> Dragging -> Animating -> Static
// [Dis|en]abling:  Static|Dragging|Animating -> Disabled -> Static
class Draggable extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "animationFrameRequest", null);
    _defineProperty(this, "isMouseMoveUpBound", void 0);
    _defineProperty(this, "_mounted", void 0);
    _defineProperty(this, "state", {
      startPosition: {
        left: 0,
        top: 0
      },
      startMouse: {
        left: 0,
        top: 0
      },
      mouse: {
        left: 0,
        top: 0
      },
      dragging: false
    });
    _defineProperty(this, "getCurrentPosition", () => {
      return {
        left: this.state.startPosition.left + this.state.mouse.left - this.state.startMouse.left,
        top: this.state.startPosition.top + this.state.mouse.top - this.state.startMouse.top
      };
    });
    _defineProperty(this, "bindMouseMoveUp", () => {
      this.isMouseMoveUpBound = true;
      $__default["default"](document).on("mousemove", this.onMouseMove);
      $__default["default"](document).on("mouseup", this.onMouseUp);
    });
    _defineProperty(this, "unbindMouseMoveUp", () => {
      this.isMouseMoveUpBound = false;
      $__default["default"](document).off("mousemove", this.onMouseMove);
      $__default["default"](document).off("mouseup", this.onMouseUp);
    });
    _defineProperty(this, "onMouseDown", event => {
      if (this.props.state !== ItemState.STATIC) {
        return;
      }
      if (!(event.button === 0 || event.touches != null && event.touches.length === 1)) {
        return;
      }
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
      this.animationFrameRequest = requestAnimationFrame(() => {
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        const $el = $__default["default"](ReactDOM__default["default"].findDOMNode(this));

        // jQuery.position() gets the position of the element wrt its offset parent,
        // but subtracts the scroll position of the parent. We need to add that back.
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
        const position = $el.position();
        const startPosition = addOffsetParentScroll($el, position);
        if (loc && this._mounted) {
          this.setState({
            startPosition,
            // NOTE(slim): We don't bother adjusting `loc` because we only keep track of (mouse - startMouse) in
            // this.getCurrentPosition(). Adjusting `loc` here requires us to also change how `loc` is used in
            // onMouseMove and onMouseUp, and this requires reading from the DOM each time to measure the parent's scrollTop.
            startMouse: loc,
            mouse: loc,
            dragging: true
          }, function () {
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.bindMouseMoveUp();

            // Static -> Dragging
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.props.onMouseDown();
          });
        }
      });
    });
    _defineProperty(this, "onMouseMove", event => {
      const notDragging = this.props.state !== ItemState.DRAGGING || !this.state.dragging;
      if (notDragging) {
        return;
      }
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);
      if (loc) {
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
        this.animationFrameRequest = requestAnimationFrame(() => {
          this.setState({
            mouse: loc
          }, this.props.onMouseMove);
        });
      }
    });
    _defineProperty(this, "onMouseUp", event => {
      const notDragging = this.props.state !== ItemState.DRAGGING || !this.state.dragging;
      if (notDragging) {
        return;
      }
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);
      if (loc) {
        this.setState({
          dragging: false
        });
        this.unbindMouseMoveUp();

        // Dragging -> Animating
        this.props.onMouseUp();
      }
    });
  }
  componentDidMount() {
    this._mounted = true;
    this.isMouseMoveUpBound = false;

    // On touch devices, we set up our own touchmove handler because React
    // all event subscriptions using `OnTouchMove` props are non-passive.
    // See: https://github.com/facebook/react/issues/6436
    // Also, we can't subscribe to `ontouchmove`  within the `ontouchstart`
    // handler because of a WebKit bug:
    // https://github.com/atlassian/react-beautiful-dnd/issues/413 and
    // https://bugs.webkit.org/show_bug.cgi?id=184250
    document.addEventListener("touchmove", this.onMouseMove,
    // Not all browsers support passive events, and when they don't
    // this third paramter is just a boolean. If we pass the "options"
    // object, it's interpreted as `capture=true` (which we don't want!)
    Util.supportsPassiveEvents() ? {
      passive: false
    } : false);
  }
  componentWillUnmount() {
    this._mounted = false;
    // Event handlers should be unbound before component unmounting, but
    // just in case...
    if (this.isMouseMoveUpBound) {
      this.unbindMouseMoveUp();
    }
    if (this.animationFrameRequest) {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      cancelAnimationFrame(this.animationFrameRequest);
    }
    document.removeEventListener("touchmove", this.onMouseMove);
  }
  render() {
    const {
      includePadding,
      layout,
      state: type
    } = this.props;

    // We need to keep backwards compatbility with rules specified directly
    // in CSS. Hence the hacky tacking on of manual classNames.
    // See sortable.less for details.
    let className = aphrodite.css(styles$e.card, styles$e.draggable, layout === Layout.HORIZONTAL && styles$e.horizontalCard, layout === Layout.VERTICAL && styles$e.verticalCard, type === ItemState.DRAGGING && styles$e.dragging, type === ItemState.DISABLED && styles$e.disabled, !includePadding && styles$e.unpaddedCard) + " " + ClassNames.INTERACTIVE + " perseus-sortable-draggable";
    if (!includePadding) {
      className += " perseus-sortable-draggable-unpadded";
    }
    const style = {
      position: "static"
    };
    if (this.props.state === ItemState.DRAGGING || this.props.state === ItemState.ANIMATING) {
      ___default["default"].extend(style, {
        position: "absolute"
      }, this.getCurrentPosition());
    }
    if (this.props.width) {
      style.width = this.props.width + 1; // Fix for non-integer widths
    }

    if (this.props.height) {
      style.height = this.props.height;
    }
    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }
    return /*#__PURE__*/React__namespace.createElement("li", {
      className: className,
      style: style,
      onMouseDown: this.onMouseDown,
      onTouchStart: this.onMouseDown,
      onTouchMove: this.onMouseMove,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.content,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "draggable"),
      onRender: this.props.onRender
    }));
  }
  componentDidUpdate(prevProps) {
    if (this.props.state === prevProps.state) {
      return;
    }
    if (this.props.state === ItemState.ANIMATING) {
      // Start animating
      const current = this.getCurrentPosition();
      const duration = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.endPosition.left - current.left, 2) + Math.pow(this.props.endPosition.top - current.top, 2)));

      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'animate' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).animate(this.props.endPosition, {
        duration: Math.max(duration, 1),
        // Animating -> Static
        complete: this.props.onAnimationEnd
      });
    } else if (this.props.state === ItemState.STATIC) {
      // Ensure that any animations are done
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'finish' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).finish();
    }
  }
}
_defineProperty(Draggable, "defaultProps", {
  includePadding: true,
  type: ItemState.STATIC,
  linterContext: PerseusLinter__namespace.linterContextDefault
});
class Sortable extends React__namespace.Component {
  constructor(props) {
    super(props);
    // Don't call this.setState() here!
    _defineProperty(this, "remeasureItems", ___default["default"].debounce(() => {
      this.setState({
        // Clear item measurements
        items: Sortable.clearItemMeasurements(this.state.items)
      });
    }, 20));
    this.state = {
      items: Sortable.itemsFromProps(this.props),
      texRendererLoaded: false
    };
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    const prevProps = this.props;
    if (!___default["default"].isEqual(nextProps.options, prevProps.options)) {
      // Regenerate items
      this.setState({
        items: Sortable.itemsFromProps(nextProps)
      });
    } else if (nextProps.layout !== prevProps.layout || nextProps.padding !== prevProps.padding || nextProps.disabled !== prevProps.disabled || !___default["default"].isEqual(nextProps.constraints, prevProps.constraints)) {
      // Clear item measurements
      this.setState({
        items: Sortable.clearItemMeasurements(this.state.items)
      });
    }
  }
  componentDidUpdate() {
    // Measure items if their dimensions have been reset
    if (this.state.items.length && !this.state.items[0].width && !this.state.items[0].height) {
      // Measure on the next frame to allow items size to settle.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(() => {
        this.measureItems();
      }, 0);
    }
  }
  static itemsFromProps(props) {
    const state = props.disabled ? ItemState.DISABLED : ItemState.STATIC;
    return props.options.map((option, i) => {
      return {
        option: option,
        key: i,
        state,
        endPosition: {},
        width: 0,
        height: 0
      };
    });
  }
  static clearItemMeasurements(items) {
    return items.map(item => {
      return {
        ...item,
        width: 0,
        height: 0
      };
    });
  }
  measureItems() {
    // Measure all items and cache what their dimensions should be, taking
    // into account constraints and the current layout. This allows syncing
    // widths and heights for pretty rows/columns. Note that dimensions are
    // explictly set on Draggables - this prevents them from changing size
    // or shape while being dragged.

    let items = [...this.state.items];

    // Fetches a jQuery list of elements for each item
    const $items = ___default["default"].map(items, function (item) {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      return $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs[item.key]));
    }, this);
    const widths = ___default["default"].invoke($items, "outerWidth");
    const heights = ___default["default"].invoke($items, "outerHeight");
    const {
      constraints,
      layout
    } = this.props;
    let syncWidth = null;
    if (constraints !== null && constraints !== void 0 && constraints.width) {
      // Items must be at least as wide as the specified constraint
      syncWidth = ___default["default"].max(widths.concat(constraints.width));
    } else if (layout === Layout.VERTICAL) {
      // Sync widths to get a clean column
      syncWidth = ___default["default"].max(widths);
    }
    let syncHeight = null;
    if (constraints !== null && constraints !== void 0 && constraints.height) {
      // Items must be at least as high as the specified constraint
      syncHeight = ___default["default"].max(heights.concat(constraints.height));
    } else if (layout === Layout.HORIZONTAL) {
      // Sync widths to get a clean row
      syncHeight = ___default["default"].max(heights);
    }
    items = ___default["default"].map(items, function (item, i) {
      item.width = syncWidth || widths[i];
      item.height = syncHeight || heights[i];
      return item;
    });
    this.setState({
      items
    }, () => {
      this.props.onMeasure && this.props.onMeasure({
        widths: widths,
        heights: heights
      });
    });
  }
  render() {
    var _this$props$constrain, _this$props$constrain2;
    // To minimize layout shift, we display a spinner until our math
    // renderer is ready to render the math inside the sortable. To
    // do this, we:
    // - render a dummy TeX component to force the math renderer to load
    // - display a spinner until the TeX component calls its onRender
    //   callback, signifying that the math is rendered (from which we can
    //   infer that the math renderer has loaded)
    //
    // If we didn't do this, the user might see a sortable with empty
    // cells on first render, and then the math would pop in a few moments
    // later once the rendering library loaded.
    if (this.props.waitForTexRendererToLoad && !this.state.texRendererLoaded) {
      const {
        TeX
      } = getDependencies();
      return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, null), /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          display: "none"
        }
      }, /*#__PURE__*/React__namespace.createElement(TeX, {
        onRender: () => this.setState({
          texRendererLoaded: true
        })
      }, "1")));
    }
    const cards = [];
    const {
      layout
    } = this.props;
    // We need to keep backwards compatbility with rules specified directly
    // in CSS. See sortable.less for details.
    const className = aphrodite.css(styles$e.sortable) + " perseus-sortable";
    const syncWidth = ((_this$props$constrain = this.props.constraints) === null || _this$props$constrain === void 0 ? void 0 : _this$props$constrain.width) || layout === Layout.VERTICAL;
    const syncHeight = ((_this$props$constrain2 = this.props.constraints) === null || _this$props$constrain2 === void 0 ? void 0 : _this$props$constrain2.height) || layout === Layout.HORIZONTAL;
    ___default["default"].each(this.state.items, function (item, i, items) {
      const isLast = i === items.length - 1;
      const isStatic = item.state === ItemState.STATIC || item.state === ItemState.DISABLED;
      let margin;

      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      if (this.props.layout === Layout.HORIZONTAL) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        margin = "0 " + this.props.margin + "px 0 0"; // right
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      } else if (this.props.layout === Layout.VERTICAL) {
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        margin = "0 0 " + this.props.margin + "px 0"; // bottom
      }

      cards.push( /*#__PURE__*/React__namespace.createElement(Draggable, {
        content: item.option,
        key: item.key,
        state: item.state
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        ,
        ref: item.key,
        width: syncWidth ? item.width : undefined,
        height: syncHeight ? item.height : undefined,
        layout: layout
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        includePadding: this.props.padding,
        margin: isLast && isStatic ? 0 : margin,
        endPosition: item.endPosition,
        linterContext: PerseusLinter__namespace.pushContextStack(
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.props.linterContext, "sortable")
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onRender: this.remeasureItems
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onMouseDown: this.onMouseDown.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onMouseMove: this.onMouseMove.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onMouseUp: this.onMouseUp.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onTouchMove: this.onMouseMove.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onTouchEnd: this.onMouseUp.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onTouchCancel: this.onMouseUp.bind(this, item.key)
        // eslint-disable-next-line react/jsx-no-bind
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onAnimationEnd: this.onAnimationEnd.bind(
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this, item.key)
      }));
      if (item.state === ItemState.DRAGGING || item.state === ItemState.ANIMATING) {
        cards.push( /*#__PURE__*/React__namespace.createElement(Placeholder, {
          key: "placeholder_" + item.key,
          ref: "placeholder_" + item.key,
          width: item.width,
          height: item.height,
          layout: layout,
          margin: isLast ? 0 : margin
        }));
      }
    }, this);
    return /*#__PURE__*/React__namespace.createElement("ul", {
      className: className
    }, cards);
  }
  onMouseDown(key) {
    // Static -> Dragging
    const items = ___default["default"].map(this.state.items, function (item) {
      if (item.key === key) {
        item.state = ItemState.DRAGGING;
      }
      return item;
    });
    this.setState({
      items: items
    });
  }

  // This is public API and it's ok for components that use
  // this sortable to call this.
  // moveOptionToIndex takes an option and a desired index and
  // will move that item to the desired index. This is useful
  // for testing and other cases where dragging and dropping may
  // not be available
  moveOptionToIndex(option, index) {
    const {
      items
    } = this.state;
    if (index < 0 || index > items.length) {
      throw new Error("index ".concat(index, " out of bounds"));
    }
    const nextItems = ___default["default"].clone(items);
    const item = items.filter(item => {
      return item.option === option;
    })[0];
    if (item == null) {
      throw new Error("option ".concat(option, " not found"));
    }
    const currentIndex = items.findIndex(i => {
      return i.key === item.key;
    });

    // @ts-expect-error [FEI-5003] - TS2551 - Property 'splice' does not exist on type 'readonly SortableItem[]'. Did you mean 'slice'?
    nextItems.splice(currentIndex, 1);
    // @ts-expect-error [FEI-5003] - TS2551 - Property 'splice' does not exist on type 'readonly SortableItem[]'. Did you mean 'slice'?
    nextItems.splice(index, 0, item);
    this.setState({
      items: nextItems
    });
    this.props.onChange && this.props.onChange({});
  }
  onMouseMove(key) {
    // Dragging: Rearrange items based on draggable's position
    // eslint-disable-next-line react/no-string-refs
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    const $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs[key]));
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    const $sortable = $__default["default"](ReactDOM__default["default"].findDOMNode(this));
    const items = ___default["default"].clone(this.state.items);
    const item = ___default["default"].findWhere(this.state.items, {
      key: key
    });
    const margin = this.props.margin || 0;
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'SortableItem | undefined' is not assignable to parameter of type 'SortableItem'.
    const currentIndex = ___default["default"].indexOf(items, item);
    let newIndex = 0;

    // @ts-expect-error [FEI-5003] - TS2551 - Property 'splice' does not exist on type 'readonly SortableItem[]'. Did you mean 'slice'?
    items.splice(currentIndex, 1);
    if (this.props.layout === Layout.HORIZONTAL) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'. | TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      const midWidth = $draggable.offset().left - $sortable.offset().left;
      let sumWidth = 0;
      let cardWidth;
      ___default["default"].each(items, function (item) {
        cardWidth = item.width;
        if (midWidth > sumWidth + cardWidth / 2) {
          newIndex += 1;
        }
        sumWidth += cardWidth + margin;
      });
    } else {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'. | TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      const midHeight = $draggable.offset().top - $sortable.offset().top;
      let sumHeight = 0;
      let cardHeight;
      ___default["default"].each(items, function (item) {
        cardHeight = item.height;
        if (midHeight > sumHeight + cardHeight / 2) {
          newIndex += 1;
        }
        sumHeight += cardHeight + margin;
      });
    }
    if (newIndex !== currentIndex) {
      // @ts-expect-error [FEI-5003] - TS2551 - Property 'splice' does not exist on type 'readonly SortableItem[]'. Did you mean 'slice'?
      items.splice(newIndex, 0, item);
      this.setState({
        items: items
      });
    }
  }
  onMouseUp(key) {
    // Dragging -> Animating
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    const nextAnimationFrame = requestAnimationFrame(() => {
      const items = ___default["default"].map(this.state.items, function (item) {
        if (item.key === key) {
          item.state = ItemState.ANIMATING;
          const $placeholder = $__default["default"](
          // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
          ReactDOM__default["default"].findDOMNode(
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.refs["placeholder_" + key]));
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
          const position = $placeholder.position();
          const endPosition = addOffsetParentScroll($placeholder, position);
          item.endPosition = endPosition;
        }
        return item;
      }, this);
      this.setState({
        items: items
      });
      // HACK: We need to know *that* the widget changed, but currently it's
      // not set up in a nice way to tell us *how* it changed, since the
      // permutation of the items is stored in state.
      this.props.onChange && this.props.onChange({});
    });

    // @ts-expect-error [FEI-5003] - TS2339 - Property 'animationFrameRequest' does not exist on type 'Sortable'.
    this.animationFrameRequest = nextAnimationFrame;
  }
  onAnimationEnd(key) {
    // Animating -> Static
    const items = ___default["default"].map(this.state.items, function (item) {
      if (item.key === key) {
        item.state = ItemState.STATIC;
      }
      return item;
    });
    this.setState({
      items: items
    });
  }
  getOptions() {
    return ___default["default"].pluck(this.state.items, "option");
  }
}
_defineProperty(Sortable, "defaultProps", {
  layout: Layout.HORIZONTAL,
  padding: true,
  disabled: false,
  constraints: {},
  onMeasure: function () {},
  margin: 5,
  onChange: function () {},
  linterContext: PerseusLinter__namespace.linterContextDefault,
  waitForTexRendererToLoad: true
});
const styles$e = aphrodite.StyleSheet.create({
  sortable: {
    boxSizing: "border-box",
    float: "left",
    padding: 0,
    margin: 0
  },
  card: {
    boxSizing: "border-box",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: 4,
    cursor: "pointer",
    minWidth: 25,
    minHeight: 44,
    padding: 10,
    listStyleType: "none",
    userSelect: "none",
    touchAction: "none"
  },
  placeholder: {
    background: "#ddd",
    border: "1px solid #ccc"
  },
  draggable: {
    textAlign: "center"
  },
  horizontalCard: {
    float: "left",
    cursor: "ew-resize"
  },
  verticalCard: {
    maxWidth: "100%",
    cursor: "ns-resize"
  },
  unpaddedCard: {
    padding: 0
  },
  dragging: {
    background: "#ffedcd",
    opacity: 0.8
  },
  disabled: {
    backgroundColor: "inherit",
    border: "1px solid transparent",
    cursor: "default"
  }
});

const {
  shuffle: shuffle$1,
  seededRNG
} = Util;
const HACKY_CSS_CLASSNAME = "perseus-widget-matcher";
class Matcher extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      leftHeight: 0,
      rightHeight: 0,
      texRendererLoaded: false
    });
    _defineProperty(this, "changeAndTrack", e => {
      this.props.onChange(e);
      this.props.trackInteraction();
    });
    _defineProperty(this, "onMeasureLeft", dimensions => {
      const height = ___default["default"].max(dimensions.heights);
      this.setState({
        leftHeight: height
      });
    });
    _defineProperty(this, "onMeasureRight", dimensions => {
      const height = ___default["default"].max(dimensions.heights);
      this.setState({
        rightHeight: height
      });
    });
    _defineProperty(this, "getUserInput", () => {
      // If the math renderer hasn't loaded then we won't be able to get the
      // contents of the sortables on the left and right, so we just return
      // empty arrays until we render for the first time.
      if (!this.state.texRendererLoaded) {
        return {
          left: [],
          right: []
        };
      }
      return {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getOptions' does not exist on type 'ReactInstance'.
        left: this.refs.left.getOptions(),
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getOptions' does not exist on type 'ReactInstance'.
        right: this.refs.right.getOptions()
      };
    });
    _defineProperty(this, "moveLeftOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'moveOptionToIndex' does not exist on type 'ReactInstance'.
      this.refs.left.moveOptionToIndex(option, index);
    });
    _defineProperty(this, "moveRightOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'moveOptionToIndex' does not exist on type 'ReactInstance'.
      this.refs.right.moveOptionToIndex(option, index);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Matcher'.
      return Matcher.validate(this.getUserInput(), rubric);
    });
  }
  render() {
    // To minimize layout shift, we display a spinner until our math
    // renderer is ready to render the math inside the matcher. To
    // do this, we:
    // - render a dummy TeX component to force the math renderer to load
    // - display a spinner until the TeX component calls its onRender
    //   callback, signifying that the math is rendered (from which we can
    //   infer that the math renderer has loaded)
    //
    // If we didn't do this, the user might see a matcher with empty
    // columns on first render, and then the math would pop in a few
    // moments later once the rendering library loaded.
    if (!this.state.texRendererLoaded) {
      const {
        TeX
      } = getDependencies();
      return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, null), /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          display: "none"
        }
      }, /*#__PURE__*/React__namespace.createElement(TeX, {
        onRender: () => {
          this.setState({
            texRendererLoaded: true
          });
        }
      }, "1")));
    }

    // Use the same random() function to shuffle both columns sequentially
    const rng = seededRNG(this.props.problemNum);
    let left;
    if (!this.props.orderMatters) {
      // If the order doesn't matter, don't shuffle the left column
      left = this.props.left;
    } else {
      left = shuffle$1(this.props.left, rng, /* ensurePermuted */true);
    }
    const right = shuffle$1(this.props.right, rng, /* ensurePermuted */true);
    const showLabels = ___default["default"].any(this.props.labels);
    const constraints = {
      height: ___default["default"].max([this.state.leftHeight, this.state.rightHeight])
    };
    const cellMarginPx = this.props.apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React__namespace.createElement("table", {
      className: aphrodite.css(styles$d.widget) + " " + HACKY_CSS_CLASSNAME
    }, /*#__PURE__*/React__namespace.createElement("tbody", null, showLabels && /*#__PURE__*/React__namespace.createElement("tr", {
      className: aphrodite.css(styles$d.row)
    }, /*#__PURE__*/React__namespace.createElement("th", {
      className: aphrodite.css(styles$d.column, styles$d.columnLabel)
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.labels[0] || "...",
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React__namespace.createElement("th", {
      className: aphrodite.css(styles$d.column, styles$d.columnRight, styles$d.columnLabel)
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.labels[1] || "...",
      linterContext: this.props.linterContext
    }))), /*#__PURE__*/React__namespace.createElement("tr", {
      className: aphrodite.css(styles$d.row)
    }, /*#__PURE__*/React__namespace.createElement("td", {
      className: aphrodite.css(styles$d.column)
    }, /*#__PURE__*/React__namespace.createElement(Sortable, {
      options: left,
      layout: Layout.VERTICAL,
      padding: this.props.padding,
      disabled: !this.props.orderMatters,
      constraints: constraints,
      onMeasure: this.onMeasureLeft,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "left"
    })), /*#__PURE__*/React__namespace.createElement("td", {
      className: aphrodite.css(styles$d.column, styles$d.columnRight)
    }, /*#__PURE__*/React__namespace.createElement(Sortable
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly unknown[]' is not assignable to type 'readonly string[]'.
    , {
      options: right,
      layout: Layout.VERTICAL,
      padding: this.props.padding,
      constraints: constraints,
      onMeasure: this.onMeasureRight,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "right"
    })))));
  }
}
_defineProperty(Matcher, "propTypes", {
  apiOptions: ApiOptions.propTypes,
  labels: PropTypes__default["default"].array,
  left: PropTypes__default["default"].array,
  onChange: PropTypes__default["default"].func,
  orderMatters: PropTypes__default["default"].bool,
  padding: PropTypes__default["default"].bool,
  problemNum: PropTypes__default["default"].number,
  right: PropTypes__default["default"].array,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(Matcher, "defaultProps", {
  left: [],
  right: [],
  labels: ["", ""],
  orderMatters: false,
  padding: true,
  problemNum: 0,
  onChange: function () {},
  linterContext: PerseusLinter.linterContextDefault
});
___default["default"].extend(Matcher, {
  validate: function (state, rubric) {
    const correct = ___default["default"].isEqual(state.left, rubric.left) && ___default["default"].isEqual(state.right, rubric.right);
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});
const padding = 5;
const border = "1px solid #444";
const styles$d = aphrodite.StyleSheet.create({
  widget: {
    paddingTop: padding,
    maxWidth: "100%",
    // Need to override minWidth in CSS :(
    minWidth: "auto"
  },
  row: {
    // Need to override global rules in CSS :(
    border: 0
  },
  column: {
    // TODO(benkomalo): constraint to half width?
    padding: 0,
    border: 0
  },
  columnRight: {
    borderLeft: border
  },
  columnLabel: {
    fontWeight: "inherit",
    borderBottom: border,
    padding: "0 ".concat(padding, "px ").concat(padding, "px ").concat(padding, "px"),
    textAlign: "center"
  }
});
var Matcher$1 = {
  name: "matcher",
  displayName: "Two column matcher",
  widget: Matcher,
  isLintable: true
};

const {
  firstNumericalParse,
  captureScratchpadTouchStart: captureScratchpadTouchStart$1
} = Util;
const toNumericString = KhanMath.toNumericString;
const getNumericFormat = KhanMath.getNumericFormat;

/* An input box that accepts only numeric strings
 *
 * Calls onChange(value, format) for valid numbers.
 * Reverts to the current value onBlur or on [ENTER],
 *   but maintains the format (i.e. 3/2, 1 1/2, 150%)
 * Accepts empty input and sends it to onChange as null
 *   if no numeric placeholder is set.
 * If given a checkValidity function, will turn
 *   the background/outline red when invalid
 * If useArrowKeys is set to true, up/down arrows will
 *   increment/decrement integers
 * Optionally takes a size ("mini", "small", "normal")
 */
class NumberInput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      format: this.props.format
    });
    _defineProperty(this, "getValue", () => {
      return this.parseInputValue(
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'value' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this.refs.input).value // eslint-disable-line react/no-string-refs
      );
    });
    _defineProperty(this, "getStringValue", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'value' does not exist on type 'Element | Text'.
      return ReactDOM__default["default"].findDOMNode(this.refs.input).value.toString(); // eslint-disable-line react/no-string-refs
    });
    _defineProperty(this, "parseInputValue", value => {
      if (value === "") {
        const placeholder = this.props.placeholder;
        return ___default["default"].isFinite(placeholder) ? +placeholder : null;
      }
      const result = firstNumericalParse(value);
      return ___default["default"].isFinite(result) ? result : this.props.value;
    });
    _defineProperty(this, "focus", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this.refs.input).focus(); // eslint-disable-line react/no-string-refs
      this._handleFocus();
    });
    _defineProperty(this, "blur", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'blur' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this.refs.input).blur(); // eslint-disable-line react/no-string-refs
      this._handleBlur();
    });
    _defineProperty(this, "setSelectionRange", (selectionStart, selectionEnd) => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'setSelectionRange' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
    });
    _defineProperty(this, "getSelectionStart", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'selectionStart' does not exist on type 'Element | Text'.
      return ReactDOM__default["default"].findDOMNode(this).selectionStart;
    });
    _defineProperty(this, "getSelectionEnd", () => {
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'selectionEnd' does not exist on type 'Element | Text'.
      return ReactDOM__default["default"].findDOMNode(this).selectionEnd;
    });
    _defineProperty(this, "_checkValidity", value => {
      if (value == null) {
        return true;
      }
      const val = firstNumericalParse(value);
      const checkValidity = this.props.checkValidity;
      return ___default["default"].isFinite(val) && checkValidity(val);
    });
    _defineProperty(this, "_handleChange", e => {
      const text = e.target.value;
      const value = this.parseInputValue(text);
      const format = getNumericFormat(text);
      this.props.onChange(value);
      if (format) {
        this.props.onFormatChange(value, format);
        this.setState({
          format: format
        });
      }
    });
    _defineProperty(this, "_handleFocus", () => {
      if (this.props.onFocus) {
        this.props.onFocus();
      }
    });
    _defineProperty(this, "_handleBlur", e => {
      // Only continue on blur or "enter"
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'keyCode' does not exist on type 'KeyboardEvent<Element> | FocusEvent<Element, Element>'.
      if (e && e.type === "keypress" && e.keyCode !== 13) {
        return;
      }
      this._setValue(this.props.value, this.state.format);
      if (this.props.onBlur) {
        this.props.onBlur();
      }
    });
    _defineProperty(this, "_onKeyDown", e => {
      if (this.props.onKeyDown) {
        this.props.onKeyDown(e);
      }
      if (!this.props.useArrowKeys || !___default["default"].contains(["ArrowUp", "ArrowDown"], e.key)) {
        return;
      }
      let val = this.getValue();
      if (val !== Math.floor(val)) {
        return; // bail if not an integer
      }

      if (e.key === "ArrowUp") {
        val = val + 1;
      } else if (e.key === "ArrowDown") {
        val = val - 1;
      }
      if (this._checkValidity(val)) {
        this.props.onChange(val);
      }
    });
    _defineProperty(this, "_setValue", (val, format) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'val' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.input)).val(toNumericString(val, format));
    });
  }
  render() {
    let classes = classNames__default["default"]({
      "number-input": true,
      "invalid-input": !this._checkValidity(this.props.value),
      mini: this.props.size === "mini",
      small: this.props.size === "small",
      normal: this.props.size === "normal"
    });
    if (this.props.className != null) {
      classes = classes + " " + this.props.className;
    }
    const {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onFormatChange,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      checkValidity,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      useArrowKeys,
      ...restProps
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement("input", _extends({}, restProps, {
      className: classes,
      type: "text"
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "input",
      onChange: this._handleChange,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      onKeyPress: this._handleBlur,
      onKeyDown: this._onKeyDown
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: TouchEvent) => void' is not assignable to type 'TouchEventHandler<HTMLInputElement>'.
      ,
      onTouchStart: captureScratchpadTouchStart$1,
      defaultValue: toNumericString(this.props.value, this.state.format),
      value: undefined
    }));
  }
  componentDidUpdate(prevProps) {
    if (!kmath.number.equal(this.getValue(), this.props.value)) {
      this._setValue(this.props.value, this.state.format);
    }
  }

  /* Return the current "value" of this input
   * If empty, it returns the placeholder (if it is a number) or null
   */
}
_defineProperty(NumberInput, "propTypes", {
  value: PropTypes__default["default"].number,
  format: PropTypes__default["default"].string,
  placeholder: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  onChange: PropTypes__default["default"].func.isRequired,
  onFormatChange: PropTypes__default["default"].func,
  checkValidity: PropTypes__default["default"].func,
  size: PropTypes__default["default"].string,
  label: PropTypes__default["default"].oneOf(["put your labels outside your inputs!"])
});
_defineProperty(NumberInput, "defaultProps", {
  value: null,
  placeholder: null,
  format: null,
  onFormatChange: () => null,
  checkValidity: () => true,
  useArrowKeys: false
});

// Type imports

const {
  assert: assert$4
} = InteractiveUtil;
const {
  stringArrayOfSize
} = Util;

// We store two sets of dimensions for the brackets, for our two types of
// inputs, which vary in formatting: (1) the normal inputs rendered on
// desktop and (2) the keypad-based inputs newly rendered for the mobile apps
// and mobile web. These sets of dimensions come from `matrix.less`;
// the keypad-based input's dimensions are provided to the component itself,
// below.
const NORMAL_DIMENSIONS = {
  INPUT_MARGIN: 3,
  INPUT_HEIGHT: 30,
  INPUT_WIDTH: 40
};
const KEYPAD_INPUT_DIMENSIONS = {
  INPUT_MARGIN: 4,
  INPUT_HEIGHT: 36,
  INPUT_WIDTH: 64
};

/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */
function getInputPath$1(row, column) {
  return ["" + row, "" + column];
}
const getDefaultPath$1 = function () {
  return getInputPath$1(0, 0);
};
const getRowFromPath$1 = function (path) {
  // 'path' should be a (row, column) pair
  assert$4(___default["default"].isArray(path) && path.length === 2);
  return +path[0];
};
const getColumnFromPath$1 = function (path) {
  // 'path' should be a (row, column) pair
  assert$4(___default["default"].isArray(path) && path.length === 2);
  return +path[1];
};
const getRefForPath$1 = function (path) {
  const row = getRowFromPath$1(path);
  const column = getColumnFromPath$1(path);
  return "answer" + row + "," + column;
};
const getMatrixSize = function (matrix) {
  const matrixSize = [1, 1];

  // We need to find the widest row and tallest column to get the correct
  // matrix size.
  ___default["default"](matrix).each((matrixRow, row) => {
    let rowWidth = 0;
    ___default["default"](matrixRow).each((matrixCol, col) => {
      if (matrixCol != null && matrixCol.toString().length) {
        rowWidth = col + 1;
      }
    });

    // Matrix width:
    matrixSize[1] = Math.max(matrixSize[1], rowWidth);

    // Matrix height:
    if (rowWidth > 0) {
      matrixSize[0] = Math.max(matrixSize[0], row + 1);
    }
  });
  return matrixSize;
};
class Matrix extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "cursorPosition", void 0);
    _defineProperty(this, "state", {
      enterTheMatrix: 0
    });
    _defineProperty(this, "getInputPaths", () => {
      const inputPaths = [];
      const maxRows = this.props.matrixBoardSize[0];
      const maxCols = this.props.matrixBoardSize[1];
      ___default["default"](maxRows).times(row => {
        ___default["default"](maxCols).times(col => {
          const inputPath = getInputPath$1(row, col);
          inputPaths.push(inputPath);
        });
      });
      return inputPaths;
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "number";
    });
    _defineProperty(this, "_handleFocus", (row, col) => {
      this.props.onFocus(getInputPath$1(row, col));
    });
    _defineProperty(this, "_handleBlur", (row, col) => {
      this.props.onBlur(getInputPath$1(row, col));
    });
    _defineProperty(this, "focus", () => {
      this.focusInputPath(getDefaultPath$1());
      return true;
    });
    _defineProperty(this, "focusInputPath", path => {
      const inputID = getRefForPath$1(path);
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      this.refs[inputID].focus();
    });
    _defineProperty(this, "blurInputPath", path => {
      if (path.length === 0) {
        path = getDefaultPath$1();
      }
      const inputID = getRefForPath$1(path);
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
      this.refs[inputID].blur();
    });
    _defineProperty(this, "getDOMNodeForPath", inputPath => {
      const inputID = getRefForPath$1(inputPath);
      // eslint-disable-next-line react/no-string-refs
      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });
    _defineProperty(this, "setInputValue", (inputPath, value, callback) => {
      const row = getRowFromPath$1(inputPath);
      const col = getColumnFromPath$1(inputPath);
      this.onValueChange(row, col, value, callback);
    });
    _defineProperty(this, "handleKeyDown", (row, col, e) => {
      const maxRow = this.props.matrixBoardSize[0];
      const maxCol = this.props.matrixBoardSize[1];
      let enterTheMatrix = null;

      // eslint-disable-next-line react/no-string-refs
      const curInput = this.refs[getRefForPath$1(getInputPath$1(row, col))];
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getStringValue' does not exist on type 'ReactInstance'.
      const curValueString = curInput.getStringValue();
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getSelectionStart' does not exist on type 'ReactInstance'.
      const cursorStartPosition = curInput.getSelectionStart();
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getSelectionEnd' does not exist on type 'ReactInstance'.
      const cursorEndPosition = curInput.getSelectionEnd();
      let nextPath = null;
      if (e.key === "ArrowUp" && row > 0) {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly string[]' is not assignable to type 'null'.
        nextPath = getInputPath$1(row - 1, col);
      } else if (e.key === "ArrowDown" && row + 1 < maxRow) {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly string[]' is not assignable to type 'null'.
        nextPath = getInputPath$1(row + 1, col);
      } else if (e.key === "ArrowLeft" && col > 0) {
        if (cursorStartPosition === 0 && cursorEndPosition === 0) {
          // Only go to next input if we're at the *start* of the content
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly string[]' is not assignable to type 'null'.
          nextPath = getInputPath$1(row, col - 1);
        }
      } else if (e.key === "ArrowRight" && col + 1 < maxCol) {
        if (cursorStartPosition === curValueString.length) {
          // Only go to next input if we're at the *end* of the content
          // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly string[]' is not assignable to type 'null'.
          nextPath = getInputPath$1(row, col + 1);
        }
      } else if (e.key === "Enter") {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
        enterTheMatrix = this.state.enterTheMatrix + 1;
      } else if (e.key === "Escape") {
        // @ts-expect-error [FEI-5003] - TS2322 - Type '0' is not assignable to type 'null'.
        enterTheMatrix = 0;
      }
      if (nextPath) {
        // Prevent the cursor from jumping again inside the next input
        e.preventDefault();

        // Focus the input and move the cursor to the end of it.
        // eslint-disable-next-line react/no-string-refs
        const input = this.refs[getRefForPath$1(nextPath)];

        // Multiply by 2 to ensure the cursor always ends up at the end;
        // Opera sometimes sees a carriage return as 2 characters.
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getStringValue' does not exist on type 'ReactInstance'.
        const inputValString = input.getStringValue();
        const valueLength = inputValString.length * 2;

        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        input.focus();
        if (e.key === "ArrowRight") {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'setSelectionRange' does not exist on type 'ReactInstance'.
          input.setSelectionRange(0, 0);
        } else {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'setSelectionRange' does not exist on type 'ReactInstance'.
          input.setSelectionRange(valueLength, valueLength);
        }
      }
      if (enterTheMatrix != null) {
        this.setState({
          enterTheMatrix: enterTheMatrix
        });
      }
    });
    _defineProperty(this, "onValueChange", (row, column, value, cb) => {
      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone);
      if (!answers[row]) {
        answers[row] = [];
      }
      // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
      answers[row][column] = value;
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      this.props.onChange({
        answers: answers
      }, cb);
      this.props.trackInteraction();
    });
    _defineProperty(this, "getUserInput", () => {
      return {
        answers: this.props.answers
      };
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Matrix'.
      return Matrix.validate(this.getUserInput(), rubric);
    });
  }
  componentDidMount() {
    // Used in the `onBlur` and `onFocus` handlers
    this.cursorPosition = [0, 0];
  }
  render() {
    // Set the input sizes through JS so we can control the size of the
    // brackets. (If we set them in CSS we won't know values until the
    // inputs are rendered.)
    let dimensions;
    if (this.props.apiOptions.customKeypad) {
      dimensions = KEYPAD_INPUT_DIMENSIONS;
    } else {
      dimensions = NORMAL_DIMENSIONS;
    }
    const {
      INPUT_MARGIN,
      INPUT_HEIGHT,
      INPUT_WIDTH
    } = dimensions;
    const matrixSize = getMatrixSize(this.props.answers);
    const maxRows = this.props.matrixBoardSize[0];
    const maxCols = this.props.matrixBoardSize[1];
    const cursorRow = this.props.cursorPosition[0];
    const cursorCol = this.props.cursorPosition[1];
    const highlightedRow = Math.max(cursorRow, matrixSize[0] - 1);
    const highlightedCol = Math.max(cursorCol, matrixSize[1] - 1);
    const bracketHeight = (highlightedRow + 1) * (INPUT_HEIGHT + 2 * INPUT_MARGIN);
    const bracketOffset = (highlightedCol + 1) * (INPUT_WIDTH + 2 * INPUT_MARGIN);
    const className = classNames__default["default"]({
      "perseus-matrix": true,
      "static-mode": this.props.static,
      "the-matrix": this.state.enterTheMatrix >= 5
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, this.props.prefix && /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-prefix"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.prefix,
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-input"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-bracket bracket-left",
      style: {
        height: bracketHeight
      }
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-bracket bracket-right",
      style: {
        height: bracketHeight,
        left: bracketOffset
      }
    }), ___default["default"](maxRows).times(row => {
      const rowVals = this.props.answers[row];
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "matrix-row",
        key: row
      }, ___default["default"](maxCols).times(col => {
        const outside = row > highlightedRow || col > highlightedCol;
        const inputProps = {
          className: outside ? "outside" : "inside",
          ref: getRefForPath$1(getInputPath$1(row, col)),
          value: rowVals ? rowVals[col] : null,
          style: {
            height: INPUT_HEIGHT,
            width: INPUT_WIDTH,
            margin: INPUT_MARGIN
          },
          disabled: this.props.apiOptions.readOnly,
          onFocus: () => {
            // We store this locally so that we can use
            // the new information in the `onBlur`
            // handler, which happens before the props
            // change has time to propagate.
            // TODO(emily): Try to fix `MathOutput` so
            // it correctly sends blur events before
            // focus events.
            this.cursorPosition = [row, col];
            this.props.onChange({
              cursorPosition: [row, col]
            }, () => {
              // This isn't a user interaction, so
              // return false to signal that the
              // matrix shouldn't be focused
              return false;
            });
            this._handleFocus(row, col);
          },
          onBlur: () => {
            if (row === this.cursorPosition[0] && col === this.cursorPosition[1]) {
              this.props.onChange({
                cursorPosition: [0, 0]
              }, () => {
                // This isn't a user interaction,
                // so return false to signal that
                // the matrix shouldn't be focused
                return false;
              });
            }
            this._handleBlur(row, col);
          },
          onKeyDown: e => {
            this.handleKeyDown(row, col, e);
          },
          onChange: (value, cb) => {
            this.onValueChange(row, col, value, cb);
          }
        };
        let MatrixInput;
        if (this.props.apiOptions.customKeypad) {
          const style = {
            margin: INPUT_MARGIN,
            minWidth: INPUT_WIDTH,
            minHeight: INPUT_HEIGHT,
            // Ensure that any borders are included in
            // the provided width.
            boxSizing: "border-box",
            backgroundColor: outside ? "#f3f3f3" : "#fff"
          };
          MatrixInput = /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput, _extends({}, inputProps, {
            style: style,
            scrollable: true,
            keypadElement: this.props.keypadElement
          }));
        } else if (this.props.numericInput) {
          MatrixInput = /*#__PURE__*/React__namespace.createElement(NumberInput, inputProps);
        } else {
          const updatedProps = {
            ...inputProps,
            style: aphrodite.StyleSheet.create({
              // eslint-disable-next-line react-native/no-unused-styles
              input: {
                ...inputProps.style,
                display: "inline-block",
                padding: 0,
                backgroundColor: outside ? "#f3f3f3" : "#fff"
              }
            }).input
          };
          MatrixInput =
          /*#__PURE__*/
          // @ts-expect-error [FEI-5003] - TS2322 - Type '{ style: CSSProperties; className: "inside" | "outside"; ref: string; value: number | null; disabled: boolean; onFocus: () => void; onBlur: () => void; onKeyDown: (e: any) => void; onChange: (value: any, cb: any) => void; }' is not assignable to type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "children" | "style" | "id" | "className" | "placeholder" | "onFocus" | "onBlur" | "onChange" | "onKeyDown" | "labelText">'.
          React__namespace.createElement(TextInput, updatedProps);
        }
        return /*#__PURE__*/React__namespace.createElement("span", {
          key: col,
          className: "matrix-input-field"
        }, MatrixInput);
      }));
    })), this.props.suffix && /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-suffix"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.suffix,
      linterContext: this.props.linterContext
    })));
  }
}
_defineProperty(Matrix, "defaultProps", {
  matrixBoardSize: [3, 3],
  answers: [[]],
  prefix: "",
  suffix: "",
  cursorPosition: [0, 0],
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});
___default["default"].extend(Matrix, {
  validate: function (state, rubric) {
    const solution = rubric.answers;
    const supplied = state.answers;
    const solutionSize = getMatrixSize(solution);
    const suppliedSize = getMatrixSize(supplied);
    const incorrectSize = solutionSize[0] !== suppliedSize[0] || solutionSize[1] !== suppliedSize[1];
    const createValidator = KhanAnswerTypes.number.createValidatorFunctional;
    let message = null;
    let hasEmptyCell = false;
    let incorrect = false;
    ___default["default"](suppliedSize[0]).times(row => {
      ___default["default"](suppliedSize[1]).times(col => {
        if (supplied[row][col] == null || supplied[row][col].toString().length === 0) {
          hasEmptyCell = true;
        }
        if (!incorrectSize) {
          const validator = createValidator(solution[row][col], {
            simplify: true
          });
          const result = validator(supplied[row][col]);
          if (result.message) {
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
            message = result.message;
          }
          if (!result.correct) {
            incorrect = true;
          }
        }
      });
    });
    if (hasEmptyCell) {
      return {
        type: "invalid",
        message: i18n__namespace._("Make sure you fill in all cells in the matrix.")
      };
    }
    if (incorrectSize) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
    return {
      type: "points",
      earned: incorrect ? 0 : 1,
      total: 1,
      message: message
    };
  }
});
const propTransform$2 = editorProps => {
  // Remove answers before passing to widget
  const blankAnswers = ___default["default"](editorProps.matrixBoardSize[0]).times(function () {
    return stringArrayOfSize(editorProps.matrixBoardSize[1]);
  });
  editorProps = ___default["default"].pick(editorProps, "matrixBoardSize", "prefix", "suffix");
  return ___default["default"].extend(editorProps, {
    answers: blankAnswers
  });
};
const staticTransform$2 = editorProps => {
  const widgetProps = ___default["default"].pick(editorProps, "matrixBoardSize", "prefix", "suffix");
  // We convert matrix cells from numbers to string to match the expected
  // input into the rendered widget.
  // @ts-expect-error [FEI-5003] - TS2339 - Property 'answers' does not exist on type 'Pick<any, "suffix" | "prefix" | "matrixBoardSize">'.
  widgetProps.answers = ___default["default"].map(editorProps.answers, row => {
    // Replace null values with empty string
    return ___default["default"].map(row, cell => cell != null ? String(cell) : "");
  });
  return widgetProps;
};
var Matrix$1 = {
  name: "matrix",
  displayName: "Matrix",
  widget: Matrix,
  transform: propTransform$2,
  staticTransform: staticTransform$2,
  isLintable: true
};

/* eslint-disable @babel/no-invalid-this, react/sort-comp */
const defaultImage = {
  url: null,
  top: 0,
  left: 0
};
const Measurer = createReactClass__default["default"]({
  displayName: "Measurer",
  propTypes: {
    apiOptions: ApiOptions.propTypes,
    box: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
    image: PropTypes__default["default"].shape({
      url: PropTypes__default["default"].string,
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }),
    showProtractor: PropTypes__default["default"].bool,
    protractorX: PropTypes__default["default"].number,
    protractorY: PropTypes__default["default"].number,
    showRuler: PropTypes__default["default"].bool,
    rulerLabel: PropTypes__default["default"].string,
    rulerTicks: PropTypes__default["default"].number,
    rulerPixels: PropTypes__default["default"].number,
    rulerLength: PropTypes__default["default"].number
  },
  getDefaultProps: function () {
    return {
      box: [480, 480],
      image: {},
      showProtractor: true,
      protractorX: 7.5,
      protractorY: 0.5,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      rulerPixels: 40,
      rulerLength: 10
    };
  },
  getInitialState: function () {
    return {};
  },
  render: function () {
    const image = ___default["default"].extend({}, defaultImage, this.props.image);

    // TODO(scottgrant): This isn't a11y-friendly! We should insist on
    // finding some valid alt text when this widget is used.
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget perseus-widget-measurer " + "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      }
    }, image.url && /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative",
        top: image.top,
        left: image.left
      }
    }, /*#__PURE__*/React__namespace.createElement(SvgImage, {
      src: image.url
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  },
  componentDidMount: function () {
    this.setupGraphie();
  },
  componentDidUpdate: function (prevProps) {
    const shouldSetupGraphie = ___default["default"].any(["box", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "rulerPixels", "rulerLength"], function (prop) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      return prevProps[prop] !== this.props[prop];
    }, this);
    if (shouldSetupGraphie) {
      this.setupGraphie();
    }
  },
  setupGraphie: function () {
    // eslint-disable-next-line react/no-string-refs
    const graphieDiv = ReactDOM__default["default"].findDOMNode(this.refs.graphieDiv);
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'empty' does not exist on type 'JQueryStatic'.
    $__default["default"](graphieDiv).empty();
    const graphie = this.graphie = GraphUtils.createGraphie(graphieDiv);
    const scale = [40, 40];
    const range = [[0, this.props.box[0] / scale[0]], [0, this.props.box[1] / scale[1]]];
    graphie.init({
      range: range,
      scale: scale
    });
    graphie.addMouseLayer({
      allowScratchpad: true,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    });
    if (this.protractor) {
      this.protractor.remove();
    }
    if (this.props.showProtractor) {
      this.protractor = graphie.protractor([this.props.protractorX, this.props.protractorY]);
    }
    if (this.ruler) {
      this.ruler.remove();
    }
    if (this.props.showRuler) {
      this.ruler = graphie.ruler({
        center: [(range[0][0] + range[0][1]) / 2, (range[1][0] + range[1][1]) / 2],
        label: this.props.rulerLabel,
        pixelsPerUnit: this.props.rulerPixels,
        ticksPerUnit: this.props.rulerTicks,
        units: this.props.rulerLength
      });
    }
  },
  getUserInput: function () {
    return {};
  },
  simpleValidate: function (rubric) {
    // TODO(joel) - I don't understand how this is useful!
    return Measurer.validate(this.getUserInput(), rubric);
  },
  focus: $__default["default"].noop
});
___default["default"].extend(Measurer, {
  validate: function (state, rubric) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }
});
const propUpgrades = {
  "1": v0props => {
    const v1props = ___default["default"](v0props).chain().omit("imageUrl", "imageTop", "imageLeft").extend({
      image: {
        url: v0props.imageUrl,
        top: v0props.imageTop,
        left: v0props.imageLeft
      }
    }).value();
    return v1props;
  }
};
var Measurer$1 = {
  name: "measurer",
  displayName: "Measurer",
  widget: Measurer,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades
};

/**
 * Draw some text into a 2D canvas drawing context.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the text.  Must look like: {
 *         type: "text",
 *         pos: [x, y],
 *         value: "some text to draw",
 *     }
 *
 */
function drawText(ctx, item) {
  if (item.value === null) {
    return;
  }
  ctx.fillStyle = styles$c.fgColor;
  ctx.font = styles$c.font;
  ctx.fillText(item.value, item.pos[0] - styles$c.fontSizePx / 2 + 1, item.pos[1] + styles$c.fontSizePx / 2);
}

/**
 * Draw a double line into a 2D canvas drawing context.
 *
 * Apparently the way you do this is to stroke an extra-wide line in the
 * foreground color and then a smaller line in the background color. 5:3
 * foreground:background width looks reasonable for drawing chemical bonds.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:double",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */
function drawDoubleLine(ctx, item) {
  // Outer line that forms both of the bond lines.
  let path = new Path2D();
  ctx.lineWidth = 5 * styles$c.lineWidth;
  ctx.strokeStyle = styles$c.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);

  // Inner white line that separates the two bond lines.
  path = new Path2D();
  ctx.lineWidth = 3 * styles$c.lineWidth;
  ctx.strokeStyle = styles$c.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}

/**
 * Draw a triple line into a 2D canvas drawing context.
 *
 * Following the strategy for the double line, we stroke a very wide
 * foreground-color line, then a medium background-color line, then a narrow
 * foreground-color line.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:triple",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */
function drawTripleLine(ctx, item) {
  // TODO(colin): consolidate duplicated code from the three line drawing
  // functions.

  // Outer line that will form the two outer bond lines.
  let path = new Path2D();
  ctx.lineWidth = 7 * styles$c.lineWidth;
  ctx.strokeStyle = styles$c.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);

  // Middle white line that separates the bonds
  path = new Path2D();
  ctx.lineWidth = 5 * styles$c.lineWidth;
  ctx.strokeStyle = styles$c.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);

  // Inner line that forms the middle bond line.
  drawLine(ctx, item);
}

/**
 * Draw a single line into a 2D canvas drawing context
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:single",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */
function drawLine(ctx, item) {
  const path = new Path2D();
  ctx.lineWidth = styles$c.lineWidth;
  ctx.strokeStyle = styles$c.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}

/**
 * Lookup table that maps drawing instruction types to the functions that
 * render them.
 */
const drawingFuncs = {
  text: drawText,
  "line:single": drawLine,
  "line:double": drawDoubleLine,
  "line:triple": drawTripleLine
};

/**
 * Draw a single rendering instruction into a 2D canvas drawing context.
 */
function drawItem(ctx) {
  return function (item) {
    drawingFuncs[item.type](ctx, item);
  };
}

/**
 * Lookup table for drawing priorities.
 *
 * Types with lower priorities are drawn first.
 */
const ordering = {
  "line:single": 0,
  "line:double": 0,
  "line:triple": 0,
  text: 1
};

/**
 * Sorting comparison function that orders rendering instructions according to
 * their type's priority.
 */
function compareElements(item0, item1) {
  return ordering[item0.type] - ordering[item1.type];
}

/**
 * Draw an array of rendering instructions into a 2D canvas drawing context.
 */
function draw(ctx, items) {
  items.sort(compareElements).forEach(drawItem(ctx));
}
const styles$c = {
  bgColor: "rgb(255, 255, 255)",
  fgColor: "rgb(0, 0, 0)",
  fontSizePx: 12,
  lineWidth: 1,
  font: "12px sans"
};

/**
 * A molecule layout engine.
 *
 * This module transforms the SMILES syntax tree into a set of rendering
 * instructions.  A rendering instruction is an object indicating what type of
 * thing to render (e.g. text or line), where to render it, and any other style
 * properties needed.
 *
 * For instance, an oxygen atom might be rendered as
 * {type: "text", value: "O", pos: [0, 0], idx: "1,0"}
 */

// Default length of the bond.  This currently corresponds directly to pixels
// in the renderer, but we may want this just to be arbitrary in the future.
const bondLength = 30;

/**
 * Compute a coordinate by moving an angle and length from an origin point.
 *
 * Args:
 *     origin: a list of the [x, y] coordinates of the origin
 *     angle: an angle in degrees from the origin, following the typical
 *         convention of +x axis = 0 degrees, +y axis = 90 degrees.
 *     length: the distance to the new point
 * Return:
 *     a two-element list containing the [x, y] coordinates of the point.
 */
function polarAdd(origin, angle, length) {
  const x = origin[0];
  const y = origin[1];
  return [x + Math.cos(angle * 2 * Math.PI / 360) * length, y + -1.0 * Math.sin(angle * 2 * Math.PI / 360) * length];
}

/**
 * Compute the layout for a single atom.
 *
 * Args:
 *     atom: the atom node for which layout is being created, as returned from
 *         convertTree; the computed position of this atom is added to this
 *         object in place, in addition to being returned in the layout
 *         instruction.
 *         TODO(colin): refactor so that we don't need to modify this in place
 *     atoms: the list of all atoms, as returned from convertTree, used to
 *         position this atom appropriately relative to its neighbors
 *     bonds: the list of all bonds, as returned from convertTree, used to
 *         determine the geometry based on bond type
 *     rotationAngle: a constant rotation for the whole molecule (in degrees)
 *
 * Return:
 *     a rendering instruction for the atom, containing a type (text), the text
 *     to render, the position, and the atom index
 */
function atomLayout(atom, atoms, bonds, rotationAngle) {
  let textValue = atom.symbol;
  if (textValue === "C" && Object.keys(atoms).length !== 1) {
    // By convention, don't render the C for carbon in a chain.
    textValue = null;
  }
  if (atom.idx === "1,0") {
    // The first atom is special-cased because there are no neighbors for
    // relative positioning.
    const pos = [0, 0];
    atom.pos = pos;
    // Conventionally, molecules are rendered where the first bond is not
    // horizontal, but at a 30 degree angle, so subtract 30 degrees for the
    // first atom's direction.
    atom.baseAngle = -30 + rotationAngle;
    return {
      type: "text",
      value: textValue,
      pos: pos,
      idx: atom.idx
    };
  }
  // If we're an atom with any other index than the case just handled, we're
  // guaranteed to have a neighbor who has a defined position.
  const prevPositionedAtom = atoms[atom.connections.find(function (c) {
    return atoms[c].pos;
  })];

  // Find this atom's index in the previous atom's connections
  const myIndex = prevPositionedAtom.connections.indexOf(atom.idx);
  let baseAngleIncrement = 60;
  let angleIncrement = 120;
  if (prevPositionedAtom.connections.length === 4) {
    // By convention, if an atom has 4 bonds, we represent it with 90
    // degree angles in 2D, even though it would have tetrahedral geometry
    // with ~110 degree angles in 3D.
    angleIncrement = 90;
    baseAngleIncrement = 90;
  } else if (bonds.find(bond => bond.bondType === "triple" && bond.to === atom.idx) || bonds.find(bond => bond.bondType === "triple" && bond.to === prevPositionedAtom.idx)) {
    // Triple bonds have a bond angle of 180 degrees, so don't change the
    // direction in which we made the previous bond.
    angleIncrement = 0;
    baseAngleIncrement = 0;
  }
  let angle = 0;
  const idxPath = prevPositionedAtom.idx.split(":");
  const lastAtomIdx = idxPath[idxPath.length - 1].split(",")[0];

  // Conventionally, a single chain of atoms is rendered as a zig-zag pattern
  // with 120 degree angles.  This means we need to flip the angle every
  // other atom.  The parser ensures that indices always alternate odd-even,
  // including taking into account branch points.
  // TODO(colin): don't depend on the parser's indexing scheme and just track
  // this entirely in the layout engine.
  if (parseInt(lastAtomIdx) % 2 !== 0) {
    angle = prevPositionedAtom.baseAngle - (baseAngleIncrement - angleIncrement * myIndex);
  } else {
    angle = prevPositionedAtom.baseAngle + (baseAngleIncrement - angleIncrement * myIndex);
  }
  const pos = polarAdd(prevPositionedAtom.pos, angle, bondLength);
  atom.pos = pos;
  atom.baseAngle = angle;
  return {
    type: "text",
    value: textValue,
    pos: pos,
    idx: atom.idx
  };
}

/**
 * Get the start and end position for a bond connecting two atoms.
 *
 * If we have non-carbon atoms that render with explicit letters connected by a
 * bond, we don't want the line for the bond to extend into the lettering for
 * the atom.
 *
 * This function returns the start and end positions of the bond's line, taking
 * into account that one or both end points might need to be moved to make room
 * for text.
 *
 * TODO(colin): this makes assumptions about the relative sizes of the length
 * of a bond and the text.  Think about alternate ways to represent this that
 * might not have that problem.
 */
function maybeShrinkLines(fromAtom, toAtom) {
  const shrinkFactor = 0.25;
  let fromPos = [fromAtom.pos[0], fromAtom.pos[1]];
  let toPos = [toAtom.pos[0], toAtom.pos[1]];
  if (fromAtom.symbol !== "C") {
    fromPos = [toAtom.pos[0] - (1 - shrinkFactor) * (toAtom.pos[0] - fromAtom.pos[0]), toAtom.pos[1] - (1 - shrinkFactor) * (toAtom.pos[1] - fromAtom.pos[1])];
  }
  if (toAtom.symbol !== "C") {
    // For carbon atoms, conventionally we don't draw any letter, so this
    // special cases drawing the bond lines all the way to the point where
    // they meet.
    toPos = [fromAtom.pos[0] - (1 - shrinkFactor) * (fromAtom.pos[0] - toAtom.pos[0]), fromAtom.pos[1] - (1 - shrinkFactor) * (fromAtom.pos[1] - toAtom.pos[1])];
  }
  return [fromPos, toPos];
}

/**
 * Compute the layout for a bond between two atoms.
 *
 * Args:
 *     bond: the bond node for which the layout is being computed, as returned
 *         by convertTree
 *     atoms: the list of all atoms returned by convertTree, which should
 *         already have been processed for layout and thus have positions set
 *
 * Return:
 *     a rendering instruction for the bond containing a type
 *     (line:{single,double,triple}) and the line's endpoints
 */
function bondLayout(bond, atoms) {
  const fromAtom = atoms[bond.from];
  const toAtom = atoms[bond.to];
  const startAndEndPos = maybeShrinkLines(fromAtom, toAtom);
  return {
    type: "line:" + bond.bondType,
    startPos: startAndEndPos[0],
    endPos: startAndEndPos[1]
  };
}

/**
 * Convert an array of atom indices to a single string unique identifier.
 *
 * For linear molecules, or for atoms in the main chain, this will just be the
 * atom index, something like "0,1".  For branched molecules, however, we
 * uniquely identify atoms by an array of atoms where the branching happened,
 * followed by the index in the current branch (like ["0,1", "1,2", "1,1"]).
 * This function just joins the parts with a colon so that we can have nice
 * object keys that still track the series of branches to get to an atom, which
 * is guaranteed to be a unique identifier.
 *
 */
function idxString(idx) {
  return idx.join(":");
}

/**
 * Convert the parse tree output by the parser into an ordered list of atoms
 * and bonds to render.
 *
 * Args:
 *     atoms: the output list of atoms that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     bonds: the output list of bonds that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     tree: the parse tree generated by the SMILES parser module.
 *
 * Return:
 *     the final value of atoms and bonds, which are lists of all the atom
 *     nodes and bond nodes, respectively, that need to be rendered.
 */
function convertTree(atoms, bonds, tree) {
  if (tree === null) {
    return [atoms, bonds];
  }
  if (tree.type === "atom") {
    const treeIdx = idxString(tree.idx);
    atoms[treeIdx] = {
      idx: treeIdx,
      symbol: tree.symbol,
      connections: []
    };
    if (tree.bonds) {
      tree.bonds.forEach(function (b) {
        const toIdx = idxString(b.to.idx);
        atoms[treeIdx].connections.push(toIdx);
        bonds.push({
          from: treeIdx,
          to: toIdx,
          bondType: b.bondType
        });
        convertTree(atoms, bonds, b.to);
        atoms[toIdx].connections.push(treeIdx);
      });
    }
  }
  return [atoms, bonds];
}

/**
 * Recursively process the queue of atoms that need to have layout computed.
 *
 * Args:
 *     outputs: the array of atom rendering instructions we're in the process
 *         of building.  This should be the empty array if not being called
 *         recursively.
 *     atomProcessingQueue: the array of unique identifier strings (see the
 *         comment for idxString for more information about these) of atoms
 *         currently in line to be processed.  When not being called
 *         recursively, this should be a array with a single element, the
 *         unique identifier of the first atom in the structure ("1,0" in the
 *         current scheme).
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the atoms in the molecule
 */
function atomLayoutHelper(outputs, atomProcessingQueue, atoms, bonds, rotationAngle) {
  if (atomProcessingQueue.length === 0) {
    return outputs;
  }
  const queuedAtomIdx = atomProcessingQueue.shift();
  const atom = atoms[queuedAtomIdx];
  atom.connections.forEach(function (c) {
    if (!atoms[c].pos) {
      atomProcessingQueue.push(c);
    }
  });
  return atomLayoutHelper(outputs.concat(atomLayout(atom, atoms, bonds, rotationAngle)), atomProcessingQueue, atoms, bonds, rotationAngle);
}

/**
 * Recursively process the queue of bonds that need to have layout computed.
 *
 * Args:
 *     outputs: the array of bond rendering instructions we're in the process
 *         of building.  This should be the empty array or the array of all
 *         atom rendering instructions if not being called recursively.
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the bonds in the molecule
 *     concatenated to the initial value of outputs
 */
function bondLayoutHelper(outputs, atoms, bonds) {
  if (bonds.length === 0) {
    return outputs;
  }
  return bondLayoutHelper(outputs.concat(bondLayout(bonds[0], atoms)), atoms, bonds.slice(1));
}

/**
 * Compute an array of rendering instructions from the parse tree of a molecule.
 *
 * Args:
 *     tree: the parse tree as returned by the SMILES parser module
 *     rotationAngle: a global rotation (in degrees) to be applied to the whole
 *         molecule; this is manually adjustable in the widget.
 *
 * Return:
 *     an array of rendering instructions for all the atoms and bonds in the
 *     molecule suitable for processing by the renderer
 */
function layout$1(tree, rotationAngle) {
  const converted = convertTree({}, [], tree);
  const atoms = converted[0];
  const bonds = converted[1];
  const outputs = atomLayoutHelper([], ["1,0"], atoms, bonds, rotationAngle);
  return bondLayoutHelper(outputs, atoms, bonds);
}
var MoleculeLayout = {
  layout: layout$1,
  // The remainder are exported for testing and are not intended for external
  // use.
  _atomLayout: atomLayout,
  _bondLayout: bondLayout,
  _bondLength: bondLength,
  _convertTree: convertTree
};

// Regexp defining characters that are valid SMILES characters that this parser
// can parse.  In addition to serving as a sort of validation, this also keeps
// out unimplemented features (like cycles and stereochemistry), which use
// additional characters.
const smilesRe = new RegExp("^[A-Za-z\\[\\]()=#+-]*$");

// Regexp defining what characters are valid as atom names.  This includes
// common 1-character elements, Cl and Br for convenience, and the open
// bracket, which can be used to include anything as an atom name.
const atomRe = new RegExp("^(Cl|Br|[CONPSFBI]|\\[)");
function ParseError$1(message) {
  // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
  this.message = message;
}

/**
 * Perform a functional update of a possibly nested object.
 *
 * Args:
 *     obj: an object, will not be modified
 *     keylist: a list of keys whose values will be updated in the object.
 *         This represents a path to a value inside nested objects.  For
 *         example, if keylist == ["a", "b", "c"], then a new object is
 *         returned with obj["a"]["b"]["c"] updated.  Note that if any of the
 *         keys is not already present, this will insert {} as a default value
 *         for that key.
 *     val: the new value to associate with the keypath
 *
 * Return: a new object, which is a shallow copy of the original with the value
 *     at the specified keypath replaced.
 */
function _mset(obj, keylist, val) {
  const k0 = keylist[0];
  const rest = keylist.slice(1);
  let newObj;
  if (Array.isArray(obj)) {
    newObj = [...obj];
  } else {
    newObj = {
      ...(obj || {})
    };
  }
  let newVal = val;
  if (rest.length > 0) {
    newVal = _mset(newObj[k0], rest, val);
  }
  newObj[k0] = newVal;
  return newObj;
}

/**
 * Perform a functional increment of a value in a nested object.
 *
 * Args:
 *     obj: an object; this will not be modified
 *     keylist: a list of keys representing a path into a nested object.  (See
 *         `_mset` for examples.)
 *
 * Return:
 *     an object that is a shallow copy of obj, with the value at the specified
 *     path incremeneted.
 */
function _inc(obj, keylist) {
  const val = keylist.reduce(function (acc, elt) {
    return acc[elt];
  }, obj);
  return _mset(obj, keylist, val + 1);
}
function validate(smiles) {
  return smilesRe.test(smiles);
}

/**
 * Parse a bond modifier character, updating the context object so that the
 * next bond created has this modifier.
 */
function parseBondModifier(smiles, ctx) {
  const firstChar = smiles[0];
  const rest = smiles.slice(1);
  if (firstChar === "=") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "double"));
  }
  if (firstChar === "#") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "triple"));
  }
  throw new ParseError$1("Invalid character: " + firstChar);
}

/**
 * Slice the input string, removing a parenthesized expression.
 * (Will handle nested parentheses.)
 *
 * parenStack should be a list containing any open parentheses already
 * encountered.  (Usually, this will be ["("])
 */
function sliceFromMatchingCloseParen(smiles, parenStack) {
  if (parenStack.length === 0) {
    return smiles;
  }
  if (smiles === "") {
    throw new ParseError$1("Mismatched parentheses");
  }
  const firstChar = smiles[0];
  const rest = smiles.slice(1);
  if (firstChar === "(") {
    return sliceFromMatchingCloseParen(rest, parenStack.concat(firstChar));
  }
  if (firstChar === ")") {
    return sliceFromMatchingCloseParen(rest, parenStack.slice(1));
  }
  return sliceFromMatchingCloseParen(rest, parenStack);
}

/**
 * Parse a branch, as indicated by the presence of a parenthesized experession.
 *
 * This returns a list of all branches (including the continuation of the
 * backbone) that should be added to the previous atom's bond list.
 */
function parseParenthesizedExpression(smiles, ctx) {
  const firstChar = smiles[0];
  const rest = smiles.slice(1);
  if (firstChar === "(") {
    let newCtx = {
      ...ctx,
      parens: ctx.parens + "("
    };
    // increment the branch index
    newCtx = _inc(ctx, ["idx", ctx.idx.length - 1, 1]);
    let inBranchIdx = -1;
    if (ctx.idx[ctx.idx.length - 1][0] % 2 === 0) {
      // HACK(colin): this is so that we preserve the odd/even series in
      // indices in branches; the layout engine uses this to select
      // angles, and if we don't do this, editing one part of a molecule
      // can cause another to flop around oddly.
      // TODO(colin): this should just start at 0 all the time, and the
      // layout engine should figure out continuity.
      inBranchIdx = 0;
    }
    const parenCtx = {
      ...newCtx,
      idx: newCtx.idx.concat([[inBranchIdx, 0]]),
      parens: newCtx.parens.concat("(")
    };
    const parenExpr = parse$2(rest, parenCtx);
    const remainder = parse$2(sliceFromMatchingCloseParen(rest, ["("]), newCtx);
    return [parenExpr].concat(remainder);
  }
  if (firstChar === ")") {
    if (ctx.parens[ctx.parens.length - 1] !== "(") {
      throw new ParseError$1("Mismatched parentheses");
    }
    return null;
  }
  throw new ParseError$1("Invalid bare character: " + firstChar);
}

/**
 * Get the symbol of the next atom in the molecule.
 *
 * Return a 2-element list containing that symbol and the remainder of the
 * molecule.
 */
function readAtomSymbol(smiles, _ctx) {
  let sym = null;
  let rest = null;
  if (smiles[0] === "[") {
    const closingIdx = smiles.indexOf("]");
    if (closingIdx === -1) {
      return ["", smiles];
    }
    sym = smiles.slice(1, closingIdx);
    rest = smiles.slice(closingIdx + 1);
  } else {
    const match = atomRe.exec(smiles);
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'. | TS2531 - Object is possibly 'null'.
    sym = match[1];
    // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
    rest = smiles.slice(sym.length);
  }
  return [sym, rest];
}

/**
 * Parse the next atom in the molecule, returning an atom object if this is the
 * first atom in the molecule, or a bond object with this atom as the
 * destination of the bond if this is not the first atom.
 */
function parseAtom(smiles, ctx) {
  const symbolInfo = readAtomSymbol(smiles);
  const atom = symbolInfo[0];
  if (atom === "") {
    return ["error", "Unable to parse bracketed atom."];
  }
  const rest = symbolInfo[1];

  // Atoms are indexed by a list of two-element lists.  In each two-element
  // list, the first element is the atom counter, and the second element is
  // the branch counter.  Branches are 1-indexed so that the main chain of
  // the molecule can be indicated by 0.  Atoms may be either 0- or
  // 1-indexed, defaulting to 1, to maintain a alternating pattern of
  // odd/even indices. So, for example, if an atom has a branch off the main
  // chain, and its atom index is x, then the indices of atoms are:
  //     Atom where branch occurs: [[x, 0]]
  //     First atom in the branch: [[x, 1], [1, 0]]  (assuming x is even)
  //     Next atom in the main chain: [[x + 1, 0]]

  // increment the atom counter and reset the branch counter
  const newCtx = _mset(ctx, ["idx", ctx.idx.length - 1], [1 + ctx.idx[ctx.idx.length - 1][0], 0]);
  let restOfMolecule = parse$2(rest, _mset(newCtx, ["bond", "bondType"], "single"));
  if (!Array.isArray(restOfMolecule) && !!restOfMolecule) {
    //TODO(colin): fix this awkwardness.
    restOfMolecule = [restOfMolecule];
  }
  const atomObj = {
    type: "atom",
    symbol: atom,
    bonds: restOfMolecule,
    idx: newCtx.idx
  };
  if (ctx.bond) {
    return {
      type: "bond",
      bondType: ctx.bond.bondType,
      to: atomObj
    };
  }
  return atomObj;
}
function startsWithAtom(s) {
  return atomRe.test(s);
}
function isModifierChar(s) {
  return s === "=" || s === "#";
}

/**
 * Parse a SMILES string to an internal tree representation.
 *
 * Args:
 *   smiles [string]: a string representing the molecule.
 *
 * Returns: the parse tree (see top-of file docstring for details).
 *
 * Throws:
 *     ParseError: if the input is not valid SMILES or contains features not
 *         yet implemented.
 */
function parse$2(smiles, ctx) {
  if (!validate(smiles)) {
    throw new ParseError$1("Invalid input.");
  }
  if (!smiles || smiles.length === 0) {
    return null;
  }
  if (startsWithAtom(smiles)) {
    return parseAtom(smiles, ctx || {
      idx: [[0, 0]],
      parens: [],
      stack: [],
      bondModifiers: []
    });
  }
  if (isModifierChar(smiles[0])) {
    // TODO(colin): add a better error message in the case where the input
    // is invalid and starts with a modifier character?
    return parseBondModifier(smiles, ctx);
  }
  // TODO(colin): add additional cases for unimplemented bits of SMILES
  // syntax.
  return parseParenthesizedExpression(smiles, ctx);
}
var SmilesParser = {
  parse: parse$2,
  ParseError: ParseError$1
};

const {
  layout
} = MoleculeLayout;
const parse$1 = SmilesParser.parse;
const ParseError = SmilesParser.ParseError;
const borderSize = 30;
class Molecule extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      parsedSmiles: null,
      error: null
    });
    _defineProperty(this, "stateFromSmiles", smiles => {
      try {
        this.setState({
          // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
          parsedSmiles: parse$1(smiles),
          error: null
        });
      } catch (e) {
        if (e instanceof ParseError) {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'message' does not exist on type '{}'.
          this.setState({
            error: e.message
          });
        } else {
          throw e;
        }
      }
    });
    _defineProperty(this, "setCanvasBounds", (canvas, items) => {
      const xmax = Math.max(...items.map(item => item.pos ? item.pos[0] : -Infinity));
      const ymax = Math.max(...items.map(item => item.pos ? item.pos[1] : -Infinity));
      const xmin = Math.min(...items.map(item => item.pos ? item.pos[0] : Infinity));
      const ymin = Math.min(...items.map(item => item.pos ? item.pos[1] : Infinity));
      const width = xmax - xmin + 2 * borderSize;
      const height = ymax - ymin + 2 * borderSize;
      canvas.width = width;
      canvas.height = height;
      return [borderSize - xmin, borderSize - ymin];
    });
    _defineProperty(this, "canvasRender", () => {
      // Since canvas drawing happens only through an imperative API, we sync
      // up the component with the canvas here, which happens when the
      // component mounts or updates.
      if (!!this.state.error || !this.state.parsedSmiles) {
        return;
      }
      const items = layout(this.state.parsedSmiles, this.props.rotationAngle);
      // eslint-disable-next-line react/no-string-refs
      const canvas = this.refs.canvas;
      const translation = this.setCanvasBounds(canvas, items);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getContext' does not exist on type 'ReactInstance'.
      const ctx = canvas.getContext("2d");
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(translation[0], translation[1]);
      draw(ctx, items);
      ctx.restore();
    });
  }
  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    this.stateFromSmiles(this.props.smiles);
  }
  componentDidMount() {
    this.canvasRender();
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this.stateFromSmiles(nextProps.smiles);
  }
  componentDidUpdate() {
    this.canvasRender();
  }
  render() {
    // TODO(colin): escape the punctuation in the SMILES alt text for
    // screen readers?
    let content = /*#__PURE__*/React__namespace.createElement("canvas", {
      className: "molecule-canvas",
      id: this.props.id + "-molecule"
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "canvas"
    }, i18n__namespace.$_("A molecular structure drawing. SMILES notation: %(content)s", {
      content: this.props.smiles
    }));
    if (this.state.error) {
      content = /*#__PURE__*/React__namespace.createElement("div", {
        className: "error"
      }, this.state.error);
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "molecule-canvas"
    }, content);
  }
}
_defineProperty(Molecule, "propTypes", {
  id: PropTypes__default["default"].string.isRequired,
  rotationAngle: PropTypes__default["default"].number,
  smiles: PropTypes__default["default"].string
});
class MoleculeWidget extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "simpleValidate", () => {
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });
    _defineProperty(this, "getUserInput", () => {
      return [];
    });
    _defineProperty(this, "validate", (state, rubric) => {
      // TODO(colin): this is here as part of the interface for a component.
      // Figure out if there is something more appropriate that this should
      // return.
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(Molecule, {
      id: this.props.widgetId,
      smiles: this.props.smiles,
      rotationAngle: this.props.rotationAngle
    });
  }
}
_defineProperty(MoleculeWidget, "propTypes", {
  rotationAngle: PropTypes__default["default"].number,
  smiles: PropTypes__default["default"].string,
  widgetId: PropTypes__default["default"].string
});
_defineProperty(MoleculeWidget, "defaultProps", {
  rotationAngle: 0
});
var Molecule$1 = {
  name: "molecule-renderer",
  displayName: "Molecule renderer",
  hidden: true,
  widget: MoleculeWidget
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'MovablePoint' does not exist on type 'typeof Graphie'.
const MovablePoint$1 = Graphie.MovablePoint;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Line' does not exist on type 'typeof Graphie'.
const Line$1 = Graphie.Line;
const {
  assert: assert$3
} = InteractiveUtil;
const bound = (x, gt, lt) => Math.min(Math.max(x, gt), lt);
const EN_DASH = "\u2013";
const horizontalPadding = 30;
const reverseRel = {
  ge: "le",
  gt: "lt",
  le: "ge",
  lt: "gt"
};
const toggleStrictRel = {
  ge: "gt",
  gt: "ge",
  le: "lt",
  lt: "le"
};
function formatImproper(n, d) {
  if (d === 1) {
    return "" + n;
  }
  return "\\dfrac{".concat(n, "}{").concat(d, "}");
}
function formatMixed(n, d) {
  if (n < 0) {
    return "-" + formatMixed(-n, d);
  }
  const w = Math.floor(n / d);
  if (w === 0) {
    return formatImproper(n, d);
  }
  if (n - w * d === 0) {
    return "" + w;
  }
  return w + formatImproper(n - w * d, d);
}
function formatNonReduced(n, d, base) {
  const factor = Math.floor(base / d);
  return formatImproper(n * factor, base);
}
const _label = (graphie, labelStyle, pos, value, base) => {
  value = value || pos;

  // TODO(jack): Find out if any exercises have "decimal ticks" set,
  // and if so, re-save them and remove this check.
  if (labelStyle === "decimal" || labelStyle === "decimal ticks") {
    return graphie.label([pos, -0.53], Math.round(value * 100) / 100, "center");
  }
  if (labelStyle === "improper") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatImproper(frac[0], frac[1]), "below");
  }
  if (labelStyle === "mixed") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatMixed(frac[0], frac[1]), "below");
  }
  if (labelStyle === "non-reduced") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatNonReduced(frac[0], frac[1], base), "below");
  }
};

// @ts-expect-error [FEI-5003] - TS2339 - Property 'createSimpleClass' does not exist on type 'typeof Graphie'.
const TickMarks = Graphie.createSimpleClass((graphie, props) => {
  // Avoid infinite loop
  if (!___default["default"].isFinite(props.tickStep) || props.tickStep <= 0) {
    return []; // this has screwed me for the last time!
  }

  const results = [];

  // For convenience, extract some props into separate variables
  const range = props.range;
  const labelRange = props.labelRange;
  const leftLabel = labelRange[0] == null ? range[0] : labelRange[0];
  const rightLabel = labelRange[1] == null ? range[1] : labelRange[1];

  // Find base via GCD for non-reduced fractions
  let base;
  if (props.labelStyle === "non-reduced") {
    const fractions = [leftLabel, rightLabel];
    for (let i = 0; i <= props.numDivisions; i++) {
      const x = range[0] + i * props.tickStep;
      fractions.push(x);
    }
    const getDenom = x => kmath.number.toFraction(x)[1];
    const denoms = ___default["default"].map(fractions, getDenom);
    base = ___default["default"].reduce(denoms, (x, y) => KhanMath.getLCM(x, y));
  } else {
    base = undefined;
  }

  // Draw and save the tick marks and tick labels
  for (let i = 0; i <= props.numDivisions; i++) {
    const x = range[0] + i * props.tickStep;
    results.push(graphie.line([x, -0.2], [x, 0.2]));
    const labelTicks = props.labelTicks;
    if (labelTicks || props.labelStyle === "decimal ticks") {
      results.push(_label(graphie, props.labelStyle, x, x, base));
    }
  }

  // Render the text labels
  results.push(graphie.style(props.isMobile ? {
    color: KhanColors.BLUE_D
  } : {}, () => _label(graphie, props.labelStyle, leftLabel, leftLabel, base)));
  results.push(graphie.style(props.isMobile ? {
    color: KhanColors.BLUE_D
  } : {}, () => _label(graphie, props.labelStyle, rightLabel, rightLabel, base)));

  // Render the labels' lines
  graphie.style({
    stroke: props.isMobile ? KhanColors.BLUE_D : KhanColors.DYNAMIC,
    strokeWidth: 3.5
  }, () => {
    results.push(graphie.line([leftLabel, -0.2], [leftLabel, 0.2]));
    results.push(graphie.line([rightLabel, -0.2], [rightLabel, 0.2]));
  });
  return results;
});
class NumberLine extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      numDivisionsEmpty: false
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "isValid", () => {
      const range = this.props.range;
      let initialX = this.props.numLinePosition;
      const divisionRange = this.props.divisionRange;
      initialX = initialX == null ? range[0] : initialX;
      return range[0] < range[1] && kmath.number.sign(initialX - range[0]) >= 0 && kmath.number.sign(initialX - range[1]) <= 0 && divisionRange[0] < divisionRange[1] && 0 < this.props.numDivisions && 0 < this.props.snapDivisions;
    });
    _defineProperty(this, "onNumDivisionsChange", (numDivisions, cb) => {
      const divRange = this.props.divisionRange.slice();
      const width = this.props.range[1] - this.props.range[0];

      // Don't allow a fraction for the number of divisions
      numDivisions = Math.round(numDivisions);

      // Don't allow negative numbers for the number of divisions
      numDivisions = numDivisions < 0 ? numDivisions * -1 : numDivisions;

      // If the number of divisions isn't blank, update the number line
      if (numDivisions) {
        const nextProps = ___default["default"].extend({}, this.props, {
          tickStep: width / numDivisions
        });
        const newNumLinePosition = this.snapNumLinePosition(nextProps, this.props.numLinePosition);
        this.setState({
          numDivisionsEmpty: false
        }, () => {
          this.props.onChange({
            divisionRange: divRange,
            numDivisions: numDivisions,
            numLinePosition: newNumLinePosition
          }, cb);
        });
      } else {
        this.setState({
          numDivisionsEmpty: true
        }, cb);
      }
    });
    _defineProperty(this, "_handleTickCtrlFocus", () => {
      this.props.onFocus(["tick-ctrl"]);
    });
    _defineProperty(this, "_handleTickCtrlBlur", () => {
      this.props.onBlur(["tick-ctrl"]);
    });
    _defineProperty(this, "focus", () => {
      if (this.props.isTickCtrl) {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        this.refs["tick-ctrl"].focus();
        return true;
      }
    });
    _defineProperty(this, "focusInputPath", path => {
      if (path.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        this.refs[path[0]].focus();
      }
    });
    _defineProperty(this, "blurInputPath", path => {
      if (path.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
        this.refs[path[0]].blur();
      }
    });
    _defineProperty(this, "getInputPaths", () => {
      if (this.props.isTickCtrl) {
        return [["tick-ctrl"]];
      }
      return [];
    });
    _defineProperty(this, "getDOMNodeForPath", inputPath => {
      if (inputPath.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        return ReactDOM__default["default"].findDOMNode(this.refs[inputPath[0]]);
      }
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
        return "number";
      }
    });
    _defineProperty(this, "setInputValue", (inputPath, value, callback) => {
      if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
        this.onNumDivisionsChange(value, callback);
      }
    });
    _defineProperty(this, "_renderGraphie", () => {
      // Position variables
      const range = this.props.range;
      const width = range[1] - range[0];
      const options = ___default["default"].pick(this.props, ["range", "isTickCtrl"]);

      // TODO(aria): Maybe save this as `this.calculatedProps`?
      const props = ___default["default"].extend({}, this.props, {
        tickStep: width / this.props.numDivisions
      });
      return /*#__PURE__*/React__namespace.createElement(Graphie
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "graphie"
        // HACK(emily): We key this graphie on the label style because
        // when the label style changes we want to resize the graphie,
        // which isn't doable without throwing away the graphie and
        // making a new one.
        ,
        key: this.props.labelStyle,
        box: [this.props.apiOptions.isMobile ? 288 : 460, 80],
        options: options,
        onMouseDown: coord => {
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'movables' does not exist on type 'ReactInstance'.
          this.refs.graphie.movables.numberLinePoint.grab(coord);
        },
        setup: this._setupGraphie,
        setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
        isMobile: this.props.apiOptions.isMobile
      }, /*#__PURE__*/React__namespace.createElement(TickMarks, _extends({}, ___default["default"].pick(props, ["range", "numDivisions", "labelTicks", "labelStyle", "labelRange", "tickStep"]), {
        isMobile: this.props.apiOptions.isMobile
      })), this._renderInequality(props), this._renderNumberLinePoint(props));
    });
    _defineProperty(this, "snapNumLinePosition", (props, numLinePosition) => {
      const left = props.range[0];
      const right = props.range[1];
      const snapX = props.tickStep / props.snapDivisions;
      let x = bound(numLinePosition, left, right);
      x = left + kmath.number.roundTo(x - left, snapX);
      assert$3(___default["default"].isFinite(x));
      return x;
    });
    _defineProperty(this, "movePosition", targetPosition => {
      this.change({
        numLinePosition: targetPosition
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "_renderNumberLinePoint", props => {
      const isOpen = ___default["default"](["lt", "gt"]).contains(props.rel);

      // In static mode the point's fill and stroke is blue to signify that
      // it can't be interacted with.
      let fill;
      if (isOpen) {
        fill = KhanColors._BACKGROUND;
      } else if (props.static) {
        fill = KhanColors.DYNAMIC;
      } else {
        fill = KhanColors.INTERACTIVE;
      }
      const normalStyle = {
        fill: fill,
        stroke: props.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE,
        "stroke-width": isOpen ? 3 : 1
      };
      const highlightStyle = {
        fill: isOpen ? KhanColors._BACKGROUND : KhanColors.INTERACTING,
        "stroke-width": isOpen ? 3 : 1
      };
      const mobileDotStyle = props.isInequality ? {
        stroke: KhanColors.INTERACTIVE,
        "fill-opacity": isOpen ? 0 : 1
      } : {};
      return /*#__PURE__*/React__namespace.createElement(MovablePoint$1
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "numberLinePoint",
        pointSize: 6,
        coord: [props.numLinePosition, 0],
        constraints: [(coord, prevCoord) => {
          // constrain-y
          return [coord[0], prevCoord[1]];
        }, (coord, prevCoord) => {
          // snap X
          const x = this.snapNumLinePosition(props, coord[0]);
          return [x, coord[1]];
        }],
        normalStyle: normalStyle,
        highlightStyle: highlightStyle,
        onMove: coord => {
          this.movePosition(coord[0]);
        },
        isMobile: this.props.apiOptions.isMobile,
        mobileStyleOverride: mobileDotStyle,
        showTooltips: this.props.showTooltips,
        xOnlyTooltip: true
      });
    });
    _defineProperty(this, "handleReverse", () => {
      const newRel = reverseRel[this.props.rel];
      this.props.onChange({
        rel: newRel
      });
    });
    _defineProperty(this, "handleToggleStrict", () => {
      const newRel = toggleStrictRel[this.props.rel];
      this.props.onChange({
        rel: newRel
      });
    });
    _defineProperty(this, "_getInequalityEndpoint", props => {
      const isGreater = ___default["default"](["ge", "gt"]).contains(props.rel);
      const widthInPixels = 400;
      const range = props.range;
      const scale = (range[1] - range[0]) / widthInPixels;
      const buffer = horizontalPadding * scale;
      const left = range[0] - buffer;
      const right = range[1] + buffer;
      const end = isGreater ? [right, 0] : [left, 0];
      return end;
    });
    _defineProperty(this, "_renderInequality", props => {
      if (props.isInequality) {
        const end = this._getInequalityEndpoint(props);
        const style = {
          arrows: "->",
          stroke: this.props.apiOptions.isMobile ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC,
          strokeWidth: 3.5
        };
        const isGreater = ["ge", "gt"].includes(props.rel);
        return /*#__PURE__*/React__namespace.createElement(Line$1
        // We shift the line to either side of the dot so they don't
        // intersect
        , {
          start: [(isGreater ? 0.4 : -0.4) + props.numLinePosition, 0],
          end: end,
          style: style
        });
      }
      return null;
    });
    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      // Ensure a sane configuration to avoid infinite loops
      if (!this.isValid()) {
        return;
      }

      // Position variables
      const widthInPixels = this.props.apiOptions.isMobile ? 288 - horizontalPadding * 2 : 400;
      const range = options.range;
      const scale = (range[1] - range[0]) / widthInPixels;
      const buffer = horizontalPadding * scale;

      // Initiate the graphie without actually drawing anything
      const left = range[0] - buffer;
      const right = range[1] + buffer;
      const hasFractionalLabels = this.props.labelStyle === "improper" || this.props.labelStyle === "mixed" || this.props.labelStyle === "non-reduced";
      const bottom = hasFractionalLabels ? -1.5 : -1;
      const top = 1;
      graphie.init({
        range: [[left, right], [bottom, top]],
        scale: [1 / scale, 40],
        isMobile: this.props.apiOptions.isMobile
      });

      // Draw the number line
      const center = (range[0] + range[1]) / 2;
      graphie.line([center, 0], [right, 0], {
        arrows: "->"
      });
      graphie.line([center, 0], [left, 0], {
        arrows: "->"
      });
    });
    _defineProperty(this, "getUserInput", () => {
      return {
        numLinePosition: this.props.numLinePosition,
        rel: this.props.isInequality ? this.props.rel : "eq",
        numDivisions: this.props.numDivisions,
        divisionRange: this.props.divisionRange
      };
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof NumberLine'.
      return NumberLine.validate(this.getUserInput(), rubric);
    });
  }
  render() {
    const divisionRange = this.props.divisionRange;
    const divRangeString = divisionRange[0] + EN_DASH + divisionRange[1];
    const invalidNumDivisions = this.props.numDivisions < divisionRange[0] || this.props.numDivisions > divisionRange[1];
    const inequalityControls = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      className: "simple-button",
      value: i18n__namespace._("Switch direction"),
      onClick: this.handleReverse
    }), /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      className: "simple-button",
      value: ___default["default"](["le", "ge"]).contains(this.props.rel) ? i18n__namespace._("Make circle open") : i18n__namespace._("Make circle filled"),
      onClick: this.handleToggleStrict
    }));
    let tickCtrl;
    if (this.props.isTickCtrl) {
      let Input;
      if (this.props.apiOptions.customKeypad) {
        Input = SimpleKeypadInput;
      } else {
        Input = NumberInput;
      }
      tickCtrl = /*#__PURE__*/React__namespace.createElement("label", null, i18n__namespace._("Number of divisions:"), " ", /*#__PURE__*/React__namespace.createElement(Input
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "tick-ctrl",
        value: this.state.numDivisionsEmpty ? null : this.props.numDivisions || divisionRange[0],
        checkValidity: val => val >= divisionRange[0] && val <= divisionRange[1],
        onChange: this.onNumDivisionsChange,
        onFocus: this._handleTickCtrlFocus,
        onBlur: this._handleTickCtrlBlur,
        useArrowKeys: true,
        keypadElement: this.props.keypadElement
      }));
    }
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-number-line"
    }, tickCtrl, !this.isValid() ? /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-error"
    }, i18n__namespace.doNotTranslate("Invalid number line configuration.")) : this.props.isTickCtrl && invalidNumDivisions ? /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-error"
    }, i18n__namespace.$_("Please make sure the number of divisions is " + "in the range %(divRangeString)s.", {
      divRangeString: divRangeString
    })) : this._renderGraphie(), !this.props.static && this.props.isInequality && inequalityControls);
  }
}
_defineProperty(NumberLine, "defaultProps", {
  range: [0, 10],
  labelStyle: "decimal",
  labelRange: [null, null],
  divisionRange: [1, 12],
  labelTicks: true,
  isTickCtrl: false,
  isInequality: false,
  numLinePosition: 0,
  snapDivisions: 2,
  showTooltips: false,
  rel: "ge",
  apiOptions: ApiOptions.defaults
});
___default["default"].extend(NumberLine, {
  validate: function (state, rubric) {
    const range = rubric.range;
    const divisionRange = state.divisionRange;
    const start = rubric.initialX != null ? rubric.initialX : range[0];
    const startRel = rubric.isInequality ? "ge" : "eq";
    const correctRel = rubric.correctRel || "eq";
    const correctPos = kmath.number.equal(state.numLinePosition, rubric.correctX || 0);
    const outsideAllowedRange = state.numDivisions > divisionRange[1] || state.numDivisions < divisionRange[0];
    if (state.isTickCrtl && outsideAllowedRange) {
      return {
        type: "invalid",
        message: "Number of divisions is outside the allowed range."
      };
    }
    if (correctPos && correctRel === state.rel) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    }
    if (state.numLinePosition === start && state.rel === startRel) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    }
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }
});
const numberLineTransform = editorProps => {
  const props = ___default["default"].pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions", "isTickCtrl", "isInequality", "showTooltips"]);
  const numLinePosition = editorProps.initialX != null ? editorProps.initialX : editorProps.range[0];
  const width = editorProps.range[1] - editorProps.range[0];
  let numDivisions;
  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  ___default["default"].extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });
  return props;
};
const staticTransform$1 = editorProps => {
  const props = ___default["default"].pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions",
  // isTickCtrl is ignored since users can't interact with it anyway
  "isInequality"]);

  // The correct x is the initial position of the point
  const numLinePosition = editorProps.correctX != null ? editorProps.correctX : editorProps.range[0];
  const width = editorProps.range[1] - editorProps.range[0];
  let numDivisions;
  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  ___default["default"].extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Render the relation in the correct answer
    rel: editorProps.isInequality ? editorProps.correctRel : null,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });
  return props;
};
var NumberLine$1 = {
  name: "number-line",
  displayName: "Number line",
  widget: NumberLine,
  transform: numberLineTransform,
  staticTransform: staticTransform$1
};

class PlaceholderCard extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE,
      style: {
        width: this.props.width
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "card placeholder",
      style: {
        height: this.props.height
      }
    }));
  }
}
_defineProperty(PlaceholderCard, "propTypes", {
  width: PropTypes__default["default"].number.isRequired,
  height: PropTypes__default["default"].number.isRequired
});
class DragHintCard extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "card drag-hint"
    }));
  }
}
const PropTypePosition = PropTypes__default["default"].shape({
  left: PropTypes__default["default"].number,
  top: PropTypes__default["default"].number
});
class Card extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "mouseMoveUpBound", void 0);
    _defineProperty(this, "state", {
      dragging: false
    });
    _defineProperty(this, "bindMouseMoveUp", () => {
      this.mouseMoveUpBound = true;
      $__default["default"](document).on("mousemove", this.onMouseMove);
      $__default["default"](document).on("mouseup", this.onMouseUp);
    });
    _defineProperty(this, "unbindMouseMoveUp", () => {
      this.mouseMoveUpBound = false;
      $__default["default"](document).off("mousemove", this.onMouseMove);
      $__default["default"](document).off("mouseup", this.onMouseUp);
    });
    _defineProperty(this, "onMouseDown", event => {
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);
      if (loc) {
        this.setState({
          dragging: true
        });
        this.bindMouseMoveUp();
        this.props.onMouseDown && this.props.onMouseDown(loc, this);
      }
    });
    _defineProperty(this, "onMouseMove", event => {
      if (!this.state.dragging) {
        return;
      }
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);
      if (loc) {
        this.props.onMouseMove && this.props.onMouseMove(loc);
      }
    });
    _defineProperty(this, "onMouseUp", event => {
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);
      if (loc) {
        this.setState({
          dragging: false
        });
        this.unbindMouseMoveUp();
        this.props.onMouseUp && this.props.onMouseUp(loc);
      }
    });
  }
  render() {
    let style = {};
    if (this.props.floating) {
      style = {
        position: "absolute",
        left: this.props.startOffset.left,
        top: this.props.startOffset.top
      };
    }
    if (this.props.width) {
      style.width = this.props.width;
    }
    const className = ["card"];
    if (this.props.stack) {
      className.push("stack");
    }
    if (this.props.floating && !this.props.animating) {
      className.push("dragging");
      style.left += this.props.mouse.left - this.props.startMouse.left;
      style.top += this.props.mouse.top - this.props.startMouse.top;
    }

    // Pull out the content to get rendered
    const rendererProps = ___default["default"].pick(this.props, "content");
    const onMouseDown = this.props.animating ? $__default["default"].noop : this.onMouseDown;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE,
      style: style,
      onMouseDown: onMouseDown,
      onTouchStart: onMouseDown,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: className.join(" ")
    }, /*#__PURE__*/React__namespace.createElement(Renderer, _extends({}, rendererProps, {
      linterContext: this.props.linterContext
    }))));
  }
  shouldComponentUpdate(nextProps, nextState) {
    // Cards in the bank or drag list don't usually change -- they only
    // reorder themselves -- so we want to skip the update to things a
    // little faster. We also need to re-render if the content changes,
    // which happens only in the editor. (We do want to update the floating
    // card on mouse move to update its position.)
    return this.props.floating || nextProps.floating || this.props.content !== nextProps.content ||
    // TODO(alpert): Remove ref here after fixing facebook/react#1392.
    this.props.fakeRef !== nextProps.fakeRef;
  }
  componentDidMount() {
    this.mouseMoveUpBound = false;

    // On touch devices, we set up our own touchmove handler because React
    // all event subscriptions using `OnTouchMove` props are non-passive.
    // See: https://github.com/facebook/react/issues/6436
    // Also, we can't subscribe to `ontouchmove`  within the `ontouchstart`
    // handler because of a WebKit bug:
    // https://github.com/atlassian/react-beautiful-dnd/issues/413 and
    // https://bugs.webkit.org/show_bug.cgi?id=184250
    document.addEventListener("touchmove", this.onMouseMove,
    // Not all browsers support passive events, and when they don't
    // this third paramter is just a boolean. If we pass the "options"
    // object, it's interpreted as `capture=true` (which we don't want!)
    Util.supportsPassiveEvents() ? {
      passive: false
    } : false);
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.props.animating && !prevProps.animating) {
      // If we just were changed into animating, start the animation.
      // We pick the animation speed based on the distance that the card
      // needs to travel. (Why sqrt? Just because it looks nice -- with a
      // linear scale, far things take too long to come back.)
      const ms = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.animateTo.left - this.props.startOffset.left, 2) + Math.pow(this.props.animateTo.top - this.props.startOffset.top, 2)));
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'animate' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).animate(this.props.animateTo, Math.max(ms, 1), this.props.onAnimationEnd);
    }
  }
  componentWillUnmount() {
    // Event handlers should be unbound before component unmounting, but
    // just in case...
    if (this.mouseMoveUpBound) {
      Log.error("Removing an element with bound event handlers.", Errors.Internal);
      this.unbindMouseMoveUp();
      Util.resetTouchHandlers();
    }
    document.removeEventListener("touchmove", this.onMouseMove);
  }
}
_defineProperty(Card, "propTypes", {
  floating: PropTypes__default["default"].bool.isRequired,
  animating: PropTypes__default["default"].bool,
  width: PropTypes__default["default"].number,
  stack: PropTypes__default["default"].bool,
  onMouseDown: PropTypes__default["default"].func,
  onMouseMove: PropTypes__default["default"].func,
  onMouseUp: PropTypes__default["default"].func,
  // Used only for floating/animating cards
  startMouse: PropTypePosition,
  startOffset: PropTypePosition,
  animateTo: PropTypePosition,
  onAnimationEnd: PropTypes__default["default"].func,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(Card, "defaultProps", {
  stack: false,
  animating: false,
  linterContext: PerseusLinter.linterContextDefault
});
const NORMAL = "normal",
  HORIZONTAL$1 = "horizontal";
class Orderer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      current: [],
      dragging: false,
      placeholderIndex: null,
      dragKey: null,
      animating: false,
      dragContent: null,
      dragWidth: null,
      dragHeight: null,
      offsetPos: null,
      animateTo: null,
      grabPos: null
    });
    _defineProperty(this, "onClick", (type, index, loc, draggable) => {
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      const $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable));
      const list = this.state.current.slice();
      let opt;
      let placeholderIndex = null;
      if (type === "current") {
        // If this is coming from the original list, remove the original
        // card from the list
        list.splice(index, 1);
        opt = this.state.current[index];
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
        placeholderIndex = index;
      } else if (type === "bank") {
        opt = this.props.options[index];
      }
      this.setState({
        current: list,
        dragging: true,
        placeholderIndex: placeholderIndex,
        dragKey: opt.key,
        dragContent: opt.content,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'JQueryStatic'.
        dragWidth: $draggable.width(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'height' does not exist on type 'JQueryStatic'.
        dragHeight: $draggable.height(),
        grabPos: loc,
        mousePos: loc,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
        offsetPos: $draggable.position()
      });
    });
    _defineProperty(this, "onRelease", loc => {
      // eslint-disable-next-line react/no-string-refs
      const draggable = this.refs.dragging;
      if (draggable == null) {
        return;
      }
      const inCardBank = this.isCardInBank(draggable);
      const index = this.state.placeholderIndex || 0;

      // Here, we build a callback function for the card to call when it is
      // done animating
      const onAnimationEnd = () => {
        const list = this.state.current.slice();
        if (!inCardBank) {
          // Insert the new card into the position
          const newCard = {
            content: this.state.dragContent,
            key: ___default["default"].uniqueId("perseus_draggable_card_"),
            width: this.state.dragWidth
          };
          list.splice(index, 0, newCard);
        }
        this.props.onChange({
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ current: any[]; }' is not assignable to parameter of type '{ hints?: readonly Hint[] | undefined; replace?: boolean | undefined; content?: string | undefined; widgets?: WidgetDict | undefined; images?: ImageDict | undefined; ... 13 more ...; plot?: any; }'.
          current: list
        });
        this.setState({
          current: list,
          dragging: false,
          placeholderIndex: null,
          animating: false
        });
        this.props.trackInteraction();
      };

      // Find the position of the card we should animate to
      // TODO(alpert): Update mouse position once more before animating?
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
      const offset = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).position();
      let finalOffset = null;
      if (inCardBank) {
        // If we're in the card bank, go through the options to find the
        // one with the same content
        ___default["default"].each(this.props.options, function (opt, i) {
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          if (opt.content === this.state.dragContent) {
            const card = ReactDOM__default["default"].findDOMNode(
            // eslint-disable-next-line react/no-string-refs
            // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
            this.refs["bank" + i]);
            // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
            finalOffset = $__default["default"](card).position();
          }
        }, this);
        // eslint-disable-next-line react/no-string-refs
      } else if (this.refs.placeholder != null) {
        // Otherwise, go to the position that the placeholder is at
        finalOffset = $__default["default"](
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        ReactDOM__default["default"].findDOMNode(this.refs.placeholder)
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'position' does not exist on type 'JQueryStatic'.
        ).position();
      }
      if (finalOffset == null) {
        // If we didn't find a card to go to, simply make the changes we
        // would have made at the end. (should only happen if we are
        // messing around with card contents, and not on the real site)
        onAnimationEnd();
      } else {
        this.setState({
          offsetPos: offset,
          animateTo: finalOffset,
          onAnimationEnd: onAnimationEnd,
          animating: true,
          dragging: false
        });
      }
    });
    _defineProperty(this, "onMouseMove", loc => {
      // eslint-disable-next-line react/no-string-refs
      const draggable = this.refs.dragging;
      if (draggable == null) {
        return;
      }
      let index;
      if (this.isCardInBank(draggable)) {
        index = null;
      } else {
        index = this.findCorrectIndex(draggable, this.state.current);
      }
      this.setState({
        mousePos: loc,
        placeholderIndex: index
      });
    });
    _defineProperty(this, "findCorrectIndex", (draggable, list) => {
      // Find the correct index for a card given the current cards.
      const isHorizontal = this.props.layout === HORIZONTAL$1;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      const $dragList = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.dragList));
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      const leftEdge = $dragList.offset().left;
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      const topEdge = $dragList.offset().top;
      const midWidth =
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).offset().left - leftEdge;
      const midHeight =
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
      $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).offset().top - topEdge;
      let index = 0;
      let sumWidth = 0;
      let sumHeight = 0;
      if (isHorizontal) {
        ___default["default"].each(list, function (opt, i) {
          const card = ReactDOM__default["default"].findDOMNode(
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.refs["sortable" + i]);
          // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'outerWidth' does not exist on type 'JQueryStatic'.
          const outerWidth = $__default["default"](card).outerWidth(true);
          if (midWidth > sumWidth + outerWidth / 2) {
            index += 1;
          }
          sumWidth += outerWidth;
        }, this);
      } else {
        ___default["default"].each(list, function (opt, i) {
          const card = ReactDOM__default["default"].findDOMNode(
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          this.refs["sortable" + i]);
          // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'outerHeight' does not exist on type 'JQueryStatic'.
          const outerHeight = $__default["default"](card).outerHeight(true);
          if (midHeight > sumHeight + outerHeight / 2) {
            index += 1;
          }
          sumHeight += outerHeight;
        }, this);
      }
      return index;
    });
    _defineProperty(this, "isCardInBank", draggable => {
      if (draggable == null) {
        return false;
      }
      const isHorizontal = this.props.layout === HORIZONTAL$1,
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)),
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        $bank = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.bank)),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
        draggableOffset = $draggable.offset(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
        bankOffset = $bank.offset(),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'outerHeight' does not exist on type 'JQueryStatic'.
        draggableHeight = $draggable.outerHeight(true),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'outerHeight' does not exist on type 'JQueryStatic'.
        bankHeight = $bank.outerHeight(true),
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'outerWidth' does not exist on type 'JQueryStatic'.
        bankWidth = $bank.outerWidth(true),
        // eslint-disable-next-line react/no-string-refs
        dragList = ReactDOM__default["default"].findDOMNode(this.refs.dragList);
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'width' does not exist on type 'JQueryStatic'.
        $__default["default"](dragList).width();
        const // @ts-expect-error [FEI-5003] - TS2339 - Property 'outerWidth' does not exist on type 'JQueryStatic'.
        draggableWidth = $draggable.outerWidth(true);
      if (isHorizontal) {
        return draggableOffset.top + draggableHeight / 2 < bankOffset.top + bankHeight;
      }
      return draggableOffset.left + draggableWidth / 2 < bankOffset.left + bankWidth;
    });
    _defineProperty(this, "setListValues", values => {
      const list = values.map(value => {
        return {
          content: value
        };
      });
      this.props.onChange({
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ current: { content: string; }[]; }' is not assignable to parameter of type '{ hints?: readonly Hint[] | undefined; replace?: boolean | undefined; content?: string | undefined; widgets?: WidgetDict | undefined; images?: ImageDict | undefined; ... 13 more ...; plot?: any; }'.
        current: list
      });
      this.setState({
        current: list
      });
    });
    _defineProperty(this, "getUserInput", () => {
      return {
        current: ___default["default"].map(this.props.current, function (v) {
          return v.content;
        })
      };
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Orderer'.
      return Orderer.validate(this.getUserInput(), rubric);
    });
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!___default["default"].isEqual(this.props.current, nextProps.current)) {
      this.setState({
        current: nextProps.current
      });
    }
  }
  render() {
    // This is the card we are currently dragging
    const dragging = this.state.dragging && /*#__PURE__*/React__namespace.createElement(Card
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "dragging",
      floating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      startMouse: this.state.grabPos,
      mouse: this.state.mousePos,
      width: this.state.dragWidth,
      onMouseUp: this.onRelease,
      onMouseMove: this.onMouseMove,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    });

    // This is the card that is currently animating
    const animating = this.state.animating && /*#__PURE__*/React__namespace.createElement(Card, {
      floating: true,
      animating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      width: this.state.dragWidth,
      animateTo: this.state.animateTo,
      onAnimationEnd: this.state.onAnimationEnd,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    });

    // This is the list of draggable, rearrangable cards
    const sortableCards = ___default["default"].map(this.state.current, function (opt, i) {
      return /*#__PURE__*/React__namespace.createElement(Card, {
        key: "sortableCard".concat(i),
        ref: "sortable" + i,
        fakeRef: "sortable" + i,
        floating: false,
        content: opt.content,
        width: opt.width
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        linterContext: this.props.linterContext
        // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseDown:
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.state.animating ? $__default["default"].noop :
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.onClick.bind(null, "current", i)
      });
    }, this);
    if (this.state.placeholderIndex != null) {
      const placeholder = /*#__PURE__*/React__namespace.createElement(PlaceholderCard
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "placeholder",
        width: this.state.dragWidth,
        height: this.state.dragHeight,
        key: "placeholder"
      });
      sortableCards.splice(this.state.placeholderIndex, 0, placeholder);
    }
    const anySortableCards = sortableCards.length > 0;
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'false | Element' is not assignable to parameter of type 'Element'.
    sortableCards.push(dragging, animating);

    // If there are no cards in the list, then add a "hint" card
    const sortable = /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-clearfix draggable-box"
    }, !anySortableCards && /*#__PURE__*/React__namespace.createElement(DragHintCard, null), /*#__PURE__*/React__namespace.createElement("div", {
      ref: "dragList"
    }, sortableCards));

    // This is the bank of stacks of cards
    const bank =
    /*#__PURE__*/
    // eslint-disable-next-line react/no-string-refs
    React__namespace.createElement("div", {
      ref: "bank",
      className: "bank perseus-clearfix"
    }, ___default["default"].map(this.props.options, (opt, i) => {
      return /*#__PURE__*/React__namespace.createElement(Card, {
        ref: "bank" + i,
        floating: false,
        content: opt.content,
        stack: true,
        key: i,
        linterContext: this.props.linterContext
        // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseDown: this.state.animating ? $__default["default"].noop : this.onClick.bind(null, "bank", i),
        onMouseMove: this.onMouseMove,
        onMouseUp: this.onRelease
      });
    }, this));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "draggy-boxy-thing orderer " + "height-" + this.props.height + " " + "layout-" + this.props.layout + " " + "above-scratchpad blank-background " + "perseus-clearfix " + ClassNames.INTERACTIVE
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "orderer"
    }, bank, sortable);
  }
}
_defineProperty(Orderer, "defaultProps", {
  current: [],
  options: [],
  correctOptions: [],
  height: NORMAL,
  layout: HORIZONTAL$1,
  linterContext: PerseusLinter.linterContextDefault
});
___default["default"].extend(Orderer, {
  validate: function (state, rubric) {
    if (state.current.length === 0) {
      return {
        type: "invalid",
        message: null
      };
    }
    const correct = ___default["default"].isEqual(state.current, ___default["default"].pluck(rubric.correctOptions, "content"));
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});
var Orderer$1 = {
  name: "orderer",
  displayName: "Orderer",
  widget: Orderer,
  isLintable: true
};

/**
 * Utility functions for manipulating ranges of highlightable content.
 */

/**
 * Given two DOMRange objects, and a choice of start/end point for each, compare
 * the two chosen points. Return -1 if a's comes first in the document, return
 * 1 if b's comes first in the document, or 0 if they represent the same point
 * in the document.
 *
 * NOTE(mdr): This function exists primarily to cover over some confusing parts
 *     of the DOM's `compareBoundaryPoints` API, and to cover over a Flow bug
 *     documented here: https://github.com/facebook/flow/issues/3734.
 */
function compareRangeBoundaryPoints(a, whichA, b, whichB) {
  let mode;
  if (whichA === "start" && whichB === "start") {
    mode = Range.START_TO_START;
  } else if (whichA === "start" && whichB === "end") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `END_TO_START`, which is the reverse of what you'd expect.
    mode = Range.END_TO_START;
  } else if (whichA === "end" && whichB === "start") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `START_TO_END`, which is the reverse of what you'd expect.
    mode = Range.START_TO_END;
  } else {
    mode = Range.END_TO_END;
  }
  return a.compareBoundaryPoints(mode, b);
}

/**
 * Given two DOMRanges, return a DOMRange whose start point comes from A, and
 * whose end point comes from B.
 */
function spanRanges(a, b) {
  const range = a.cloneRange();
  range.setEnd(b.endContainer, b.endOffset);
  return range;
}

/**
 * Given two DOMRanges, return whether they overlap.
 *
 * We here treat ranges like closed intervals: the boundary points are
 * considered to be included in the range, and, if a ends exactly where b
 * starts, they are considered to overlap.
 */
function rangesOverlap(a, b) {
  // Two ranges do *not* overlap iff one ends before the other begins.
  const rangesDoNotOverlap = compareRangeBoundaryPoints(a, "end", b, "start") < 0 || compareRangeBoundaryPoints(b, "end", a, "start") < 0;
  return !rangesDoNotOverlap;
}

/**
 * Given two DOMRanges, return whether the first includes the second: whether
 * all points that B contains are also contained by A.
 */
function rangeIncludes(a, b) {
  const rangeIsIncluded = compareRangeBoundaryPoints(a, "start", b, "start") <= 0 && compareRangeBoundaryPoints(a, "end", b, "end") >= 0;
  return rangeIsIncluded;
}

/**
 * Given two DOMRanges, intersect them: return a range that contains all points
 * that both A contains and B contains, and contains no other points.
 *
 * If A and B do not overlap, no intersection exists; return null.
 */
function intersectRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  }

  // Find the range with the latest start point, and the range with the
  // earliest end point.
  const starter = compareRangeBoundaryPoints(a, "start", b, "start") > 0 ? a : b;
  const ender = compareRangeBoundaryPoints(a, "end", b, "end") < 0 ? a : b;
  return spanRanges(starter, ender);
}

/**
 * Given two DOMRanges, union them: return a range that contains all points
 * that either A contains or B contains, and contains no other points.
 *
 * If A and B do not overlap, no union exists; return null.
 */
function unionRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  }

  // Find the range with the earliest start point, and the range with the
  // latest end point.
  const starter = compareRangeBoundaryPoints(a, "start", b, "start") < 0 ? a : b;
  const ender = compareRangeBoundaryPoints(a, "end", b, "end") > 0 ? a : b;
  return spanRanges(starter, ender);
}

/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the index of the goal word, or -1 if no satisfactory goal word
 * exists in the list.
 *
 * If `goal` is "first", return the index of the first word whose end point is
 * after the selection's start point.
 *
 * If `goal` is "last", return the index of the last word whose start point is
 * before the selection's end point.
 */
function findBoundaryWordIndex(selectionRange, wordRanges, goal, initialLowerBound, initialUpperBound) {
  let bestValidWordIndex = -1;
  let lowerBound = initialLowerBound;
  let upperBound = initialUpperBound;
  let iterationCount = 0;
  while (lowerBound <= upperBound) {
    iterationCount++;
    if (iterationCount > wordRanges.length * 2) {
      throw new Error("Assertion error: Binary search isn't terminating? " + "lower=".concat(lowerBound, ", upper=").concat(upperBound));
    }
    const mid = Math.floor((lowerBound + upperBound) / 2);
    if (goal === "first") {
      const rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "end", selectionRange, "start");
      if (rangeComparison <= 0) {
        // If this word's end point is before or equal to the
        // selection's start point, then this word is not a valid
        // candidate, nor are any of the words before it.
        //
        // Update our bounds to look for a valid word after this one.
        lowerBound = mid + 1;
      } else {
        // If this word's end point is after the selection's start
        // point, then this word is valid, and is, by nature of the
        // search, the earliest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word before
        // this one.
        bestValidWordIndex = mid;
        upperBound = mid - 1;
      }
    } else {
      const rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "start", selectionRange, "end");
      if (rangeComparison >= 0) {
        // If this word's start point is after or equal to the
        // selection's end point, then this word is not a valid
        // candidate, nor are any of the words after it.
        //
        // Update our bounds to look for a valid word before this one.
        upperBound = mid - 1;
      } else {
        // If this word's start point is before the selection's end
        // point, then this word is valid, and is, by nature of the
        // search, the latest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word after
        // this one.
        bestValidWordIndex = mid;
        lowerBound = mid + 1;
      }
    }
  }
  return bestValidWordIndex;
}

/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the indexes of the first and last words that the selection
 * intersects, or `null` if the range includes no words.
 */
function findFirstAndLastWordIndexes(selectionRange, wordRanges) {
  // Find the first word whose end point is after the selection's start
  // point.
  //
  // Note that this does *not* alone prove that this word is *intersected* by
  // the current range; to intersect, the first word's start point must also
  // be before the selection's end point. This is proven by the success of
  // the second search.
  //
  // (For example, imagine highlighting the space between two words. This
  // search would return the first word after the selection, despite not
  // intersecting the selection.)
  const firstWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "first", 0, wordRanges.length - 1);
  if (firstWordIndex < 0) {
    return null;
  }

  // Find the last word whose start point is before the selection's end
  // point.
  //
  // Start the search with our candidate first word, because, while we don't
  // know whether our candidate first word intersects the selection, we *do*
  // know that no *earlier* word intersects the selection, or else it would
  // have been yielded as the candidate first word instead.
  const lastWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "last", firstWordIndex, wordRanges.length - 1);
  if (lastWordIndex < 0) {
    return null;
  }

  // Now, we have discovered a candidate first word F, and a candidate last
  // word L. Let's prove that these are indeed the first and last intersected
  // words of the selection S.
  //
  // Syntax: Let A1 and A2 represent the start and end point of range A.
  //
  // Definition: A1 <= A2 for any range A.
  //
  // Theorem 1: Two ranges A and B intersect iff A1 <= B2 and B1 <= A2.
  // Proof: See http://www.rgrjr.com/emacs/overlap.html, and extend the
  //     result to closed intervals by also accepting equality.
  //
  // Given 1: F1 <= L1 and F2 <= L2. That is, either the first and last word
  //     are the same, or the last word comes after, because we provided
  //     `firstWordIndex` as the lower bound when search for L.
  // Given 2: S1 <= F2, and no earlier word's end point is >= S1, because
  //     F was returned by `findBoundaryWordIndex` with goal "first".
  // Given 3: L1 <= S2, and no later word's start point is <= S2, because
  //     L was returned by `findBoundaryWordIndex` with goal "last".
  //
  // Conclusion 1: F intersects S.
  // Proof: By Theorem 1, we must show that F1 <= S2 and S1 <= F2.
  //     F1 <= L1 <= S2, by Given 1 and Given 3.
  //     S1 <= F2, by Given 2. QED.
  //
  // Conclusion 2: L intersects S.
  // Proof: By Theorem 1, we must show that L1 <= S2 and S1 <= L2.
  //     L1 <= S2 by Given 3.
  //     S1 <= F2 <= L2, by Given 1 and Given 2. QED.
  //
  // Conclusion 3: No word earlier than F intersects S.
  // Proof: Consider some word W earlier than F.
  //     W2 < S1, by Given 2. Therefore, it's false that S1 <= W2.
  //     Therefore, W and S do not intersect, by Theorem 1. QED.
  //
  // Conclusion 4: No word later than L intersects S.
  // Proof: Consider some word W later than L.
  //     W1 > S2, by Given 2. Therefore, it's false that W1 <= S2.
  //     Therefore, W and S do not intersect, by Theorem 1, QED.
  //
  // Therefore, while neither of these two searches alone proves that F is
  // the first intersected word of S, or that L is the last intersected word
  // of S, the implications of the two searches are sufficient proof when
  // combined. Return these two indexes with confidence, hooray!

  return [firstWordIndex, lastWordIndex];
}

/**
 * Utility functions for manipulating highlights.
 */
/**
 * Given a list of DOMHighlights, return a new list that also includes the
 * given DOMRange as a new DOMHighlight. If the DOMHighlight intersects
 * existing DOMHighlights, the other Highlights are removed and their ranges
 * are merged into the new DOMHighlight.
 */
function addHighlight(existingHighlights, newHighlight) {
  const newHighlights = {};

  // Merge the new highlight with any existing highlights that intersect it.
  let mergedDomRange = newHighlight.domRange;
  let mergedFirstWordIndex = newHighlight.firstWordIndex;
  let mergedLastWordIndex = newHighlight.lastWordIndex;
  for (const key of Object.keys(existingHighlights)) {
    const h = existingHighlights[key];
    const newMergedDomRange = unionRanges(h.domRange, mergedDomRange);
    if (newMergedDomRange) {
      // This highlight's range was successfully merged into the new
      // highlight. Update `mergedDomRange`, and *don't* add it to the
      // new set of highlights.
      mergedDomRange = newMergedDomRange;
      mergedFirstWordIndex = Math.min(h.firstWordIndex, mergedFirstWordIndex);
      mergedLastWordIndex = Math.max(h.lastWordIndex, mergedLastWordIndex);
    } else {
      // This highlight's range can't be merged into the new highlight.
      // Add it to the new set of highlights.
      newHighlights[key] = h;
    }
  }
  const newMergedHighlight = {
    firstWordIndex: mergedFirstWordIndex,
    lastWordIndex: mergedLastWordIndex,
    domRange: mergedDomRange
  };

  // Add the newly-merged highlight to the set of highlights, under a new,
  // unique key.
  const existingKeys = Object.keys(newHighlights);
  const newKey = createNewUniqueKey(existingKeys);
  newHighlights[newKey] = newMergedHighlight;
  return newHighlights;
}

/**
 * Given a DOMRange and a list of word ranges, build a corresponding
 * DOMHighlight.
 *
 * If the DOMRange is not a valid highlight given the word ranges, return null.
 */
function buildHighlight(existingHighlights, wordRanges, newHighlightRange) {
  // If any existing highlight fully contains the new highlight range, it's
  // redundant and therefore not valid to build this as a highlight.
  // Return null.
  //
  // NOTE(mdr): Really, our goal is to determine whether the new range's
  //     content is already fully highlighted, so you could imagine this
  //     logic not catching the case where a range's contents are fully
  //     highlighted, but by multiple ranges.
  //
  //     However, words aren't actually adjacent; they have spaces between
  //     them. So, even if each word in the range is currently highlighted,
  //     the space between a pair of words will only be highlighted if
  //     they're included in the same highlight range.
  //
  //     Therefore, if this new range isn't fully contained by an existing
  //     highlight, then there's at *least* an unhighlighted space within the
  //     range. In that case, it makes sense to offer this as a new highlight
  //     that, when added, will merge with the highlights that it intersects.
  for (const key of Object.keys(existingHighlights)) {
    const existingHighlightRange = existingHighlights[key].domRange;
    if (rangeIncludes(existingHighlightRange, newHighlightRange)) {
      return null;
    }
  }

  // If the new highlight range doesn't span two words from the content, it's
  // not valid to build this as a highlight. Return null.
  const indexes = findFirstAndLastWordIndexes(newHighlightRange, wordRanges);
  if (!indexes) {
    return null;
  }
  const [firstWordIndex, lastWordIndex] = indexes;
  const firstWord = wordRanges[firstWordIndex];
  const lastWord = wordRanges[lastWordIndex];
  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}

/**
 * Given a list of keys, return a new unique key that is not in the list.
 */
function createNewUniqueKey(existingKeys) {
  // The base of the key is the current time, in milliseconds since epoch.
  const base = "".concat(new Date().getTime());
  if (!existingKeys.includes(base)) {
    return base;
  }

  // But, if the user is a fast-clicker or time-traveler or something, and
  // already has a highlight from this millisecond, then let's attach a
  // suffix and keep incrementing it until we find an unused suffix.
  let suffix = 0;
  let key;
  do {
    key = "".concat(base, "-").concat(suffix);
    suffix++;
  } while (existingKeys.includes(key));
  return key;
}

/**
 * Given a SerializedHightlight and the current set of word ranges, return a
 * DOMHighlight representing the SerializedHighlight.
 *
 * If the SerializedHighlight is not valid given the list of word ranges, throw
 * an error.
 */
function deserializeHighlight(serializedHighlight, wordRanges) {
  const {
    firstWordIndex,
    lastWordIndex
  } = serializedHighlight.range;
  const firstWord = wordRanges[firstWordIndex];
  if (!firstWord) {
    throw new PerseusError("first word index ".concat(firstWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"), Errors.InvalidInput, {
      metadata: {
        firstWord,
        wordRanges: JSON.stringify(wordRanges)
      }
    });
  }
  const lastWord = wordRanges[lastWordIndex];
  if (!lastWord) {
    throw new PerseusError("last word index ".concat(lastWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"), Errors.InvalidInput, {
      metadata: {
        lastWord,
        wordRanges: JSON.stringify(wordRanges)
      }
    });
  }
  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}

/**
 * Return a SerializedHighlight representing the given DOMHighlight.
 */
function serializeHighlight(highlight) {
  const {
    firstWordIndex,
    lastWordIndex
  } = highlight;
  return {
    range: {
      type: "word-indexes",
      firstWordIndex,
      lastWordIndex
    }
  };
}

/**
 * Utility functions for highlighting UI.
 */
/**
 * Given two positions relative to the same origin, return `child`'s position
 * relative to `parent`'s position.
 */
function getRelativePosition(child, parent) {
  return {
    left: child.left - parent.left,
    top: child.top - parent.top
  };
}

/**
 * `getRelativePosition`, but for Rects.
 *
 * Given a rectangle and a position relative to the same origin, return a new
 * rectangle of the same size, whose position is relative to the given
 * position.
 */
function getRelativeRect(_ref, parent) {
  let {
    left,
    top,
    width,
    height
  } = _ref;
  return {
    ...getRelativePosition({
      left,
      top
    }, parent),
    width,
    height
  };
}

/**
 * Given a DOMRange, return a list of client-relative rects that cover the text
 * inside the DOMRange.
 *
 * This behaves differently than the browser's built-in `getClientRects` method
 * for DOMRanges, because this method only gets rects for the *text* nodes,
 * whereas the browser's method will also return rects for any fully-contained
 * *element* nodes.
 *
 * For example, if an entire paragraph is selected, then `getClientRects` will
 * return a rectangle that covers the entire paragraph block, whereas this
 * method will only return rectangles for the text inside the paragraph.
 */
function getClientRectsForTextInRange(range) {
  const mutableRects = [];
  addClientRectsForTextInNodeAndRange(range.commonAncestorContainer, range, mutableRects);
  return mutableRects;
}

/**
 * A helper method for getClientRectsForTextInRange.
 *
 * Given a node and a range, find text that is contained within both the node
 * and the range by recursing down the node's subtree, and push the text's
 * client rects onto the given `mutableRects` array.
 */
function addClientRectsForTextInNodeAndRange(node, range, mutableRects) {
  const nodeContentsRange = new Range();
  nodeContentsRange.selectNodeContents(node);
  if (node.nodeType === Node.TEXT_NODE) {
    // Get the text that appears both in this text node and in the range
    // we're searching.
    const intersectedRange = intersectRanges(range, nodeContentsRange);
    if (intersectedRange) {
      addClientRectsForText(node, intersectedRange, mutableRects);
    }
  } else if (node.nodeType === Node.ELEMENT_NODE) {
    // Don't bother deep-traversing a node that doesn't even overlap the
    // range we're searching.
    if (!rangesOverlap(range, nodeContentsRange)) {
      return;
    }

    // NOTE(mdr): Safari returns a non-iterable `childNodes` object, so
    //     convert it to an array.
    for (const child of Array.from(node.childNodes)) {
      // TODO(mdr): If this parent has overflow: hidden, bound the child
      //     rects accordingly. This would allow us to remove the hack
      //     we added to .perseus-sr-only.
      addClientRectsForTextInNodeAndRange(child, range, mutableRects);
    }
  }
}

/**
 * Given a DOMRange of text fully contained by the given `textNode`, compute
 * rectangles that visually cover the range, and push them onto the given
 * `mutableRects` array.
 *
 * This function adjusts the rectangles to the line height of the text, to
 * match the visual behavior of native text selection, and remove annoying gaps
 * between lines that disrupt hover behavior.
 */
function addClientRectsForText(textNode, textRange, mutableRects) {
  const parentElement = textNode.parentElement;
  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'HTMLElement | null' is not assignable to parameter of type 'Element'.
  const computedStyle = window.getComputedStyle(parentElement);

  // NOTE(mdr): I'm not sure how computed line height works in all contexts
  //     in all browsers. It's valid to specify line height as a ratio,
  //     relative to font size. Latest Chrome seems to transform this into a
  //     px value, but maybe some browsers don't, so I'm being defensive here
  //     and only using the computed line height if it's explicitly a px
  //     value. We could also handle other browsers by computing font size
  //     and doing the math ourselves, but let's punt that until we need it.
  let lineHeight = null;
  if (typeof computedStyle.lineHeight === "string" && computedStyle.lineHeight.endsWith("px")) {
    const parsedLineHeight = parseFloat(computedStyle.lineHeight);
    if (!isNaN(parsedLineHeight)) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'number' is not assignable to type 'null'.
      lineHeight = parsedLineHeight;
    }
  }

  // NOTE(mdr): Safari returns a non-iterable `getClientRects` object, so
  //     convert it to an array.
  const boundingRects = Array.from(textRange.getClientRects());
  for (const boundingRect of boundingRects) {
    const rect = {
      left: boundingRect.left,
      top: boundingRect.top,
      height: boundingRect.height,
      width: boundingRect.width
    };

    // Adjust the rectangle according to the text's line height. It should
    // keep the same bottom coordinate, so the top coordinate will move
    // accordingly.
    if (lineHeight !== null) {
      const heightIncrease = lineHeight - rect.height;
      rect.top -= heightIncrease;
      rect.height = lineHeight;
    }
    mutableRects.push(rect);
  }
}

class HighlightRenderer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      cachedHighlightRects: this._computeRects(this.props),
      // @ts-expect-error [FEI-5003] - TS2322 - Type '{ cachedHighlightRects: readonly Rect[]; tooltipIsHovered: boolean; }' is not assignable to type 'HighlightRendererState'.
      tooltipIsHovered: false
    });
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.highlight !== nextProps.highlight || this.props.offsetParent !== nextProps.offsetParent) {
      this.setState({
        cachedHighlightRects: this._computeRects(nextProps)
      });
    }
  }

  /**
   * Compute the set of rectangles that cover the highlighted content, with
   * coordinates relative to the offset parent. That way, we can use them
   * for CSS positioning.
   */
  _computeRects(props) {
    const {
      highlight,
      offsetParent
    } = props;

    // Get the set of rectangles that covers the range's text, relative to
    // the offset parent.
    const clientRects = getClientRectsForTextInRange(highlight.domRange);
    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const relativeRects = clientRects.map(rect => getRelativeRect(rect, {
      left,
      top
    }));
    return relativeRects;
  }

  /**
   * Return whether the given mouse position (coordinates relative to this
   * component's offset parent) is hovering over the given rectangle
   * (coordinates also relative to this component's offset parent).
   */
  _rectIsHovered(rect, mouseOffsetPosition) {
    const positionWithinRect = getRelativePosition(mouseOffsetPosition, {
      left: rect.left,
      top: rect.top
    });
    return 0 <= positionWithinRect.left && positionWithinRect.left < rect.width && 0 <= positionWithinRect.top && positionWithinRect.top < rect.height;
  }

  /**
   * Return whether the given mouse position (coordinates relative to the
   * viewport) is hovering over this highlight.
   */
  isHovered(mouseClientPosition) {
    if (!mouseClientPosition) {
      return false;
    }
    const {
      offsetParent
    } = this.props;
    const {
      cachedHighlightRects
    } = this.state;

    // Convert the client-relative mouse coordinates to be relative to the
    // offset parent. That way, we can compare them to the cached highlight
    // rectangles.
    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const mouseOffsetPosition = getRelativePosition(mouseClientPosition, {
      left,
      top
    });
    return cachedHighlightRects.some(rect => this._rectIsHovered(rect, mouseOffsetPosition));
  }
  render() {
    const rects = this.state.cachedHighlightRects;
    return /*#__PURE__*/React__namespace.createElement("div", null, rects.map((rect, index) => /*#__PURE__*/React__namespace.createElement("div", {
      key: index,
      className: aphrodite.css(styles$b.highlightRect),
      style: {
        // NOTE(mdr): We apply `position: absolute` here
        //     rather than in Aphrodite styles, because
        //     Aphrodite styles are delayed. If this
        //     element temporarily has `position: static`,
        //     then it'll displace the content, and other
        //     highlights rendering during this update will
        //     measure the displaced content instead, oops!
        position: "absolute",
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        zIndex: this.props.zIndexes.belowContent
      }
    })));
  }
}
const styles$b = aphrodite.StyleSheet.create({
  highlightRect: {
    background: "#fffabe" // highlighter yellow :)
  }
});

/**
 * A tooltip to point to the focus of a highlight.
 *
 * We use the NewTooltip component, which positions itself not by coordinate,
 * but by watching the position of a target DOM element. So, we render a 0x0
 * DOM element, absolute-position it to the position of the the highlight
 * focus, and point the tooltip at that 0x0 element.
 *
 * This technique enables NewTooltip to use its existing visibility-watching
 * and scroll-tracking logic to effectively "watch" the focus of this
 * highlight. So, we get lots of the repositioning logic for free! But we _do_
 * still have to notify the tooltip to remeasure itself when the highlight
 * focus _changes_.
 */
class HighlightTooltip extends React__namespace.PureComponent {
  _getFocusRect() {
    const {
      focusNode,
      focusOffset,
      offsetParent
    } = this.props;

    // Get a range of *just* the focus point of the selection.
    const focusRange = document.createRange();
    focusRange.setStart(focusNode, focusOffset);
    focusRange.setEnd(focusNode, focusOffset);

    // Then, get the bounding box of the collapsed range. This will be a
    // zero-width rectangle, but still have positioning information, which
    // we can use the position the tooltip.
    //
    // NOTE(mdr): If we used getClientBoundingRect here instead, Safari
    //     would return an unpositioned rect. But all tested browsers at
    //     time of writing (latest Chrome, Firefox, Safari) return at least
    //     one rectangle from getClientRects, and it's well-positioned.
    const focusRect = focusRange.getClientRects()[0];

    // NOTE(mdr): ...except in the case where the focus is between two
    //     paragraphs, in which case the focus range has no client rects?
    //     Not sure why, or in what browsers (only noticed in Chrome 60),
    //     but let's catch that case and bail out.
    // TODO(mdr): Instead, we should somehow walk back the range until we
    //     find an appropriate position for the tooltip. Sounds tricky!
    if (!focusRect) {
      Log.log("[Highlighting] Known bug: Could not determine the focus " + 'position, so did not show an "Add Highlight" tooltip. ' + "https://app.asana.com/0/329800276300868/413878480039713 " + "(see also /r/asana-links)");
      return null;
    }

    // Compute the desired position of the tooltip relative to the offset
    // parent.
    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const relativeFocusRect = getRelativeRect({
      left: focusRect.left,
      top: focusRect.top,
      width: focusRect.width,
      height: focusRect.height
    }, {
      left,
      top
    });
    return relativeFocusRect;
  }
  render() {
    const focusRect = this._getFocusRect();
    if (!focusRect) {
      return null;
    }

    // using div instead of TooltipContent because
    // TooltipContent wouldn't let me overwrite
    // user-select and onClick
    const content = /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$a.tooltipLabel),
      onClick: this.props.onClick
    }, this.props.label);
    const style = {
      position: "absolute",
      left: focusRect.left,
      // offset the spacing WB provides around tooltips
      top: "calc(".concat(Math.round(focusRect.top), "px + 0.95em)"),
      height: 0
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: style,
      onMouseEnter: this.props.onMouseEnter,
      onMouseLeave: this.props.onMouseLeave
    }, /*#__PURE__*/React__namespace.createElement(Tooltip__default["default"], {
      content: content,
      opened: true
    }, /*#__PURE__*/React__namespace.createElement("div", null)));
  }
}
const styles$a = aphrodite.StyleSheet.create({
  tooltipLabel: {
    // Unlike most tooltip contents, we don't want this label to be
    // selectable. Selecting it is not only unhelpful, but dangerous: if
    // the user accidentally selects the "Add highlight" tooltip text, then
    // we lose our reference to the _actual_ text they want to highlight,
    // and the "Add highlight" action fails.
    userSelect: "none",
    fontFamily: "\"Lato\", sans-serif",
    padding: "10px ".concat(Spacing__default["default"].medium_16, "px"),
    cursor: "pointer"
  }
});

class HighlightSetRenderer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      hoveredHighlightKey: null,
      hoveringTooltipFor: null
    });
    _defineProperty(this, "_highlightRenderers", {});
    _defineProperty(this, "_handleMouseMove", e => {
      const mouseClientPosition = {
        left: e.clientX,
        top: e.clientY
      };
      const hoveredHighlightKey = this._getHoveredHighlightKey(mouseClientPosition);
      this.setState({
        hoveredHighlightKey
      });
    });
  }
  componentDidMount() {
    this._updateEditListeners(false, this.props.editable);
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this._updateEditListeners(this.props.editable, nextProps.editable);

    // If we were previously hovering over a highlight that has been
    // removed, reset the hover state accordingly.
    if (this.state.hoveredHighlightKey != null && !(this.state.hoveredHighlightKey in nextProps.highlights)) {
      this.setState({
        hoveredHighlightKey: null
      });
    }

    // Similarly, if we were previously hovering over the tooltip for a
    // highlight that has been removed, reset the hover state accordingly.
    if (this.state.hoveringTooltipFor != null && !(this.state.hoveringTooltipFor in nextProps.highlights)) {
      this.setState({
        hoveringTooltipFor: null
      });
    }
  }
  componentWillUnmount() {
    this._updateEditListeners(this.props.editable, false);
  }

  /**
   * Given whether we were previously listening to mousemove events, and
   * whether we will now listen to mousemove events, add or remove the
   * listener accordingly.
   */
  _updateEditListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousemove", this._handleMouseMove);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousemove", this._handleMouseMove);

      // Additionally, reset the hover state, to ensure that we don't
      // keep old hover state around.
      this.setState({
        hoveredHighlightKey: null,
        hoveringTooltipFor: null
      });
    }
  }
  _getHoveredHighlightKey(mouseClientPosition) {
    // If we're hovering over the tooltip, the hovered highlight is the
    // highlight that the tooltip is pointing to.
    const {
      hoveringTooltipFor
    } = this.state;
    if (typeof hoveringTooltipFor === "string") {
      return hoveringTooltipFor;
    }

    // Otherwise, check each highlight renderer to see whether the current
    // mouse position intersects any of the highlight rectangles.
    const highlightKeys = Object.keys(this.props.highlights);
    return highlightKeys.find(key => {
      const highlightRenderer = this._highlightRenderers[key];
      return highlightRenderer && highlightRenderer.isHovered(mouseClientPosition);
    });
  }
  _renderTooltip() {
    const {
      hoveredHighlightKey
    } = this.state;
    if (hoveredHighlightKey == null) {
      return null;
    }
    const hoveredHighlight = this.props.highlights[hoveredHighlightKey];
    return /*#__PURE__*/React__namespace.createElement(HighlightTooltip, {
      label: i18n__namespace._("Remove highlight"),
      focusNode: hoveredHighlight.domRange.endContainer,
      focusOffset: hoveredHighlight.domRange.endOffset,
      offsetParent: this.props.offsetParent,
      onClick: () => this.props.onRemoveHighlight(hoveredHighlightKey),
      onMouseEnter: () => this.setState({
        hoveringTooltipFor: hoveredHighlightKey
      }),
      onMouseLeave: () => this.setState({
        hoveringTooltipFor: null
      })
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null, Object.keys(this.props.highlights).map(key => /*#__PURE__*/React__namespace.createElement(HighlightRenderer, {
      ref: r => {
        if (r) {
          this._highlightRenderers[key] = r;
        } else {
          delete this._highlightRenderers[key];
        }
      },
      key: key,
      highlight: this.props.highlights[key],
      highlightKey: key,
      offsetParent: this.props.offsetParent,
      zIndexes: this.props.zIndexes
    })), this.props.editable && this._renderTooltip());
  }
}

class SelectionTracker extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      mouseState: "up",
      trackedSelection: null
    });
    _defineProperty(this, "_handleSelectionChange", () => {
      this._updateTrackedSelection();
      if (this.state.mouseState === "down") {
        this.setState({
          mouseState: "down-and-selecting"
        });
      }
    });
    _defineProperty(this, "_handleMouseDown", () => {
      this.setState({
        mouseState: "down"
      });
    });
    _defineProperty(this, "_handleMouseUp", () => {
      this.setState({
        mouseState: "up"
      });
    });
  }
  componentDidMount() {
    this._updateListeners(false, this.props.enabled);
  }
  componentDidUpdate(prevProps) {
    if (this.props.buildHighlight !== prevProps.buildHighlight) {
      // The highlight-building function changed, so the
      // proposedHighlight we built with it might be different, or no
      // longer be valid. Update accordingly.
      this._updateTrackedSelection();
    }
    this._updateListeners(prevProps.enabled, this.props.enabled);
  }
  componentWillUnmount() {
    this._updateListeners(this.props.enabled, false);
  }
  _updateListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousedown", this._handleMouseDown);
      window.addEventListener("mouseup", this._handleMouseUp);
      document.addEventListener("selectionchange", this._handleSelectionChange);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousedown", this._handleMouseDown);
      window.removeEventListener("mouseup", this._handleMouseUp);
      document.removeEventListener("selectionchange", this._handleSelectionChange);

      // Additionally, reset the state, to guard against errors where we
      // re-enter listening mode and have stale values stored.
      this.setState({
        mouseState: "up",
        trackedSelection: null
      });
    }
  }

  /**
   * Get the current selection focus and range, if present and non-collapsed.
   *
   * Otherwise, if there is no current selection or it's collapsed, return
   * null.
   */
  _computeFocusAndRange() {
    const selection = document.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    const range = selection.getRangeAt(0);
    if (range.collapsed) {
      return null;
    }

    // NOTE(mdr): The focus node is guaranteed to exist, because
    //     there's a range, but the type annotations for
    //     Selection don't know that. Cast it ourselves.
    const focusNode = selection.focusNode;
    const focusOffset = selection.focusOffset;
    return {
      focusNode,
      focusOffset,
      range
    };
  }

  /**
   * Compute and update the TrackedSelection to reflect the document state.
   */
  _updateTrackedSelection() {
    const focusAndRange = this._computeFocusAndRange();
    if (!focusAndRange) {
      this.setState({
        trackedSelection: null
      });
      return;
    }
    const {
      focusNode,
      focusOffset,
      range
    } = focusAndRange;
    const proposedHighlight = this.props.buildHighlight(range);
    if (!proposedHighlight) {
      this.setState({
        trackedSelection: null
      });
      return;
    }
    const trackedSelection = {
      focusNode,
      focusOffset,
      proposedHighlight
    };
    this.setState({
      trackedSelection
    });
  }
  render() {
    const {
      mouseState,
      trackedSelection
    } = this.state;
    const userIsMouseSelecting = mouseState === "down-and-selecting";
    return this.props.children ? /*#__PURE__*/React__namespace.createElement("div", null, this.props.children(trackedSelection, userIsMouseSelecting)) : null;
  }
}

/**
 * This component, given a set of DOMHighlights, draws highlight rectangles in
 * the same absolute position as the highlighted content, as computed by the
 * range's `getClientRects` method.
 *
 * TODO(mdr): Many things can affect the correct positioning of highlighting,
 *     and this component does not attempt to anticipate them. If we start
 *     using this highlighting library on content with a more dynamic layout,
 *     we should add a hook to allow the parent to `forceUpdate` the
 *     `HighlightingUI`.
 */
class HighlightingUI extends React__namespace.PureComponent {
  _handleAddHighlight(highlightToAdd) {
    this.props.onAddHighlight(highlightToAdd);

    // Deselect the newly-highlighted text, by collapsing the selection
    // to the end of the range.
    const selection = document.getSelection();
    if (selection) {
      selection.collapseToEnd();
    }
  }
  _selectionIsValid(trackedSelection) {
    if (!trackedSelection) {
      return false;
    }
    const {
      contentNode
    } = this.props;

    // Create a range over the content node.
    const contentRange = new Range();
    contentRange.selectNodeContents(contentNode);

    // Create a range over the focus position.
    const focusRange = new Range();
    focusRange.setStart(trackedSelection.focusNode, trackedSelection.focusOffset);
    focusRange.collapse(true /* to start */);

    // Determine whether the content range contains the focus, by checking
    // whether they intersect. Because the focus range is a single point,
    // intersection is equivalent to being fully contained.
    const contentContainsFocus = rangesOverlap(contentRange, focusRange);

    // If the content contains the focus, this is a valid selection. Some
    // parts of the range might go beyond the content, but that's okay; the
    // corresponding DOMHighlight is already trimmed to only contain valid
    // words. We're just checking that the tooltip we render will be inside
    // the content, because rendering a tooltip outside the content would
    // be weird.
    const selectionIsValid = contentContainsFocus;
    return selectionIsValid;
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(SelectionTracker, {
      buildHighlight: this.props.buildHighlight,
      enabled: this.props.editable
    }, (trackedSelection, userIsMouseSelecting) => /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(HighlightSetRenderer, {
      editable:
      /* An existing highlight is editable when the
       * component is in editable mode, and there's no
       * selection in progress. */
      this.props.editable && !this._selectionIsValid(trackedSelection),
      highlights: this.props.highlights,
      offsetParent: this.props.offsetParent,
      onRemoveHighlight: this.props.onRemoveHighlight,
      zIndexes: this.props.zIndexes
    }), this._selectionIsValid(trackedSelection) && !userIsMouseSelecting && /*#__PURE__*/React__namespace.createElement(HighlightTooltip, {
      label: i18n__namespace._("Add highlight"),
      onClick: () => this._handleAddHighlight(trackedSelection.proposedHighlight),
      focusNode: trackedSelection.focusNode,
      focusOffset: trackedSelection.focusOffset,
      offsetParent: this.props.offsetParent
    })));
  }
}

class WordIndexer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_container", void 0);
  }
  /* eslint-enable react/sort-comp */

  componentDidMount() {
    this._sendWordsUpdate();
  }
  componentDidUpdate() {
    this._sendWordsUpdate();
  }
  _sendWordsUpdate() {
    this.props.onWordsUpdate(this._getWordRanges());
  }
  _getWordRanges() {
    const container = this._container;
    if (!container) {
      throw new PerseusError("invariant violation: `this._container` is not defined, but " + "this method is only called after mount/update", Errors.NotAllowed);
    }

    // Create a TreeWalker that visits text nodes and element nodes.
    // We select the types of nodes we're interested in by bitwise-ORing
    // the desired filters together.
    const treeWalker = container.ownerDocument.createTreeWalker(container, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, () => NodeFilter.FILTER_ACCEPT,
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 1-3 arguments, but got 4.
    false);

    // Traverse the container's descendant text nodes in DOM order,
    // indexing the words we find.
    const index = [];
    let trailingWordRange = null;
    while (treeWalker.nextNode()) {
      const node = treeWalker.currentNode;
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        if (getComputedStyle(element).display !== "inline") {
          // Block-level elements interrupt text words, so set the
          // current trailing word to `null`.
          //
          // This includes exiting one paragraph to visit another,
          // but also includes text interrupted by inline-block
          // elements.
          //
          // TODO(mdr): Is this behavior *generalizably* correct?
          // TODO(mdr): I don't *fully* understand the performance
          //     implications of `getComputedStyle`, but I think it's
          //     gonna be nbd at the current call sites. If we try to
          //     generalize to frequently-updating content, we might
          //     want to watch this as a potential performance
          //     bottleneck.
          trailingWordRange = null;
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.nodeValue;

        // A "word" is here simply defined as a maximal-length
        // substring of non-space characters.
        //
        // Loop over all the words in the string, by repeatedly calling
        // `wordPattern.exec(text)`.
        const wordPattern = /\S+/g;
        let wordMatch;
        let newTrailingWordRange = null;
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | null' is not assignable to parameter of type 'string'.
        while ((wordMatch = wordPattern.exec(text)) !== null) {
          const startOffset = wordMatch.index;
          const endOffset = wordMatch.index + wordMatch[0].length;
          let range;
          if (startOffset === 0 && trailingWordRange) {
            // This word is at the start of this text node, and
            // there's a trailing word from the previous text node,
            // and there was no non-inline element between them.
            // This word and the trailing word are probably
            // intended to be two parts of the same word.
            //
            // So, instead of creating a new word range, we add
            // this word to the previous range by extending it.
            range = trailingWordRange;
            range.setEnd(node, endOffset);
          } else {
            // Otherwise, start a new word range here, and add it
            // to the list.
            // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
            range = node.ownerDocument.createRange();
            range.setStart(node, startOffset);
            range.setEnd(node, endOffset);
            index.push(range);
          }

          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          if (endOffset === text.length) {
            newTrailingWordRange = range;
          }
        }
        trailingWordRange = newTrailingWordRange;
      }
    }
    return index;
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      ref: container => this._container = container
    }, this.props.children);
  }
}

class HighlightableContent extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_container", void 0);
    _defineProperty(this, "_content", void 0);
    _defineProperty(this, "state", {
      wordRanges: []
    });
    _defineProperty(this, "_handleAddHighlight", highlight => {
      const newDomHighlights = addHighlight(this._getDOMHighlights(), highlight);
      const newSerializedHighlights = {};
      for (const key of Object.keys(newDomHighlights)) {
        newSerializedHighlights[key] = serializeHighlight(newDomHighlights[key]);
      }
      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });
    _defineProperty(this, "_handleRemoveHighlight", keyToRemove => {
      const {
        serializedHighlights
      } = this.props;
      const newSerializedHighlights = {
        ...serializedHighlights
      };
      // @ts-expect-error [FEI-5003] - TS2542 - Index signature in type '{ readonly [x: string]: SerializedHighlight; }' only permits reading.
      delete newSerializedHighlights[keyToRemove];
      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });
    _defineProperty(this, "_handleWordsUpdate", wordRanges => {
      this.setState({
        wordRanges
      });
    });
  }
  _buildHighlight(highlightRange) {
    // TODO(mdr): If _buildHighlight starts getting called more often, we
    //     might want to cache the DOMHighlightSet instead of recomputing
    //     it here.
    return buildHighlight(this._getDOMHighlights(), this.state.wordRanges, highlightRange);
  }

  /**
   * Take the highlights from props, and deserialize them into DOMHighlights,
   * according to the latest cache of word ranges.
   */
  _getDOMHighlights() {
    const {
      serializedHighlights
    } = this.props;
    const {
      wordRanges
    } = this.state;
    const domHighlights = {};
    for (const key of Object.keys(serializedHighlights)) {
      domHighlights[key] = deserializeHighlight(serializedHighlights[key], wordRanges);
    }
    return domHighlights;
  }

  /**
   * Add the given DOMHighlight to the current set.
   */

  render() {
    const highlights = this._getDOMHighlights();

    // NOTE(mdr): This lambda is rebuilt every time this component updates,
    //     so every update to HighlightableContent triggers an update in
    //     the child HighlightingUI and SelectionTracker, even if the
    //     behavior hasn't changed.
    //
    //     Over-updating is preferable to under-updating here, because some
    //     updates in this component's props/state *do* affect
    //     `buildHighlight`'s behavior, and *should* trigger an update.
    //
    //     A more performant approach would be to cache this function
    //     object until its implicitly-bound inputs change. If profiling
    //     leads us to implement such caching, this draft might be a good
    //     starting point: https://phabricator.khanacademy.org/D35623?id=170698
    const buildHighlight = r => this._buildHighlight(r);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$9.container),
      ref: container => this._container = container
    }, /*#__PURE__*/React__namespace.createElement("div", null, this.props.enabled && this._container && this._content && /*#__PURE__*/React__namespace.createElement(HighlightingUI, {
      buildHighlight: buildHighlight,
      contentNode: this._content,
      editable: this.props.editable,
      highlights: highlights,
      offsetParent: this._container,
      zIndexes: {
        // The content has a z-index of 1, so, to
        // be below the content, use z-index of 0.
        //
        // TODO(mdr): Is this way of passing around
        //     `z-index: 0` actually worth the
        //     trouble? We used to have more, but
        //     now we don't need them...
        belowContent: 0
      },
      onAddHighlight: this._handleAddHighlight,
      onRemoveHighlight: this._handleRemoveHighlight
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$9.content),
      ref: content => this._content = content
    }, /*#__PURE__*/React__namespace.createElement(WordIndexer, {
      onWordsUpdate: this._handleWordsUpdate
    }, this.props.children)));
  }
}
const styles$9 = aphrodite.StyleSheet.create({
  // We render content with z-index 1, and highlights with z-index 0, so that
  // content will receive the browser's native pointer events. (Highlights
  // have their own magic code to manage hover detection, despite being
  // behind the content.)

  container: {
    // Position the container and give it a z-index, to scope the z-indexes
    // inside by creating a stacking context.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
    //
    // This way, content's z-index of 1, and highlights' z-index of 0, and
    // tooltips' z-index of 2 don't interact with anything external;
    // external UI will see `HighlightableContent` as a single flat layer
    // with a z-index of 0. This removes the need for us to coordinate our
    // choices of z-index with external UI.
    position: "relative",
    zIndex: 0
  },
  content: {
    // NOTE(mdr): Creating a stacking context for content of z-index 1 may
    //    be problematic if the content and external page want to
    //    interleave layers between each other, e.g., if the application UI
    //    wants to render something above some parts of our content, but
    //    below other parts. It's not relevant for the current Passage-only
    //    call site, but could be relevant someday…
    position: "relative",
    zIndex: 1
  }
});

function getInitialParseState() {
  return {
    currentRef: [],
    useRefs: true,
    lastRef: 0,
    firstSentenceRef: null,
    firstQuestionRef: null,
    lastFootnote: {
      id: 0,
      text: ""
    }
  };
}
class RefStart extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "getRefContent", () => {
      return this.props.refContent;
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("span", {
      style: REF_STYLE
    }, i18n__namespace.doNotTranslate("_"));
  }

  // @ts-expect-error [FEI-5003] - TS2322 - Type '() => React.ReactNode' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>>'.
}

class RefEnd extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("span", {
      style: REF_STYLE
    }, i18n__namespace.doNotTranslate("_"));
  }
}
const rules = {
  newline: SimpleMarkdown__default["default"].defaultRules.newline,
  paragraph: SimpleMarkdown__default["default"].defaultRules.paragraph,
  escape: SimpleMarkdown__default["default"].defaultRules.escape,
  passageFootnote: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.1,
    match: SimpleMarkdown__default["default"].inlineRegex(/^\^/),
    parse: (capture, parse, state) => {
      // if no footnotes have been seen, we're id 1. otherwise,
      // we're the next subsequent id
      const id = state.lastFootnote.id + 1;
      const footnote = {
        id: id,
        // our text is what to output. if there is only one footnote,
        // it's a *; otherwise it's a superscript number
        text: id === 1 ? "*" : "" + id
      };

      // If the previous footnote was a *, we need to adjust it to be
      // a number, since now we know there is more than one footnote
      if (state.lastFootnote.text === "*") {
        state.lastFootnote.text = "" + state.lastFootnote.id;
      }

      // and update our last footnote, + return.
      state.lastFootnote = footnote;
      return footnote;
    },
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement("sup", {
        key: state.key
      }, node.text);
    }
  },
  refStart: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.2,
    match: function (source) {
      const capture = /^\{\{/.exec(source);
      if (capture) {
        // We need to do extra processing here to capture the
        // full text of the reference, which we include so that
        // we can use that information as a screenreader
        let closeIndex = 2; // start looking after the opening "{{"
        let refNestingLevel = 0;

        // Find the closing "}}" for our opening "{{"
        while (closeIndex < source.length) {
          const token = source.slice(closeIndex, closeIndex + 2);
          if (token === "{{") {
            refNestingLevel++;
            // increment an extra character so we get the
            // full 2-char token
            closeIndex++;
          } else if (token === "}}") {
            if (refNestingLevel > 0) {
              refNestingLevel--;
              // increment an extra character so we get the
              // full 2-char token
              closeIndex++;
            } else {
              break;
            }
          }
          closeIndex++;
        }

        // A "magic" capture that matches the opening {{
        // but captures the full ref text internally :D
        // unfortunately the "magic" makes TypeScript upset,
        // so there's this questionable workaround
        capture[1] = source.slice(2, closeIndex);
        return capture;
      }
      return null;
    },
    parse: (capture, parse, state) => {
      if (!state.useRefs) {
        return {
          ref: null,
          refContent: null
        };
      }
      const ref = state.lastRef + 1;
      state.lastRef = ref;
      state.currentRef.push(ref);
      const refContent = parse(
      // Curly quotes
      "(\u201C" + capture[1] + "\u201D)\n\n", ___default["default"].defaults({
        // We don't want to parse refs while looking through
        // this refs contents. We definitely don't want
        // to make those refs into react refs on the
        // passage, for instance!
        useRefs: false
      }, getInitialParseState()));
      return {
        ref: ref,
        refContent: refContent
      };
    },
    react: (node, output, state) => {
      const ref = node.ref;
      if (ref == null) {
        return null;
      }

      // We don't pass state here because this is parsed
      // and output out-of-band. We don't want to affect
      // our state by the double-output here :).
      const refContent = output(node.refContent, {});

      // note(matthewc) the refs created here become the refs
      // pulled from `this.refs` in passage.jsx
      return /*#__PURE__*/React__namespace.createElement(RefStart, {
        ref: START_REF_PREFIX + ref,
        key: START_REF_PREFIX + ref,
        refContent: refContent
      });
    }
  },
  refEnd: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.3,
    match: SimpleMarkdown__default["default"].inlineRegex(/^\}\}/),
    parse: (capture, parse, state) => {
      if (!state.useRefs) {
        return {
          ref: null
        };
      }
      const ref = state.currentRef.pop() || null;
      return {
        ref: ref
      };
    },
    react: (node, output, state) => {
      if (node.ref != null) {
        // note(matthewc) the refs created here become the refs
        // pulled from `this.refs` in passage.jsx
        return /*#__PURE__*/React__namespace.createElement(RefEnd, {
          ref: END_REF_PREFIX + node.ref,
          key: END_REF_PREFIX + node.ref
        });
      }
      // if we didn't have a matching start reference, or
      // we aren't parsing refs for this pass (we do this
      // inside of refContent), don't output a ref
      return null;
    }
  },
  squareLabel: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.4,
    match: SimpleMarkdown__default["default"].inlineRegex(/^\[\[(\w+)\]\]( *)/),
    parse: (capture, parse, state) => {
      if (!state.firstQuestionRef) {
        state.firstQuestionRef = capture[1];
      }
      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-square",
        className: "perseus-passage-square-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": "true"
      }, /*#__PURE__*/React__namespace.createElement("span", {
        style: SQUARE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Marker for question %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  circleLabel: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.5,
    match: SimpleMarkdown__default["default"].inlineRegex(/^\(\((\w+)\)\)( *)/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      // @ts-expect-error [FEI-5003] - TS2739 - Type '(string | Element | null)[]' is missing the following properties from type 'ReactElement<any, string | JSXElementConstructor<any>>': type, props, key
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-circle",
        className: "perseus-passage-circle-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": true
      }, /*#__PURE__*/React__namespace.createElement("span", {
        style: CIRCLE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Circle marker %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  squareBracketRef: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.6,
    match: SimpleMarkdown__default["default"].inlineRegex(/^\[(\d+)\]( *)/),
    parse: (capture, parse, state) => {
      if (!state.firstSentenceRef) {
        state.firstSentenceRef = capture[1];
      }
      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-brackets",
        className: "perseus-passage-bracket-label",
        "aria-hidden": "true"
      }, "[", node.content, "]"), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Sentence %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  highlight: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.7,
    match: SimpleMarkdown__default["default"].inlineRegex(/^{highlighting.start}(.+?){highlighting.end}/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: 0,
        className: "perseus-highlight"
      }, node.content)];
    }
  },
  reviewHighlight: {
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.7,
    match: SimpleMarkdown__default["default"].inlineRegex(/^{review-highlighting.start}(.+?){review-highlighting.end}/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: 0,
        className: "perseus-review-highlight"
      }, node.content)];
    }
  },
  strong: SimpleMarkdown__default["default"].defaultRules.strong,
  u: SimpleMarkdown__default["default"].defaultRules.u,
  em: SimpleMarkdown__default["default"].defaultRules.em,
  del: SimpleMarkdown__default["default"].defaultRules.del,
  text: {
    ...SimpleMarkdown__default["default"].defaultRules.text,
    react(node, output, state) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        key: state.key
      }, node.content);
    }
  }
};
const START_REF_PREFIX = "start-ref-";
const END_REF_PREFIX = "end-ref-";
const REF_STYLE = {
  display: "inline-block",
  width: 0,
  visibility: "hidden"
};
const LABEL_OUTER_STYLE = {
  // for some reason we need these to keep the nbsp from wrapping when the
  // inner circle/square is display: inline-block
  display: "inline",
  whiteSpace: "nowrap"
};
const SQUARE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  paddingLeft: 10,
  paddingRight: 10,
  userSelect: "none",
  WebkitUserSelect: "none"
};
const CIRCLE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  userSelect: "none",
  WebkitUserSelect: "none",
  width: 22,
  height: 22,
  borderRadius: "50%",
  textAlign: "center"
};
const builtParser = SimpleMarkdown__default["default"].parserFor(rules);
const parse = (source, state) => {
  // @ts-expect-error [FEI-5003] - TS2322 - Type 'ParseState | {}' is not assignable to type 'ParseState | null | undefined'.
  state = state || {};
  const paragraphedSource = source + "\n\n";
  return builtParser(paragraphedSource, ___default["default"].extend(state, getInitialParseState()));
};

// @ts-expect-error [FEI-5003] - TS2322 - Type 'ReactOutput' is not assignable to type '(arg1: SingleASTNode[]) => ReactElement<any, string | JSXElementConstructor<any>>'.
const output = SimpleMarkdown__default["default"].reactFor(SimpleMarkdown__default["default"].ruleOutput(rules, "react"));
var PassageMarkdown = {
  parse,
  output,
  START_REF_PREFIX,
  END_REF_PREFIX,
  getInitialParseState
};

// A fake paragraph to measure the line height of the passage,
// so we can adapt to browser zoom
class LineHeightMeasurer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_line", void 0);
  }
  measureLineHeight() {
    if (!this._line) {
      return 0;
    }
    return this._line.clientHeight;
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$8.measurer),
      "aria-hidden": "true"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      ref: ref => this._line = ref,
      className: "paragraph"
    }, "Line Height Measurement"));
  }
}
const styles$8 = aphrodite.StyleSheet.create({
  measurer: {
    position: "absolute",
    top: 0,
    left: 0,
    visibility: "hidden",
    // keep from blocking text selection
    zIndex: -1
  }
});
class Passage extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_contentRef", void 0);
    _defineProperty(this, "_lineHeightMeasurerRef", void 0);
    _defineProperty(this, "_onResize", void 0);
    _defineProperty(this, "_stylesAppiedTimer", void 0);
    _defineProperty(this, "state", {
      nLines: null,
      startLineNumbersAfter: 0,
      stylesAreApplied: false
    });
    _defineProperty(this, "_handleSerializedHighlightsUpdate", serializedHighlights => {
      this.props.onChange({
        highlights: serializedHighlights
      });
    });
  }
  componentDidMount() {
    this._updateState();

    // @ts-expect-error [FEI-5003] - TS2322 - Type '(() => void) & Cancelable' is not assignable to type '() => Record<any, any>'.
    this._onResize = ___default["default"].throttle(() => {
      var _this$_lineHeightMeas;
      // If we're rendering JIPT text, we won't have line numbers or a
      // line height measurer, so skip handling this resize.
      if (this.shouldRenderJipt()) {
        return;
      }

      // Remeasure the line height on resize, because the only line
      // height changes we expect are subpixel changes when the user
      // zooms in/out, and the only way to listen for zoom events is to
      // listen for resize events.
      (_this$_lineHeightMeas = this._lineHeightMeasurerRef) === null || _this$_lineHeightMeas === void 0 ? void 0 : _this$_lineHeightMeas.measureLineHeight();
      this._updateState();
    }, 500);
    window.addEventListener("resize", this._onResize);

    // Wait for Aphrodite styles (which are guaranteed to apply after one
    // tick), then set state.
    //
    // This flag is used to set the `enabled` prop of the
    // `HighlightableContent` component. That way, we only show highlights
    // once styles are ready, and they're measured with the correct
    // position.
    //
    // HACK(mdr): It's not really the Passage's Aphrodite styles that are
    //     causing bad measures, but more so the Khan Academy Test Prep
    //     app's Aphrodite styles. We would ideally instead offer the
    //     embedding application an API to signal that the app's layout has
    //     changed in a way that affects the Renderer... but, for now, just
    //     hardcode this hack into here.
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax
    this._stylesAppiedTimer = window.setTimeout(() => {
      this.setState({
        stylesAreApplied: true
      });
    }, 0);
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !___default["default"].isEqual(this.props, nextProps) || !___default["default"].isEqual(this.state, nextState);
  }
  componentDidUpdate() {
    this._updateState();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this._onResize);
    // eslint-disable-next-line no-restricted-syntax
    clearTimeout(this._stylesAppiedTimer);
  }
  /**
   * Line numbering
   *
   * These functions support passage line numbering, which is non-trivial
   * because we manually measure lines to support resizing as well as
   * continuing line numbers from previous passages.
   */

  _updateState() {
    // If we're rendering JIPT text, we're not rendering line numbers so we
    // don't need to update this state.
    if (this.shouldRenderJipt()) {
      return;
    }
    this.setState({
      nLines: this._measureLines(),
      startLineNumbersAfter: this._getInitialLineNumber()
    });
  }
  _measureLines() {
    const renderer = ReactDOM__namespace.findDOMNode(this._contentRef);
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'height' does not exist on type 'JQueryStatic'.
    const contentsHeight = $__default["default"](renderer).height();
    const lineHeight = this._getLineHeight();
    const nLines = Math.round(contentsHeight / lineHeight);
    return nLines;
  }
  _getInitialLineNumber() {
    let isPassageBeforeThisPassage = true;
    const passagesBeforeUs = this.props.findWidgets((id, widgetInfo) => {
      if (widgetInfo.type !== "passage") {
        return false;
      }
      if (id === this.props.widgetId) {
        isPassageBeforeThisPassage = false;
      }
      return isPassageBeforeThisPassage;
    });
    return passagesBeforeUs.map(passageWidget => {
      return passageWidget.getLineCount();
    }).reduce((a, b) => a + b, 0);
  }
  _getLineHeight() {
    var _this$_lineHeightMeas2;
    return ((_this$_lineHeightMeas2 = this._lineHeightMeasurerRef) === null || _this$_lineHeightMeas2 === void 0 ? void 0 : _this$_lineHeightMeas2.measureLineHeight()) || 0;
  }
  getLineCount() {
    if (this.state.nLines != null) {
      return this.state.nLines;
    }
    return this._measureLines();
  }

  /**
   * Passage refs
   *
   * These are functions to support the passage refs inter-widgets feature
   * where other widgets can fetch the line numbers of a reference inside of
   * a passage.
   *
   * todo(matthewc): The refs are created by PassageMarkdown's refStart and refEnd,
   * somehow bubbling up to Passage's `this.refs`. This runs against
   * current best practices for refs by using string refs, but also
   * by breaking our expectation of explicit data flow.
   */

  _getStartRefLineNumber(referenceNumber) {
    const refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber;
    const ref = this.refs[refRef];
    if (!ref) {
      return null;
    }

    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    const $ref = $__default["default"](ReactDOM__namespace.findDOMNode(ref));
    // We really care about the first text after the ref, not the
    // ref element itself:
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'next' does not exist on type 'JQueryStatic'.
    let $refText = $ref.next();
    if ($refText.length === 0) {
      // But if there are no elements after the ref, just
      // use the ref itself.
      $refText = $ref;
    }
    const vPos = $refText.offset().top;
    return this.state.startLineNumbersAfter + 1 + this._convertPosToLineNumber(vPos);
  }
  _getEndRefLineNumber(referenceNumber) {
    const refRef = PassageMarkdown.END_REF_PREFIX + referenceNumber;
    const ref = this.refs[refRef];
    if (!ref) {
      return null;
    }

    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    const $ref = $__default["default"](ReactDOM__namespace.findDOMNode(ref));
    // We really care about the last text before the ref, not the
    // ref element itself:
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'prev' does not exist on type 'JQueryStatic'.
    let $refText = $ref.prev();
    if ($refText.length === 0) {
      // But if there are no elements before the ref, just
      // use the ref itself.
      $refText = $ref;
    }
    const height = $refText.height();
    const vPos = $refText.offset().top;
    let line = this._convertPosToLineNumber(vPos + height);
    if (height === 0) {
      // If the element before the end ref span was the start
      // ref span, it might have 0 height. This is obviously not
      // the intended use case, but we should handle it gracefully.
      // If this is the case, then the "bottom" of our element is
      // actually the top of the line we're on, so we need to add
      // one to the line number.
      line += 1;
    }
    return this.state.startLineNumbersAfter + line;
  }
  _convertPosToLineNumber(absoluteVPos) {
    const content = ReactDOM__namespace.findDOMNode(this._contentRef);
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'offset' does not exist on type 'JQueryStatic'.
    const relativeVPos = absoluteVPos - $__default["default"](content).offset().top;
    const lineHeight = this._getLineHeight();
    const line = Math.round(relativeVPos / lineHeight);
    return line;
  }
  _getRefContent(referenceNumber) {
    const refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber;
    const ref = this.refs[refRef];
    if (!ref) {
      return null;
    }
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'getRefContent' does not exist on type 'ReactInstance'.
    return ref.getRefContent();
  }
  getReference(referenceNumber) {
    const refStartLine = this._getStartRefLineNumber(referenceNumber);
    const refEndLine = this._getEndRefLineNumber(referenceNumber);
    if (refStartLine == null || refEndLine == null) {
      return null;
    }
    const refContent = this._getRefContent(referenceNumber);
    return {
      startLine: refStartLine,
      endLine: refEndLine,
      content: refContent
    };
  }

  /**
   * Misc functions
   *
   * These are misc widget functions used for the widget API
   */

  getUserInput() {
    return null;
  }
  simpleValidate(rubric) {
    return Passage.validate(this.getUserInput(), rubric);
  }

  /* eslint-disable react/sort-comp */
  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  /* eslint-enable react/sort-comp */

  /**
   * Rendering
   *
   * Functions to render the passage widget.
   */

  _renderInstructions(parseState) {
    const firstQuestionNumber = parseState.firstQuestionRef;
    const firstSentenceRef = parseState.firstSentenceRef;
    let instructions = "";
    if (firstQuestionNumber) {
      instructions += i18n__namespace._("The symbol %(questionSymbol)s indicates that question " + "%(questionNumber)s references this portion of the " + "passage.", {
        questionSymbol: "[[" + firstQuestionNumber + "]]",
        questionNumber: firstQuestionNumber
      });
    }
    if (firstSentenceRef) {
      instructions += i18n__namespace._(" The symbol %(sentenceSymbol)s indicates that the " + "following sentence is referenced in a question.", {
        sentenceSymbol: "[" + firstSentenceRef + "]"
      });
    }
    const parsedInstructions = PassageMarkdown.parse(instructions);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage-instructions"
    }, PassageMarkdown.output(parsedInstructions));
  }
  shouldRenderJipt() {
    // Mostly copied from `renderer.jsx`. If we're doing JIPT, we want to
    // render our content differently.
    const {
      JIPT
    } = getDependencies();
    return JIPT.useJIPT && this.props.passageText.indexOf("crwdns") !== -1;
  }
  _renderContent(parsed) {
    // Wait until Aphrodite styles are applied before enabling highlights,
    // so that we measure the correct positions.
    const enabled = this.state.stylesAreApplied;

    // Highlights are read-only in review mode.
    const editable = !this.props.reviewModeRubric;
    return /*#__PURE__*/React__namespace.createElement(HighlightableContent, {
      editable: editable,
      enabled: enabled,
      onSerializedHighlightsUpdate: this._handleSerializedHighlightsUpdate,
      serializedHighlights: this.props.highlights
    }, /*#__PURE__*/React__namespace.createElement("div", {
      ref: ref => this._contentRef = ref
    }, /*#__PURE__*/React__namespace.createElement(LineHeightMeasurer, {
      ref: ref => this._lineHeightMeasurerRef = ref
    }), PassageMarkdown.output(parsed)));
  }
  _hasFootnotes() {
    const rawContent = this.props.footnotes;
    const isEmpty = /^\s*$/.test(rawContent);
    return !isEmpty;
  }
  _renderFootnotes() {
    const rawContent = this.props.footnotes;
    const parsed = PassageMarkdown.parse(rawContent);
    return PassageMarkdown.output(parsed);
  }
  render() {
    let lineNumbers;
    const nLines = this.state.nLines;
    if (this.props.showLineNumbers && nLines) {
      // lineN is the line number in the current passage
      // lineAt is the actual line number across multiple passages
      lineNumbers = ___default["default"].range(1, nLines + 1).map(lineN => {
        const lineAt = lineN + this.state.startLineNumbersAfter;
        if (lineAt === 4) {
          // we leave a space in i18n to disambiguate translations, see TP-5392
          // I18N: a label next to a reading passage to denote the line number
          const translatedLine = i18n__namespace._("Line ");
          return /*#__PURE__*/React__namespace.createElement("span", {
            key: "line-marker",
            className: "line-marker"
          }, translatedLine);
        }
        return /*#__PURE__*/React__namespace.createElement("span", {
          key: lineN
        }, lineAt);
      });
    }
    const parseState = PassageMarkdown.getInitialParseState();

    // Replace the vertical double quote characters quoting text with
    // an unicode left and right double quote characters. This would
    // avoid rendering right or left unicode double quotes on both
    // ends of a sentence wrapped by double quotes.
    const re = /("{1})([^"]*)("{1})/g;
    const doubleQuoteParsedContent = this.props.passageText.replace(re, "\u201c$2\u201d");
    const parsedContent = PassageMarkdown.parse(doubleQuoteParsedContent, parseState);
    // Check if the title has any non-empty text in it.
    const hasTitle = /\S/.test(this.props.passageTitle);
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage-container"
    }, this._renderInstructions(parseState), /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage"
    }, hasTitle && /*#__PURE__*/React__namespace.createElement("h3", {
      className: "passage-title"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.passageTitle,
      linterContext: this.props.linterContext
    })), lineNumbers && /*#__PURE__*/React__namespace.createElement("div", {
      className: "line-numbers",
      "aria-hidden": true
    }, lineNumbers), !hasTitle && /*#__PURE__*/React__namespace.createElement("h3", {
      className: "perseus-sr-only"
    }, i18n__namespace._("Beginning of reading passage.")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "passage-text"
    }, this.shouldRenderJipt() ?
    /*#__PURE__*/
    // If we're in JIPT mode, just pass off our
    // content to a <Renderer /> which knows how
    // to handle rendering JIPT text.
    React__namespace.createElement(Renderer, {
      content: this.props.passageText
    }) : this._renderContent(parsedContent)), this._hasFootnotes() && [/*#__PURE__*/React__namespace.createElement("h4", {
      key: "footnote-start",
      className: "perseus-sr-only"
    }, i18n__namespace._("Beginning of reading passage footnotes.")), /*#__PURE__*/React__namespace.createElement("div", {
      key: "footnotes",
      className: "footnotes"
    }, this._renderFootnotes())], /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sr-only"
    }, i18n__namespace._("End of reading passage.")))));
  }
}
_defineProperty(Passage, "defaultProps", {
  passageTitle: "",
  passageText: "",
  footnotes: "",
  showLineNumbers: true,
  highlights: {},
  linterContext: PerseusLinter.linterContextDefault
});
var Passage$1 = {
  name: "passage",
  displayName: "Passage (SAT only)",
  widget: Passage,
  transform: editorProps => {
    return ___default["default"].pick(editorProps, "passageTitle", "passageText", "footnotes", "showLineNumbers");
  },
  isLintable: true
};

class PassageRefTarget extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return PassageRefTarget.validate(this.getUserInput(), rubric);
    });
  }
  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.content
      // @ts-expect-error [FEI-5003] - TS2322 - Type '{ content: any; inline: boolean; apiOptions: any; linterContext: any; }' is not assignable to type 'IntrinsicAttributes & IntrinsicClassAttributes<Renderer> & Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "children" | ... 3 more ... | "legacyPerseusLint"> & InexactPartial<...> & InexactPartial<...>'.
      ,
      inline: true,
      apiOptions: this.props.apiOptions,
      linterContext: this.props.linterContext
    });
  }
}
_defineProperty(PassageRefTarget, "propTypes", {
  ...propTypes,
  content: PropTypes__default["default"].string,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(PassageRefTarget, "defaultProps", {
  content: "",
  linterContext: PerseusLinter.linterContextDefault
});
var PassageRefTarget$1 = {
  name: "passage-ref-target",
  displayName: "PassageRefTarget",
  defaultAlignment: "inline",
  widget: PassageRefTarget,
  hidden: true,
  transform: editorProps => {
    return ___default["default"].pick(editorProps, "content");
  },
  version: {
    major: 0,
    minor: 0
  },
  isLintable: true
};

const {
  deepEq: deepEq$1
} = Util;
const BAR = "bar",
  LINE = "line",
  PIC = "pic",
  HISTOGRAM = "histogram",
  DOTPLOT = "dotplot";
({
  type: PropTypes__default["default"].oneOf([BAR, LINE, PIC, HISTOGRAM, DOTPLOT]),
  labels: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  categories: PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string])),
  scaleY: PropTypes__default["default"].number,
  maxY: PropTypes__default["default"].number,
  snapsPerLine: PropTypes__default["default"].number,
  picSize: PropTypes__default["default"].number,
  pixBoxHeight: PropTypes__default["default"].number,
  picUrl: PropTypes__default["default"].string,
  plotDimensions: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  labelInterval: PropTypes__default["default"].number,
  starting: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  static: PropTypes__default["default"].bool
});
class Plotter extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "shouldSetupGraphie", void 0);
    _defineProperty(this, "_isMounted", false);
    _defineProperty(this, "horizHairline", void 0);
    _defineProperty(this, "hairlineRange", void 0);
    _defineProperty(this, "graphie", void 0);
    _defineProperty(this, "state", {
      values: this.props.starting || [1],
      // The measured rendered height of category strings. Used to calculate
      // bottom padding of plot, to prevent categories from overlapping the
      // bottom label.
      categoryHeights: {}
    });
    _defineProperty(this, "DOT_PLOT_POINT_SIZE", () => {
      return this.props.apiOptions.isMobile ? 6 : 4;
    });
    _defineProperty(this, "DOT_PLOT_POINT_PADDING", () => {
      return 8;
    });
    _defineProperty(this, "DOT_TICK_POINT_SIZE", () => {
      return 2;
    });
    _defineProperty(this, "setupGraphie", prevState => {
      const self = this;
      self.shouldSetupGraphie = false;
      const graphieDiv = ReactDOM__default["default"].findDOMNode(self.refs.graphieDiv);
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call. | TS2339 - Property 'empty' does not exist on type 'JQueryStatic'.
      $__default["default"](graphieDiv).empty();
      const graphie = GraphUtils.createGraphie(graphieDiv);

      // TODO(jakesandlund): It's not the react way to hang
      // something off the component object, but since graphie
      // is outside React, it makes it easier to do this.
      self.graphie = graphie;
      self.graphie.pics = [];
      self.graphie.dotTicks = [];
      const isBar = self.props.type === BAR,
        isLine = self.props.type === LINE,
        isPic = self.props.type === PIC,
        isHistogram = self.props.type === HISTOGRAM,
        isDotplot = self.props.type === DOTPLOT;
      const isTiledPlot = isPic || isDotplot;
      const config = {};
      const c = config; // c for short

      const isMobile = this.props.apiOptions.isMobile;
      c.graph = {
        lines: [],
        bars: [],
        points: [],
        dividers: []
      };
      c.scaleY = self.props.scaleY;
      c.dimX = self.props.categories.length;
      const plotDimensions = isMobile ? [288, 336] : self.props.plotDimensions;
      if (isLine) {
        // Subtracting 0.2 makes line have equal padding on each side
        c.dimX += isMobile ? -0.2 : 1;
      } else if (isHistogram) {
        c.barPad = 0;
        c.barWidth = 1;
      } else if (isBar) {
        c.barPad = isMobile ? 0.08 : 0.15;
        c.barWidth = 1 - 2 * c.barPad;
        c.dimX += (isMobile ? -2 : 2) * c.barPad;
      } else if (isTiledPlot) {
        c.picBoxHeight = self.props.picBoxHeight;
        c.picBoxWidthPx = plotDimensions[0] / self.props.categories.length;
        const picPadAllWidth = plotDimensions[0] - c.dimX * c.picBoxWidthPx;
        c.picPad = picPadAllWidth / (2 * c.dimX + 2);
        const picFullWidth = c.picBoxWidthPx + 2 * c.picPad;

        // Convert from px to "unscaled"
        c.picPad = c.picPad / picFullWidth;
        c.picBoxWidth = c.picBoxWidthPx / picFullWidth;
        c.dimX += 2 * c.picPad;
      }
      if (isDotplot) {
        c.picBoxHeight = this.DOT_PLOT_POINT_SIZE() * 2 + this.DOT_PLOT_POINT_PADDING();
      }
      c.dimY = Math.ceil(self.props.maxY / c.scaleY) * c.scaleY;
      let padX = 25;
      if ((isBar || isLine) && isMobile) {
        padX = self.props.labels[1].length !== 0 ? 17 : 11;
      }

      // Since dotplot doesn't have an axis along the left it looks weird
      // with the same padding as the others
      if (isDotplot) {
        padX /= 2;
      }
      if (isMobile && isTiledPlot && self.props.labels[1].length === 0) {
        padX = 0;
      }

      // Default vertical padding.
      let padTop = 25;
      let padBottom = 25 * 3;

      // TODO(michaelpolyak): Handle other plot types: Dot, Histogram, Line.
      if (isMobile && (isBar || isTiledPlot)) {
        const maxCategoryHeight = Math.max(0,
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'unknown' is not assignable to parameter of type 'number'.
        ...Object.values(self.state.categoryHeights));
        if (maxCategoryHeight) {
          // Account for bottom label position, height.
          let offsetY = 25;
          if (isTiledPlot) {
            // Tiled plot categories have additional spacing.
            offsetY += 10;
          }
          padBottom = offsetY + maxCategoryHeight;
        }
      }
      if (isMobile) {
        c.scale = [
        // We multiply pad by 4 because we add 3*pad padding on the left
        // and 1*pad on the right
        (plotDimensions[0] - padX * 4) / c.dimX, (plotDimensions[1] - (padTop + padBottom)) / c.dimY];
      } else {
        c.scale = ___default["default"].map([c.dimX, c.dimY], function (dim, i) {
          return plotDimensions[i] / dim;
        });
      }
      if (isTiledPlot) {
        c.scale[1] = c.picBoxHeight / c.scaleY;
      }

      // Transform from screen space (pixels) to plot space.
      padX /= c.scale[0];
      padTop /= c.scale[1];
      padBottom /= c.scale[1];
      graphie.init({
        range: [[-3 * padX, c.dimX + padX], [-padBottom, c.dimY + padTop]],
        scale: c.scale,
        isMobile: this.props.apiOptions.isMobile
      });
      graphie.addMouseLayer({
        allowScratchpad: true,
        setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
      });
      if (!isTiledPlot) {
        // If we have isMobile, we skip the 0 label.
        const initialY = isMobile ? c.scaleY : 0;
        for (let y = initialY; y <= c.dimY; y += c.scaleY) {
          graphie.label([0, y], KhanMath.roundToApprox(y, 2), "left", /* isTeX */true /* for the \approx symbol */);

          graphie.style({
            stroke: isMobile ? "#e9ebec" : "#000",
            strokeWidth: 1,
            opacity: isMobile ? 1 : 0.3
          }, function () {
            graphie.line([0, y], [c.dimX, y]);
          });
        }
      }
      if ((isBar || isLine) && isMobile) {
        self.graphie.dragPrompt = graphie.label([c.dimX / 2, c.dimY / 2], i18n__namespace._("Drag handles to make graph"), "center", false).css("font-weight", "bold").css("color", KhanColors.KA_GREEN).css("display", "none");
      }
      self.setupCategories(config);
      if (isTiledPlot && isMobile) {
        self.graphie.dotPrompt = graphie.label([c.dimX / 2, c.dimY / 2], i18n__namespace._("Tap to add points"), "center", false).css("font-weight", "bold").css("color", KhanColors.KA_GREEN).css("display", "none");
      }
      if (isTiledPlot) {
        self.drawPicHeights(self.state.values, prevState.values);
      }
      graphie.style({
        stroke: "#000",
        strokeWidth: 2,
        opacity: 1.0
      }, function () {
        if (isTiledPlot) {
          if (isDotplot) {
            // Dotplot is a subtype of tiled plot, here we only draw
            // the x-axis
            graphie.style({
              stroke: isMobile ? KhanColors.GRAY_G : "#000",
              strokeWidth: isMobile ? 1 : 2
            }, () => graphie.line([isMobile ? 0 : 0.5, 0], [c.dimX - (isMobile ? 0 : 0.5), 0]));
          } else {
            graphie.line([0, 0], [c.dimX, 0]);

            // Draw the left axis for non-dotplots
            if (self.props.labels[1].length !== 0 || !isMobile) {
              graphie.style({
                stroke: isMobile ? KhanColors.GRAY_G : "#000",
                strokeWidth: isMobile ? 1 : 2
              }, () => graphie.line([0, 0], [0, c.dimY]));
            }
          }
        } else {
          // Draw normal axes
          graphie.style({
            stroke: isMobile ? KhanColors.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2
          }, () => graphie.line([isMobile ? -padX * 3 : 0, 0], [c.dimX + (isMobile ? padX : 0), 0]));
          if (!((isBar || isLine) && isMobile)) {
            graphie.style({
              stroke: isMobile ? KhanColors.GRAY_G : "#000",
              strokeWidth: isMobile ? 1 : 2
            }, () => graphie.line([0, 0], [0, c.dimY]));
          }
        }
      });
      graphie.label([c.dimX / 2, isMobile ? -padBottom : -35 / c.scale[1]], self.props.labels[0], isMobile ? "above" : "below", false).css("font-weight", "bold").css("color", isMobile && KhanColors.GRAY_F);
      graphie.label([(isMobile ? -35 : -60) / c.scale[0], c.dimY / 2], self.props.labels[1], "center", false).css("font-weight", "bold").css("color", isMobile && KhanColors.GRAY_F).addClass("rotate");
      if (this.props.apiOptions.isMobile) {
        this.horizHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.horizHairline.hide();
        this.hairlineRange = [[0, c.dimX], [0, c.dimY]];
      }
    });
    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        this.horizHairline.moveTo([this.hairlineRange[0][0], point[1]], [this.hairlineRange[0][1], point[1]]);
        this.horizHairline.show();
      }
    });
    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        this.horizHairline.hide();
      }
    });
    _defineProperty(this, "labelCategory", (x, category) => {
      const isMobile = this.props.apiOptions.isMobile;
      const graphie = this.graphie;
      category = category + "";
      let isTeX = false;
      const mathyCategory = category.match(/^\$(.*)\$$/);
      if (mathyCategory) {
        category = mathyCategory[1];
        isTeX = true;
      }
      const translateX = 5;
      const rotationDeg = 45;
      const rotationRad = rotationDeg * (Math.PI / 180);
      const labelRotation = "translateX(-50%) translateX(".concat(translateX, "px) ") + "translateY(-50%) rotate(-".concat(rotationDeg, "deg)");
      const shouldRotate = isMobile && !mathyCategory;

      // We return a promise that will resolve to measured category height.
      return new Promise(resolve => {
        graphie.style({
          color: isMobile ? KhanColors.GRAY_G : "inherit",
          transform: shouldRotate ? labelRotation : "none",
          transformOrigin: "100%"
        }, () => {
          const $span = graphie.label([x, isMobile ? -0.5 : 0], category, "below", isTeX);
          const height =
          // Additional padding is applied by style.
          14 + (shouldRotate ? Math.round($span.height() * Math.cos(rotationRad) + ($span.width() + translateX) * Math.sin(rotationRad)) : $span.height());
          resolve({
            category,
            height
          });
        });
      });
    });
    _defineProperty(this, "setupCategories", config => {
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const isMobile = this.props.apiOptions.isMobile;

      // The deferred measurements returned from `labelCategory`.
      const categoryHeightPromises = [];
      if (self.props.type === HISTOGRAM) {
        // Histograms with n labels/categories have n - 1 buckets
        ___default["default"].times(self.props.categories.length - 1, function (i) {
          self.setupBar({
            index: i,
            startHeight: self.state.values[i],
            config: config,
            isHistogram: true
          });
        });

        // Label categories
        ___default["default"].each(self.props.categories, function (category, i) {
          const x = 0.5 + i * c.barWidth;

          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Promise<any>' is not assignable to parameter of type 'never'.
          categoryHeightPromises.push(self.labelCategory(x, category));
          const tickHeight = 6 / c.scale[1];
          graphie.style({
            stroke: "#000",
            strokeWidth: isMobile ? 1 : 2,
            opacity: 1.0
          }, function () {
            graphie.line([x, -tickHeight], [x, 0]);
          });
        });
      } else {
        ___default["default"].each(self.props.categories, function (category, i) {
          const startHeight = self.state.values[i];
          let x;
          if (self.props.type === BAR) {
            x = self.setupBar({
              index: i,
              startHeight: startHeight,
              config: config,
              isHistogram: false
            });
          } else if (self.props.type === LINE) {
            x = self.setupLine(i, startHeight, config);
          } else if (self.props.type === PIC) {
            x = self.setupPic(i, config);
          } else if (self.props.type === DOTPLOT) {
            x = self.setupDotplot(i, config);
          }
          let tickStart = 0;
          let tickEnd = -6 / c.scale[1];
          if (self.props.type === DOTPLOT && !isMobile) {
            tickStart = -tickEnd;
          }
          if (self.props.type === DOTPLOT) {
            // Dotplot lets you specify to only show labels every 'n'
            // ticks. It also looks nicer if it makes the labelled
            // ticks a bit bigger.
            if (i % self.props.labelInterval === 0 || i === self.props.categories.length - 1) {
              categoryHeightPromises.push(
              // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Promise<any>' is not assignable to parameter of type 'never'.
              self.labelCategory(x, category));
              tickStart *= 1.5;
              tickEnd *= 1.5;
            }
          } else {
            categoryHeightPromises.push(
            // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Promise<any>' is not assignable to parameter of type 'never'.
            self.labelCategory(x, category));
          }
          graphie.style({
            stroke: isMobile ? KhanColors.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2,
            opacity: 1.0
          }, function () {
            graphie.line([x, tickStart], [x, tickEnd]);
          });
        });
      }
      Promise.all(categoryHeightPromises).then(measurements => {
        if (self._isMounted) {
          const categoryHeights = {};
          measurements.forEach(_ref => {
            let {
              category,
              height
            } = _ref;
            return categoryHeights[category] = height;
          });
          self.setState({
            categoryHeights
          });
        }
      });
    });
    _defineProperty(this, "_clampValue", (v, min, max) => {
      return Math.max(Math.min(v, max), min);
    });
    _defineProperty(this, "_maybeShowDragPrompt", () => {
      // The drag prompt is only added on certain types of plots.
      if (this.graphie.dragPrompt != null) {
        this.graphie.dragPrompt[0].style.display = "inline";
      }
    });
    _defineProperty(this, "_maybeHideDragPrompt", () => {
      // The drag prompt is only added on certain types of plots.
      if (this.graphie.dragPrompt != null) {
        this.graphie.dragPrompt[0].style.display = "none";
      }
    });
    _defineProperty(this, "setupBar", args => {
      const isMobile = this.props.apiOptions.isMobile;
      const i = args.index;
      const startHeight = args.startHeight;
      const config = args.config;
      const isHistogram = args.isHistogram;
      const self = this;
      const graphie = self.graphie;
      const barHalfWidth = config.barWidth / 2;
      let x;
      if (isHistogram) {
        x = 0.5 + i * config.barWidth + barHalfWidth;
      } else {
        x = (isMobile ? barHalfWidth : 0.5 + config.barPad) + i;
      }

      /**
       * Updates the bar with given index to the given height
       * @param i the index of the bar to update
       * @param height the new height of the bar
       */
      const scaleBar = function (i, height) {
        const center = graphie.scalePoint(0);

        // Scale filled bucket (bar)
        config.graph.bars[i].scale(1, Math.max(isMobile ? 0.2 : 0.01, height / config.scaleY), center[0], center[1]);
        if (isHistogram) {
          // Scale dividers between buckets
          const leftDivider = config.graph.dividers[i - 1],
            rightDivider = config.graph.dividers[i];
          if (leftDivider) {
            const divHeight = Math.min(self.state.values[i - 1], height);
            leftDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
          }
          if (rightDivider) {
            const divHeight = Math.min(self.state.values[i + 1], height);
            rightDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
          }
        }
      };
      graphie.style({
        stroke: "none",
        fill: isMobile ? KhanColors.BLUE_C : KhanColors.LIGHT_BLUE,
        opacity: 1.0
      }, function () {
        config.graph.bars[i] = graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY], [x + barHalfWidth, config.scaleY], [x + barHalfWidth, 0], [x - barHalfWidth, 0]]);
      });
      if (isHistogram) {
        if (i > 0) {
          // Don't draw a divider to the left of the first bucket
          graphie.style({
            stroke: "#000",
            strokeWidth: 1,
            opacity: 0.3
          }, function () {
            config.graph.dividers.push(graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY]]));
          });
        }
      }
      if (isMobile) {
        const snap = config.scaleY / self.props.snapsPerLine;
        config.graph.lines[i] = Interactive2.addMaybeMobileMovablePoint(this, {
          coord: [x, startHeight],
          constraints: [(coord, prev, options) => {
            return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
          }],
          onMoveStart: function () {
            config.graph.bars[i].attr({
              fill: KhanColors.INTERACTIVE
            });
          },
          onMove: function () {
            const y = config.graph.lines[i].coord()[1];
            const values = ___default["default"].clone(self.state.values);
            values[i] = y;
            self.setState({
              values: values
            });
            self.changeAndTrack({
              values: values
            });
            self._maybeHideDragPrompt();
            scaleBar(i, y);
          },
          onMoveEnd: function () {
            config.graph.bars[i].attr({
              fill: KhanColors.BLUE_C
            });
          }
        });

        // We set the z-index to 1 here so that the hairlines cover up the
        // points
        config.graph.lines[i].state.visibleShape.wrapper.style.zIndex = "1";
        self._maybeShowDragPrompt();
      } else {
        config.graph.lines[i] = graphie.addMovableLineSegment({
          coordA: [x - barHalfWidth, startHeight],
          coordZ: [x + barHalfWidth, startHeight],
          snapY: config.scaleY / self.props.snapsPerLine,
          constraints: {
            constrainX: true
          },
          normalStyle: {
            stroke: KhanColors.INTERACTIVE,
            // Don't display graph handles in static mode
            "stroke-width": this.props.static ? 0 : 4
          }
        });
        config.graph.lines[i].onMove = function (dx, dy) {
          let y = this.coordA[1];
          if (y < 0 || y > config.dimY) {
            y = Math.min(Math.max(y, 0), config.dimY);
            this.coordA[1] = this.coordZ[1] = y;

            // Snap the line back into range.
            this.transform();
          }
          const values = ___default["default"].clone(self.state.values);
          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });
          scaleBar(i, y);
        };
      }
      scaleBar(i, startHeight);
      return x;
    });
    _defineProperty(this, "setupLine", (i, startHeight, config) => {
      const isMobile = this.props.apiOptions.isMobile;
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const x = i + (isMobile ? 0.4 : 1);
      if (isMobile) {
        const snap = config.scaleY / self.props.snapsPerLine;
        c.graph.points[i] = Interactive2.addMaybeMobileMovablePoint(this, {
          coord: [x, startHeight],
          constraints: [(coord, prev, options) => {
            return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
          }],
          onMove: function () {
            const y = c.graph.points[i].coord()[1];
            const values = ___default["default"].clone(self.state.values);
            values[i] = y;
            self.setState({
              values: values
            });
            self.changeAndTrack({
              values: values
            });
            self._maybeHideDragPrompt();
          }
        });
        self._maybeShowDragPrompt();
        if (i > 0) {
          c.graph.lines[i] = Interactive2.addMovableLine(graphie, {
            points: [c.graph.points[i - 1], c.graph.points[i]],
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'constraints' does not exist on type '(graphie: any, movable: any, options: any) => void'.
            constraints: Interactive2.MovablePoint.constraints.fixed(),
            normalStyle: {
              stroke: KhanColors.BLUE_C,
              "stroke-width": 2
            },
            highlightStyle: {
              stroke: KhanColors.BLUE_C,
              "stroke-width": 2
            }
          });
        }
      } else {
        c.graph.points[i] = graphie.addMovablePoint({
          coord: [x, startHeight],
          constraints: {
            constrainX: true
          },
          normalStyle: {
            fill: KhanColors.INTERACTIVE,
            stroke: KhanColors.INTERACTIVE
          },
          snapY: c.scaleY / self.props.snapsPerLine
        });
        c.graph.points[i].onMove = function (x, y) {
          y = Math.min(Math.max(y, 0), c.dimY);
          const values = ___default["default"].clone(self.state.values);
          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });
          return [x, y];
        };
        if (i > 0) {
          c.graph.lines[i] = graphie.addMovableLineSegment({
            pointA: c.graph.points[i - 1],
            pointZ: c.graph.points[i],
            constraints: {
              fixed: true
            },
            normalStyle: {
              stroke: "#9ab8ed",
              "stroke-width": 2
            }
          });
        }
      }
      return x;
    });
    _defineProperty(this, "setupDotplot", (i, config) => {
      const graphie = this.graphie;
      const isMobile = this.props.apiOptions.isMobile;
      return this.setupTiledPlot(i, isMobile ? 0.5 : 1, config, (x, y) => {
        return graphie.ellipse([x, y], [this.DOT_PLOT_POINT_SIZE() / graphie.scale[0], this.DOT_PLOT_POINT_SIZE() / graphie.scale[1]], {
          fill: KhanColors.INTERACTIVE,
          stroke: KhanColors.INTERACTIVE
        });
      });
    });
    _defineProperty(this, "setupPic", (i, config) => {
      const graphie = this.graphie;
      return this.setupTiledPlot(i, 0, config, (x, y) => {
        const scaledCenter = graphie.scalePoint([x, y]);
        const size = this.props.picSize;
        return graphie.raphael.image(this.props.picUrl, scaledCenter[0] - size / 2, scaledCenter[1] - size / 2, size, size);
      });
    });
    _defineProperty(this, "setupTiledPlot", (i, bottomMargin, config, createImage) => {
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const pics = graphie.pics;
      const dotTicks = graphie.dotTicks;
      const x = i + 0.5 + c.picPad;

      // In order to make sure that manipulating the graph doesn't cause
      // dragging, we disable touch actions for the whole mouselayer.
      // TODO(emily): Figure out a way to turn of touch actions for only the
      // part of the widget that can be manipulated. Putting this style
      // directly on the rects below doesn't work.
      graphie.mouselayer.canvas.style.touchAction = "none";
      pics[i] = [];
      dotTicks[i] = [];
      const n = Math.round(c.dimY / c.scaleY) + 1;
      ___default["default"](n).times(function (j) {
        j -= 1;
        const midY = (j + 0.5) * c.scaleY;
        const leftX = x - c.picBoxWidth / 2;
        const topY = midY + 0.5 * c.scaleY;
        const coord = graphie.scalePoint([leftX, topY + bottomMargin]);
        const mouseRect = graphie.mouselayer.rect(coord[0], coord[1], c.picBoxWidthPx, c.picBoxHeight);
        $__default["default"](mouseRect[0]).css({
          fill: "#000",
          opacity: 0.0,
          cursor: "pointer"
        }).on("vmousedown", function (e) {
          e.preventDefault();
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'whichPicClicked' does not exist on type 'Plotter'.
          self.whichPicClicked = i;
          self.setPicHeight(i, topY);
          $__default["default"](document).on("vmouseup.plotTile", function (e) {
            $__default["default"](document).unbind(".plotTile");
          });
          $__default["default"](document).on("vmousemove.plotTile", function (e) {
            e.preventDefault();

            // Reverse-engineer the initial calculation
            const yCoord = graphie.getMouseCoord(e)[1];
            const adjustedCoord = Math.floor(yCoord - bottomMargin);

            // Calculate top coord from j value, but don't let them
            // go below j = -1, which is equivalent to having '0'
            // on the dot plot (due to weird indexing).
            const newJ = Math.max(-1, Math.floor(adjustedCoord / c.scaleY));
            const newMidY = (newJ + 0.5) * c.scaleY;
            // Constrain the max Y value to max displayable Y of the
            // plot.  Otherwise users can unintentionally select an
            // out-of-range value and not see that they have done so.
            const newTopY = Math.min(newMidY + 0.5 * c.scaleY, c.dimY);
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'whichPicClicked' does not exist on type 'Plotter'.
            self.setPicHeight(self.whichPicClicked, newTopY);
          });
        });
        if (j < 0) {
          // Don't show a pic underneath the axis!
          return;
        }
        pics[i][j] = createImage(x, midY + bottomMargin);
        dotTicks[i][j] = graphie.ellipse([x, midY + bottomMargin], [self.DOT_TICK_POINT_SIZE() / graphie.scale[0], self.DOT_TICK_POINT_SIZE() / graphie.scale[1]], {
          fill: "#dee1e3",
          stroke: "#dee1e3"
        });
      });
      return x;
    });
    _defineProperty(this, "setPicHeight", (i, y) => {
      const values = ___default["default"].clone(this.state.values);
      values[i] = y;
      this.drawPicHeights(values, this.state.values);
      this.setState({
        values: values
      });
      this.changeAndTrack({
        values: values
      });
    });
    _defineProperty(this, "changeAndTrack", data => {
      this.props.onChange(data);
      this.props.trackInteraction();
    });
    _defineProperty(this, "drawPicHeights", (values, prevValues) => {
      const self = this;
      const graphie = self.graphie;
      const pics = graphie.pics;
      const isMobile = this.props.apiOptions.isMobile;
      if (isMobile) {
        const shouldDisplay = values.every(v => v === 0);
        graphie.dotPrompt[0].style.display = shouldDisplay ? "inline" : "none";
      }
      ___default["default"].each(pics, function (ps, i) {
        ___default["default"].each(ps, function (pic, j) {
          const y = (j + 1) * self.props.scaleY;
          const show = y <= values[i];
          if (self.props.type === DOTPLOT) {
            const wasShown = y <= prevValues[i];
            const wasJustShown = show && !wasShown;
            if (wasJustShown) {
              pic.animate({
                "stroke-width": 8
              }, 75, () => pic.animate({
                "stroke-width": 2
              }, 75));
            }
          }
          $__default["default"](pic[0]).css({
            display: show ? "inline" : "none"
          });
          graphie.dotTicks[i][j][0].style.display = show || !isMobile ? "none" : "inline";
        });
      });
    });
    _defineProperty(this, "getUserInput", () => {
      return this.state.values;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Plotter'.
      return Plotter.validate(this.getUserInput(), rubric);
    });
  }
  render() {
    // TODO(kevinb) actually compute the size of the graphie correctly and
    // make it that size so we don't have to add extra padding.  The value
    // was determined by eye-balling the layout.  :(
    const paddingForBottomLabel = 75;
    const style = {
      marginBottom: this.props.labels[0] ? paddingForBottomLabel : 0
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-plotter graphie " + ClassNames.INTERACTIVE
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "graphieDiv",
      style: style
    });
  }
  componentDidUpdate(prevProps, prevState) {
    this.shouldSetupGraphie = this.shouldSetupGraphie || !___default["default"].isEqual(this.state.categoryHeights, prevState.categoryHeights);
    if (this.shouldSetupGraphie) {
      this.setupGraphie(prevState);
    }
  }
  componentDidMount() {
    this._isMounted = true;
    this.setupGraphie(this.state);
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    const props = ["type", "labels", "categories", "scaleY", "maxY", "snapsPerLine", "picUrl", "labelInterval", "static"];
    this.shouldSetupGraphie = ___default["default"].any(props, function (prop) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      return !___default["default"].isEqual(this.props[prop], nextProps[prop]);
    }, this);
    if (!___default["default"].isEqual(this.props.starting, nextProps.starting) && !___default["default"].isEqual(this.state.values, nextProps.starting)) {
      this.shouldSetupGraphie = true;
      this.setState({
        values: nextProps.starting
      });
    }
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
}
_defineProperty(Plotter, "propTypes", {
  onChange: PropTypes__default["default"].func.isRequired,
  trackInteraction: PropTypes__default["default"].func.isRequired
  // TODO(alex): Figure out why lint chokes on this line
  // ...widgetPropTypes,
});
_defineProperty(Plotter, "defaultProps", {
  type: BAR,
  labels: ["", ""],
  categories: [""],
  scaleY: 1,
  maxY: 10,
  snapsPerLine: 2,
  picSize: 40,
  picBoxHeight: 48,
  picUrl: "",
  plotDimensions: [380, 300],
  labelInterval: 1
});
___default["default"].extend(Plotter, {
  validate: function (guess, rubric) {
    if (deepEq$1(guess, rubric.starting)) {
      return {
        type: "invalid",
        message: null
      };
    }
    return {
      type: "points",
      earned: deepEq$1(guess, rubric.correct) ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

// We don't need to change any of the original props for static mode
const staticTransform = ___default["default"].identity;
var Plotter$1 = {
  name: "plotter",
  displayName: "Plotter",
  widget: Plotter,
  staticTransform: staticTransform
};

class Separator extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "arrowLength", 100);
    _defineProperty(this, "drawArrow", () => {
      // eslint-disable-next-line react/no-string-refs
      const canvas = this.refs["arrowCanvas" + this.props.index];
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getContext' does not exist on type 'ReactInstance'.
      const ctx = canvas.getContext("2d");
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const path = new Path2D();
      ctx.strokeStyle = "rgb(0,0,0)";
      ctx.lineWidth = 1.2;
      ctx.lineCap = "round";
      const offset = 5;
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.moveTo(offset, canvas.height / 2);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.lineTo(canvas.width - offset, canvas.height / 2);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.moveTo(canvas.width - 2 * offset, canvas.height / 2 - offset);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.lineTo(canvas.width - offset, canvas.height / 2);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.moveTo(canvas.width - 2 * offset, canvas.height / 2 + offset);
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'width' does not exist on type 'ReactInstance'. | TS2339 - Property 'height' does not exist on type 'ReactInstance'.
      path.lineTo(canvas.width - offset, canvas.height / 2);
      ctx.stroke(path);
    });
  }
  componentDidMount() {
    this.drawArrow();
  }
  componentDidUpdate() {
    this.drawArrow();
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "arrow-container"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "above-text"
    }, this.props.data.topText), /*#__PURE__*/React__namespace.createElement("canvas", {
      height: "30",
      id: "arrowCanvas" + this.props.index,
      ref: "arrowCanvas" + this.props.index,
      width: this.arrowLength
    }, i18n__namespace._("Reaction arrow pointing to the right.")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "below-text"
    }, this.props.data.bottomText));
  }
}
_defineProperty(Separator, "propTypes", {
  // TODO(colin): figure out and add shape.
  data: PropTypes__default["default"].any,
  index: PropTypes__default["default"].number
});
class ReactionDiagramWidget extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "simpleValidate", () => {
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });
    _defineProperty(this, "getUserInput", () => {
      return [];
    });
    _defineProperty(this, "validate", (state, rubric) => {
      // TODO(colin): this appears to be part of the perseus interface.
      // Figure out if there's a more appropriate value to return.
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });
    _defineProperty(this, "focus", () => {
      return true;
    });
  }
  render() {
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/no-string-refs
      React__namespace.createElement("div", {
        className: "reaction",
        ref: "reaction"
      }, this.props.smiles.map((s, i) => {
        const id = this.props.widgetId + "-" + i;
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: id,
          className: "molecule-container"
        }, /*#__PURE__*/React__namespace.createElement(Molecule, {
          id: id,
          rotationAngle: this.props.rotationAngle[i],
          smiles: s
        }), i === this.props.smiles.length - 1 ? null : /*#__PURE__*/React__namespace.createElement(Separator, {
          data: this.props.separators[i],
          index: i
        }));
      }))
    );
  }
}
_defineProperty(ReactionDiagramWidget, "propTypes", {
  // TODO(colin): at the moment, these must be arrays of two elements;
  // we're limited to a single reaction step.  At some point, add support
  // for more steps in the reaction.
  rotationAngle: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  // eslint-disable-next-line react/forbid-prop-types
  separators: PropTypes__default["default"].arrayOf(PropTypes__default["default"].object),
  smiles: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  widgetId: PropTypes__default["default"].string
});
_defineProperty(ReactionDiagramWidget, "defaultProps", {
  smiles: [],
  rotationAngle: [],
  separators: []
});
var ReactionDiagram = {
  name: "reaction-diagram",
  displayName: "Chemical reaction",
  hidden: true,
  widget: ReactionDiagramWidget
};

class Sequence extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "state", {
      visible: 1
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return change.apply(_this, args);
    });
    _defineProperty(this, "_handleInteraction", groupWidgetId => {
      const step = parseInt(groupWidgetId.split(" ")[1]);
      if (step === this.state.visible - 1) {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getWidgetInstance' does not exist on type 'ReactInstance'.
        const widget = this.refs.renderer.getWidgetInstance("group " + step);
        widget.showRationalesForCurrentlySelectedChoices();
        const score = widget.simpleValidate();
        if (score.type === "points" && score.total === score.earned) {
          this.setState({
            visible: this.state.visible + 1
          });
          this.props.trackInteraction({
            visible: this.state.visible + 1
          });
        }
      }
    });
  }
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }
  render() {
    const icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends({}, iconOk, {
      style: {
        color: "green"
      }
    }));
    const content = ___default["default"].chain(this.props.json).first(this.state.visible).map((step, i) => "[[".concat(Util.snowman, " group ").concat(i, "]]")).join("\n\n").value();
    const widgets = {};
    ___default["default"].each(this.props.json, (step, i) => {
      const widgetId = "group ".concat(i);
      widgets[widgetId] = {
        type: "group",
        graded: true,
        version: {
          major: 0,
          minor: 0
        },
        options: ___default["default"].extend({}, step, {
          icon: i < this.state.visible - 1 ? icon : null
        })
      };
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sequence"
    }, /*#__PURE__*/React__namespace.createElement(Renderer
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "renderer",
      content: content,
      widgets: widgets,
      onInteractWithWidget: this._handleInteraction,
      apiOptions: this.props.apiOptions,
      linterContext: this.props.linterContext
    }));
  }
}
_defineProperty(Sequence, "propTypes", {
  ...propTypes,
  apiOptions: ApiOptions.propTypes,
  json: PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
    content: PropTypes__default["default"].string,
    images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
    widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
  })),
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(Sequence, "defaultProps", {
  json: [{
    content: "",
    widgets: {},
    images: {}
  }],
  linterContext: PerseusLinter.linterContextDefault
});
const traverseChildWidgets = function (props, traverseRenderer) {
  let oldJson = props.json;
  if (!___default["default"].isArray(oldJson)) {
    oldJson = [oldJson];
  }
  const json = ___default["default"].map(oldJson, rendererOptions => {
    return traverseRenderer(rendererOptions);
  });
  return ___default["default"].extend({}, props, {
    json: json
  });
};
var Sequence$1 = {
  name: "sequence",
  displayName: "Graded Sequence",
  widget: Sequence,
  traverseChildWidgets: traverseChildWidgets,
  tracking: "all",
  hidden: true,
  isLintable: true
};

const colors = {
  grayLight: "#aaa",
  basicBorderColor: "#ccc",
  white: "#fff"
};
const triangleBeforeAfter = {
  borderBottom: "9px solid transparent",
  borderTop: "9px solid transparent",
  content: '" "',
  height: "0",
  position: "absolute",
  top: "0",
  width: "0"
};
const styles$7 = aphrodite.StyleSheet.create({
  infoTip: {
    display: "inline-block",
    marginLeft: "5px",
    position: "relative"
  },
  infoTipContainer: {
    position: "absolute",
    top: "-12px",
    left: "22px",
    zIndex: 1000
  },
  infoTipTriangle: {
    height: "10px",
    left: "0",
    position: "absolute",
    top: "8px",
    width: "0",
    zIndex: 1,
    ":before": {
      ...triangleBeforeAfter,
      borderRight: "9px solid #bbb",
      right: "0"
    },
    ":after": {
      ...triangleBeforeAfter,
      borderRight: "9px solid ".concat(colors.white),
      right: "-1px"
    }
  },
  verticalShadow: {
    border: "1px solid ".concat(colors.basicBorderColor),
    boxShadow: "0 1px 3px ".concat(colors.basicBorderColor),
    borderBottom: "1px solid ".concat(colors.grayLight)
  },
  infoTipContentContainer: {
    background: colors.white,
    padding: "5px 10px",
    width: "240px"
  }
});
const questionMark = "data:image/png;base64," + "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBB" + "ZG9iZSBJbWFnZVJlYWR5ccllPAAAA3NpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/" + "eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+" + "IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2Jl" + "IFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAg" + "ICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5" + "LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9" + "IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHht" + "bG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3Vy" + "Y2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHht" + "cE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2N2M3NTAxYS04YmVlLTQ0M2Mt" + "YmRiNS04OGM2N2IxN2NhYzEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUJCRTk4" + "Qjc4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5p" + "aWQ6OUJCRTk4QjY4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcDpDcmVhdG9yVG9v" + "bD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRG" + "cm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NGE5ZDI0OTMtODk1NC00OGFkLTlh" + "MTgtZDAwM2MwYWNjNDJlIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3Yzc1MDFh" + "LThiZWUtNDQzYy1iZGI1LTg4YzY3YjE3Y2FjMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4g" + "PC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pqm89uYAAADM" + "SURBVHjaXJA9DoJAEIUH1M4TUHIFsCMGen9OwCGw1YRGW2ntKel0exsojHIBC0ouQAyU" + "viFDstmXfNmZeS+zm7XSNCXRFiRgJf0bXIHixpbhGdxBBJYC1w/xaA424MhNEATkui71" + "fU9KqfEU78UbD9PdbJRlOdae55GmhIP+1NV1TcMwkOM41DSNHvRtMhTHMRVFQW3b6mOL" + "gx99kue5GRp/gIOZuZGvNpTNwjD8oliANU+qqqKu6/TQBdymN57AHjzBT+B6Jx79BRgA" + "vc49kQA4yxgAAAAASUVORK5CYII=";
class InfoTip$1 extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      hover: false
    });
    _defineProperty(this, "handleMouseEnter", () => {
      this.setState({
        hover: true
      });
    });
    _defineProperty(this, "handleMouseLeave", () => {
      this.setState({
        hover: false
      });
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTip)
    }, /*#__PURE__*/React__namespace.createElement("img", {
      alt: "",
      width: 10,
      height: 10,
      src: questionMark,
      onMouseEnter: this.handleMouseEnter,
      onMouseLeave: this.handleMouseLeave
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTipContainer),
      style: {
        display: this.state.hover ? "block" : "none"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTipTriangle)
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.verticalShadow, styles$7.infoTipContentContainer)
    }, this.props.children)));
  }
}

class InfoTip extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      didMount: false
    });
  }
  componentDidMount() {
    /* eslint-disable react/no-did-mount-set-state */
    this.setState({
      didMount: true
    });
    /* eslint-enable react/no-did-mount-set-state */
  }

  render() {
    if (this.state.didMount) {
      return /*#__PURE__*/React__namespace.createElement(InfoTip$1, this.props);
    }
    return /*#__PURE__*/React__namespace.createElement("div", null);
  }
}

const {
  assert: assert$2
} = InteractiveUtil;
// @ts-expect-error [FEI-5003] - TS2339 - Property 'Path' does not exist on type 'typeof Graphie'. | TS2339 - Property 'Arc' does not exist on type 'typeof Graphie'. | TS2339 - Property 'Circle' does not exist on type 'typeof Graphie'. | TS2339 - Property 'Label' does not exist on type 'typeof Graphie'. | TS2339 - Property 'Line' does not exist on type 'typeof Graphie'. | TS2339 - Property 'MovablePoint' does not exist on type 'typeof Graphie'. | TS2339 - Property 'MovableLine' does not exist on type 'typeof Graphie'.
const {
  Path,
  Arc,
  Circle,
  Label,
  Line,
  MovablePoint,
  MovableLine
} = Graphie;
const defaultBoxSize$1 = 400;
const maxSampleSize = 1000;
class Histogram extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_renderThresholdLine", () => {
      // Recall the the y-range goes from [-1, yMax] to allow for ticks on
      // the x-axis.
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      const yRange = [0, this._range()[1][1]];
      const coords = ___default["default"].map(yRange, y => [this.state.threshold, y]);

      // Returns an inivisble, placeholder coord that anchors the line
      const invisiblePointForCoord = (coord, i) => {
        return /*#__PURE__*/React__namespace.createElement(MovablePoint, {
          key: i,
          static: true,
          coord: coord,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        });
      };
      return /*#__PURE__*/React__namespace.createElement(MovableLine, {
        onMove: this.handleMouseInteraction
      }, ___default["default"].map(coords, invisiblePointForCoord));
    });
    _defineProperty(this, "_renderCircle", () => {
      const data = this.props.data;

      // Get proportion of results below threshold
      const total = ___default["default"].reduce(data, (sum, next) => {
        return sum + next;
      }, 0);
      const numBelow = ___default["default"].reduce(data, (sum, next, i) => {
        if (this.state.threshold != null && i <= this.state.threshold) {
          return sum + next;
        }
        return sum;
      }, 0);
      const proportionBelow = numBelow / total;

      // This is a hack around the arc taking angles modulo 360.
      // TODO(charlie): Find a better way around this.
      const epsilon = 1e-5;
      const radius = 20;
      const center = [this.props.box[0] - 1.5 * radius, 1.5 * radius];

      // Plot little circle
      const plotBelowCircle = () => {
        const options = {
          key: "below",
          center: center,
          radius: radius,
          startAngle: 0,
          endAngle: proportionBelow < 1 ? 360 * proportionBelow : 360 - epsilon,
          sector: proportionBelow !== 1,
          unscaled: true,
          style: {
            fill: KhanColors.LIGHT_RED,
            stroke: KhanColors.RED
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Arc, options);
      };
      const plotAboveCircle = () => {
        const options = {
          key: "above",
          center: center,
          radius: radius,
          startAngle: proportionBelow > 0 ? 360 * proportionBelow : epsilon,
          endAngle: 360,
          sector: proportionBelow !== 0,
          unscaled: true,
          style: {
            fill: KhanColors.LIGHT_BLUE,
            stroke: KhanColors.BLUE
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Arc, options);
      };

      // Plot the label below the circle
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      const xRange = this._range()[0];
      const formattedThreshold = Math.min(Math.max(this.state.threshold, xRange[0]), xRange[1]).toFixed(2);
      const plotLabel = () => {
        const options = {
          key: "label",
          coord: [center[0], center[1] + 1.5 * radius],
          text: numBelow + " of " + total + " results below " + formattedThreshold + "%",
          direction: "center",
          tex: false,
          unscaled: true,
          style: {
            fontSize: "12px"
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Label, options);
      };
      return [proportionBelow > 0 && plotBelowCircle(), proportionBelow < 1 && plotAboveCircle(), plotLabel()];
    });
    _defineProperty(this, "_renderData", () => {
      const data = this.props.data;
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      this._range();

      // Plot bars
      const barWidth = 1;
      const pathForData = (count, i) => {
        // Avoid plotting bars of height 0, else you get a thick blue line
        // over the x-axis. We don't filter these out of the data passed in
        // to this function, however, to preserve absolute indices.
        if (!count) {
          return;
        }
        const isBelow = this.state.threshold != null && i <= this.state.threshold;
        const style = {
          fill: isBelow ? KhanColors.LIGHT_RED : KhanColors.LIGHT_BLUE,
          stroke: isBelow ? KhanColors.RED : KhanColors.BLUE
        };
        const coords = [[i, 0], [i, count], [i + barWidth, count], [i + barWidth, 0]];
        return /*#__PURE__*/React__namespace.createElement(Path, {
          key: i,
          coords: coords,
          style: style
        });
      };
      return ___default["default"].map(data, pathForData);
    });
    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      const data = options.data;
      const range = options.range;
      const scale = options.scale;

      /* Plot the bars that run parallel to the x-axis. */
      const xWidth = range[0][1] - range[0][0];
      const yWidth = range[1][1] - 0;
      const maxYAxisEntities = 20;
      const ySkip = Math.ceil(yWidth / maxYAxisEntities);
      ___default["default"].each(___default["default"].range(0, range[1][1], ySkip), y => {
        // If there's no data, we don't label the axes
        if (data) {
          graphie.label([range[0][0], y], KhanMath.roundToApprox(y, 2), "left", /* isTeX */true /* for the \approx symbol */);
        }

        graphie.line([range[0][0], y], [range[0][1], y], {
          stroke: "#000",
          strokeWidth: 1,
          opacity: 0.3
        });
      });

      // If there's no data, we don't label the x-axis at all
      if (data) {
        // Plot the labels below the bars
        const maxXAxisEntities = 15;
        const xSkip = Math.ceil(xWidth / maxXAxisEntities);
        ___default["default"].each(___default["default"].range(range[0][0], range[0][1], xSkip), x => {
          graphie.label([x, 0], kmath.number.round(x, 2), "below", true);
          const tickHeight = 8;
          graphie.line([x, 0], [x, -tickHeight / scale[1]], {
            stroke: "#000",
            strokeWidth: 1
          });
        });
      }

      // Add y axis (x axis is added later to overlap the bars)
      const axisStyle = {
        stroke: "#000",
        strokeWidth: 2,
        opacity: 1.0
      };
      const origin = [range[0][0], 0];
      const topLeft = [range[0][0], range[1][1]];
      graphie.line(origin, topLeft, axisStyle);

      // Add axis labels
      const xMid = range[0][0] + xWidth / 2;
      const xOffset = data ? 25 : 0;
      graphie.label([xMid, -xOffset / scale[1]], options.xAxisLabel, "below", false).css("font-weight", "bold");
      const yMid = 0 + yWidth / 2;
      const yOffset = data ? 55 : 28;
      graphie.label([range[0][0] - yOffset / scale[0], yMid], options.yAxisLabel, "center", false).css("font-weight", "bold").css("-webkit-transform", "rotate(-90deg)");
    });
    _defineProperty(this, "handleMouseInteraction", point => {
      this.setState({
        threshold: point[0]
      });
    });
    _defineProperty(this, "_range", props => {
      const defaultRange = [[0, 100], [-1, 10]];
      props = props || this.props;
      return props.data ? this._getRangeForData(props.data) : defaultRange;
    });
    _defineProperty(this, "_getRangeForData", data => {
      // Find first/last non-zero entry and add some padding
      const padding = 10;
      const firstIndex = ___default["default"].indexOf(data, ___default["default"].find(data, n => n > 0));
      const xMin = Math.max(0, firstIndex - padding);
      const lastIndex = ___default["default"].lastIndexOf(data, ___default["default"].last(___default["default"].filter(data, n => n > 0)));
      const xMax = Math.min(100 + 1, lastIndex + 1 + padding);

      // The y-axis is bounded above by largest value, and below by 0.
      // However, the 'range' of the y-axis goes as low as -1 to allow
      // Graphie to draw ticks on the x-Axis that extend vertically below
      // y = 0.
      const yMin = -1;
      const yMax = ___default["default"].max(data);
      return [[xMin, xMax], [yMin, yMax]];
    });
    _defineProperty(this, "_getInitialThreshold", range => {
      // We pick a pretty-looking threshold, 1/3 of the way along the axis
      const xRange = range[0];
      return xRange[0] + (xRange[1] - xRange[0]) / 3;
    });
    _defineProperty(this, "state", {
      // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
      threshold: this._getInitialThreshold(this._range())
    });
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    // Reset the threshold if the range has changed
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
    const oldRange = this._range();
    const nextRange = this._range(nextProps);
    if (!Util.deepEq(oldRange, nextRange)) {
      this.setState({
        threshold: this._getInitialThreshold(nextRange)
      });
    }
  }

  /* Renders the vertical line that users can drag across the histogram. */

  render() {
    const data = this.props.data;
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
    const range = this._range();
    const options = {
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      box: this.props.box,
      range: range,
      data: data,
      scale: [Util.scaleFromExtent(range[0], this.props.box[0]), Util.scaleFromExtent(range[1], this.props.box[1])]
    };
    const axisStyle = {
      stroke: "#000",
      strokeWidth: 1,
      opacity: 1.0
    };
    const origin = [range[0][0], 0];
    const bottomRight = [range[0][1], 0];
    return /*#__PURE__*/React__namespace.createElement(Graphie, {
      box: options.box,
      range: options.range,
      options: options,
      setup: this._setupGraphie,
      onMouseMove: this.handleMouseInteraction,
      onMouseDown: this.handleMouseInteraction,
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }, /*#__PURE__*/React__namespace.createElement(Line, {
      start: origin,
      end: bottomRight,
      style: axisStyle
    }), data && this._renderData(), data && this._renderCircle(), data && this._renderThresholdLine());
  }
}
_defineProperty(Histogram, "propTypes", {
  data: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  xAxisLabel: PropTypes__default["default"].string,
  yAxisLabel: PropTypes__default["default"].string,
  box: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)
});
_defineProperty(Histogram, "defaultProps", {
  data: null,
  xAxisLabel: "Proportion (%)",
  yAxisLabel: "Number of times seen",
  box: [defaultBoxSize$1, defaultBoxSize$1]
});
class Simulator extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "generateNumber", void 0);
    _defineProperty(this, "state", {
      invalidInput: false
    });
    _defineProperty(this, "calculateDisplayProportion", () => {
      const userProportion = this.props.userProportion;

      // If we want to display as a percentage, multiply proportion by 100.0.
      if (this.props.proportionOrPercentage === "percentage") {
        return Math.round(100 * userProportion);
      }
      return userProportion;
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "checkProportionValidity", value => {
      return value >= 0.0 && this.props.proportionOrPercentage === "proportion" && value <= 1.0 || this.props.proportionOrPercentage === "percentage" && value <= 100.0;
    });
    _defineProperty(this, "handleUserProportionChange", (value, cb) => {
      let userProportion;

      // If "percentage" mode is enabled, user will have entered value as
      // a percentage. However, we always store as a proportion, so we cast.
      if (this.props.proportionOrPercentage === "percentage") {
        userProportion = value / 100.0;
      } else {
        userProportion = value;
      }

      // If they entered a number, we may need to cap it
      if (userProportion != null) {
        userProportion = Math.min(1.0, Math.max(0.0, userProportion));
      }
      this.props.onChange({
        userProportion: userProportion
      }, cb);
    });
    _defineProperty(this, "handleSampleSizeChange", (sampleSize, cb) => {
      if (sampleSize != null) {
        sampleSize = Math.min(maxSampleSize, Math.max(0, Math.floor(sampleSize)));
      }
      this.props.onChange({
        sampleSize: sampleSize
      }, cb);
    });
    _defineProperty(this, "handleRunSimulation", () => {
      // If they haven't filled out a parameter field, highlight it.
      if (this.props.numTrials == null || this.props.userProportion == null || this.props.sampleSize == null) {
        this.setState({
          invalidInput: true
        });
        return;
      }
      this.setState({
        invalidInput: false
      });
      this.props.onChange({
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
        data: this.generateData()
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "generateData", props => {
      props = props || this.props;
      const getSampleDistribution = (sampleSize, numTrials, proportion) => {
        const draw = () => {
          return this.generateNumber() < proportion;
        };
        const sampleDistribution = ___default["default"].times(100 + 1, () => 0);
        ___default["default"].times(numTrials, () => {
          const results = ___default["default"].times(sampleSize, draw);
          const count = ___default["default"].filter(results, ___default["default"].identity).length;
          const normalizedCount = Math.floor(100 * count / sampleSize);
          sampleDistribution[normalizedCount]++;
        });
        return sampleDistribution;
      };
      return getSampleDistribution(props.sampleSize, props.numTrials, props.userProportion);
    });
    _defineProperty(this, "getInputPaths", () => {
      return [["userProportion"], ["sampleSize"]];
    });
    _defineProperty(this, "focus", () => {
      const path = ___default["default"].head(this.getInputPaths());
      this.focusInputPath(path);
      return true;
    });
    _defineProperty(this, "focusInputPath", path => {
      assert$2(path.length > 0);
      const inputID = ___default["default"].head(path);
      // eslint-disable-next-line react/no-string-refs
      const inputComponent = this.refs[inputID];
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
      inputComponent.focus();
    });
    _defineProperty(this, "blurInputPath", path => {
      assert$2(path.length > 0);
      const inputID = ___default["default"].head(path);
      // eslint-disable-next-line react/no-string-refs
      const inputComponent = this.refs[inputID];
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
      inputComponent.blur();
    });
    _defineProperty(this, "getDOMNodeForPath", path => {
      assert$2(path.length > 0);
      const inputID = ___default["default"].head(path);
      // eslint-disable-next-line react/no-string-refs
      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });
    _defineProperty(this, "getGrammarTypeForPath", path => {
      assert$2(path.length > 0);
      return "number";
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      assert$2(path.length > 0);
      const inputID = ___default["default"].head(path);
      const capitalizedID = inputID.charAt(0).toUpperCase() + inputID.slice(1);
      const functionName = "handle" + capitalizedID + "Change";
      this[functionName](newValue, cb);
    });
    _defineProperty(this, "getUserInput", () => {
      return null;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Simulator'.
      return Simulator.validate(this.getUserInput(), rubric);
    });
  }
  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    if (this.props.randomSeed != null) {
      this.generateNumber = Util.seededRNG(this.props.randomSeed);
    }
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.randomSeed !== this.props.randomSeed) {
      this.generateNumber = Util.seededRNG(nextProps.randomSeed);
    }
  }
  render() {
    const inputStyle = {
      marginLeft: "5px"
    };
    const highlight = "0px 0px 0px 2px rgba(255, 165, 0, 1)";
    const highlightStyle = ___default["default"].extend({}, inputStyle, {
      boxShadow: highlight,
      transition: "all 0.15s"
    });
    const unhighlightStyle = ___default["default"].extend({}, inputStyle, {
      transition: "all 0.15s"
    });
    const style = this.state.invalidInput ? highlightStyle : unhighlightStyle;
    const proportionInput = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(NumberInput
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "userProportion",
      style: style,
      value: this.calculateDisplayProportion(),
      checkValidity: this.checkProportionValidity,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleUserProportionChange,
      onFocus: () => this.props.onFocus(["userProportion"]),
      onBlur: () => this.props.onBlur(["userProportion"])
    }), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This controls the proportion or percentage that will be used in your simulation."))));
    const sampleSizeInput = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(NumberInput
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "sampleSize",
      style: style,
      value: this.props.sampleSize,
      checkValidity: val => val >= 0,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleSampleSizeChange,
      onFocus: () => this.props.onFocus(["sampleSize"]),
      onBlur: () => this.props.onBlur(["sampleSize"])
    }), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This controls the sample size that will be used in your simulation. For example, if you set this to 100, then for each trial, responses from 100 participants will be simulated."))));
    const numTrialsDisplay = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        textAlign: "right"
      }
    }, /*#__PURE__*/React__namespace.createElement("b", null, this.props.numTrials), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This is the number of trials used in the simulation. For example, if set to 50, then the survey will be conducted 50 times."))));

    // Generates a table from a set of titles and values.
    const generateTable = contents => {
      const header = /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, /*#__PURE__*/React__namespace.createElement("th", null, i18n__namespace._("Parameter")), /*#__PURE__*/React__namespace.createElement("th", null, i18n__namespace._("Value"))));
      const body = /*#__PURE__*/React__namespace.createElement("tbody", null, ___default["default"].map(contents, (row, i) => {
        return /*#__PURE__*/React__namespace.createElement("tr", {
          key: i
        }, /*#__PURE__*/React__namespace.createElement("td", null, row.title), /*#__PURE__*/React__namespace.createElement("td", null, row.value));
      }));
      return /*#__PURE__*/React__namespace.createElement("table", null, header, body);
    };

    // Contents for the table to-be generated
    const contents = [{
      title: this.props.proportionLabel + ":",
      value: proportionInput
    }, {
      title: i18n__namespace._("Sample size:"),
      value: sampleSizeInput
    }, {
      title: i18n__namespace._("Number of trials:"),
      value: numTrialsDisplay
    }];

    // The 'Run Simulation' button
    const buttonStyle = {
      margin: "20px 0"
    };
    const startButton = /*#__PURE__*/React__namespace.createElement("button", {
      className: "simple-button",
      style: buttonStyle,
      disabled: this.props.apiOptions.readOnly,
      onClick: this.handleRunSimulation
    }, i18n__namespace._("Run simulation"));

    // When we plot data, ticks on the x-axis require some vertical padding
    const histogramStyle = {
      paddingBottom: this.props.data ? 40 : 0
    };
    const histogram = /*#__PURE__*/React__namespace.createElement("div", {
      style: histogramStyle
    }, /*#__PURE__*/React__namespace.createElement(Histogram, {
      data: this.props.data,
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }));
    return /*#__PURE__*/React__namespace.createElement("div", null, generateTable(contents), startButton, histogram);
  }
}
_defineProperty(Simulator, "propTypes", {
  ...propTypes,
  apiOptions: ApiOptions.propTypes,
  data: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  numTrials: PropTypes__default["default"].number,
  proportionLabel: PropTypes__default["default"].string,
  proportionOrPercentage: PropTypes__default["default"].string,
  randomSeed: PropTypes__default["default"].number,
  sampleSize: PropTypes__default["default"].number,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  userProportion: PropTypes__default["default"].number,
  xAxisLabel: PropTypes__default["default"].string,
  yAxisLabel: PropTypes__default["default"].string
});
_defineProperty(Simulator, "defaultProps", {
  data: null,
  userProportion: null,
  sampleSize: null,
  numTrials: null,
  randomSeed: 0,
  xAxisLabel: "Proportion (%)",
  yAxisLabel: "Number of times seen",
  proportionLabel: "Underlying proportion",
  proportionOrPercentage: "proportion",
  apiOptions: ApiOptions.defaults
});
___default["default"].extend(Simulator, {
  validate: function (state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});
const propTransform$1 = editorProps => {
  const widgetProps = ___default["default"].clone(editorProps);
  widgetProps.randomSeed = editorProps.problemNum;
  return widgetProps;
};
var Simulator$1 = {
  name: "simulator",
  displayName: "Simulator",
  widget: Simulator,
  transform: propTransform$1,
  hidden: true
};

const {
  shuffle
} = Util;
const HORIZONTAL = "horizontal";
const VERTICAL = "vertical";
class Sorter extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_isMounted", void 0);
    _defineProperty(this, "state", {
      changed: false
    });
    _defineProperty(this, "handleChange", e => {
      if (!this._isMounted) {
        return;
      }
      this.setState({
        changed: true
      }, () => {
        // Wait until all components have rendered. In React 16, the
        // setState callback fires immediately after componentDidUpdate,
        // and there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          this.props.onChange(e);
          this.props.trackInteraction();
        }, 0);
      });
    });
    _defineProperty(this, "getUserInput", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getOptions' does not exist on type 'ReactInstance'.
      return {
        options: this.refs.sortable.getOptions()
      };
    });
    _defineProperty(this, "moveOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'moveOptionToIndex' does not exist on type 'ReactInstance'.
      this.refs.sortable.moveOptionToIndex(option, index);
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // If this widget hasn't been changed yet, we treat it as "empty" which
      // prevents the "Check" button from becoming active. We want the user
      // to make a change before trying to move forward. This makes an
      // assumption that the initial order isn't the correct order! However,
      // this should be rare if it happens, and interacting with the list
      // will enable the button, so they won't be locked out of progressing.
      if (!this.state.changed) {
        return {
          type: "invalid",
          message: null
        };
      }
      return Sorter.validate(this.getUserInput(), rubric);
    });
  }
  static validate(state, rubric) {
    const correct = ___default["default"].isEqual(state.options, rubric.correct);
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const options = shuffle(this.props.correct, this.props.problemNum, /* ensurePermuted */true);
    const {
      apiOptions
    } = this.props;
    const marginPx = apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-sorter perseus-clearfix"
    }, /*#__PURE__*/React__namespace.createElement(Sortable
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'readonly unknown[]' is not assignable to type 'readonly string[]'.
    , {
      options: options,
      layout: this.props.layout,
      margin: marginPx,
      padding: this.props.padding,
      onChange: this.handleChange,
      linterContext: this.props.linterContext
      // eslint-disable-next-line react/no-string-refs
      ,
      ref: "sortable"
    }));
  }
}
_defineProperty(Sorter, "propTypes", {
  apiOptions: ApiOptions.propTypes,
  // eslint-disable-next-line react/forbid-prop-types
  correct: PropTypes__default["default"].array,
  layout: PropTypes__default["default"].oneOf([HORIZONTAL, VERTICAL]),
  onChange: PropTypes__default["default"].func,
  padding: PropTypes__default["default"].bool,
  problemNum: PropTypes__default["default"].number,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(Sorter, "defaultProps", {
  correct: [],
  layout: HORIZONTAL,
  padding: true,
  problemNum: 0,
  onChange: function () {},
  linterContext: PerseusLinter.linterContextDefault
});
var Sorter$1 = {
  name: "sorter",
  displayName: "Sorter",
  widget: Sorter,
  isLintable: true
};

const {
  assert: assert$1
} = InteractiveUtil;

/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */
const getInputPath = function (row, column) {
  return ["" + row, "" + column];
};
const getDefaultPath = function () {
  return getInputPath(0, 0);
};
const getRowFromPath = function (path) {
  // 'path' should be a (row, column) pair
  assert$1(___default["default"].isArray(path) && path.length === 2);
  return +path[0];
};
const getColumnFromPath = function (path) {
  // 'path' should be a (row, column) pair
  assert$1(___default["default"].isArray(path) && path.length === 2);
  return +path[1];
};
const getRefForPath = function (path) {
  const row = getRowFromPath(path);
  const column = getColumnFromPath(path);
  return "answer" + row + "," + column;
};
class Table extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_getRows", () => {
      return this.props.answers.length;
    });
    _defineProperty(this, "_getColumns", () => {
      return this.props.answers[0].length;
    });
    _defineProperty(this, "getUserInput", () => {
      return ___default["default"].map(this.props.answers, ___default["default"].clone);
    });
    _defineProperty(this, "onValueChange", (row, column, eventOrValue) => {
      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone);

      // If this is coming from an "input", the last argument will be an
      // event. If it's coming from a SimpleKeypadInput, it'll be the value.
      // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
      answers[row][column] = eventOrValue.target ? eventOrValue.target.value : eventOrValue;
      this.props.onChange({
        answers: answers
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "onHeaderChange", (index, e) => {
      const headers = this.props.headers.slice();
      headers[index] = e.content;
      this.props.onChange({
        headers: headers
      });
    });
    _defineProperty(this, "simpleValidate", rubric => {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'validate' does not exist on type 'typeof Table'.
      return Table.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "_handleFocus", inputPath => {
      this.props.onFocus(inputPath);
    });
    _defineProperty(this, "_handleBlur", inputPath => {
      this.props.onBlur(inputPath);
    });
    _defineProperty(this, "focus", () => {
      this.focusInputPath(getDefaultPath());
      return true;
    });
    _defineProperty(this, "focusInputPath", path => {
      const inputID = getRefForPath(path);
      // eslint-disable-next-line react/no-string-refs
      const inputComponent = this.refs[inputID];
      if (this.props.apiOptions.customKeypad) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        inputComponent.focus();
      } else {
        // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
        ReactDOM__default["default"].findDOMNode(inputComponent).focus();
      }
    });
    _defineProperty(this, "blurInputPath", path => {
      const inputID = getRefForPath(path);
      // eslint-disable-next-line react/no-string-refs
      const inputComponent = this.refs[inputID];
      if (this.props.apiOptions.customKeypad) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'ReactInstance'.
        inputComponent.blur();
      } else {
        // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'blur' does not exist on type 'Element | Text'.
        ReactDOM__default["default"].findDOMNode(inputComponent).blur();
      }
    });
    _defineProperty(this, "getDOMNodeForPath", path => {
      const inputID = getRefForPath(path);
      // eslint-disable-next-line react/no-string-refs
      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });
    _defineProperty(this, "getInputPaths", () => {
      const rows = this._getRows();
      const columns = this._getColumns();
      const inputPaths = [];
      ___default["default"](rows).times(r => {
        ___default["default"](columns).times(c => {
          const inputPath = getInputPath(r, c);
          inputPaths.push(inputPath);
        });
      });
      return inputPaths;
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "number";
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      // Extract row, column information
      const row = getRowFromPath(path);
      const column = getColumnFromPath(path);
      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone);
      // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
      answers[row][column] = newValue;
      this.props.onChange({
        answers: answers
      }, cb);
    });
  }
  render() {
    const rows = this._getRows();
    const columns = this._getColumns();
    const headers = this.props.headers;
    let InputComponent;
    let inputStyle;
    const extraInputProps = {};
    if (this.props.apiOptions.customKeypad) {
      InputComponent = SimpleKeypadInput;
      // NOTE(charlie): This is intended to match the "width: 80px" in
      // input in table.less. Those values should be kept in-sync.
      inputStyle = {
        width: 80
      };
      extraInputProps.keypadElement = this.props.keypadElement;
    } else {
      InputComponent = "input";
      inputStyle = {};
    }
    return /*#__PURE__*/React__namespace.createElement("table", {
      className: "perseus-widget-table-of-values non-markdown"
    }, /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, ___default["default"].map(headers, (header, i) => {
      if (this.props.editableHeaders) {
        return /*#__PURE__*/React__namespace.createElement("th", {
          key: i
        }, /*#__PURE__*/React__namespace.createElement(this.props.Editor, {
          ref: "columnHeader" + i,
          apiOptions: this.props.apiOptions,
          content: header,
          widgetEnabled: false,
          onChange: ___default["default"].partial(this.onHeaderChange, i)
        }));
      }
      return /*#__PURE__*/React__namespace.createElement("th", {
        key: i
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: header,
        linterContext: this.props.linterContext
      }));
    }))), /*#__PURE__*/React__namespace.createElement("tbody", null, ___default["default"](rows).times(r => {
      return /*#__PURE__*/React__namespace.createElement("tr", {
        key: r
      }, ___default["default"](columns).times(c => {
        return /*#__PURE__*/React__namespace.createElement("td", {
          key: c
        }, /*#__PURE__*/React__namespace.createElement(InputComponent, _extends({
          ref: getRefForPath(getInputPath(r, c)),
          type: "text",
          value: this.props.answers[r][c],
          disabled: this.props.apiOptions.readOnly,
          onFocus: ___default["default"].partial(this._handleFocus, getInputPath(r, c)),
          onBlur: ___default["default"].partial(this._handleBlur, getInputPath(r, c)),
          onChange: ___default["default"].partial(this.onValueChange, r, c),
          style: inputStyle
        }, extraInputProps)));
      }));
    })));
  }
}
_defineProperty(Table, "propTypes", {
  answers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)),
  editableHeaders: PropTypes__default["default"].bool,
  // The editor to use when editableHeaders is enabled
  Editor: PropTypes__default["default"].func,
  headers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  keypadElement: mathInput.keypadElementPropType,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});
_defineProperty(Table, "defaultProps", function () {
  const defaultRows = 4;
  const defaultColumns = 1;
  const blankAnswers = ___default["default"](defaultRows).times(function () {
    return Util.stringArrayOfSize(defaultColumns);
  });
  return {
    apiOptions: ApiOptions.defaults,
    headers: [""],
    editableHeaders: false,
    rows: defaultRows,
    columns: defaultColumns,
    answers: blankAnswers,
    linterContext: PerseusLinter.linterContextDefault
  };
}());
___default["default"].extend(Table, {
  validate: function (state, rubric) {
    const filterNonEmpty = function (table) {
      return ___default["default"].filter(table, function (row) {
        // Check if row has a cell that is nonempty
        return ___default["default"].some(row, ___default["default"].identity);
      });
    };
    const solution = filterNonEmpty(rubric.answers);
    const supplied = filterNonEmpty(state);
    const hasEmptyCell = ___default["default"].some(supplied, function (row) {
      return ___default["default"].some(row, function (cell) {
        return cell === "";
      });
    });
    if (hasEmptyCell || !supplied.length) {
      return {
        type: "invalid",
        message: null
      };
    }
    if (supplied.length !== solution.length) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
    const createValidator = KhanAnswerTypes.number.createValidatorFunctional;
    let message = null;
    const allCorrect = ___default["default"].every(solution, function (rowSolution) {
      let i;
      for (i = 0; i < supplied.length; i++) {
        const rowSupplied = supplied[i];
        const correct = ___default["default"].every(rowSupplied, function (cellSupplied, i) {
          const cellSolution = rowSolution[i];
          const validator = createValidator(cellSolution, {
            simplify: true
          });
          const result = validator(cellSupplied);
          if (result.message) {
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
            message = result.message;
          }
          return result.correct;
        });
        if (correct) {
          supplied.splice(i, 1);
          return true;
        }
      }
      return false;
    });
    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: message
    };
  }
});
const propTransform = editorProps => {
  // Remove answers before passing to widget
  const rows = editorProps.answers.length;
  const columns = editorProps.answers[0].length;
  const blankAnswers = ___default["default"](rows).times(function () {
    return Util.stringArrayOfSize(columns);
  });
  return ___default["default"].extend({}, editorProps, {
    answers: blankAnswers
  });
};
var Table$1 = {
  name: "table",
  displayName: "Table of values",
  accessible: true,
  widget: Table,
  transform: propTransform,
  hidden: true,
  isLintable: true
};

const {
  deepEq,
  getGridStep,
  captureScratchpadTouchStart
} = Util;
const {
  assert
} = InteractiveUtil;
const ROTATE_SNAP_DEGREES = 15;
const DEGREE_SIGN = "\u00B0";
const RENDER_TRANSFORM_DELAY_IN_MS = 300;
const ROTATE_HANDLE_DIST = 1.5;
const REFLECT_ROTATE_HANDLE_DIST = 2;
const REFLECT_BUTTON_SIZE = 1;
const defaultBoxSize = 400;
const defaultBackgroundImage = {
  url: null
};

/* Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */
function pluckObject(object, subKey) {
  return ___default["default"].object(___default["default"].map(object, function (value, key) {
    return [key, value[subKey]];
  }));
}
const defaultGraphProps = function (setProps, boxSize) {
  setProps = setProps || {};
  const labels = setProps.labels || ["x", "y"];
  const range = setProps.range || [[-10, 10], [-10, 10]];
  const step = setProps.step || [1, 1];
  const gridStep = setProps.gridStep || getGridStep(range, step, boxSize);
  return {
    box: [boxSize, boxSize],
    labels: labels,
    range: range,
    step: step,
    gridStep: gridStep,
    valid: true,
    backgroundImage: defaultBackgroundImage,
    markings: "grid",
    showProtractor: false
  };
};
const defaultTransformerProps = {
  apiOptions: ApiOptions.defaults,
  gradeEmpty: false,
  graphMode: "interactive",
  listMode: "dynamic",
  graph: {},
  tools: {
    translation: {
      enabled: true,
      required: false,
      constraints: {}
    },
    rotation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [1, 6]
    },
    reflection: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coords: [[2, -4], [2, 2]]
    },
    dilation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [6, 6]
    }
  },
  drawSolutionShape: true,
  starting: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  },
  correct: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  }
};
function colorForTool(tool) {
  return tool.constraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
}

/* Scales a distance from the default range of
 * [-10, 10] to a given props.range pair
 *
 * Used for sizing various transformation tools
 * (rotation handle, dilation circle)
 */
function scaleToRange(dist, range) {
  const spreadX = range[0][1] - range[0][0];
  const spreadY = range[1][1] - range[1][0];
  return dist * Math.max(spreadX, spreadY) / 20;
}
function dilatePointFromCenter(point, dilationCenter, scale) {
  const pv = kmath.vector.subtract(point, dilationCenter);
  const pvScaled = kmath.vector.scale(pv, scale);
  const transformedPoint = kmath.vector.add(dilationCenter, pvScaled);
  return transformedPoint;
}

// TODO(jack): i18nize this
function stringFromDecimal(number) {
  return String(KhanMath.roundTo(9, number));
}
function stringFromFraction(number) {
  const frac = KhanMath.toFraction(number, kmath.number.DEFAULT_TOLERANCE);
  if (frac[1] === 1) {
    return stringFromDecimal(number);
  }
  return stringFromDecimal(frac[0]) + "/" + stringFromDecimal(frac[1]);
}
function texFromPoint(point) {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "("
  }, "("), stringFromDecimal(point[0]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ","
  }, ", {}"), stringFromDecimal(point[1]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ")"
  }, ")")];
}
function texFromVector(vector) {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "<"
  }, i18n__namespace.doNotTranslate("\\langle")), stringFromDecimal(vector[0]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ","
  }, ", {}"), stringFromDecimal(vector[1]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ">"
  }, i18n__namespace.doNotTranslate("\\rangle"))];
}
function texFromAngleDeg(angleDeg) {
  return stringFromDecimal(angleDeg) + DEGREE_SIGN;
}
function orderInsensitiveCoordsEqual(coords1, coords2) {
  coords1 = ___default["default"].clone(coords1).sort(kmath.point.compare);
  coords2 = ___default["default"].clone(coords2).sort(kmath.point.compare);
  return ___default["default"].all(___default["default"].map(coords1, function (coord1, i) {
    const coord2 = coords2[i];
    return kmath.point.equal(coord1, coord2);
  }));
}
const inputComponentForApiOptions = apiOptions => {
  if (apiOptions.customKeypad) {
    return SimpleKeypadInput;
  }
  return NumberInput;
};

/* Perform operations on raw transform objects */
const TransformOps = {
  apply: function (transform) {
    // Any transformation with empty text boxes is a no-op until
    // filled out (these show up as nulls in transform.vector/line/etc).
    // TODO (jack): Merge this just into reflections now that other
    // transforms are always valid (after merging transformation
    // collapsing, which may use isValid)
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'PerseusTransformerTransformation' is not assignable to parameter of type 'never'.
    if (!Transformations[transform.type].isValid(transform)) {
      return ___default["default"].identity; // do not transform the coord
    }
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'PerseusTransformerTransformation' is not assignable to parameter of type 'never'.
    return Transformations[transform.type].apply(transform);
  },
  append: function (transformList, newTransform) {
    // Append newTransform to transformList, and collapse the last
    // two transforms if they are collapsable
    const results = TransformOps._appendAndCollapseLastTwo(transformList, newTransform);
    // Collapse any no-ops at the end of the transformation list
    return TransformOps._collapseFinalNoOps(results);
  },
  _collapseFinalNoOps: function (transforms) {
    // Collapse no-op transformations at the end of the list
    if (transforms.length && TransformOps.isNoOp(___default["default"].last(transforms))) {
      return ___default["default"].initial(transforms);
    }
    return transforms;
  },
  _appendAndCollapseLastTwo: function (transformList, newTransform) {
    if (!transformList.length) {
      return [newTransform];
    }
    const collapsed = TransformOps.collapse(___default["default"].last(transformList), newTransform);
    return ___default["default"].initial(transformList).concat(collapsed);
  },
  isNoOp: function (transform) {
    return Transformations[transform.type].isNoOp(transform);
  },
  collapse: function (transform1, transform2) {
    // We can only collapse transforms that have the same type
    if (transform1.type !== transform2.type) {
      return [transform1, transform2];
    }

    // Clicking the button again removes empty transformations
    if (TransformOps.isEmpty(transform1) && TransformOps.isEmpty(transform2)) {
      return [];
    }

    // Don't collapse invalid transformations otherwise
    if (!TransformOps.isValid(transform1) || !TransformOps.isValid(transform2)) {
      return [transform1, transform2];
    }
    return TransformOps._collapseValidMonotypedTransforms(transform1, transform2);
  },
  isValid: function (transform) {
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'PerseusTransformerTransformation' is not assignable to parameter of type 'never'.
    return Transformations[transform.type].isValid(transform);
  },
  isEmpty: function (transform) {
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'PerseusTransformerTransformation' is not assignable to parameter of type 'never'.
    return Transformations[transform.type].isEmpty(transform);
  },
  _collapseValidMonotypedTransforms: function (transform1, transform2) {
    let collapsed = Transformations[transform1.type].collapse(transform1, transform2);
    if (collapsed) {
      // Force all answers into an array
      if (!___default["default"].isArray(collapsed)) {
        collapsed = [collapsed];
      }
      // Add types to all transforms in the answer
      ___default["default"].each(collapsed, function (transform) {
        transform.type = transform1.type;
      });
      return collapsed;
    }
    // These transforms can't be collapsed together
    return [transform1, transform2];
  },
  toTeX: function (transform) {
    return Transformations[transform.type].toTeX(transform);
  },
  /* A react representation of this transform object */
  ListItem: createReactClass__default["default"]({
    displayName: "ListItem",
    render: function () {
      if (this.props.mode === "dynamic") {
        return /*#__PURE__*/React__namespace.createElement("div", null, TransformOps.toTeX(this.props.transform));
      }
      if (this.props.mode === "interactive") {
        const TransformClass = Transformations[this.props.transform.type].Input;
        return /*#__PURE__*/React__namespace.createElement(TransformClass
        // eslint-disable-next-line react/no-string-refs
        , _extends({
          ref: "transform",
          onChange: this.handleChange,
          onFocus: this.props.onFocus,
          onBlur: this.props.onBlur,
          keypadElement: this.props.keypadElement,
          apiOptions: this.props.apiOptions
        }, this.props.transform));
      }
      throw new PerseusError("Invalid mode: " + this.props.mode, Errors.InvalidInput);
    },
    value: function () {
      if (this.props.mode === "interactive") {
        return ___default["default"].extend({
          type: this.props.transform.type
        },
        // eslint-disable-next-line react/no-string-refs
        this.refs.transform.value());
      }
      return this.props.transform;
    },
    handleChange: ___default["default"].debounce(function (callback) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      this.props.onChange(this.value(), callback);
    }, RENDER_TRANSFORM_DELAY_IN_MS),
    /* InputPath API: depending on the API call, this could involve simply
     * navigating to the right ref and calling the function on that
     * component, or threading the call down and returning the result. */
    _getComponentAtPath: function (path) {
      // eslint-disable-next-line react/no-string-refs
      const transform = this.refs.transform;
      const ref = ___default["default"].head(path);
      return transform.refs[ref];
    },
    focus: function () {
      // eslint-disable-next-line react/no-string-refs
      const transform = this.refs.transform;
      const path = ___default["default"].head(transform.getInputPaths());
      if (path) {
        this.focusInputPath(path);
      }
    },
    focusInputPath: function (path) {
      this._getComponentAtPath(path).focus();
    },
    blurInputPath: function (path) {
      this._getComponentAtPath(path).blur();
    },
    getDOMNodeForPath: function (path) {
      return ReactDOM__default["default"].findDOMNode(this._getComponentAtPath(path));
    },
    getGrammarTypeForPath: function (path) {
      return "number";
    },
    setInputValue: function (path, value, cb) {
      // `value` comes in as a string on mobile, but we need a number
      // We let through the empty string so that "Clear" works -- in
      // that case, the transformer widget will just act as if there is
      // no input, which is what we want.
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'length' does not exist on type 'string | number'.
      if (value.length) {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string | number' is not assignable to parameter of type 'string'.
        value = parseFloat(value);
        if (isNaN(value)) {
          return;
        }
      }
      // eslint-disable-next-line react/no-string-refs
      this.refs.transform.setInputValue(path, value, cb);
    },
    getInputPaths: function () {
      // If we're in dynamic mode, then the list items are made up of
      // static text.
      if (this.props.mode === "dynamic") {
        return [];
      }
      // eslint-disable-next-line react/no-string-refs
      return this.refs.transform.getInputPaths();
    }
  })
};
const Transformations = {
  translation: {
    // I18N: As in the command, "Translate the polygon"
    verbName: i18n__namespace._("Translate"),
    nounName: i18n__namespace._("Translation"),
    lowerNounName: i18n__namespace._("translation"),
    apply: function (transform) {
      return function (coord) {
        return kmath.vector.add(coord, transform.vector);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.vector[0]) && ___default["default"].isFinite(transform.vector[1]);
    },
    isEmpty: function (transform) {
      return transform.vector[0] === null && transform.vector[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.vector.equal(transform.vector, [0, 0]);
    },
    collapse: function (transform1, transform2) {
      return {
        vector: kmath.vector.add(transform1.vector, transform2.vector)
      };
    },
    toTeX: function (transform) {
      // I18N: As in the command, "Translation by <3, 1>"
      return i18n__namespace.$_("Translation by %(vector)s", {
        vector: texFromVector(transform.vector)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "state", {
          vector: this.props.vector || [null, null]
        });
        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const x = this.refs.x.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const y = this.refs.y.getValue();
          return {
            vector: [x, y]
          };
        });
        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);
          const vector = ___default["default"].clone(this.state.vector);
          if (id === "x") {
            vector[0] = value;
          } else if (id === "y") {
            vector[1] = value;
          }
          this.setState({
            vector: vector
          }, () => {
            this.props.onChange(cb);
          });
        });
        _defineProperty(this, "getInputPaths", () => {
          return [["x"], ["y"]];
        });
      }
      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            vector: this.props.vector
          });
        }
      }
      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const vector = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "<"
        }, i18n__namespace.doNotTranslate("\\langle")), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "vec_x"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x",
          placeholder: 0,
          value: this.state.vector[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.vector[1];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "x"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "vec_y"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y",
          placeholder: 0,
          value: this.state.vector[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.vector[0];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "y"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ">"
        }, i18n__namespace.doNotTranslate("\\rangle"))];
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Translation by %(vector)s", {
          vector: vector
        }));
      }
    }
  },
  rotation: {
    // I18N: As in the command, "Rotate the polygon"
    verbName: i18n__namespace._("Rotate"),
    nounName: i18n__namespace._("Rotation"),
    lowerNounName: i18n__namespace._("rotation"),
    apply: function (transform) {
      return function (coord) {
        return kmath.point.rotateDeg(coord, transform.angleDeg, transform.center);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.angleDeg) && ___default["default"].isFinite(transform.center[0]) && ___default["default"].isFinite(transform.center[1]);
    },
    isEmpty: function (transform) {
      return transform.angleDeg === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.number.equal(transform.angleDeg, 0);
    },
    collapse: function (transform1, transform2) {
      if (!kmath.point.equal(transform1.center, transform2.center)) {
        return false;
      }
      return {
        center: transform1.center,
        angleDeg: transform1.angleDeg + transform2.angleDeg
      };
    },
    toTeX: function (transform) {
      return i18n__namespace.$_("Rotation by %(degrees)s about %(point)s", {
        degrees: texFromAngleDeg(transform.angleDeg),
        point: texFromPoint(transform.center)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "state", {
          center: this.props.center || [null, null],
          angleDeg: this.props.angleDeg || null
        });
        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const angleDeg = this.refs.angleDeg.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const centerX = this.refs.centerX.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const centerY = this.refs.centerY.getValue();
          return {
            angleDeg: angleDeg,
            center: [centerX, centerY]
          };
        });
        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);
          let angleDeg = ___default["default"].clone(this.state.angleDeg);
          const center = ___default["default"].clone(this.state.center);
          if (id === "angleDeg") {
            angleDeg = value;
          } else if (id === "centerX") {
            center[0] = value;
          } else if (id === "centerY") {
            center[1] = value;
          }
          this.setState({
            angleDeg: angleDeg,
            center: center
          }, () => {
            this.props.onChange(cb);
          });
        });
        _defineProperty(this, "getInputPaths", () => {
          return [["centerX"], ["centerY"], ["angleDeg"]];
        });
      }
      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            angleDeg: this.props.angleDeg
          });
        }
      }
      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "X"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "centerX",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "centerX"),
          onBlur: ___default["default"].partial(this.props.onBlur, "centerX"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "Y"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "centerY",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "centerY"),
          onBlur: ___default["default"].partial(this.props.onBlur, "centerY"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const degrees = [/*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "deg"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "angleDeg",
          placeholder: 0,
          value: this.state.angleDeg,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              angleDeg: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "angleDeg"),
          onBlur: ___default["default"].partial(this.props.onBlur, "angleDeg"),
          keypadElement: this.props.keypadElement
        }), DEGREE_SIGN];
        // I18N: %(point)s must come before %(degrees)s in this phrase
        const text = i18n__namespace.$_("Rotation about %(point)s by %(degrees)s", {
          point,
          degrees
        });
        return /*#__PURE__*/React__namespace.createElement("div", null, text);
      }
    }
  },
  reflection: {
    // I18N: As in the command, "Reflect the polygon"
    verbName: i18n__namespace._("Reflect"),
    nounName: i18n__namespace._("Reflection"),
    lowerNounName: i18n__namespace._("reflection"),
    apply: function (transform) {
      return function (coord) {
        return kmath.point.reflectOverLine(coord, transform.line);
      };
    },
    isValid: function (transform) {
      // A bit hacky, but we'll also define reflecting over a
      // single point as a no-op, to avoid NaN fun.
      return ___default["default"].all(___default["default"].flatten(transform.line), ___default["default"].isFinite) && !kmath.point.equal(transform.line[0], transform.line[1]);
    },
    isEmpty: function (transform) {
      return ___default["default"].all(___default["default"].flatten(transform.line), ___default["default"].isNull);
    },
    isNoOp: function (transform) {
      // Invalid transforms are implicitly no-ops, so we don't
      // have to catch that case here.
      return false;
    },
    collapse: function (transform1, transform2) {
      if (!kmath.line.equal(transform1.line, transform2.line)) {
        return false;
      }
      return [];
    },
    toTeX: function (transform) {
      const point1 = transform.line[0];
      const point2 = transform.line[1];
      return i18n__namespace.$_("Reflection over the line from %(point1)s to %(point2)s", {
        point1: texFromPoint(point1),
        point2: texFromPoint(point2)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "state", {
          line: this.props.line || [[null, null], [null, null]]
        });
        _defineProperty(this, "changePoint", (i, j, val, cb) => {
          const line = ___default["default"].map(this.state.line, ___default["default"].clone);
          // @ts-expect-error [FEI-5003] - TS2538 - Type 'undefined' cannot be used as an index type.
          line[i][j] = val;
          this.setState({
            line: line
          }, () => {
            this.props.onChange(cb);
          });
        });
        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const x1 = this.refs.x1.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const y1 = this.refs.y1.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const x2 = this.refs.x2.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const y2 = this.refs.y2.getValue();
          return {
            line: [[x1, y1], [x2, y2]]
          };
        });
        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);
          let j;
          if (id[0] === "x") {
            j = 0;
          } else if (id[0] === "y") {
            j = 1;
          }
          let i;
          if (id[1] === "1") {
            i = 0;
          } else if (id[1] === "2") {
            i = 1;
          }
          this.changePoint(i, j, value, cb);
        });
        _defineProperty(this, "getInputPaths", () => {
          return [["x1"], ["y1"], ["x2"], ["y2"]];
        });
      }
      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            line: this.props.line
          });
        }
      }
      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point1 = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "x1"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x1",
          value: this.state.line[0][0],
          useArrowKeys: true
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 0, 0),
          onFocus: ___default["default"].partial(this.props.onFocus, "x1"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "y1"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y1",
          value: this.state.line[0][1],
          useArrowKeys: true
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 0, 1),
          onFocus: ___default["default"].partial(this.props.onFocus, "y1"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const point2 = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "x2"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x2",
          value: this.state.line[1][0],
          useArrowKeys: true
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 1, 0),
          onFocus: ___default["default"].partial(this.props.onFocus, "x2"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "y2"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y2",
          value: this.state.line[1][1],
          useArrowKeys: true
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 1, 1),
          onFocus: ___default["default"].partial(this.props.onFocus, "y2"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Reflection over the line from " + "%(point1)s to %(point2)s", {
          point1,
          point2
        }));
      }
    }
  },
  dilation: {
    // I18N: As in the command, "Dilate the polygon"
    verbName: i18n__namespace._("Dilate"),
    nounName: i18n__namespace._("Dilation"),
    lowerNounName: i18n__namespace._("dilation"),
    apply: function (transform) {
      return function (coord) {
        return dilatePointFromCenter(coord, transform.center, transform.scale);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.scale) && ___default["default"].isFinite(transform.center[0]) && ___default["default"].isFinite(transform.center[1]);
    },
    isEmpty: function (transform) {
      return transform.scale === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.number.equal(transform.scale, 1);
    },
    collapse: function (transform1, transform2) {
      if (!kmath.point.equal(transform1.center, transform2.center)) {
        return false;
      }
      return {
        center: transform1.center,
        scale: transform1.scale * transform2.scale
      };
    },
    toTeX: function (transform) {
      const scaleString = stringFromFraction(transform.scale);
      return i18n__namespace.$_("Dilation of scale %(scale)s about %(point)s", {
        scale: scaleString,
        point: texFromPoint(transform.center)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "state", {
          center: this.props.center || [null, null],
          scale: this.props.scale || null
        });
        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const scale = this.refs.scale.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const x = this.refs.x.getValue();
          // eslint-disable-next-line react/no-string-refs
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'getValue' does not exist on type 'ReactInstance'.
          const y = this.refs.y.getValue();
          return {
            scale: scale,
            center: [x, y]
          };
        });
        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);
          let scale = this.state.scale;
          const center = ___default["default"].clone(this.state.center);
          if (id === "x") {
            center[0] = value;
          } else if (id === "y") {
            center[1] = value;
          } else if (id === "scale") {
            scale = value;
          }
          this.setState({
            scale: scale,
            center: center
          }, () => {
            this.props.onChange(cb);
          });
        });
        _defineProperty(this, "getInputPaths", () => {
          return [["x"], ["y"], ["scale"]];
        });
      }
      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            scale: this.props.scale
          });
        }
      }
      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "point_x"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "x"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "point_y"
          // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "y"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const scale = /*#__PURE__*/React__namespace.createElement(InputComponent
        // eslint-disable-next-line react/no-string-refs
        , {
          ref: "scale",
          placeholder: 1,
          value: this.state.scale,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              scale: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "scale"),
          onBlur: ___default["default"].partial(this.props.onBlur, "scale"),
          keypadElement: this.props.keypadElement
        });
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Dilation about %(point)s by %(scale)s", {
          point,
          scale
        }));
      }
    }
  }
};

/* Various functions to deal with different shape types */
const ShapeTypes = {
  getPointCountForType: function (type) {
    const splitType = type.split("-");
    if (splitType[0] === "polygon") {
      return splitType[1] || 3;
    }
    if (splitType[0] === "line" || splitType[0] === "lineSegment") {
      return 2;
    }
    if (splitType[0] === "angle") {
      return 3;
    }
    if (splitType[0] === "circle") {
      return 2;
    }
    if (splitType[0] === "point") {
      return 1;
    }
  },
  addMovableShape: function (graphie, options) {
    if (options.editable && options.translatable) {
      throw new PerseusError("It doesn't make sense to have a movable shape " + "where you can stretch the points and translate them " + "simultaneously. options: " + JSON.stringify(options), Errors.InvalidInput);
    }
    const points = ___default["default"].map(options.shape.coords, function (coord) {
      let isMoving = false;
      let previousCoord = coord;
      const onMove = function (x, y) {
        if (!isMoving) {
          previousCoord = currentPoint.coord;
          isMoving = true;
        }
        let moveVector = kmath.vector.subtract([x, y], currentPoint.coord);

        // Translate from (x, y) semantics to (dX, dY) semantics
        // This is more useful for translations on multiple points,
        // where we care about how the points moved, not where any
        // individual point ended up
        if (options.onMove) {
          moveVector = options.onMove(moveVector[0], moveVector[1]);
        }

        // Perform a translation on all points in this shape when
        // any point moves
        if (options.translatable) {
          ___default["default"].each(points, function (point) {
            // The point itself will be updated by the
            // movablePoint class, so only translate the other
            // points
            if (point !== currentPoint) {
              point.setCoord(kmath.vector.add(point.coord, moveVector));
            }
          });
        }

        // Update our shape and our currentPoint
        // Without this, some shapes (circles, angles) appear
        // "bouncy" as they are updated with currentPoint at the
        // current mouse coordinate (oldCoord), rather than newCoord
        const oldCoord = currentPoint.coord;
        const newCoord = kmath.vector.add(currentPoint.coord, moveVector);
        // Temporarily change our coordinate so that
        // shape.update() sees the new coordinate
        currentPoint.coord = newCoord;
        shape.update();
        // ...But don't break onMove, which assumes it
        // is the only thing changing our coord
        currentPoint.coord = oldCoord;
        return newCoord;
      };
      const onMoveEnd = function () {
        // onMove isn't guaranteed to be called before onMoveEnd, so
        // we have to take into account that we may not have moved and
        // set previousCoord.
        if (options.onMoveEnd && isMoving) {
          isMoving = false;
          // We don't use the supplied x and y parameters here
          // because MovablePoint's onMoveEnd semantics suck.
          // It returns the mouseX, mouseY without processing them
          // through onMove, leaving us with weird fractional moves
          const change = kmath.vector.subtract(currentPoint.coord, previousCoord);
          options.onMoveEnd(change[0], change[1]);
        }
        shape.update();
      };
      const currentPoint = graphie.addMovablePoint({
        coord: coord,
        normalStyle: options.normalPointStyle,
        highlightStyle: options.highlightPointStyle,
        constraints: {
          fixed: !options.translatable && !options.editable
        },
        visible: options.showPoints,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        bounded: false,
        // Don't bound it when placing it on the graph
        onMove: onMove,
        onMoveEnd: onMoveEnd
      });

      // Bound it when moving
      // We can't set this earlier, because doing so would mean any
      // points outside of the graph would be moved into a moved into
      // a position that doesn't preserve the shape
      currentPoint.bounded = true;
      return currentPoint;
    });
    const shape = ShapeTypes.addShape(graphie, options, points);
    const removeShapeWithoutPoints = shape.remove;
    shape.remove = function () {
      removeShapeWithoutPoints.apply(shape);
      ___default["default"].invoke(points, "remove");
    };
    return shape;
  },
  addShape: function (graphie, options, points) {
    points = points || options.shape.coords;
    const types = ShapeTypes._typesOf(options.shape);
    const typeOptions = options.shape.options || ShapeTypes.defaultOptions(types);

    // @ts-expect-error [FEI-5003] - TS2554 - Expected 4 arguments, but got 3.
    const shapes = ShapeTypes._mapTypes(types, points, function (type, points, i) {
      const shapeOptions = ___default["default"].extend({}, options, typeOptions[i]);
      return ShapeTypes._addType(graphie, type, points, shapeOptions);
    });
    const updateFuncs = ___default["default"].filter(___default["default"].pluck(shapes, "update"), ___default["default"].identity);
    const update = function () {
      ___default["default"].invoke(updateFuncs, "call");
    };
    const removeFuncs = ___default["default"].filter(___default["default"].pluck(shapes, "remove"), ___default["default"].identity);
    const remove = function () {
      ___default["default"].invoke(removeFuncs, "call");
    };
    const getOptions = function () {
      return ___default["default"].map(shapes, function (shape) {
        if (shape.getOptions) {
          return shape.getOptions();
        }
        return {};
      });
    };
    const toJSON = function () {
      const coords = ___default["default"].map(points, function (pt) {
        if (___default["default"].isArray(pt)) {
          return pt;
        }
        return pt.coord;
      });
      return {
        type: types,
        coords: coords,
        options: getOptions()
      };
    };
    return {
      type: types,
      points: points,
      update: update,
      remove: remove,
      toJSON: toJSON,
      getOptions: getOptions
    };
  },
  equal: function (shape1, shape2) {
    const types1 = ShapeTypes._typesOf(shape1);
    const types2 = ShapeTypes._typesOf(shape2);
    if (types1.length !== types2.length) {
      return false;
    }
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 4 arguments, but got 3.
    const shapes1 = ShapeTypes._mapTypes(types1, shape1.coords, ShapeTypes._combine);
    // @ts-expect-error [FEI-5003] - TS2554 - Expected 4 arguments, but got 3.
    const shapes2 = ShapeTypes._mapTypes(types2, shape2.coords, ShapeTypes._combine);
    return ___default["default"].all(___default["default"].map(shapes1, function (partialShape1, i) {
      const partialShape2 = shapes2[i];
      if (partialShape1.type !== partialShape2.type) {
        return false;
      }
      return ShapeTypes._forType(partialShape1.type).equal(partialShape1.coords, partialShape2.coords);
    }));
  },
  _typesOf: function (shape) {
    let types = shape.type;
    if (!___default["default"].isArray(types)) {
      types = [types];
    }
    return ___default["default"].map(types, function (type) {
      if (type === "polygon") {
        return "polygon-3";
      }
      return type;
    });
  },
  defaultOptions: function (types) {
    return ___default["default"].map(types, function (type) {
      const typeDefaultOptions = ShapeTypes._forType(type).defaultOptions;
      return ___default["default"].extend({}, typeDefaultOptions);
    });
  },
  _forType: function (type) {
    const baseType = type.split("-")[0];
    return ShapeTypes[baseType];
  },
  _mapTypes: function (types, points, func, context) {
    return ___default["default"].map(types, function (type, i) {
      const pointCount = ShapeTypes.getPointCountForType(type);
      const currentPoints = ___default["default"].first(points, pointCount);
      points = ___default["default"].rest(points, pointCount);
      return func.call(context, type, currentPoints, i);
    });
  },
  _addType: function (graphie, type, points, options) {
    const lineCoords = ___default["default"].isArray(points[0]) ? {
      coordA: points[0],
      coordZ: points[1]
    } : {
      pointA: points[0],
      pointZ: points[1]
    };
    type = type.split("-")[0];
    if (type === "polygon") {
      const polygon = graphie.addMovablePolygon(___default["default"].extend({}, options, {
        fixed: !options.editable,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        points: points,
        constrainToGraph: false
      }));
      return {
        update: polygon.transform.bind(polygon),
        remove: polygon.remove.bind(polygon)
      };
    }
    if (type === "line" || type === "lineSegment") {
      const line = graphie.addMovableLineSegment(___default["default"].extend({}, options, lineCoords, {
        movePointsWithLine: true,
        fixed: true,
        constraints: {
          fixed: true
        },
        extendLine: type === "line"
      }));

      // TODO(jack): Hide points on uneditable lines when translation
      // is a vector.
      // We can't just remove the points yet, because they are the
      // translation handle for the line.
      return {
        update: line.transform.bind(line, true),
        remove: line.remove.bind(line)
      };
    }
    if (type === "angle") {
      // If this angle is editable, we want to be able to make angles
      // both larger and smaller than 180 degrees.
      // If this angle is not editable, it should always maintain
      // it's angle measure, even if it is reflected (causing the
      // clockwise-ness of the points to change)
      const shouldChangeReflexivity = options.editable ? null : false;
      const angle = graphie.addMovableAngle({
        angleLabel: "$deg0",
        fixed: true,
        points: points,
        normalStyle: options.normalStyle,
        reflex: options.reflex
      });

      // Hide non-vertex points on uneditable angles
      if (!___default["default"].isArray(points[0]) && !options.editable) {
        points[0].remove();
        points[2].remove();
      }
      return {
        update: angle.update.bind(angle, shouldChangeReflexivity),
        remove: angle.remove.bind(angle),
        getOptions: function () {
          return {
            reflex: angle.isReflex()
          };
        }
      };
    }
    if (type === "circle") {
      let perimeter = {
        // temporary object for the first removal
        remove: ___default["default"].identity
      };
      const redrawPerim = function () {
        const coord0 = points[0].coord || points[0];
        const coord1 = points[1].coord || points[1];
        const radius = kmath.point.distanceToPoint(coord0, coord1);
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
        perimeter.remove();
        perimeter = graphie.circle(coord0, radius, ___default["default"].extend({
          stroke: KhanColors.DYNAMIC,
          "stroke-width": 2
        }, options.normalStyle));
      };
      redrawPerim();
      if (points[1].remove && !options.editable) {
        points[1].remove();
      }
      return {
        update: redrawPerim,
        remove: function () {
          // Not _.bind because the remove function changes
          // when the perimeter is redrawn
          // @ts-expect-error [FEI-5003] - TS2554 - Expected 1 arguments, but got 0.
          perimeter.remove();
        }
      };
    }
    if (type === "point") {
      // do nothing
      return {
        update: null,
        remove: null
      };
    }
    throw new PerseusError("Invalid shape type " + type, Errors.InvalidInput);
  },
  _combine: function (type, coords) {
    return {
      type: type,
      coords: coords
    };
  },
  polygon: {
    equal: orderInsensitiveCoordsEqual
  },
  line: {
    equal: kmath.line.equal
  },
  lineSegment: {
    equal: orderInsensitiveCoordsEqual
  },
  angle: {
    equal: function (points1, points2) {
      if (!kmath.point.equal(points1[1], points2[1])) {
        return false;
      }
      const line1_0 = [points1[1], points1[0]];
      const line1_2 = [points1[1], points1[2]];
      const line2_0 = [points2[1], points2[0]];
      const line2_2 = [points2[1], points2[2]];
      const equalUnflipped =
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'Ray'. | TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'Ray'.
      kmath.ray.equal(line1_0, line2_0) && kmath.ray.equal(line1_2, line2_2);
      const equalFlipped =
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'Ray'. | TS2345 - Argument of type 'any[]' is not assignable to parameter of type 'Ray'.
      kmath.ray.equal(line1_0, line2_2) && kmath.ray.equal(line1_2, line2_0);
      return equalUnflipped || equalFlipped;
    },
    defaultOptions: {
      reflex: false
    }
  },
  circle: {
    equal: function (points1, points2) {
      const radius1 = kmath.point.distanceToPoint(points1[0], points1[1]);
      const radius2 = kmath.point.distanceToPoint(points2[0], points2[1]);
      return kmath.point.equal(points1[0], points2[0]) && kmath.number.equal(radius1, radius2);
    }
  },
  point: {
    equal: kmath.point.equal
  }
};
const TransformationListItem = TransformOps.ListItem;
class TransformationList extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_transformationRefs", () => {
      return ___default["default"].times(this.props.transformations.length, i => {
        // eslint-disable-next-line react/no-string-refs
        return this.refs["transformation" + i];
      });
    });
    _defineProperty(this, "value", () => {
      return ___default["default"].invoke(this._transformationRefs(), "value");
    });
    _defineProperty(this, "handleChange", (changed, callback) => {
      this.props.onChange(this.value(), callback);
    });
    _defineProperty(this, "focusLast", () => {
      const transformationRefs = this._transformationRefs();
      if (transformationRefs.length !== 0) {
        // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2339 - Property 'focus' does not exist on type 'ReactInstance'.
        ___default["default"].last(transformationRefs).focus();
      }
    });
  }
  render() {
    if (this.props.mode === "static") {
      return /*#__PURE__*/React__namespace.createElement("span", null); // don't render anything
    }

    const transformationList = ___default["default"].map(this.props.transformations, function (transform, i) {
      return /*#__PURE__*/React__namespace.createElement(TransformationListItem, {
        ref: "transformation" + i,
        key: "transformation" + i,
        transform: transform
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        mode: this.props.mode
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onChange: this.handleChange
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onFocus: ___default["default"].partial(this.props.onFocus, "" + i)
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        onBlur: ___default["default"].partial(this.props.onBlur, "" + i)
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        keypadElement: this.props.keypadElement
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        ,
        apiOptions: this.props.apiOptions
      });
    }, this);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-transformation-list"
    }, transformationList);
  }
}
class ToolButton extends React__namespace.Component {
  render() {
    const classes = this.props.toggled ? "simple-button exercise-orange toggled highlighted-tool-button" : "simple-button";
    return /*#__PURE__*/React__namespace.createElement("button", {
      type: "button",
      className: classes,
      disabled: this.props.disabled,
      onClick: this.props.onClick
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: TouchEvent) => void' is not assignable to type 'TouchEventHandler<HTMLButtonElement>'.
      ,
      onTouchStart: captureScratchpadTouchStart
    }, this.props.children);
  }
}
class ToolsBar extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      selected: null
    });
    _defineProperty(this, "changeSelected", tool => {
      this.props.removeTool(this.state.selected);
      if (!tool || tool === this.state.selected) {
        this.setState({
          selected: null
        });
      } else {
        this.props.addTool(tool);
        this.setState({
          selected: tool
        });
      }
    });
  }
  render() {
    const tools = ___default["default"].map(Transformations, function (tool, type) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React__namespace.createElement(ToolButton, {
          key: type
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          disabled: this.props.apiOptions.readOnly
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          toggled: this.state.selected === type
          // eslint-disable-next-line react/jsx-no-bind
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          onClick: this.changeSelected.bind(this, type)
        }, tool.verbName);
      }
    }, this);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "transformer-tools-bar"
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "simple-button-group"
    }, tools), /*#__PURE__*/React__namespace.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onUndoClick
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: TouchEvent) => void' is not assignable to type 'TouchEventHandler<HTMLButtonElement>'.
      ,
      onTouchStart: captureScratchpadTouchStart
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconUndo), " " + i18n__namespace._("Undo")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clear"
    }));
  }
}
class AddTransformBar extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "changeSelected", tool => {
      if (tool) {
        this.props.addTool(tool);
      }
    });
  }
  render() {
    const tools = ___default["default"].map(Transformations, function (tool, type) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React__namespace.createElement(ToolButton, {
          key: type,
          toggled: false
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          disabled: this.props.apiOptions.readOnly
          // eslint-disable-next-line react/jsx-no-bind
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation. | TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          ,
          onClick: this.changeSelected.bind(this, type)
        }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconPlus), " ", tool.nounName);
      }
    }, this);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "transformer-tools-bar"
    }, tools, /*#__PURE__*/React__namespace.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      onClick: this.props.onUndoClick,
      disabled: this.props.apiOptions.readOnly
      // @ts-expect-error [FEI-5003] - TS2322 - Type '(e: TouchEvent) => void' is not assignable to type 'TouchEventHandler<HTMLButtonElement>'.
      ,
      onTouchStart: captureScratchpadTouchStart
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconUndo), " " + i18n__namespace._("Undo")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clear"
    }));
  }
}
class Transformer extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "tools", void 0);
    _defineProperty(this, "currentTool", void 0);
    _defineProperty(this, "transformations", void 0);
    _defineProperty(this, "shape", void 0);
    _defineProperty(this, "dilationCircle", void 0);
    _defineProperty(this, "rotatePoint", void 0);
    _defineProperty(this, "rotateHandle", void 0);
    _defineProperty(this, "shouldSetupGraphie", (nextProps, prevProps) => {
      if (!deepEq(prevProps.starting, nextProps.starting)) {
        return true;
      }
      if (prevProps.graphMode !== nextProps.graphMode) {
        return true;
      }
      if (prevProps.listMode !== nextProps.listMode) {
        return true;
      }
      if (prevProps.drawSolutionShape !== nextProps.drawSolutionShape) {
        return true;
      }
      if (nextProps.drawSolutionShape && !deepEq(prevProps.correct.shape, nextProps.correct.shape)) {
        return true;
      }
      if (!deepEq(this.tools, nextProps.tools)) {
        return true;
      }
      return false;
    });
    _defineProperty(this, "graphie", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type 'ReactInstance'.
      return this.refs.graph.graphie();
    });
    _defineProperty(this, "setupGraphie", graphie => {
      // A background image of our solution:
      if (this.props.drawSolutionShape && this.props.correct.shape && this.props.correct.shape.coords) {
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 3 arguments, but got 2.
        ShapeTypes.addShape(graphie, {
          fixed: true,
          shape: this.props.correct.shape,
          normalStyle: {
            stroke: KhanColors.GRAY,
            "stroke-dasharray": "",
            "stroke-width": 2
          }
        });
      }
      this.currentTool = null;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'changeSelected' does not exist on type 'ReactInstance'.
      this.refs.toolsBar.changeSelected(null);
      this.addTransformerShape(this.props.starting.shape, /* translatable */false);
      this.setTransformations(this.props.transformations);

      // Save a copy of our tools so that we can check future
      // this.props.tools changes against them
      // This seems weird, but gives us an easy way to tell whether
      // props changes were self-inflicted (for which a graphie reset
      // is not required, and is in fact a bad idea right now because
      // of resetting the size of the dilation tool).
      // TODO (jack): A deepClone method would be nice here
      this.tools = {
        translation: ___default["default"].clone(this.props.tools.translation),
        rotation: ___default["default"].clone(this.props.tools.rotation),
        reflection: ___default["default"].clone(this.props.tools.reflection),
        dilation: ___default["default"].clone(this.props.tools.dilation)
      };
    });
    _defineProperty(this, "setTransformations", transformations => {
      this.resetCoords();
      this.transformations = ___default["default"].clone(transformations);
      ___default["default"].each(this.transformations, this.applyTransform);
    });
    _defineProperty(this, "addTransformerShape", (shape, translatable) => {
      const self = this;
      const graphie = this.graphie();
      this.shape = ShapeTypes.addMovableShape(graphie, {
        shape: shape,
        editable: false,
        showPoints: this.props.graphMode !== "static",
        translatable: translatable,
        onMove: function (dX, dY) {
          dX = KhanMath.roundToNearest(graphie.snap[0], dX);
          dY = KhanMath.roundToNearest(graphie.snap[1], dY);
          // NOTE(kevinb): object is missing .constraints property
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ type: "translation"; vector: [any, any]; }' is not assignable to parameter of type 'PerseusTransformerTransformation'.
          self.addTransform({
            type: "translation",
            vector: [dX, dY]
          });
          return [dX, dY];
        },
        normalPointStyle: {
          fill: translatable ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC,
          stroke: translatable ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC
        },
        highlightPointStyle: {
          fill: KhanColors.INTERACTING,
          stroke: KhanColors.INTERACTING
        }
      });
    });
    _defineProperty(this, "addTool", toolId => {
      const self = this;
      if (this.props.graphMode === "interactive") {
        if (toolId === "translation") {
          this.currentTool = this.addTranslationTool();
        } else if (toolId === "rotation") {
          this.currentTool = this.addRotationTool();
        } else if (toolId === "reflection") {
          this.currentTool = this.addReflectionTool();
        } else if (toolId === "dilation") {
          this.currentTool = this.addDilationTool();
        } else {
          throw new PerseusError("Invalid tool id: " + toolId, Errors.InvalidInput);
        }
      } else {
        let transform;
        if (toolId === "translation") {
          // NOTE(kevinb): object is missing .constraints property
          transform = {
            type: "translation",
            // NOTE(kevib): these should be numbers
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'. | TS2322 - Type 'null' is not assignable to type 'number'.
            vector: [null, null]
          };
        } else if (toolId === "rotation") {
          // NOTE(kevinb): object is missing .constraints property
          transform = {
            type: "rotation",
            // NOTE(kevib): these should be numbers
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'. | TS2322 - Type 'null' is not assignable to type 'number'.
            center: [null, null],
            // NOTE(kevib): this should be a number
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'.
            angleDeg: null
          };
        } else if (toolId === "reflection") {
          // Reflections with nulls in them won't be applied until
          // fills in the blanks
          transform = {
            type: "reflection",
            line: [
            // NOTE(kevib): these should be numbers
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'. | TS2322 - Type 'null' is not assignable to type 'number'.
            [null, null],
            // NOTE(kevib): these should be numbers
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'. | TS2322 - Type 'null' is not assignable to type 'number'.
            [null, null]]
          };
        } else if (toolId === "dilation") {
          // NOTE(kevinb): object is missing .constraints property
          transform = {
            type: "dilation",
            // NOTE(kevib): these should be numbers
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'. | TS2322 - Type 'null' is not assignable to type 'number'.
            center: [null, null],
            // NOTE(kevib): this should be a number
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'null' is not assignable to type 'number'.
            scale: null
          };
        } else {
          throw new PerseusError("Invalid tool id: " + toolId, Errors.InvalidInput);
        }
        this.doTransform(transform, function () {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'focusLast' does not exist on type 'ReactInstance'.
          self.refs.transformationList.focusLast();
        });
      }
    });
    _defineProperty(this, "removeTool", toolId => {
      if (this.currentTool) {
        this.currentTool.remove();
      }
      this.currentTool = null;
    });
    _defineProperty(this, "addTranslationTool", () => {
      var _this$shape, _this$shape2;
      const self = this;
      (_this$shape = this.shape) === null || _this$shape === void 0 ? void 0 : _this$shape.remove();
      this.addTransformerShape((_this$shape2 = this.shape) === null || _this$shape2 === void 0 ? void 0 : _this$shape2.toJSON(), /* translatable */true);
      return {
        remove: function () {
          var _self$shape, _self$shape2;
          (_self$shape = self.shape) === null || _self$shape === void 0 ? void 0 : _self$shape.remove();
          self.addTransformerShape((_self$shape2 = self.shape) === null || _self$shape2 === void 0 ? void 0 : _self$shape2.toJSON(), /* translatable */false);
        }
      };
    });
    _defineProperty(this, "snapCoord", coord => {
      const graphie = this.graphie();
      return ___default["default"].map(coord, function (val, dim) {
        return KhanMath.roundToNearest(graphie.snap[dim], val);
      });
    });
    _defineProperty(this, "normalizeReflectionCoords", messyCoords => {
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Point' is not assignable to parameter of type 'Coord'.
      const midpoint = this.snapCoord(kmath.line.midpoint(messyCoords));
      const origDirectionPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(messyCoords[0], messyCoords[1]));
      const direction = kmath.vector.cartFromPolarDeg(1, KhanMath.roundToNearest(45, origDirectionPolar[1]));
      const coords = ___default["default"].map([-1, 1], function (directionCoefficient) {
        const coord = kmath.vector.add(midpoint, kmath.vector.scale(direction, directionCoefficient *
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST)));
        // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
        return this.snapCoord(coord);
      }, this);
      return coords;
    });
    _defineProperty(this, "addReflectionTool", () => {
      const options = this.props.tools.reflection;
      if (!options.enabled) {
        return;
      }
      const self = this;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type 'ReactInstance'.
      const graphie = this.refs.graph.graphie();
      const updateReflectionTool = function () {
        self.changeTool("reflection", {
          coords: ___default["default"].pluck(reflectPoints, "coord")
        });
      };
      const coords = this.normalizeReflectionCoords(options.coords);

      // The points defining the line of reflection; hidden from the
      // user.
      const reflectPoints = ___default["default"].map(coords, function (coord) {
        return graphie.addMovablePoint({
          coord: coord,
          visible: false
        });
      }, this);

      // the line of reflection
      // TODO(jack): graphie.style here is a hack to prevent the dashed
      // style from leaking into the rest of the shapes. Remove when
      // graphie.addMovableLineSegment doesn't leak styles anymore.
      let reflectLine;
      const normalColor = colorForTool(options);
      graphie.style({}, function () {
        reflectLine = graphie.addMovableLineSegment({
          fixed: options.constraints.fixed,
          constraints: options.constraints,
          pointA: reflectPoints[0],
          pointZ: reflectPoints[1],
          snapX: graphie.snap[0],
          snapY: graphie.snap[1],
          extendLine: true,
          normalStyle: {
            stroke: normalColor,
            "stroke-width": 2,
            "stroke-dasharray": "- "
          },
          highlightStyle: {
            stroke: KhanColors.INTERACTING,
            "stroke-width": 2,
            "stroke-dasharray": "- " // TODO(jack) solid doesn't
            // work here, but would be
            // nicer
          },

          movePointsWithLine: true,
          onMoveEnd: updateReflectionTool
        });
      });

      // the "button" point in the center of the line of reflection
      const reflectButton = graphie.addReflectButton({
        fixed: options.constraints.fixed,
        line: reflectLine,
        size: this.scaleToCurrentRange(REFLECT_BUTTON_SIZE),
        onClick: function () {
          self.doTransform({
            type: "reflection",
            // @ts-expect-error [FEI-5003] - TS2322 - Type 'any[]' is not assignable to type '[Coord, Coord]'.
            line: ___default["default"].pluck(reflectPoints, "coord")
          });
          if (reflectRotateHandle) {
            // flip the rotation handle
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'setCoord' does not exist on type 'never'.
            reflectRotateHandle.setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.subtract(reflectButton.coord,
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'coord' does not exist on type 'never'.
            reflectRotateHandle.coord)));
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'update' does not exist on type 'never'.
            reflectRotateHandle.update();
          }
        },
        normalStyle: {
          stroke: normalColor,
          "stroke-width": 2,
          fill: normalColor
        },
        highlightStyle: {
          stroke: KhanColors.INTERACTING,
          "stroke-width": 3,
          fill: KhanColors.INTERACTING
        },
        onMoveEnd: updateReflectionTool
      });
      let reflectRotateHandle = null;
      if (!options.constraints.fixed) {
        // The rotation handle for rotating the line of reflection
        const initRotateHandleAngle = kmath.vector.polarDegFromCart(kmath.vector.subtract(reflectPoints[1].coord, reflectPoints[0].coord))[1] + 90; // 90 degrees off of the line
        reflectRotateHandle = graphie.addRotateHandle({
          center: reflectButton,
          radius: this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST),
          angleDeg: initRotateHandleAngle,
          width: this.scaleToCurrentRange(0.24),
          hoverWidth: this.scaleToCurrentRange(0.4),
          lengthAngle: 17,
          onMove: function (newAngle) {
            return KhanMath.roundToNearest(45, newAngle);
          },
          onMoveEnd: updateReflectionTool
        });
      }

      // Move the reflectButton and reflectRotateHandle with the line
      $__default["default"](reflectLine).on("move", function () {
        reflectButton.update();
        $__default["default"](reflectButton).trigger("move"); // update the rotation handle,
        // which watches for this in util/interactive.js.
      });

      // Update the line and reflect button when the reflectRotateHandle is
      // rotated
      if (reflectRotateHandle) {
        $__default["default"](reflectRotateHandle).on("move", function () {
          const rotateHandleApprox = self.snapCoord(
          // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'.
          reflectRotateHandle.coord);
          const rotateVector = kmath.vector.subtract(rotateHandleApprox, reflectButton.coord);
          const flipped = reflectButton.isFlipped() ? 1 : 0;
          reflectPoints[flipped].setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.rotateDeg(rotateVector, 90)));
          reflectPoints[1 - flipped].setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.rotateDeg(rotateVector, -90)));
          reflectLine.transform(true);
          reflectButton.update();
        });
      }
      return {
        remove: function () {
          reflectButton.remove();
          if (reflectRotateHandle) {
            // @ts-expect-error [FEI-5003] - TS2339 - Property 'remove' does not exist on type 'never'.
            reflectRotateHandle.remove();
          }
          reflectLine.remove();
          reflectPoints[0].remove();
          reflectPoints[1].remove();
        }
      };
    });
    _defineProperty(this, "scaleToCurrentRange", dist => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type 'ReactInstance'.
      return scaleToRange(dist, this.refs.graph.props.range);
    });
    _defineProperty(this, "addRotationTool", () => {
      const options = this.props.tools.rotation;
      if (!options.enabled) {
        return;
      }
      const self = this;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type 'ReactInstance'.
      const graphie = this.refs.graph.graphie();
      const pointColor = colorForTool(options);
      // The center of our rotation, which can be moved to change the
      // center of rotation
      this.rotatePoint = graphie.addMovablePoint({
        constraints: options.constraints,
        coord: options.coord,
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        normalStyle: {
          // ugh, this seems to be a global and
          "stroke-dasharray": "",
          // is set to dash above
          stroke: pointColor,
          fill: pointColor
        },
        highlightStyle: {
          "stroke-dasharray": "",
          stroke: KhanColors.INTERACTING,
          fill: KhanColors.INTERACTING
        }
      });

      // The point that we move around the center of rotation to actually
      // cause rotations
      this.rotateHandle = graphie.addRotateHandle({
        center: this.rotatePoint,
        radius: this.scaleToCurrentRange(ROTATE_HANDLE_DIST),
        width: this.scaleToCurrentRange(0.24),
        hoverWidth: this.scaleToCurrentRange(0.4),
        onMove: function (newAngle, oldAngle) {
          const transform = self.getRotationTransformFromAngle(self.rotatePoint.coord, newAngle - oldAngle);

          // Rotate polygon with rotateHandle
          self.doTransform(transform);

          // @ts-expect-error [FEI-5003] - TS2339 - Property 'angleDeg' does not exist on type 'PerseusTransformerTransformation'.
          return oldAngle + transform.angleDeg;
        }
      });

      // Update tools.rotation.coord
      this.rotatePoint.onMoveEnd = (x, y) => {
        self.changeTool("rotation", {
          coord: [x, y]
        });
      };
      return {
        remove: function () {
          var _self$rotateHandle, _self$rotatePoint;
          (_self$rotateHandle = self.rotateHandle) === null || _self$rotateHandle === void 0 ? void 0 : _self$rotateHandle.remove();
          (_self$rotatePoint = self.rotatePoint) === null || _self$rotatePoint === void 0 ? void 0 : _self$rotatePoint.remove();
        }
      };
    });
    _defineProperty(this, "addDilationTool", () => {
      const options = this.props.tools.dilation;
      if (!options.enabled) {
        return;
      }
      const self = this;
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'graphie' does not exist on type 'ReactInstance'.
      const graphie = this.refs.graph.graphie();
      const pointColor = colorForTool(options);
      // the circle for causing dilation transforms
      self.dilationCircle = graphie.addCircleGraph({
        centerConstraints: options.constraints,
        center: options.coord,
        radius: self.scaleToCurrentRange(2),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        minRadius: self.scaleToCurrentRange(1),
        snapRadius: self.scaleToCurrentRange(0.5),
        onResize: function (newRadius, oldRadius) {
          // NOTE(kevinb): object is missing .constraints property
          // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '{ type: "dilation"; center: any; scale: number; }' is not assignable to parameter of type 'PerseusTransformerTransformation'.
          self.doTransform({
            type: "dilation",
            // NOTE(kevinb): It's hard to convince that this.dilationCircle
            // will still be defined here.                    center: self.dilationCircle.centerPoint.coord,
            scale: newRadius / oldRadius
          });
        },
        circleNormalStyle: {
          stroke: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": "- ",
          "fill-opacity": 0
        },
        circleHighlightStyle: {
          stroke: KhanColors.INTERACTING,
          "stroke-width": 2,
          "stroke-dasharray": "",
          fill: KhanColors.INTERACTING,
          "fill-opacity": 0.05
        },
        centerNormalStyle: {
          stroke: pointColor,
          fill: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": ""
        },
        centerHighlightStyle: {
          stroke: pointColor,
          fill: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": ""
        }
      });
      const origOnMoveEnd = this.dilationCircle.centerPoint.onMoveEnd;
      this.dilationCircle.centerPoint.onMoveEnd = function () {
        if (origOnMoveEnd) {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          origOnMoveEnd(args);
        }
        self.changeTool("dilation", {
          coord: self.dilationCircle.centerPoint.coord
        });
      };
      return {
        remove: function () {
          var _self$dilationCircle;
          (_self$dilationCircle = self.dilationCircle) === null || _self$dilationCircle === void 0 ? void 0 : _self$dilationCircle.remove();
        }
      };
    });
    _defineProperty(this, "getRotationTransformFromAngle", (center, angleChanged) => {
      angleChanged = (angleChanged + 360) % 360;
      if (angleChanged > 180) {
        angleChanged -= 360;
      }
      const roundedAngle = Math.round(angleChanged / ROTATE_SNAP_DEGREES) * ROTATE_SNAP_DEGREES;

      // NOTE(kevinb): return object is missing .constraints property
      return {
        type: "rotation",
        center: center,
        angleDeg: roundedAngle
      };
    });
    _defineProperty(this, "doTransform", (transform, callback) => {
      this.applyTransform(transform);
      this.addTransform(transform, callback);
    });
    _defineProperty(this, "applyTransform", transform => {
      if (this.props.graphMode !== "static") {
        const transformFunc = TransformOps.apply(transform);
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(coord: any) => any' is not assignable to parameter of type 'PerseusTransformerTransformation'.
        this.applyCoordTransformation(transformFunc);
      }
    });
    _defineProperty(this, "applyCoordTransformation", pointTransform => {
      var _this$shape3;
      ___default["default"].each(this.shape.points, function (point) {
        // @ts-expect-error [FEI-5003] - TS2349 - This expression is not callable.
        const newCoord = pointTransform(point.coord);
        point.setCoord(newCoord);
      });
      (_this$shape3 = this.shape) === null || _this$shape3 === void 0 ? void 0 : _this$shape3.update();
    });
    _defineProperty(this, "resetCoords", () => {
      var _this$shape4;
      const startCoords = this.props.starting.shape.coords;
      ___default["default"].each(this.shape.points, function (point, i) {
        point.setCoord(startCoords[i]);
      });
      (_this$shape4 = this.shape) === null || _this$shape4 === void 0 ? void 0 : _this$shape4.update();
    });
    _defineProperty(this, "handleUndoClick", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'changeSelected' does not exist on type 'ReactInstance'.
      this.refs.toolsBar.changeSelected(null);
      if (this.props.transformations.length) {
        this.props.onChange({
          transformations: ___default["default"].initial(this.props.transformations)
        });
      }
    });
    _defineProperty(this, "setTransformationProps", (newTransfomationList, callback) => {
      this.props.onChange({
        transformations: newTransfomationList
      },
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '(arg1: any) => unknown' is not assignable to parameter of type '() => unknown'.
      callback);
    });
    _defineProperty(this, "addTransform", (transform, callback) => {
      this.transformations = TransformOps.append(this.transformations, transform);
      this.props.onChange({
        transformations: ___default["default"].clone(this.transformations)
      },
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type '((arg1: any) => unknown) | undefined' is not assignable to parameter of type '(() => unknown) | undefined'.
      callback);
    });
    _defineProperty(this, "changeTool", (tool, changes) => {
      const newTools = ___default["default"].clone(this.props.tools);
      newTools[tool] = ___default["default"].extend({}, this.props.tools[tool], changes);
      this.tools[tool] = ___default["default"].clone(newTools[tool]);
      this.props.onChange({
        // @ts-expect-error [FEI-5003] - TS2740 - Type '{ dilation: DilationTool; reflection: ReflectionTool; rotation: RotationTool; translation: TranslationTool; }' is missing the following properties from type 'readonly any[]': length, concat, join, slice, and 18 more.
        tools: newTools
      });
      this.props.trackInteraction();
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Transformer.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "getCoords", () => {
      const startCoords = this.props.starting.shape.coords;
      const transforms = this.props.transformations;
      return ___default["default"].reduce(transforms, function (coords, transform) {
        return ___default["default"].map(coords, TransformOps.apply(transform));
      }, startCoords);
    });
    _defineProperty(this, "getEditorJSON", () => {
      const json = ___default["default"].pick(this.props, "grading", "starting", "graphMode", "listMode", "tools", "drawSolutionShape", "gradeEmpty");
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'graph' does not exist on type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "tools" | "starting" | "drawSolutionShape" | "gradeEmpty" | "graphMode" | "listMode">'. | TS2339 - Property 'toJSON' does not exist on type 'ReactInstance'.
      json.graph = this.refs.graph.toJSON();
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'version' does not exist on type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "tools" | "starting" | "drawSolutionShape" | "gradeEmpty" | "graphMode" | "listMode">'.
      json.version = 1.2; // Give us some safety to change the format
      // when we realize that I wrote
      // a horrible json spec for this widget

      // @ts-expect-error [FEI-5003] - TS2339 - Property 'answer' does not exist on type 'Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "tools" | "starting" | "drawSolutionShape" | "gradeEmpty" | "graphMode" | "listMode">'.
      json.answer = this.getUserInput();
      return json;
    });
    _defineProperty(this, "getUserInput", () => {
      var _this$shape5;
      return {
        transformations: this.props.transformations,
        // This doesn't call this.shape.toJSON() because that doesn't
        // handle coordinates in formal mode without movement, since
        // the movablepoints never move
        shape: {
          type: this.shape.type,
          coords: this.getCoords(),
          options: (_this$shape5 = this.shape) === null || _this$shape5 === void 0 ? void 0 : _this$shape5.getOptions()
        }
      };
    });
    _defineProperty(this, "_handleFocus", function () {
      for (var _len2 = arguments.length, path = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        path[_key2] = arguments[_key2];
      }
      _this.props.onFocus(path);
    });
    _defineProperty(this, "_handleBlur", function () {
      for (var _len3 = arguments.length, path = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        path[_key3] = arguments[_key3];
      }
      _this.props.onBlur(path);
    });
    _defineProperty(this, "_getTransformationForID", transformationID => {
      // Returns the 'transformation' component corresponding to a given ID
      const refPath = ["transformationList", "transformation" + transformationID];

      // Follow the path of references
      let component = this;
      ___default["default"].each(refPath, ref => {
        // @ts-expect-error [FEI-5003] - TS2322 - Type 'ReactInstance' is not assignable to type 'this'.
        component = component.refs[ref];
      });
      return component;
    });
    _defineProperty(this, "getInputPaths", () => {
      // If we're in static mode, then there is no transformation list, and,
      // as a result, no input paths.
      if (this.props.listMode === "static") {
        return [];
      }
      let inputPaths = [];
      ___default["default"].each(this.props.transformations, (transformation, i) => {
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'number' is not assignable to parameter of type 'string'.
        transformation = this._getTransformationForID(i);
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getInputPaths' does not exist on type 'PerseusTransformerTransformation'.
        const innerPaths = transformation.getInputPaths();
        const fullPaths = ___default["default"].map(innerPaths, innerPath => {
          return ["" + i].concat(innerPath);
        });
        // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string[][]' is not assignable to parameter of type 'ConcatArray<never>'.
        inputPaths = inputPaths.concat(fullPaths);
      });
      return inputPaths;
    });
    _defineProperty(this, "_passToInner", function (functionName, path) {
      if (!path || !path.length) {
        return;
      }

      // First argument tells us which transformation will receive the call;
      // remaining arguments are used within that transformation to identify
      // a specific input.
      const innerPath = ___default["default"].rest(path);

      // Pass arguments down to appropriate 'transformation' component
      const transformationID = ___default["default"].head(path);
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      const caller = this._getTransformationForID(transformationID);
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }
      return caller[functionName](innerPath, ...args);
    });
    _defineProperty(this, "focus", () => {
      // Just focus the first showing input
      const inputs = this.getInputPaths();
      if (inputs.length > 0) {
        this.focusInputPath(inputs[0]);
        return true;
      }
      return false;
    });
    _defineProperty(this, "focusInputPath", path => {
      // Since the transformer exposes the input API, it needs to be robust
      // to empty paths. We don't expect this to happen, as entire-widget
      // focusing is typically done through the focus() method, which already
      // handles the empty path case properly, but it's better to be safe
      // here.
      if (path.length === 0) {
        return false;
      }
      assert(path.length >= 2);
      return this._passToInner("focusInputPath", path);
    });
    _defineProperty(this, "blurInputPath", path => {
      // Since the transformer exposes the input API, it needs to be robust
      // to empty paths (which indicate a blurring of the entire widget,
      // e.g., when switching from interacting with the transformer to
      // interacting with some other widget).
      if (path.length === 0) {
        return false;
      }
      assert(path.length >= 2);
      return this._passToInner("blurInputPath", path);
    });
    _defineProperty(this, "setInputValue", (path, value, cb) => {
      assert(path.length >= 2);
      return this._passToInner("setInputValue", path, value, cb);
    });
    _defineProperty(this, "getDOMNodeForPath", path => {
      assert(path.length >= 2);
      return this._passToInner("getDOMNodeForPath", path);
    });
    _defineProperty(this, "getGrammarTypeForPath", path => {
      assert(path.length >= 2);
      return this._passToInner("getGrammarTypeForPath", path);
    });
  }
  render() {
    // Fill in any missing value in this.props.graph
    // this can happen because the graph json doesn't include
    // box, for example
    const graph = ___default["default"].extend(defaultGraphProps(this.props.graph, defaultBoxSize), this.props.graph);
    const interactiveToolsMode = this.props.graphMode === "interactive";
    const ToolsBarClass = interactiveToolsMode ? ToolsBar : AddTransformBar;

    // This style is applied inline because it is dependent on the
    // size of the graph as set by the graph.box prop, and this also
    // lets us specify it in the same place the graph's width is
    // specified.
    const toolsBar = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        width: graph.box[0]
      }
    }, /*#__PURE__*/React__namespace.createElement(ToolsBarClass
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "toolsBar",
      enabled: pluckObject(this.props.tools, "enabled"),
      apiOptions: this.props.apiOptions,
      addTool: this.addTool,
      removeTool: this.removeTool,
      onUndoClick: this.handleUndoClick
    }));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-transformer"
    }, /*#__PURE__*/React__namespace.createElement(Graph
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "graph",
      box: graph.box,
      range: graph.range,
      labels: graph.labels,
      step: graph.step,
      gridStep: graph.gridStep,
      markings: graph.markings,
      backgroundImage: graph.backgroundImage,
      showProtractor: graph.showProtractor,
      onGraphieUpdated: this.setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }), !interactiveToolsMode && i18n__namespace._("Add transformations below:"), this.props.graphMode === "static" && [/*#__PURE__*/React__namespace.createElement("br", {
      key: "static-br"
    }), /*#__PURE__*/React__namespace.createElement("em", {
      key: "static-nomove"
    }, " ", i18n__namespace._("Note: For this question, the shape will not move."), " ")], interactiveToolsMode && toolsBar, /*#__PURE__*/React__namespace.createElement(TransformationList
    // eslint-disable-next-line react/no-string-refs
    , {
      ref: "transformationList",
      mode: this.props.listMode,
      transformations: this.props.transformations,
      onChange: this.setTransformationProps,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      keypadElement: this.props.keypadElement,
      apiOptions: this.props.apiOptions
    }), !interactiveToolsMode && toolsBar);
  }
  componentDidMount() {
    this.setupGraphie(this.graphie());
  }
  componentDidUpdate(prevProps) {
    if (this.shouldSetupGraphie(this.props, prevProps)) {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'reset' does not exist on type 'ReactInstance'.
      this.refs.graph.reset();
    } else if (!deepEq(this.props.transformations, this.transformations)) {
      this.setTransformations(this.props.transformations);
    }
  }
  static validate(guess, rubric) {
    // Check for any required transformations
    for (const type in Transformations) {
      if (rubric.tools[type].required) {
        const isUsed = ___default["default"].any(___default["default"].map(guess.transformations, function (transform) {
          // Required transformations must appear in the
          // transformation list, and must not be no-ops
          return transform.type === type && !TransformOps.isEmpty(transform) && !TransformOps.isNoOp(transform);
        }));
        if (!isUsed) {
          return {
            type: "invalid",
            message: i18n__namespace._("Your transformation must use a " + "%(type)s.", {
              type: Transformations[type].lowerNounName
            })
          };
        }
      }
    }

    // Compare shapes
    if (ShapeTypes.equal(guess.shape, rubric.correct.shape)) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    }
    if (!rubric.gradeEmpty && deepEq(guess.shape.coords, rubric.starting.shape.coords)) {
      return {
        type: "invalid",
        message: i18n__namespace._("Use the interactive graph to define a " + "correct transformation.")
      };
    }
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }
}
_defineProperty(Transformer, "defaultProps", ___default["default"].defaults({
  transformations: []
}, defaultTransformerProps));
var Transformer$1 = {
  name: "transformer",
  displayName: "Transformer",
  widget: Transformer
};

var hubble = {exports: {}};

(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
	  module.exports = factory();
	})(commonjsGlobal, function () {
	  return (/******/function (modules) {
	      // webpackBootstrap
	      /******/ // The module cache
	      /******/
	      var installedModules = {};
	      /******/
	      /******/ // The require function
	      /******/
	      function __webpack_require__(moduleId) {
	        /******/
	        /******/ // Check if module is in cache
	        /******/if (installedModules[moduleId]) {
	          /******/return installedModules[moduleId].exports;
	          /******/
	        }
	        /******/ // Create a new module (and put it into the cache)
	        /******/
	        var module = installedModules[moduleId] = {
	          /******/i: moduleId,
	          /******/l: false,
	          /******/exports: {}
	          /******/
	        };
	        /******/
	        /******/ // Execute the module function
	        /******/
	        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	        /******/
	        /******/ // Flag the module as loaded
	        /******/
	        module.l = true;
	        /******/
	        /******/ // Return the exports of the module
	        /******/
	        return module.exports;
	        /******/
	      }
	      /******/
	      /******/
	      /******/ // expose the modules object (__webpack_modules__)
	      /******/
	      __webpack_require__.m = modules;
	      /******/
	      /******/ // expose the module cache
	      /******/
	      __webpack_require__.c = installedModules;
	      /******/
	      /******/ // define getter function for harmony exports
	      /******/
	      __webpack_require__.d = function (exports, name, getter) {
	        /******/if (!__webpack_require__.o(exports, name)) {
	          /******/Object.defineProperty(exports, name, {
	            /******/configurable: false,
	            /******/enumerable: true,
	            /******/get: getter
	            /******/
	          });
	          /******/
	        }
	        /******/
	      };
	      /******/
	      /******/ // getDefaultExport function for compatibility with non-harmony modules
	      /******/
	      __webpack_require__.n = function (module) {
	        /******/var getter = module && module.__esModule ? /******/function getDefault() {
	          return module['default'];
	        } : /******/function getModuleExports() {
	          return module;
	        };
	        /******/
	        __webpack_require__.d(getter, 'a', getter);
	        /******/
	        return getter;
	        /******/
	      };
	      /******/
	      /******/ // Object.prototype.hasOwnProperty.call
	      /******/
	      __webpack_require__.o = function (object, property) {
	        return Object.prototype.hasOwnProperty.call(object, property);
	      };
	      /******/
	      /******/ // __webpack_public_path__
	      /******/
	      __webpack_require__.p = "";
	      /******/
	      /******/ // Load entry module and return exports
	      /******/
	      return __webpack_require__(__webpack_require__.s = 1);
	      /******/
	    }
	    /************************************************************************/
	    /******/([/* 0 */
	    /***/function (module, exports) {
	      var isObject = function (obj) {
	        return obj === Object(obj);
	      };
	      var merge = function () {
	        var obj = {};
	        for (var i = 0; i < arguments.length; i++) {
	          var source = arguments[i];
	          if (source) {
	            for (var prop in source) {
	              obj[prop] = source[prop];
	            }
	          }
	        }
	        return obj;
	      };
	      var clone = function (obj) {
	        if (!isObject(obj)) {
	          return obj;
	        }
	        return Array.isArray(obj) ? obj.slice() : merge(obj);
	      };
	      module.exports = {
	        isObject: isObject,
	        merge: merge,
	        clone: clone
	      };

	      /***/
	    }, /* 1 */
	    /***/function (module, exports, __webpack_require__) {
	      /* TODO batch *all* mutations
	       * idea: freeze / thaw implementations for all types
	       * lens constructor thaws, freeze delegates to type's freeze
	       */

	      var util = __webpack_require__(0);
	      var clone = util.clone;
	      var isObject = util.isObject;
	      var merge = util.merge;
	      var arr = __webpack_require__(2);
	      var obj = __webpack_require__(3);
	      var str = __webpack_require__(4);

	      // equivalents, without requiring it
	      // find the implementation to use for a given object
	      var dispatch = function (x) {
	        if (Array.isArray(x)) {
	          return arr;
	        } else if (isObject(x)) {
	          return obj;
	        } else if (typeof x === "string") {
	          return str;
	        }
	      };

	      // This is underscore with a different name
	      var lens = function (obj) {
	        if (obj instanceof lens) {
	          return obj;
	        }
	        if (!(this instanceof lens)) {
	          return new lens(obj);
	        }
	        var ops = dispatch(obj);
	        this._wrapped = ops.thaw ? ops.thaw(obj) : obj;
	      };
	      lens.prototype.freeze = function () {
	        var obj = this._wrapped;
	        var ops = dispatch(obj);
	        return ops.freeze ? ops.freeze(obj) : obj;
	      };
	      lens.prototype.zoom = function (lensArr) {
	        if (this._zoomStack === undefined) {
	          this._zoomStack = [];
	        }
	        this._zoomStack.push({
	          zoom: lensArr,
	          wrapped: this._wrapped
	        });
	        this._wrapped = lens(this._wrapped).get(lensArr);
	        return this;
	      };
	      lens.prototype.deZoom = function () {
	        var frame = this._zoomStack.pop();
	        this._wrapped = lens(frame.wrapped).set(frame.zoom, this._wrapped).freeze();
	        return this;
	      };
	      lens.prototype.get = function (lensArr) {
	        var obj = this._wrapped;
	        for (var i = 0; i < lensArr.length; i++) {
	          obj = dispatch(obj).get(obj, lensArr[i]);
	        }
	        return obj;
	      };
	      lens.prototype.mod = function (lensArr, f) {
	        var obj = this._wrapped;
	        var newObj = clone(obj);
	        var ops = dispatch(obj);
	        if (lensArr.length === 0) {
	          this._wrapped = f(this._wrapped);
	        } else if (lensArr.length === 1) {
	          this._wrapped = ops.mod(newObj, lensArr[0], f);
	        } else {
	          var monocle = lensArr[0];
	          var shortLens = lensArr.slice(1);

	          // newObj = ops.mod(obj[monocle], shortLens, f);

	          newObj[monocle] = lens(obj[monocle]).mod(shortLens, f).freeze();
	          this._wrapped = newObj;
	        }
	        return this;
	      };

	      // TODO - move to individual files
	      lens.prototype.merge = function (lensArr, props) {
	        this._wrapped = lens(this._wrapped).mod(lensArr, function (oldProps) {
	          return merge(oldProps, props);
	        }).freeze();
	        return this;
	      };

	      // Lens must have length >= 1 or there would be nothing to return
	      lens.prototype.del = function (lensArr) {
	        var obj = this._wrapped;
	        var ops = dispatch(obj);
	        if (lensArr.length === 1) {
	          this._wrapped = ops.del(obj, lensArr[0]);
	        } else {
	          var monocle = lensArr[0];
	          var shortLens = lensArr.slice(1);
	          var newObj = clone(obj);
	          newObj[monocle] = lens(obj[monocle]).del(shortLens).freeze();
	          this._wrapped = newObj;
	        }
	        return this;
	      };
	      lens.prototype.set = function (lensArr, set) {
	        return this.mod(lensArr, function () {
	          return set;
	        });
	      };
	      module.exports = lens;

	      /***/
	    }, /* 2 */
	    /***/function (module, exports) {
	      var get = function (arr, monocle) {
	        return arr[monocle];
	      };
	      var set = function (arr, monocle, val) {
	        var newArr = arr.splice();
	        newArr[monocle] = val;
	        return newArr;
	      };
	      var mod = function (arr, monocle, f) {
	        var newArr = arr.slice();
	        newArr[monocle] = f(arr[monocle]);
	        return newArr;
	      };
	      var del = function (arr, monocle) {
	        var newArr = arr.slice();
	        newArr.splice(monocle, 1);
	        return newArr;
	      };

	      /*
	      // Lens must point to a member of an array. We'll insert into that array.
	      lens.prototype.insertAt = function(lensArr, toInsert) {
	          var obj = this._wrapped;
	      
	          var arrLens = lensArr.slice(0, -1);
	          var arr = lens(obj).get(arrLens).slice(); // slice to copy
	      
	          var arrIdx = lensArr[lensArr.length-1];
	          arr.splice(arrIdx, 0, toInsert);
	          return lens(obj).set(arrLens, arr);
	      };
	      
	      lens.prototype.insertBefore = lens.prototype.insertAt;
	      lens.prototype.insertAfter = function(lensArr, toInsert) {
	          var newLens = lensArr.slice();
	          newLens[newLens.length-1] += 1;
	          return lens(this._wrapped).insertAt(newLens, toInsert);
	      };
	      */

	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };

	      /***/
	    }, /* 3 */
	    /***/function (module, exports, __webpack_require__) {
	      var clone = __webpack_require__(0).clone;
	      var get = function (obj, monocle) {
	        return obj[monocle];
	      };
	      var set = function (obj, monocle, val) {
	        var newObj = clone(obj);
	        newObj[monocle] = val;
	        return newObj;
	      };
	      var mod = function (obj, monocle, f) {
	        var newObj = clone(obj);
	        newObj[monocle] = f(obj[monocle]);
	        return newObj;
	      };
	      var del = function (obj, monocle) {
	        var newObj = clone(obj);
	        delete newObj[monocle];
	        return newObj;
	      };
	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };

	      /***/
	    }, /* 4 */
	    /***/function (module, exports) {
	      var get = function (arr, monocle) {
	        return arr[monocle];
	      };
	      var set = function (arr, monocle, val) {
	        var newArr = arr.splice();
	        newArr[monocle] = val;
	        return newArr;
	      };
	      var mod = function (arr, monocle, f) {
	        var newArr = arr.splice();
	        newArr[monocle] = f(arr[monocle]);
	        return newArr;
	      };
	      var del = function (arr, monocle) {
	        var newArr = arr.slice();
	        newArr.splice(monocle);
	        return newArr;
	      };
	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };

	      /***/
	    }
	    /******/])
	  );
	});
} (hubble));

var lens = /*@__PURE__*/getDefaultExportFromCjs(hubble.exports);

/* eslint-disable eqeqeq, @typescript-eslint/no-unused-vars */
/*
 * A class for formatting number to significant digits.
 * Copyright (C) 2001 Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding?JavaScript+Significant+Figures
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**
 * An object tho both scans floating points to
 * determine the number of significant figures.
 * and can display a floating point using any number
 * of significant figures.
 *
 * @param s A string representation of a floating point.
 */
class SignificantFigures {
  constructor(s) {
    _defineProperty(this, "order", void 0);
    _defineProperty(this, "mantissa", void 0);
    _defineProperty(this, "positive", void 0);
    _defineProperty(this, "sigFigs", void 0);
    _defineProperty(this, "sigDecs", void 0);
    this.order = parseOrder(s);
    this.mantissa = parseMantissa(s);
    this.positive = parseSign(s);

    /**
     * Get the number of significant figures this object uses.
     * Leading zeros are not significant.  Traling zeros up to
     * and after the decimal point are significant.
     * Significant figures is good to know when the number is
     * used in multiplication.
     *
     * @return the number of significant figures.
     */
    this.sigFigs = this.mantissa.length;

    /**
     * Get the least significant decimal this object uses.
     * This is useful to know if a number is being used
     * in addition.
     * 400 - 2 the hundreds place (10^2) is the least significant decimal.
     * 75 - 0 the ones place (10^0) is the least significant decimal.
     * .543 - -3 the 1/1000's place (10^-3) is the least significant decimal.
     *
     * @return an integer representing the least significant decimal place.
     */
    this.sigDecs = this.order - this.mantissa.length;
  }
}

/**
 * Format a floating point for display using the specified
 * number of significant figures and least significant decimal.
 * Scientific notation may used by this method if this
 * object is very small, very large, has many significant
 * figures, or the number of significant figures would be
 * ambiguous in the output if scientific notation were not
 * used.
 *
 * @param f A floating point number that should be displayed
 * @param sigFigs desired number of significant figures (integer).
 * @param sigDecs the least significant decimal place (integer).
 * @param scientific true iff scientific notation should always be used.
 * @return a string of this object formatted correctly.
 */
function displaySigFigs(f, sigFigs, sigDecs, scientific) {
  const s = "" + f;
  let order = parseOrder(s);
  let mantissa = parseMantissa(s);
  let positive = parseSign(s);
  let add;
  let decAdd;
  let sigAdd;
  let zeroScientific = false;
  if (f == 0 || mantissa == "" || mantissa == "0") {
    mantissa = "";
    for (let i = 0; i < sigFigs; i++) {
      mantissa += "0";
    }
    order = sigFigs + sigDecs;
    if (sigDecs < 0 && -sigDecs >= sigFigs) {
      zeroScientific = true;
    }
  } else {
    decAdd = order - mantissa.length - sigDecs;
    sigAdd = sigFigs - mantissa.length;
    add = Math.min(sigAdd, decAdd);
    if (add < 0) {
      let rounded = round(mantissa, -add);
      if (rounded.length > mantissa.length + add) {
        order++;
        if (decAdd > sigAdd) {
          rounded = round(rounded, 1);
        }
      }
      mantissa = rounded;
    } else if (add > 0) {
      for (let i = 0; i < add; i++) {
        mantissa += "0";
      }
    }
    if (mantissa == "" || mantissa == "0") {
      mantissa = "0";
      positive = true;
      order = 1 + sigDecs;
      if (order != 0) {
        zeroScientific = true;
      }
    }
  }
  const useScientific = scientific || mantissa.length > 20 || order > 4 || order < -2 || order - mantissa.length > 0 && trailingZeros(mantissa) > 0 || zeroScientific;
  let returnVal = "";
  if (!positive) {
    returnVal += "-";
  }
  if (useScientific) {
    returnVal += mantissa.charAt(0);
    if (mantissa.length > 1) {
      returnVal += "." + mantissa.substring(1, mantissa.length);
    }
    if (order - 1 != 0) {
      returnVal += " x 10^" + (order - 1);
    }
  } else {
    let wholePart = "";
    let fractPart = "";
    let needDot = true;
    if (order > 0) {
      if (mantissa.length > order) {
        wholePart = mantissa.substring(0, order);
        fractPart = mantissa.substring(order, mantissa.length);
      } else {
        wholePart = mantissa;
        needDot = trailingZeros(mantissa) != 0;
        for (let i = 0; i < order - mantissa.length; i++) {
          wholePart += "0";
        }
      }
    } else {
      for (let i = 0; i < -order; i++) {
        fractPart += "0";
      }
      fractPart += mantissa;
    }
    returnVal += (wholePart == "" ? "0" : wholePart) + (needDot ? "." : "") + fractPart;
  }
  return returnVal;
}

/**
 * Count the significant trailing zeros on this object.
 *
 * @return the number of trailing zeros
 */
function trailingZeros(mantissa) {
  let zeros = 0;
  for (let i = mantissa.length - 1; i >= 0; i--) {
    const c = mantissa.charAt(i);
    if (c == "0") {
      zeros++;
    } else {
      return zeros;
    }
  }
  return zeros;
}

/**
 * Parse a string representation of a floating point
 * and pull out the sign.
 *
 * @param s the string representation of a floating point.
 * @return true iff this is a positive number
 */
function parseSign(s) {
  let beginning = true;
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let all = "";
  let pos = true;
  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);
    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;
      beginning = false;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        }
      } else {
        if (seenSomething) {
          zeros += c;
        }
      }
      beginning = false;
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
      beginning = false;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else if (beginning && (c == "+" || c == "-")) {
      if (c == "-") {
        pos = !pos;
      }
    }
  }
  if (all == "") {
    return true;
  }
  return pos;
}

/**
 * Parse a string representation of a floating point
 * and pull out the mantissa.
 *
 * @param s the string representation of a floating point.
 * @return the mantissa of this number.
 */
function parseMantissa(s) {
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let leadZeros = "";
  let all = "";
  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);
    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          leadZeros += c;
        }
      } else {
        if (seenSomething) {
          leadZeros += c;
          zeros += c;
        } else {
          leadZeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else ;
  }
  if (all == "") {
    return leadZeros;
  }
  return all;
}

/**
 * Parse a string representation of a floating point
 * and pull out the exponent.
 *
 * @param s the string representation of a floating point.
 * @return (integer) the number after the e.
 */
function parseOrder(s) {
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let all = "";
  let decPlaces = 0;
  let totalDecs = 0;
  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);
    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;
      if (!seenDot) {
        totalDecs++;
        decPlaces++;
      }
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          decPlaces--;
        }
      } else {
        totalDecs++;
        if (seenSomething) {
          decPlaces++;
          zeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      const raised = parseInt(s.substring(i + 1, s.length));
      decPlaces += raised;
      totalDecs += raised;
      i = s.length;
    } else ;
  }
  if (all == "") {
    return totalDecs;
  }
  return decPlaces;
}

/**
 * Remove the specified number of digits from string by
 * rounding.  Proper rounding rules for scientific purposes
 * are followed.
 * This method may cause an extra significant figure
 * to be added to the number.  For example, if 999999
 * were rounded, A one would carry over and become
 * a significant figure.  Those who call this method
 * should check for this and call round again if needed.
 *
 * @param mantissa A string representing an whole number of arbitrary length.
 * @param digits A number of digits to remove
 * @return A string represted the rounded version of mantissa
 */
function round(mantissa, digits) {
  const last = mantissa.length - digits - 1;
  if (last < 0) {
    return "";
  }
  if (last >= mantissa.length - 1) {
    return mantissa;
  }
  const nextToLast = mantissa.charAt(last + 1);
  const lastChar = mantissa.charAt(last);
  let roundUp = false;
  if (nextToLast > "5") {
    roundUp = true;
  } else if (nextToLast == "5") {
    for (let j = last + 2; j < mantissa.length; j++) {
      if (mantissa.charAt(j) != "0") {
        roundUp = true;
      }
    }
    // @ts-expect-error [FEI-5003] - TS2362 - The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    if (lastChar % 2 == 1) {
      roundUp = true;
    }
  }
  let result = "";
  for (let i = last; i >= 0; i--) {
    const c = mantissa.charAt(i);
    if (roundUp) {
      let nextChar;
      if (c == "9") {
        nextChar = "0";
      } else {
        switch (c) {
          case "0":
            nextChar = "1";
            break;
          case "1":
            nextChar = "2";
            break;
          case "2":
            nextChar = "3";
            break;
          case "3":
            nextChar = "4";
            break;
          case "4":
            nextChar = "5";
            break;
          case "5":
            nextChar = "6";
            break;
          case "6":
            nextChar = "7";
            break;
          case "7":
            nextChar = "8";
            break;
          case "8":
            nextChar = "9";
            break;
        }
        roundUp = false;
      }
      result = nextChar + result;
    } else {
      result = c + result;
    }
  }
  if (roundUp) {
    result = "1" + result;
  }
  return result;
}

const ALL = "all";
const countSigfigs = function (value) {
  return new SignificantFigures(value).sigFigs;
};
/* I just wrote this, but it's old by analogy to `OldExpression`, in that it's
 * the version that non-mathquill platforms get stuck with. Constructed with an
 * <input>, a parser, popsicle sticks, and glue.
 *
 * In the same way as OldExpression, this parses continuously as you type, then
 * shows and hides an error buddy. The error message is only shown after a
 * rolling two second delay, but hidden immediately on further typing.
 */
class OldUnitInput extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_errorTimeout", void 0);
    _defineProperty(this, "_showError", () => {
      if (this.props.value === "") {
        return;
      }

      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      const $error = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.error));
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'is' does not exist on type 'JQueryStatic'.
      if (!$error.is(":visible")) {
        $error
        // @ts-expect-error [FEI-5003] - TS2554 - Expected 2 arguments, but got 1.
        .css({
          top: 50,
          opacity: 0.1
        }).show().animate({
          top: 0,
          opacity: 1.0
        }, 300);
      }
    });
    _defineProperty(this, "_hideError", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      const $error = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.error));
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'is' does not exist on type 'JQueryStatic'.
      if ($error.is(":visible")) {
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'animate' does not exist on type 'JQueryStatic'.
        $error.animate({
          top: 50,
          opacity: 0.1
        }, 300, function () {
          // eslint-disable-next-line @babel/no-invalid-this
          // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
          // eslint-disable-next-line @babel/no-invalid-this
          $__default["default"](this).hide();
        });
      }
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly any[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
    _defineProperty(this, "handleBlur", () => {
      this.props.onBlur([]);
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      clearTimeout(this._errorTimeout);
      if (!KAS__namespace.unitParse(this.props.value).parsed) {
        this._showError();
      }
    });
    _defineProperty(this, "handleChange", event => {
      this._hideError();
      this.props.onChange({
        value: event.target.value
      });
    });
    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {
      return OldUnitInput.validate(this.getUserInput(), rubric);
    });
    _defineProperty(this, "getUserInput", () => {
      return this.props.value;
    });
    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.
      return [[]];
    });
    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      const input = ReactDOM__default["default"].findDOMNode(this.refs.input);
      if (input) {
        /**
         * TODO(somewhatabstract, JIRA-XXXX):
         * Change to using a ref callback so that focus() can be
         * accessed.
         */
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'Element | Text'.
        input.focus();
      }
    });
    _defineProperty(this, "handleFocus", () => {
      this.props.onFocus([]);
    });
    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      const input = ReactDOM__default["default"].findDOMNode(this.refs.input);
      if (input) {
        /**
         * TODO(somewhatabstract, JIRA-XXXX):
         * Change to using a ref callback so that focus() can be
         * accessed.
         */
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type 'Element | Text'.
        input.blur();
      }
    });
    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        value: newValue
      }, cb);
    });
    _defineProperty(this, "getDOMNodeForPath", () => {
      // eslint-disable-next-line react/no-string-refs
      return ReactDOM__default["default"].findDOMNode(this.refs.input);
    });
    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "unit";
    });
  }
  static validate(userInput, rubric) {
    const answer = KAS__namespace.unitParse(rubric.value).expr;
    const guess = KAS__namespace.unitParse(userInput);
    if (!guess.parsed) {
      return {
        type: "invalid",
        message: i18n__namespace._("I couldn't understand those units.")
      };
    }

    // Note: we check sigfigs, then numerical correctness, then units, so
    // the most significant things come last, that way the user will see
    // the most important message.
    let message = null;

    // did the user specify the right number of sigfigs?
    // TODO(joel) - add a grading mode where the wrong number of sigfigs
    // isn't marked wrong
    const sigfigs = rubric.sigfigs;
    const sigfigsCorrect = countSigfigs(guess.coefficient) === sigfigs;
    if (!sigfigsCorrect) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      message = i18n__namespace._("Check your significant figures.");
    }

    // now we need to check that the answer is correct to the precision we
    // require.
    let numericallyCorrect;
    try {
      const x = new KAS__namespace.Var("x");
      const equality = new KAS__namespace.Eq(answer.simplify(), "=", new KAS__namespace.Mul(x, guess.expr.simplify()));
      const conversion = equality.solveLinearEquationForVariable(x);

      // Make sure the conversion factor between the user's input answer
      // and the canonical answer is 1, to sigfig places.
      // TODO(joel) is this sound?
      numericallyCorrect = Number(conversion.eval()).toPrecision(sigfigs) === Number(1).toPrecision(sigfigs);
    } catch (e) {
      numericallyCorrect = false;
    }
    if (!numericallyCorrect) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      message = i18n__namespace._("That answer is numerically incorrect.");
    }
    let kasCorrect;
    const guessUnit = primUnits(guess.expr.simplify());
    const answerUnit = primUnits(answer.simplify());
    if (rubric.accepting === ALL) {
      // We're accepting all units - KAS does the hard work of figuring
      // out if the user's unit is equivalent to the author's unit.
      kasCorrect = KAS__namespace.compare(guessUnit, answerUnit).equal;
    } else {
      // Are any of the accepted units the same as what the user entered?
      kasCorrect = ___default["default"](rubric.acceptingUnits).any(unit => {
        const thisAnswerUnit = primUnits(KAS__namespace.unitParse(unit).unit.simplify());
        return KAS__namespace.compare(thisAnswerUnit, guessUnit
        // TODO(joel) - make this work as intended.
        // { form: true }
        ).equal;
      });
    }
    if (!kasCorrect) {
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'null'.
      message = i18n__namespace._("Check your units.");
    }
    const correct = kasCorrect && numericallyCorrect && sigfigsCorrect;
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message
    };
  }
  componentDidUpdate() {
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    clearTimeout(this._errorTimeout);
    if (KAS__namespace.unitParse(this.props.value).parsed) {
      this._hideError();
    } else {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'Timeout' is not assignable to type 'number'.
      this._errorTimeout = setTimeout(this._showError, 2000);
    }
  }
  componentWillUnmount() {
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
    clearTimeout(this._errorTimeout);
  }
  // end mobile stuff

  // TODO(joel) think about showing the error buddy
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "old-unit-input"
    }, /*#__PURE__*/React__namespace.createElement("input", {
      onChange: this.handleChange,
      ref: "input" // eslint-disable-line react/no-string-refs
      ,
      className: ClassNames.INTERACTIVE,
      value: this.props.value,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    }), /*#__PURE__*/React__namespace.createElement("div", {
      ref: "error",
      className: "error",
      style: {
        display: "none"
      }
    }, i18n__namespace._("I don't understand that")));
  }
}

// Extract the primitive units from a unit expression. This first simplifies
// `expr` to a `Mul` like "5 kg m / s^2" then removes the first term.
_defineProperty(OldUnitInput, "defaultProps", {
  apiOptions: ApiOptions.defaults,
  value: ""
});
const primUnits = function (expr) {
  return expr.simplify().asMul().partition()[1].flatten().simplify();
};
var Unit = {
  name: "unit-input",
  displayName: "Unit",
  defaultAlignment: "inline-block",
  widget: OldUnitInput,
  transform: x => lens(x).del(["value"]).freeze(),
  version: {
    major: 0,
    minor: 1
  },
  hidden: true
};

/**
 * This is a component that adds a link to the transcript for embedded videos in articles.
 */
const IS_URL$1 = /^https?:\/\//;
const getYoutubeId = url => {
  const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);
  if (match && match[7].length === 11) {
    return match[7];
  }
  return "videoNotFound";
};

// will accept a youtube link or a video's slug name from embedded video and then query accordingly.

/**
 * Video Transcript Link Component.
 */
const VideoTranscriptLink = props => {
  const {
    location
  } = props;
  const {
    useVideo
  } = getDependencies();
  const [id, kind] = IS_URL$1.test(location) ? [getYoutubeId(location), "YOUTUBE_ID"] : [location, "READABLE_ID"];
  // The result value conforms to the wonder-blocks-data `Result` type
  // which is used by our GraphQL framework.
  // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'VideoKind'.
  const result = useVideo(id, kind);
  switch (result.status) {
    case "loading":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Loading..."));
    case "success":
      {
        var _result$data;
        const video = (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.video;
        return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, {
          style: styles$6.transcriptLink
        }, /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.Text, null, video === null || video === void 0 ? void 0 : video.title), /*#__PURE__*/React__namespace.createElement(wonderBlocksLayout.Strut, {
          size: 10
        }), /*#__PURE__*/React__namespace.createElement(Link__default["default"], {
          href: "/transcript/" + ((video === null || video === void 0 ? void 0 : video.contentId) || "videoNotFound"),
          target: "_blank",
          className: "visited-no-recolor"
        }, i18n__namespace._("See video transcript")));
      }
    case "error":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));
    case "aborted":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));
    default:
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));
  }
};
const styles$6 = aphrodite.StyleSheet.create({
  transcriptLink: {
    flexDirection: "row",
    width: "100%",
    justifyContent: "center"
  }
});

// Current default is 720p, based on the typical videos we upload currently
const DEFAULT_WIDTH = 1280;
const DEFAULT_HEIGHT = 720;
const KA_EMBED = "{host}/embed_video?slug={slug}" + "&internal_video_only=1";
const IS_URL = /^https?:\/\//;
const IS_KA_SITE = /(khanacademy\.org|localhost)/;
/**
 * Video renderer.
 */
class Video extends React__namespace.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "getUserInput", () => {
      return null;
    });
    _defineProperty(this, "simpleValidate", rubric => {
      return Video.validate(null, rubric);
    });
    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'readonly unknown[]' is not assignable to parameter of type 'any[]'.
      return change.apply(_this, args);
    });
  }
  /**
   * This is the widget's grading function.
   * Points for videos are tallied by the embedded video itself, in the case
   * of Khan Academy videos.
   */
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  render() {
    const {
      InitialRequestUrl
    } = getDependencies();
    const location = this.props.location;
    if (!location) {
      return /*#__PURE__*/React__namespace.createElement("div", null);
    }
    let url;
    if (IS_URL.test(location)) {
      url = location;
    } else {
      url = KA_EMBED.replace("{slug}", location);
      let embedHostname = "https://www.khanacademy.org";
      if (IS_KA_SITE.test(InitialRequestUrl.host)) {
        embedHostname = InitialRequestUrl.origin;
      }
      url = url.replace("{host}", embedHostname);
    }
    return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
      // The key is here for the benefit of the editor, to ensure that
      // any changes cause a re-rendering of the frame.
      ,
      key: location + this.props.alignment
    }, /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, {
      style: a11y.srOnly
    }, i18n__namespace._("Khan Academy video wrapper")), /*#__PURE__*/React__namespace.createElement("iframe", {
      // TODO(joshuan): Consider not using iframes when we're
      // loading this from webapp. This iframe is problematic
      // for screenreaders.
      className: "perseus-video-widget",
      sandbox: "allow-same-origin allow-scripts",
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT,
      src: url,
      allowFullScreen: true
    })), /*#__PURE__*/React__namespace.createElement(VideoTranscriptLink, {
      location: location
    }));
  }
}
var Video$1 = {
  name: "video",
  displayName: "Video",
  defaultAlignment: "block",
  supportedAlignments: ["block", "float-left", "float-right", "full-width"],
  widget: Video
};

/* eslint-disable import/no-named-as-default */
var extraWidgets = [Categorizer$1, CSProgram$1, Dropdown$1, Explanation$1, Definition$1, Grapher$1, GradedGroup$1, GradedGroupSet$1, Group$1, Iframe$1, Image$1, Interactive, InteractiveGraph$1, LabelImage$1, LightsPuzzle$1, Matrix$1, Matcher$1, Measurer$1, Molecule$1, NumberLine$1, Orderer$1, Passage$1, PassageRef$1, PassageRefTarget$1, Plotter$1, ReactionDiagram, Sequence$1, Simulator$1, Sorter$1, Table$1, Transformer$1, Unit, Video$1];

/**
 * This should be called by all clients, specifying whether extra widgets are
 * needed via `loadExtraWidgets`. It is idempotent, so it's not a problem to
 * call it multiple times.
 *
 * skipMathJax:
 *   If false/undefined, MathJax will be configured, and the
 *   promise will wait for MathJax to load (if it hasn't already).
 */
const init = function (options) {
  registerWidgets(basicWidgets);
  registerWidgets(extraWidgets);

  // Pass skipMathJax: true if MathJax is already loaded and configured.
  const skipMathJax = options.skipMathJax;
  if (skipMathJax) {
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'Promise<void>' is not assignable to type 'Promise<undefined>'.
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    MathJax.Hub.Config({
      messageStyle: "none",
      skipStartupTypeset: "none",
      "HTML-CSS": {
        availableFonts: ["TeX"],
        imageFont: null,
        scale: 100,
        showMathMenu: false
      }
    });
    MathJax.Hub.Configured();
    MathJax.Hub.Queue(resolve);
  });
};

var allWidgets = [...basicWidgets, ...extraWidgets];

registerWidgets(allWidgets);
const ItemVersion = getVersionVector();
ItemVersion["::renderer::"] = version.itemDataVersion;

/**
 * A mixin that renders a custom software keypad in additional to the base
 * component. The base component will receive blur events when the keypad is
 * dismissed and can access the keypad element itself so as to manage its
 * activation and dismissal.
 *
 * TODO(charlie): This would make a nicer higher-order component, except that
 * we need to expose methods on the base component (i.e., `ItemRenderer`). When
 * `ItemRenderer` and friends are written as ES6 Classes, we can have them
 * extend a `ProvideKeypad` component instead of using this mixin.
 */
// NOTE: This is not a real component.  It's a collection of methods used to
// create and manage a Keypad instances.
// TODO(LP-10789): replace this with a React Context object to pass information
// between Perseus and the Keypad.
const ProvideKeypad = {
  propTypes: {
    apiOptions: PropTypes__default["default"].shape({
      customKeypad: PropTypes__default["default"].bool,
      nativeKeypadProxy: PropTypes__default["default"].func
    }),
    // An Aphrodite style object, to be applied to the keypad container.
    // Note that, given our awkward structure of injecting the keypad, this
    // style won't be applied or updated dynamically. Rather, it will only
    // be applied in `componentDidMount`.
    keypadStyle: PropTypes__default["default"].any
  },
  getInitialState() {
    const _this = this;
    let keypadElement = null;
    if (
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    _this.props.apiOptions &&
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    _this.props.apiOptions.customKeypad &&
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    _this.props.apiOptions.nativeKeypadProxy) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      keypadElement = _this.props.apiOptions.nativeKeypadProxy(
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'. | TS2339 - Property 'blur' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      () => _this.blur && _this.blur());
    }
    return {
      keypadElement
    };
  },
  componentDidMount() {
    const _this = this;
    if (
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    _this.props.apiOptions &&
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    _this.props.apiOptions.customKeypad &&
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    !_this.props.apiOptions.nativeKeypadProxy) {
      var _document$body;
      // TODO(charlie): Render this and the wrapped component in the same
      // React tree. We may also want to add this keypad asynchronously
      // or on-demand in the future.
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      _this._keypadContainer = document.createElement("div");
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(_this._keypadContainer);
      render( /*#__PURE__*/React__namespace.createElement(mathInput.Keypad, {
        onElementMounted: element => {
          // NOTE(kevinb): The reason why this setState works is
          // b/c we're calling it manually from item-renderer.jsx
          // and we're manually setting the 'this' by using 'call'
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'setState' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
          _this.setState({
            keypadElement: element
          });
        },
        onDismiss: () => {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'blur' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'. | TS2339 - Property 'blur' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
          _this.blur && _this.blur();
        }
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
        ,
        style: _this.props.keypadStyle
      }),
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      _this._keypadContainer);
    }
  },
  componentWillUnmount() {
    const _this = this;
    // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    if (_this._keypadContainer) {
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      ReactDOM__default["default"].unmountComponentAtNode(_this._keypadContainer);
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      if (_this._keypadContainer.parentNode) {
        // Note ChildNode.remove() isn't available in older Android
        // webviews.
        // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
        _this._keypadContainer.parentNode.removeChild(
        // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
        _this._keypadContainer);
      }
      // @ts-expect-error [FEI-5003] - TS2339 - Property '_keypadContainer' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
      _this._keypadContainer = null;
    }
  },
  keypadElement() {
    const _this = this;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'state' does not exist on type '{ readonly propTypes: { readonly apiOptions: React.PropType<{ customKeypad?: boolean | undefined; nativeKeypadProxy?: ((...a: readonly any[]) => unknown) | undefined; }>; readonly keypadStyle: Requireable<any>; }; readonly getInitialState: () => { ...; }; readonly componentDidMount: () => void; readonly componentWil...'.
    return _this.state.keypadElement;
  }
};

const rendererProps = PropTypes__default["default"].shape({
  content: PropTypes__default["default"].string,
  widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
  images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
});
class ArticleRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_currentFocus", void 0);
    _defineProperty(this, "keypadElement", () => {
      return ProvideKeypad.keypadElement.call(this);
    });
    _defineProperty(this, "_handleFocusChange", (newFocusPath, oldFocusPath) => {
      // TODO(charlie): DRY this up--some of this logic is repeated in
      // ItemRenderer.
      if (newFocusPath) {
        this._setCurrentFocus(newFocusPath);
      } else {
        this._onRendererBlur(oldFocusPath);
      }
    });
    _defineProperty(this, "_setCurrentFocus", newFocusPath => {
      const keypadElement = this.keypadElement();
      const prevFocusPath = this._currentFocus;
      this._currentFocus = newFocusPath;

      // Use the section prefix to extract the relevant Renderer's input
      // paths, so as to check whether the focused path represents an
      // input.
      let didFocusInput = false;
      if (this._currentFocus) {
        const [sectionRef, ...focusPath] = this._currentFocus;
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getInputPaths' does not exist on type 'ReactInstance'.
        const inputPaths = this.refs[sectionRef].getInputPaths();
        didFocusInput = inputPaths.some(inputPath => {
          return Util.inputPathsEqual(inputPath, focusPath);
        });
      }
      if (this.props.apiOptions.onFocusChange != null) {
        this.props.apiOptions.onFocusChange(this._currentFocus, prevFocusPath,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getDOMNode' does not exist on type 'never'.
        didFocusInput && keypadElement && keypadElement.getDOMNode());
      }

      // @ts-expect-error [FEI-5003] - TS1345 - An expression of type 'void' cannot be tested for truthiness.
      if (keypadElement) {
        if (didFocusInput) {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'activate' does not exist on type 'never'.
          keypadElement.activate();
        } else {
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'dismiss' does not exist on type 'never'.
          keypadElement.dismiss();
        }
      }
    });
    _defineProperty(this, "_onRendererBlur", blurPath => {
      const blurringFocusPath = this._currentFocus;

      // Failsafe: abort if ID is different, because focus probably happened
      // before blur.
      if (!Util.inputPathsEqual(blurPath, blurringFocusPath)) {
        return;
      }

      // Wait until after any new focus events fire this tick before declaring
      // that nothing is focused, since if there were a focus change across
      // sections, we could receive the blur before the focus.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(() => {
        if (Util.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
          this._setCurrentFocus(null);
        }
      });
    });
    _defineProperty(this, "blur", () => {
      if (this._currentFocus) {
        const [sectionRef, ...inputPath] = this._currentFocus;
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'blurPath' does not exist on type 'ReactInstance'.
        this.refs[sectionRef].blurPath(inputPath);
      }
    });
    _defineProperty(this, "_sections", () => {
      return Array.isArray(this.props.json) ? this.props.json : [this.props.json];
    });
    this.state = ProvideKeypad.getInitialState.call(this);
  }
  componentDidMount() {
    ProvideKeypad.componentDidMount.call(this);
    this._currentFocus = null;
  }
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }
  componentWillUnmount() {
    ProvideKeypad.componentWillUnmount.call(this);
  }
  render() {
    const apiOptions = {
      ...ApiOptions.defaults,
      ...this.props.apiOptions,
      isArticle: true
    };
    const classes = classNames__default["default"]({
      "framework-perseus": true,
      "perseus-article": true,
      "bibliotron-article": this.props.useNewStyles,
      // NOTE(charlie): For exercises, this is applied outside of Perseus
      // (in webapp).
      [ClassNames.MOBILE]: apiOptions.isMobile
    });

    // TODO(alex): Add mobile api functions and pass them down here
    const sections = this._sections().map((section, i) => {
      const refForSection = "section-".concat(i);
      return /*#__PURE__*/React__namespace.createElement("div", {
        key: i,
        className: "clearfix"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, _extends({}, section, {
        ref: refForSection,
        key: i,
        key_: i,
        keypadElement: this.keypadElement(),
        apiOptions: {
          ...apiOptions,
          onFocusChange: (newFocusPath, oldFocusPath) => {
            // Prefix the paths with the relevant section,
            // so as to allow us to distinguish between
            // equivalently-named inputs across Renderers.
            this._handleFocusChange(newFocusPath && [refForSection].concat(newFocusPath), oldFocusPath && [refForSection].concat(oldFocusPath));
          }
        },
        linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "article"),
        legacyPerseusLint: this.props.legacyPerseusLint
      })));
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classes
    }, sections);
  }
}
_defineProperty(ArticleRenderer, "propTypes", {
  ...ProvideKeypad.propTypes,
  apiOptions: PropTypes__default["default"].shape({
    onFocusChange: PropTypes__default["default"].func,
    isMobile: PropTypes__default["default"].bool
  }),
  json: PropTypes__default["default"].oneOfType([rendererProps, PropTypes__default["default"].arrayOf(rendererProps)]).isRequired,
  // Whether to use the new Bibliotron styles for articles
  useNewStyles: PropTypes__default["default"].bool,
  linterContext: PerseusLinter__namespace.linterContextProps,
  legacyPerseusLint: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)
});
_defineProperty(ArticleRenderer, "defaultProps", {
  apiOptions: {},
  useNewStyles: false,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

/* Renders just a hint preview */
class HintRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "getSerializedState", () => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'getSerializedState' does not exist on type 'ReactInstance'.
      return this.refs.renderer.getSerializedState();
    });
    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      // eslint-disable-next-line react/no-string-refs
      // @ts-expect-error [FEI-5003] - TS2339 - Property 'restoreSerializedState' does not exist on type 'ReactInstance'.
      this.refs.renderer.restoreSerializedState(state, callback);
    });
  }
  render() {
    const {
      apiOptions,
      className,
      hint,
      lastHint,
      lastRendered,
      pos,
      totalHints
    } = this.props;
    const {
      isMobile
    } = apiOptions;
    const classNames = classNames__default["default"](!isMobile && "perseus-hint-renderer", isMobile && aphrodite.css(styles$5.newHint), isMobile && lastRendered && aphrodite.css(styles$5.lastRenderedNewHint), lastHint && "last-hint", lastRendered && "last-rendered", className);

    // TODO(charlie): Allowing `customKeypad` would require that we
    // extend `ItemRenderer` to support nested inputs in the `HintsRenderer`.
    // For now, we disable this option.
    // Instead, clients will get standard <input/> elements, which
    // aren't nice to use on mobile, but are at least usable.
    const rendererApiOptions = {
      ...apiOptions,
      customKeypad: false
    };
    return (
      /*#__PURE__*/
      // @ts-expect-error [FEI-5003] - TS2322 - Type 'string' is not assignable to type 'number | undefined'.
      React__namespace.createElement("div", {
        className: classNames,
        tabIndex: "-1"
      }, !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-sr-only"
      }, i18n__namespace._("Hint #%(pos)s", {
        pos: pos + 1
      })), !apiOptions.isMobile && totalHints != null && pos != null && /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-hint-label",
        style: {
          display: "block",
          color: apiOptions.hintProgressColor
        }
      }, "".concat(pos + 1, " / ").concat(totalHints)), /*#__PURE__*/React__namespace.createElement(Renderer
      // eslint-disable-next-line react/no-string-refs
      , {
        ref: "renderer",
        widgets: hint.widgets,
        content: hint.content || "",
        images: hint.images,
        apiOptions: rendererApiOptions,
        findExternalWidgets: this.props.findExternalWidgets,
        linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "hint")
      }))
    );
  }
}
_defineProperty(HintRenderer, "defaultProps", {
  linterContext: PerseusLinter__namespace.linterContextDefault
});
const styles$5 = aphrodite.StyleSheet.create({
  newHint: {
    marginBottom: 1.5 * baseUnitPx,
    borderLeftColor: gray97,
    borderLeftStyle: "solid",
    borderLeftWidth: hintBorderWidth,
    // Only apply left-padding on tablets, to avoid being flush with the
    // border. On phones, padding is applied internally by the child
    // renderers. Some content on phones that is rendered at full-bleed may
    // end up flush with the border, but that's acceptable for now.
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: baseUnitPx
    },
    [mediaQueries.smOrSmaller]: {
      paddingLeft: 0
    },
    ":focus": {
      outline: "none"
    }
  },
  lastRenderedNewHint: {
    marginBottom: 0,
    borderLeftColor: kaGreen$1
  }
});

// Use of UNSAFE_componentWillReceiveProps:
// eslint-disable-next-line react/no-unsafe
class HintsRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      isFinalHelpPage: false
    });
    _defineProperty(this, "_hintsVisible", () => {
      if (this.props.hintsVisible == null || this.props.hintsVisible === -1) {
        return this.props.hints.length;
      }
      return this.props.hintsVisible;
    });
    _defineProperty(this, "_cacheImagesInHint", hint => {
      ___default["default"].each(hint.images, (data, src) => {
        const image = new Image();
        image.src = Util.getRealImageUrl(src);
      });
    });
    _defineProperty(this, "_cacheHintImages", () => {
      // Only cache images in the first hint at the start. When hints are
      // taken, cache images in the rest of the hints
      if (this._hintsVisible() > 0) {
        ___default["default"].each(this.props.hints, this._cacheImagesInHint);
      } else if (this.props.hints.length > 0) {
        this._cacheImagesInHint(this.props.hints[0]);
      }
    });
    _defineProperty(this, "getApiOptions", () => {
      // When an item is answered correctly, the entire exercise is set to
      // `readOnly = true` so that the user cannot switch answers. However, this
      // makes hyperlinks in hints unclickable. Thus, we always set readOnly to be
      // false in hints.
      return {
        ...ApiOptions.defaults,
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'apiOptions' does not exist on type 'Readonly<{ className?: string | undefined; hints: readonly any[]; hintsVisible?: number | undefined; }> & Readonly<{ children?: ReactNode; }>'.
        ...this.props.apiOptions,
        readOnly: false
      };
    });
    _defineProperty(this, "getSerializedState", () => {
      return ___default["default"].times(this._hintsVisible(), i => {
        // eslint-disable-next-line react/no-string-refs
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'getSerializedState' does not exist on type 'ReactInstance'.
        return this.refs["hintRenderer" + i].getSerializedState();
      });
    });
    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      // We need to wait until all the renderers are finished restoring their
      // state before we fire our callback.
      let numCallbacks = 1;
      const fireCallback = () => {
        --numCallbacks;
        if (callback && numCallbacks === 0) {
          callback();
        }
      };
      ___default["default"].each(state, (hintState, i) => {
        // eslint-disable-next-line react/no-string-refs
        const hintRenderer = this.refs["hintRenderer" + i];
        // This is not ideal in that it doesn't restore state
        // if the hint isn't visible, but we can't exactly restore
        // the state to an unmounted renderer, so...
        // If you want to restore state to hints, make sure to
        // have the appropriate number of hints visible already.
        if (hintRenderer) {
          ++numCallbacks;
          // @ts-expect-error [FEI-5003] - TS2339 - Property 'restoreSerializedState' does not exist on type 'ReactInstance'.
          hintRenderer.restoreSerializedState(hintState, fireCallback);
        }
      });

      // This makes sure that the callback is fired if there aren't any
      // mounted renderers.
      fireCallback();
    });
  }
  componentDidMount() {
    this._cacheHintImages();
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    // @ts-expect-error [FEI-5003] - TS2532 - Object is possibly 'undefined'. | TS2532 - Object is possibly 'undefined'.
    if (nextProps.hintsVisible - this.props.hintsVisible > 1) {
      this.setState({
        isFinalHelpPage: true
      });
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (!___default["default"].isEqual(prevProps.hints, this.props.hints) || prevProps.hintsVisible !== this.props.hintsVisible) {
      this._cacheHintImages();
    }

    // Force number to make TypeScript happy
    const prevHintsVisible = prevProps.hintsVisible || 0;
    const nextHintsVisible = this.props.hintsVisible || 0;

    // When a new hint is displayed we immediately focus it
    // (keeping within the boundaries of hint count)
    if (prevHintsVisible < nextHintsVisible && nextHintsVisible <= this.props.hints.length && nextHintsVisible >= 0) {
      const pos = nextHintsVisible - 1;
      // @ts-expect-error [FEI-5003] - TS2531 - Object is possibly 'null'. | TS2339 - Property 'focus' does not exist on type 'Element | Text'.
      ReactDOM__default["default"].findDOMNode(this.refs["hintRenderer" + pos]).focus(); // eslint-disable-line react/no-string-refs
    }
  }

  render() {
    const apiOptions = this.getApiOptions();
    const hintsVisible = this._hintsVisible();
    const hints = [];
    const isFinalHelpPage = this.state.isFinalHelpPage;
    this.props.hints.slice(0, hintsVisible).forEach((hint, i) => {
      const lastHint = i === this.props.hints.length - 1 && !/\*\*/.test(hint.content);
      const lastRendered = i === hintsVisible - 1;
      const renderer = /*#__PURE__*/React__namespace.createElement(HintRenderer, {
        lastHint: lastHint,
        lastRendered: lastRendered,
        hint: hint,
        pos: i,
        totalHints: this.props.hints.length,
        ref: "hintRenderer" + i,
        key: "hintRenderer" + i,
        apiOptions: apiOptions
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'findExternalWidgets' does not exist on type 'Readonly<{ className?: string | undefined; hints: readonly any[]; hintsVisible?: number | undefined; }> & Readonly<{ children?: ReactNode; }>'.
        ,
        findExternalWidgets: this.props.findExternalWidgets,
        linterContext: PerseusLinter__namespace.pushContextStack(
        // @ts-expect-error [FEI-5003] - TS2339 - Property 'linterContext' does not exist on type 'Readonly<{ className?: string | undefined; hints: readonly any[]; hintsVisible?: number | undefined; }> & Readonly<{ children?: ReactNode; }>'.
        this.props.linterContext, "hints[" + i + "]")
      });
      if (isFinalHelpPage) {
        hints.push(renderer);
      } else {
        if (hint.replace && hints.length > 0) {
          hints[hints.length - 1] = renderer;
        } else {
          hints.push(renderer);
        }
      }
    });
    const {
      getAnotherHint
    } = apiOptions;
    const showGetAnotherHint = getAnotherHint && hintsVisible > 0 && hintsVisible < this.props.hints.length;
    const hintRatioCopy = "(".concat(hintsVisible, "/").concat(this.props.hints.length, ")");
    const classNames = classNames__default["default"](this.props.className, apiOptions.isMobile && hintsVisible > 0 && aphrodite.css(styles$4.mobileHintStylesHintsRenderer));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames
    }, apiOptions.isMobile && hintsVisible > 0 && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$4.mobileHintStylesHintTitle, sharedStyles.responsiveLabel)
    }, i18n__namespace._("Hints")), hints, showGetAnotherHint && /*#__PURE__*/React__namespace.createElement("button", {
      // @ts-expect-error [FEI-5003] - TS2322 - Type '{ children: Element[]; rel: string; className: string; onClick: (evt: MouseEvent<HTMLButtonElement, MouseEvent>) => void; }' is not assignable to type 'DetailedHTMLProps<ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>'.
      rel: "button",
      className: aphrodite.css(styles$4.linkButton, styles$4.getAnotherHintButton, apiOptions.isMobile && styles$4.mobileHintStylesGetAnotherHintButton),
      onClick: evt => {
        evt.preventDefault();
        evt.stopPropagation();
        if (getAnotherHint) {
          getAnotherHint();
        }
      }
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$4.plusText, apiOptions.isMobile && styles$4.mobileHintStylesPlusText)
    }, "+"), /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$4.getAnotherHintText)
    }, i18n__namespace._("Get another hint"), " ", hintRatioCopy)));
  }
}
_defineProperty(HintsRenderer, "defaultProps", {
  linterContext: PerseusLinter__namespace.linterContextDefault
});
const hintIndentation = baseUnitPx + hintBorderWidth;
const styles$4 = aphrodite.StyleSheet.create({
  // eslint-disable-next-line react-native/no-unused-styles
  rendererMargins: {
    marginTop: baseUnitPx
  },
  linkButton: {
    cursor: "pointer",
    border: "none",
    backgroundColor: "transparent",
    fontSize: "100%",
    fontFamily: "inherit",
    fontWeight: "bold",
    color: kaGreen$1,
    padding: 0,
    position: "relative"
  },
  plusText: {
    fontSize: 20,
    position: "absolute",
    top: -3,
    left: 0
  },
  getAnotherHintText: {
    marginLeft: 16
  },
  mobileHintStylesHintsRenderer: {
    marginTop: 4 * baseUnitPx,
    border: "solid ".concat(gray85),
    borderWidth: "1px 0 0 0",
    position: "relative",
    ":before": {
      content: '""',
      display: "table",
      clear: "both"
    },
    ":after": {
      content: '""',
      display: "table",
      clear: "both"
    }
  },
  mobileHintStylesHintTitle: {
    fontFamily: "inherit",
    fontStyle: "normal",
    fontWeight: "bold",
    color: gray17,
    paddingTop: baseUnitPx,
    paddingBottom: 1.5 * baseUnitPx,
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries.smOrSmaller]: {
      // On phones, ensure that the button is aligned with the hint body
      // content, which is inset at the standard `baseUnitPx`, plus an
      // additional `hintBorderWidth`.
      paddingLeft: hintIndentation
    }
  },
  getAnotherHintButton: {
    marginTop: 1.5 * baseUnitPx
  },
  mobileHintStylesGetAnotherHintButton: {
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries.smOrSmaller]: {
      // As with the title, on phones, ensure that the button is aligned
      // with the hint body content.
      paddingLeft: hintIndentation
    }
  },
  mobileHintStylesPlusText: {
    [mediaQueries.lgOrSmaller]: {
      left: 0
    },
    [mediaQueries.smOrSmaller]: {
      left: hintIndentation
    }
  }
});

const {
  mapObject: mapObject$1
} = objective_;
class ItemRenderer extends React__namespace.Component {
  // @ts-expect-error [FEI-5003] - TS2564 - Property 'questionRenderer' has no initializer and is not definitely assigned in the constructor.

  constructor(props) {
    super(props);
    _defineProperty(this, "questionRenderer", void 0);
    _defineProperty(this, "hintsRenderer", void 0);
    _defineProperty(this, "_currentFocus", void 0);
    _defineProperty(this, "_handleFocusChange", (newFocus, oldFocus) => {
      if (newFocus != null) {
        this._setCurrentFocus(newFocus);
      } else {
        this._onRendererBlur(oldFocus);
      }
    });
    _defineProperty(this, "handleInteractWithWidget", widgetId => {
      const withRemoved = ___default["default"].difference(this.state.questionHighlightedWidgets, [widgetId]);
      this.setState({
        questionCompleted: false,
        questionHighlightedWidgets: withRemoved
      });
      if (this.props.apiOptions.interactionCallback) {
        this.props.apiOptions.interactionCallback();
      }
    });
    this.state = {
      // NOTE: This value is used in provide-keypad.jsx which contains a
      // "mixin" that this file calls methods on.
      ...ProvideKeypad.getInitialState.call(this),
      hintsVisible: props.initialHintsVisible || 0,
      questionCompleted: false,
      questionHighlightedWidgets: []
    };
  }
  componentDidMount() {
    ProvideKeypad.componentDidMount.call(this);
    if (this.props.controlPeripherals && this.props.apiOptions.setDrawingAreaAvailable) {
      this.props.apiOptions.setDrawingAreaAvailable(true);
    }
    this._currentFocus = null;
    this.update();
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  }
  componentDidUpdate() {
    this.update();
  }
  componentWillUnmount() {
    ProvideKeypad.componentWillUnmount.call(this);
    const workArea = document.querySelector(this.props.workAreaSelector);
    if (workArea != null) {
      ReactDOM__namespace.unmountComponentAtNode(workArea);
    }
    const hintsArea = document.querySelector(this.props.hintsAreaSelector);
    if (hintsArea != null) {
      ReactDOM__namespace.unmountComponentAtNode(hintsArea);
    }
    if (this.props.controlPeripherals) {
      const answerArea = this.props.item.answerArea || {};
      if (answerArea.calculator) {
        $__default["default"]("#calculator").hide();
      }
      if (answerArea.periodicTable) {
        $__default["default"](".periodic-table-info-box").hide();
      }
      if (answerArea.zTable) {
        $__default["default"](".z-table-info-box").hide();
      }
      if (answerArea.tTable) {
        $__default["default"](".t-table-info-box").hide();
      }
      if (answerArea.chi2Table) {
        $__default["default"](".chi2-table-info-box").hide();
      }
    }
  }
  keypadElement() {
    return ProvideKeypad.keypadElement.call(this);
  }
  update() {
    const apiOptions = {
      ...ApiOptions.defaults,
      ...this.props.apiOptions,
      onFocusChange: this._handleFocusChange
    };
    const workArea = document.querySelector(this.props.workAreaSelector);
    const hintsArea = document.querySelector(this.props.hintsAreaSelector);
    if (!workArea || !hintsArea) {
      return;
    }

    // Since the item renderer works by rendering things into three divs
    // that have completely different places in the DOM, we have to do this
    // strangeness instead of relying on React's normal render() method.
    // TODO(alpert): Figure out how to clean this up somehow
    render( /*#__PURE__*/React__namespace.createElement(Renderer, _extends({
      ref: node => {
        if (!node) {
          return;
        }
        this.questionRenderer = node;

        // NOTE(jeremy): Why don't we just pass this into the
        // renderer as a prop?
        const {
          answerableCallback
        } = apiOptions;
        if (answerableCallback) {
          const isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
          answerableCallback(isAnswerable);
        }
      },
      keypadElement: this.keypadElement(),
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      savedState: this.props.savedState,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "question")
    }, this.props.item.question, {
      legacyPerseusLint: this.props.legacyPerseusLint
    })),
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Element' is not assignable to parameter of type 'HTMLElement'.
    workArea);
    render( /*#__PURE__*/React__namespace.createElement(HintsRenderer, {
      ref: node => this.hintsRenderer = node,
      hints: this.props.item.hints,
      hintsVisible: this.state.hintsVisible
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      ,
      apiOptions: apiOptions,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "hints")
    }),
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'Element' is not assignable to parameter of type 'HTMLElement'.
    hintsArea);
    const answerArea = this.props.item.answerArea || {};
    if (this.props.controlPeripherals) {
      $__default["default"]("#calculator").toggle(answerArea.calculator || false);
      $__default["default"](".periodic-table-info-box").toggle(answerArea.periodicTable || false);
      $__default["default"](".z-table-info-box").toggle(answerArea.zTable || false);
      $__default["default"](".t-table-info-box").toggle(answerArea.tTable || false);
      $__default["default"](".chi2-table-info-box").toggle(answerArea.chi2Table || false);
    } else {
      if (answerArea.calculator) {
        this.props.onShowCalculator && this.props.onShowCalculator();
      }
      if (answerArea.periodicTable) {
        this.props.onShowPeriodicTable && this.props.onShowPeriodicTable();
      }
      if (answerArea.zTable) {
        this.props.onShowZTable && this.props.onShowZTable();
      }
      if (answerArea.tTable) {
        this.props.onShowTTable && this.props.onShowTTable();
      }
      if (answerArea.chi2Table) {
        this.props.onShowChi2Table && this.props.onShowChi2Table();
      }
    }
  }
  // Sets the current focus path and element and send an onChangeFocus event
  // back to our parent.
  _setCurrentFocus(newFocus) {
    const keypadElement = this.keypadElement();
    // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.
    const prevFocus = this._currentFocus;
    this._currentFocus = newFocus;

    // Determine whether the newly focused path represents an input.
    const inputPaths = this.getInputPaths();
    const didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util.inputPathsEqual(inputPath, this._currentFocus);
    });
    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocus, didFocusInput && keypadElement && keypadElement.getDOMNode());
    }
    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  }
  _onRendererBlur(blurPath) {
    const blurringFocusPath = this._currentFocus;

    // Failsafe: abort if ID is different, because focus probably happened
    // before blur.
    if (!Util.inputPathsEqual(blurPath, blurringFocusPath)) {
      return;
    }

    // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused, since if there were a focus change
    // across Renderers (e.g., from the HintsRenderer to the
    // QuestionRenderer), we could receive the blur before the focus.
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
    // eslint-disable-next-line no-restricted-syntax
    setTimeout(() => {
      if (Util.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  }

  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  }

  /**
   * Sets the input value into the widget found at `path`. The `focus`
   * function provided is called when all affected widgets have been
   * re-rendered with the new value.
   */
  setInputValue(path, newValue, focus) {
    return this.questionRenderer.setInputValue(path, newValue, focus);
  }
  focusPath(path) {
    return this.questionRenderer.focusPath(path);
  }
  blurPath(path) {
    return this.questionRenderer.blurPath(path);
  }
  getDOMNodeForPath(path) {
    return this.questionRenderer.getDOMNodeForPath(path);
  }
  getGrammarTypeForPath(path) {
    return this.questionRenderer.getGrammarTypeForPath(path);
  }
  getInputPaths() {
    const questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  }

  // NOTE: this must remain as an arrow function because we pass it Renderer

  focus() {
    return this.questionRenderer.focus();
  }
  blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  }
  showHint() {
    if (this.state.hintsVisible < this.getNumHints()) {
      this.setState({
        hintsVisible: this.state.hintsVisible + 1
      });
    }
  }
  getNumHints() {
    return this.props.item.hints.length;
  }

  /**
   * Grades the item.
   *
   * Returns a KE-style score of {
   *     empty: bool,
   *     correct: bool,
   *     message: string|null,
   *     guess: Array
   * }
   */
  scoreInput() {
    const guessAndScore = this.questionRenderer.guessAndScore();
    const guess = guessAndScore[0];
    const score = guessAndScore[1];

    // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.
    const maxCompatGuess = [guess, []];
    const keScore = Util.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    const emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  }

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */
  getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  }

  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets() {
    const qScore = this.questionRenderer.scoreWidgets();
    const qGuess = this.questionRenderer.getUserInputForWidgets();
    const state = this.questionRenderer.getSerializedState();
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'Partial<Record<string, KEScore>>' is not assignable to type '{ [id: string]: KEScore; }'. | TS2345 - Argument of type '{ [widgetId: string]: PerseusScore; }' is not assignable to parameter of type 'Partial<Record<string, { type: "invalid"; message?: string | null | undefined; suppressAlmostThere?: boolean | null | undefined; }>>'.
    return mapObject$1(qScore, (score, id) => {
      return Util.keScoreFromPerseusScore(score, qGuess[id], state[id]);
    });
  }

  /**
   * Get a representation of the current state of the item.
   */
  getSerializedState() {
    var _this$hintsRenderer;
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: (_this$hintsRenderer = this.hintsRenderer) === null || _this$hintsRenderer === void 0 ? void 0 : _this$hintsRenderer.getSerializedState()
    };
  }

  // TODO(kevinb): make the type for this state better
  restoreSerializedState(state, callback) {
    var _this$hintsRenderer2;
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    let numCallbacks = 2;
    const fireCallback = () => {
      --numCallbacks;
      if (callback && numCallbacks === 0) {
        callback();
      }
    };
    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    (_this$hintsRenderer2 = this.hintsRenderer) === null || _this$hintsRenderer2 === void 0 ? void 0 : _this$hintsRenderer2.restoreSerializedState(state.hints, fireCallback);
  }
  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  }
  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null);
  }
}
_defineProperty(ItemRenderer, "defaultProps", {
  apiOptions: ApiOptions.defaults,
  // defaults are set in `this.update()`
  controlPeripherals: true,
  hintsAreaSelector: "#hintsarea",
  initialHintsVisible: 0,
  workAreaSelector: "#workarea",
  reviewMode: false,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

/**
 * A React context for signaling when all of the components in a Perseus
 * renderer is fully rendered.  This means that all images and math have
 * finished loading/rendering.
 *
 * Currently only used by ServerItemRender to indicate when the question
 * renderer is fully rendered.
 */
const defaultContext = {
  onRendered: isRendered => {}
};
const context$1 = /*#__PURE__*/React__namespace.createContext(defaultContext);

const {
  mapObject
} = objective_;
/* eslint-disable-next-line react/no-unsafe */
class ServerItemRenderer extends React__namespace.Component {
  // @ts-expect-error [FEI-5003] - TS2564 - Property 'questionRenderer' has no initializer and is not definitely assigned in the constructor.

  constructor(props) {
    super(props);
    _defineProperty(this, "questionRenderer", void 0);
    _defineProperty(this, "hintsRenderer", void 0);
    _defineProperty(this, "_currentFocus", void 0);
    _defineProperty(this, "_fullyRendered", void 0);
    _defineProperty(this, "blurTimeoutID", void 0);
    _defineProperty(this, "_handleFocusChange", (newFocus, oldFocus) => {
      if (newFocus != null) {
        this._setCurrentFocus(newFocus);
      } else {
        this._onRendererBlur(oldFocus);
      }
    });
    _defineProperty(this, "handleInteractWithWidget", widgetId => {
      const withRemoved = ___default["default"].difference(this.state.questionHighlightedWidgets, [widgetId]);
      this.setState({
        questionCompleted: false,
        questionHighlightedWidgets: withRemoved
      });
      if (this.props.apiOptions.interactionCallback) {
        this.props.apiOptions.interactionCallback();
      }
    });
    _defineProperty(this, "setAssetStatus", (assetKey, status) => {
      // setState doesn't properly merge objects so we have to do it ourselves
      const assetStatuses = {
        ...this.state.assetStatuses,
        [assetKey]: status
      };
      this.setState({
        assetStatuses
      });
    });
    this.state = {
      questionCompleted: false,
      questionHighlightedWidgets: [],
      assetStatuses: {}
    };
    this._fullyRendered = false;
  }
  componentDidMount() {
    this._currentFocus = null;
    this._fullyRendered = false;
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.props.apiOptions.answerableCallback) {
      const isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
      const {
        answerableCallback
      } = this.props.apiOptions;
      if (answerableCallback) {
        answerableCallback(isAnswerable);
      }
    }
    if (!this._fullyRendered) {
      const assetsLoaded = Object.values(this.state.assetStatuses).every(Boolean);
      if (assetsLoaded) {
        this._fullyRendered = true;
        this.props.onRendered(true);
      }
    }
  }
  componentWillUnmount() {
    if (this.blurTimeoutID != null) {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      clearTimeout(this.blurTimeoutID);
      this.blurTimeoutID = null;
    }
  }
  // Sets the current focus path and element and
  // send an onChangeFocus event back to our parent.
  _setCurrentFocus(newFocus) {
    const {
      apiOptions: {
        isMobile,
        onFocusChange
      },
      keypadElement
    } = this.props;

    // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.
    const prevFocus = this._currentFocus;
    this._currentFocus = newFocus;

    // Determine whether the newly focused path represents an input.
    const inputPaths = this.getInputPaths();
    const didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util.inputPathsEqual(inputPath, this._currentFocus);
    });
    if (onFocusChange != null) {
      onFocusChange(this._currentFocus, prevFocus, didFocusInput && keypadElement && keypadElement.getDOMNode(),
      // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'false | Element | Text | null | undefined' is not assignable to parameter of type 'HTMLElement | undefined'.
      didFocusInput && this.questionRenderer.getDOMNodeForPath(newFocus));
    }
    if (keypadElement && isMobile) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  }
  _onRendererBlur(blurPath) {
    const blurringFocusPath = this._currentFocus;

    // Failsafe: abort if ID is different, because focus probably happened
    // before blur
    if (!___default["default"].isEqual(blurPath, blurringFocusPath)) {
      return;
    }

    // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused.
    // If a different widget was focused, we'll see an onBlur event
    // now, but then an onFocus event on a different element before
    // this callback is executed
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'Timeout' is not assignable to type 'number'.
    this.blurTimeoutID = setTimeout(() => {
      if (___default["default"].isEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    }, 0);
  }

  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  }
  setInputValue(path, newValue, focus) {
    return this.questionRenderer.setInputValue(path, newValue, focus);
  }
  focusPath(path) {
    return this.questionRenderer.focusPath(path);
  }
  blurPath(path) {
    return this.questionRenderer.blurPath(path);
  }
  getDOMNodeForPath(path) {
    return this.questionRenderer.getDOMNodeForPath(path);
  }
  getGrammarTypeForPath(path) {
    return this.questionRenderer.getGrammarTypeForPath(path);
  }
  getInputPaths() {
    const questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  }
  focus() {
    return this.questionRenderer.focus();
  }
  blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  }
  getNumHints() {
    return this.props.item.hints.length;
  }

  /**
   * Grades the item.
   */
  scoreInput() {
    const guessAndScore = this.questionRenderer.guessAndScore();
    const guess = guessAndScore[0];
    const score = guessAndScore[1];

    // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.
    const maxCompatGuess = [guess, []];
    const keScore = Util.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    const emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  }

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */
  getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  }

  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets() {
    const qScore = this.questionRenderer.scoreWidgets();
    const qGuess = this.questionRenderer.getUserInputForWidgets();
    const state = this.questionRenderer.getSerializedState();
    // @ts-expect-error [FEI-5003] - TS2322 - Type 'Partial<Record<string, KEScore>>' is not assignable to type '{ [key: string]: KEScore; }'. | TS2345 - Argument of type '{ [widgetId: string]: PerseusScore; }' is not assignable to parameter of type 'Partial<Record<string, { type: "invalid"; message?: string | null | undefined; suppressAlmostThere?: boolean | null | undefined; }>>'.
    return mapObject(qScore, (score, id) => {
      return Util.keScoreFromPerseusScore(score, qGuess[id], state);
    });
  }

  /**
   * Get a representation of the current state of the item.
   */
  getSerializedState() {
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: this.hintsRenderer.getSerializedState()
    };
  }
  restoreSerializedState(state, callback) {
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    let numCallbacks = 2;
    const fireCallback = () => {
      --numCallbacks;
      if (callback && numCallbacks === 0) {
        callback();
      }
    };
    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    this.hintsRenderer.restoreSerializedState(state.hints, fireCallback);
  }
  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  }
  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  }

  // This must be pre-bound otherwise SvgImage's shouldComponentUpdate
  // won't behave correctly and we'll get an infinite loop.

  render() {
    const apiOptions = {
      ...ApiOptions.defaults,
      ...this.props.apiOptions,
      onFocusChange: this._handleFocusChange
    };
    const contextValue = {
      assetStatuses: this.state.assetStatuses,
      setAssetStatus: this.setAssetStatus
    };
    const questionRenderer = /*#__PURE__*/React__namespace.createElement(context$2.Provider, {
      value: contextValue
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      keypadElement: this.props.keypadElement,
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      ref: elem => {
        if (elem != null) {
          this.questionRenderer = elem;
        }
      },
      content: this.props.item.question.content,
      widgets: this.props.item.question.widgets,
      images: this.props.item.question.images
    }));
    const hintsRenderer = /*#__PURE__*/React__namespace.createElement(HintsRenderer, {
      hints: this.props.item.hints,
      hintsVisible: this.props.hintsVisible
      // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      ,
      apiOptions: apiOptions,
      ref: elem => this.hintsRenderer = elem
    });
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("div", null, questionRenderer), /*#__PURE__*/React__namespace.createElement("div", {
      className:
      // Avoid adding any horizontal padding when applying the
      // mobile hint styles, which are flush to the left.
      // NOTE(charlie): We may still want to apply this
      // padding for desktop exercises.
      apiOptions.isMobile ? undefined : aphrodite.css(styles$3.hintsContainer)
    }, hintsRenderer));
  }
}
_defineProperty(ServerItemRenderer, "defaultProps", {
  apiOptions: {},
  // a deep default is done in `this.update()`
  onRendered: isRendered => {}
});
const styles$3 = aphrodite.StyleSheet.create({
  hintsContainer: {
    marginLeft: 50
  }
});
const ref = /*#__PURE__*/React__namespace.forwardRef((props, ref) => /*#__PURE__*/React__namespace.createElement(context$1.Consumer, null, _ref => {
  let {
    onRendered
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(ServerItemRenderer, _extends({}, props, {
    onRendered: onRendered,
    ref: ref
  }));
}));

class ArrowPicker extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2014")
      }, {
        value: "->",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2192")
      }
      /*
      TODO(eater): fix khan-exercises so these are supported
      {value: "<-", content: <span>&#x2190;</span>},
      {value: "<->", content: <span>&#x2194;</span>}
      */],

      onChange: this.props.onChange
    });
  }
}
_defineProperty(ArrowPicker, "defaultProps", {
  value: ""
});

const COLORS = [KhanColors.BLACK, KhanColors.BLUE, KhanColors.GREEN, KhanColors.PINK, KhanColors.PURPLE, KhanColors.RED, KhanColors.GRAY];
const LIGHT_COLORS = [KhanColors.LIGHT_BLUE, KhanColors.LIGHT_ORANGE, KhanColors.LIGHT_PINK, KhanColors.LIGHT_GREEN, KhanColors.LIGHT_PURPLE, KhanColors.LIGHT_RED, "#fff"];
class ColorPicker extends React__namespace.Component {
  render() {
    const colors = this.props.lightColors ? LIGHT_COLORS : COLORS;
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: ___default["default"].map(colors, color => {
        return {
          value: color,
          content: /*#__PURE__*/React__namespace.createElement("span", null, /*#__PURE__*/React__namespace.createElement("span", {
            className: "colorpicker-circle",
            style: {
              background: color
            }
          }), "\xA0")
        };
      }),
      onChange: this.props.onChange
    });
  }
}
_defineProperty(ColorPicker, "defaultProps", {
  value: KhanColors.BLACK,
  lightColors: false
});

class DashPicker extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2014")
      }, {
        value: "-",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2013\u2013\u2013")
      }, {
        value: "- ",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2013\xA0\xA0\u2013")
      }, {
        value: ".",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\xB7\xB7\xB7\xB7")
      }, {
        value: ". ",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\xB7 \xB7 \xB7")
      }],
      onChange: this.props.onChange
    });
  }
}
_defineProperty(DashPicker, "defaultProps", {
  value: ""
});

class ElementContainer extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "toggle", e => {
      e.preventDefault();
      this.setState({
        show: !this.state.show
      });
    });
    this.state = {
      show: props.initiallyVisible
    };
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-interaction-element"
    }, /*#__PURE__*/React__namespace.createElement("a", {
      href: "#",
      className: "perseus-interaction-element-title " + (this.state.show ? "open" : "closed"),
      onClick: this.toggle
    }, this.state.show ? /*#__PURE__*/React__namespace.createElement(InlineIcon, iconChevronDown) : /*#__PURE__*/React__namespace.createElement(InlineIcon, iconChevronRight), this.props.title), /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-interaction-element-content " + (this.state.show ? "enter" : "leave")
    }, this.props.children, (this.props.onUp != null || this.props.onDown != null || this.props.onDelete != null) && /*#__PURE__*/React__namespace.createElement("div", {
      className: "edit-controls"
    }, this.props.onUp != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onUp
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleArrowUp)), this.props.onDown != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onDown
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleArrowDown)), this.props.onDelete != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onDelete
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconTrash)))));
  }
}
_defineProperty(ElementContainer, "defaultProps", {
  initiallyVisible: false,
  title: "More"
});

// Displays a stylized open eye: lint warnings are visible
const VisibleIcon = () => /*#__PURE__*/React__namespace.createElement("svg", {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  className: aphrodite.css(styles$2.icon)
}, /*#__PURE__*/React__namespace.createElement("defs", null, /*#__PURE__*/React__namespace.createElement("path", {
  id: "a",
  d: "M7.401 10.035c-1.424.748-2.599 1.905-3.544 " + "3.48a1 1 0 0 1-1.714-1.03C4.325 8.849 7.652 7 " + "12 7c4.348 0 7.675 1.848 9.857 5.486a1 1 0 0 " + "1-1.714 1.028c-.945-1.574-2.12-2.73-3.544-" + "3.48a5 5 0 1 1-9.198 0zM12 15a3 3 0 1 0 0-6 3 3 " + "0 0 0 0 6z"
})), /*#__PURE__*/React__namespace.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /*#__PURE__*/React__namespace.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React__namespace.createElement("mask", {
  id: "b",
  fill: "#fff"
}, /*#__PURE__*/React__namespace.createElement("use", {
  href: "#a"
})), /*#__PURE__*/React__namespace.createElement("use", {
  fill: "#fff",
  fillRule: "nonzero",
  href: "#a"
}), /*#__PURE__*/React__namespace.createElement("g", {
  fill: "#fff",
  mask: "url(#b)"
}, /*#__PURE__*/React__namespace.createElement("path", {
  d: "M0 0h24v24H0z"
}))));

// Displays a stylized eye with a line through it: I don't want to see lint
const HiddenIcon = () => /*#__PURE__*/React__namespace.createElement("svg", {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  className: aphrodite.css(styles$2.icon)
}, /*#__PURE__*/React__namespace.createElement("defs", null, /*#__PURE__*/React__namespace.createElement("path", {
  id: "a",
  d: "M8.794 7.38C9.791 7.127 10.86 7 12 7c4.348 0 " + "7.675 1.848 9.857 5.486a1 1 0 0 1-1.714 " + "1.028c-.945-1.574-2.12-2.73-3.544-3.48.258." + "604.401 1.268.401 1.966 0 1.02-.305 " + "1.967-.828 2.757l2.535 2.536a1 1 0 0 " + "1-1.414 1.414l-12-12a1 1 0 0 1 " + "1.414-1.414L8.794 7.38zm5.914 5.913a3 3 0 0 " + "0-4.001-4.001l4 4.001zM6.072 8.486l2.976 " + "2.976a3 3 0 0 0 3.49 3.49l1.579 1.58A5 5 0 " + "0 1 7.4 10.035c-1.424.747-2.599 1.904-3.544 " + "3.478a1 1 0 0 1-1.714-1.028c1.049-1.75 " + "2.363-3.085 3.929-4z"
})), /*#__PURE__*/React__namespace.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /*#__PURE__*/React__namespace.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React__namespace.createElement("mask", {
  id: "b",
  fill: "#fff"
}, /*#__PURE__*/React__namespace.createElement("use", {
  href: "#a"
})), /*#__PURE__*/React__namespace.createElement("use", {
  fill: "#fff",
  fillRule: "nonzero",
  href: "#a"
}), /*#__PURE__*/React__namespace.createElement("g", {
  fill: "#fff",
  mask: "url(#b)"
}, /*#__PURE__*/React__namespace.createElement("path", {
  d: "M0 0h24v24H0z"
}))));
const HUD = _ref => {
  let {
    message,
    enabled,
    onClick,
    fixedPosition = true
  } = _ref;
  let state;
  let icon;
  if (enabled) {
    state = styles$2.enabled;
    icon = /*#__PURE__*/React__namespace.createElement(VisibleIcon, null);
  } else {
    state = styles$2.disabled;
    icon = /*#__PURE__*/React__namespace.createElement(HiddenIcon, null);
  }
  return /*#__PURE__*/React__namespace.createElement("button", {
    className: aphrodite.css(styles$2.hud, fixedPosition && styles$2.hudFixedPosition, state),
    onClick: e => {
      onClick();
    }
  }, icon, message);
};
const styles$2 = aphrodite.StyleSheet.create({
  hud: {
    boxSizing: "border-box",
    height: 36,
    padding: "9px 16px",
    borderRadius: 18,
    fontFamily: boldFontFamily,
    fontSize: "15px",
    lineHeight: "18px",
    color: white$1,
    userSelect: "none",
    borderWidth: 0 // <button> gives us a border by default
  },

  // We want to render the element in-place in our fixtures, so allow us to
  // render in the bottom corner in production and in-place in testing.
  hudFixedPosition: {
    bottom: 20,
    position: "fixed",
    right: 20,
    zIndex: 1
  },
  icon: {
    width: 24,
    height: 24,
    marginRight: 8,
    marginTop: -3,
    verticalAlign: "middle"
  },
  enabled: {
    backgroundColor: warningColor,
    ":hover": {
      backgroundColor: warningColorHover
    },
    ":active": {
      backgroundColor: warningColorActive
    }
  },
  disabled: {
    backgroundColor: gray76,
    ":hover": {
      backgroundColor: "#a1a5a9" // in between those two grays
    },

    ":active": {
      backgroundColor: gray68
    }
  }
});

/**
 * MultiButtonGroup is an aesthetically pleasing group of buttons,
 * which allows multiple buttons to be selected at the same time.
 *
 * NOTE: This component is almost identical to ./button-group.jsx except that
 * this component allows multiple selection!
 */
class MultiButtonGroup extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "toggleSelect", newValue => {
      const values = (this.props.values || []).slice(0);
      const allowEmpty = this.props.allowEmpty;
      if (values.indexOf(newValue) >= 0 && (values.length > 1 || allowEmpty)) {
        // If the value is already selected, unselect it
        values.splice(values.indexOf(newValue), 1);
      } else {
        // Otherwise merge with other values and return
        if (values.indexOf(newValue) < 0) {
          values.push(newValue);
        }
      }
      this.props.onChange(values);
    });
  }
  focus() {
    var _ReactDOM$findDOMNode;
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'focus' does not exist on type 'Element | Text'.
    (_ReactDOM$findDOMNode = ReactDOM__namespace.findDOMNode(this)) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.focus();
    return true;
  }
  render() {
    const values = this.props.values || [];
    const buttons = this.props.buttons.map((button, i) => {
      const selected = values.indexOf(button.value) >= 0;
      return /*#__PURE__*/React__namespace.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        key: "" + i,
        ref: "button" + i,
        className: aphrodite.css(styles$1.buttonStyle, selected && styles$1.selectedStyle),
        onClick: () => this.toggleSelect(button.value)
      }, button.content || "" + button.value);
    });
    const outerStyle = {
      display: "inline-block"
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: outerStyle
    }, buttons);
  }
}
_defineProperty(MultiButtonGroup, "defaultProps", {
  values: [],
  allowEmpty: true
});
const styles$1 = aphrodite.StyleSheet.create({
  buttonStyle: {
    backgroundColor: "white",
    border: "1px solid #ccc",
    borderLeft: "0",
    cursor: "pointer",
    margin: "0",
    padding: "5px 10px",
    position: "relative",
    // for hover

    ":first-child": {
      borderLeft: "1px solid #ccc",
      borderTopLeftRadius: "3px",
      borderBottomLeftRadius: "3px"
    },
    ":last-child": {
      borderRight: "1px solid #ccc",
      borderTopRightRadius: "3px",
      borderBottomRightRadius: "3px"
    },
    ":hover": {
      backgroundColor: "#ccc"
    },
    ":focus": {
      zIndex: 2
    }
  },
  selectedStyle: {
    backgroundColor: "#ddd"
  }
});

/* eslint-disable react/prop-types */

/* A checkbox that syncs its value to props using the
 * renderer's onChange method, and gets the prop name
 * dynamically from its props list
 */
const PropCheckBox = createReactClass__default["default"]({
  displayName: "PropCheckBox",
  propTypes: {
    labelAlignment: PropTypes__default["default"].oneOf(["left", "right"])
  },
  DEFAULT_PROPS: {
    label: null,
    onChange: null,
    labelAlignment: "left"
  },
  getDefaultProps: function () {
    return this.DEFAULT_PROPS;
  },
  propName: function () {
    const propName = ___default["default"].find(___default["default"].keys(this.props), function (localPropName) {
      // @ts-expect-error [FEI-5003] - TS2683 - 'this' implicitly has type 'any' because it does not have a type annotation.
      return !___default["default"].has(this.DEFAULT_PROPS, localPropName);
    }, this);
    if (!propName) {
      throw new PerseusError("Attempted to create a PropCheckBox with no prop!", Errors.InvalidInput);
    }
    return propName;
  },
  _labelAlignLeft: function () {
    return this.props.labelAlignment === "left";
  },
  render: function () {
    const propName = this.propName();
    return /*#__PURE__*/React__namespace.createElement("label", null, this._labelAlignLeft() && this.props.label, /*#__PURE__*/React__namespace.createElement("input", {
      type: "checkbox",
      checked: this.props[propName],
      onChange: this.toggle
    }), !this._labelAlignLeft() && this.props.label);
  },
  toggle: function () {
    const propName = this.propName();
    const changes = {};
    changes[propName] = !this.props[propName];
    this.props.onChange(changes);
  }
});

const truth = () => true;

/* A minor abstraction on top of NumberInput for ranges
 *
 */
class RangeInput extends React__namespace.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "onChange", (i, newVal) => {
      const value = this.props.value;
      if (i === 0) {
        this.props.onChange([newVal, value[1]]);
      } else {
        this.props.onChange([value[0], newVal]);
      }
    });
  }
  render() {
    const value = this.props.value;
    const checkValidity = this.props.checkValidity || truth;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "range-input"
    }, /*#__PURE__*/React__namespace.createElement(NumberInput, _extends({}, this.props, {
      value: value[0],
      checkValidity: val => checkValidity([val, value[1]])
      // eslint-disable-next-line react/jsx-no-bind
      ,
      onChange: this.onChange.bind(this, 0),
      placeholder: this.props.placeholder[0]
    })), /*#__PURE__*/React__namespace.createElement(NumberInput, _extends({}, this.props, {
      value: value[1],
      checkValidity: val => checkValidity([value[0], val])
      // eslint-disable-next-line react/jsx-no-bind
      ,
      onChange: this.onChange.bind(this, 1),
      placeholder: this.props.placeholder[1]
    })));
  }
}
_defineProperty(RangeInput, "propTypes", {
  value: PropTypes__default["default"].array.isRequired,
  onChange: PropTypes__default["default"].func.isRequired,
  placeholder: PropTypes__default["default"].array,
  checkValidity: PropTypes__default["default"].func
});
_defineProperty(RangeInput, "defaultProps", {
  placeholder: [null, null]
});

var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ButtonGroup: ButtonGroup,
    Graph: Graph,
    Graphie: Graphie,
    HUD: HUD,
    Icon: Icon,
    InfoTip: InfoTip,
    InlineIcon: InlineIcon,
    MathInput: MathInput,
    MultiButtonGroup: MultiButtonGroup,
    NumberInput: NumberInput,
    PropCheckBox: PropCheckBox,
    RangeInput: RangeInput,
    SvgImage: SvgImage,
    TextInput: TextInput,
    TexButtons: TexButtons,
    TextListEditor: TextListEditor
});

const devices = {
  PHONE: "phone",
  TABLET: "tablet",
  DESKTOP: "desktop"
};

// How many pixels do we reserve on the right-hand side of a preview
// for displaying lint indicators? This space needs to be reserved
// in DeviceFramer, but it is actually allocated in PerseusFrame
const lintGutterWidth = 36;

// How wide a border does PerseusFrame draw? We need to allocate enough
// space for it in DeviceFramer.
const perseusFrameBorderWidth = 1;

var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    devices: devices,
    lintGutterWidth: lintGutterWidth,
    perseusFrameBorderWidth: perseusFrameBorderWidth
});

/**
 * KeypadContext provides a way to the Keypad and (Server)ItemRenderer to
 * communicate.
 *
 * The KeypadContext.Provider wraps the ExerciseFooter while KeypadContext.Consumer
 * wraps each (Server)ItemRenderer render site and the Keypad rendered in the
 * ExerciseFooter.
 */
// @ts-expect-error [FEI-5003] - TS2322 - Type 'Context<{ setKeypadElement: (keypadElement: HTMLElement | null | undefined) => void; keypadElement: null; setRenderer: (renderer: RendererInterface | null | undefined) => void; renderer: null; setScrollableElement: (scrollableElement: HTMLElement | ... 1 more ... | undefined) => void; scrollableElement: null; }>' is not assignable to type 'Context<KeypadContext>'.
const context = /*#__PURE__*/React__namespace.createContext({
  setKeypadElement: keypadElement => {},
  keypadElement: null,
  setRenderer: renderer => {},
  renderer: null,
  setScrollableElement: scrollableElement => {},
  scrollableElement: null
});

/**
 * Traverses a {content, widgets, images} renderer props object,
 * such as `itemData.question`
 *
 * This traversal is deep and handles some widget prop upgrades
 * (TODO(aria): Handle minor prop upgrades :) )
 *
 * This is the right way to traverse itemData.
 *
 * NOTE: We should not expose this on the perseus API yet. Instead,
 * build the traversal method you want inside perseus, and use this
 * from that. We might eventually expose this, but I'd like to be
 * more confident in the interface provided first.
 */
const noop = function () {};
const deepCallbackFor = function (contentCallback, widgetCallback, optionsCallback) {
  const deepCallback = function (widgetInfo, widgetId) {
    var _upgradedWidgetInfo$v;
    // This doesn't modify the widget info if the widget info
    // is at a later version than is supported, which is important
    // for our latestVersion test below.
    const upgradedWidgetInfo = upgradeWidgetInfoToLatestVersion(widgetInfo);
    const latestVersion = getVersion(upgradedWidgetInfo.type);

    // Only traverse our children if we can understand this version
    // of the widget props.
    // TODO(aria): This will break if the traversal code assumes that
    // any props that usually get defaulted in are present. That is,
    // it can fail on minor version upgrades.
    // For this reason, and because the upgrade code doesn't handle
    // minor versions correctly (it doesn't report anything useful
    // about what minor version a widget is actually at, since it
    // doesn't have meaning in the context of upgrades), we
    // just check the major version here.
    // TODO(aria): This is seriously quirky and would be unpleasant
    // to think about while writing traverseChildWidgets code. Please
    // make all of this a little tighter.
    // I think once we use react class defaultProps instead of relying
    // on getDefaultProps, this will become easier.
    let newWidgetInfo;
    if (latestVersion && ((_upgradedWidgetInfo$v = upgradedWidgetInfo.version) === null || _upgradedWidgetInfo$v === void 0 ? void 0 : _upgradedWidgetInfo$v.major) === latestVersion.major) {
      newWidgetInfo = traverseChildWidgets$4(upgradedWidgetInfo, rendererOptions => {
        return traverseRenderer$1(rendererOptions, contentCallback,
        // so that we traverse grandchildren, too:
        deepCallback, optionsCallback);
      });
    } else {
      newWidgetInfo = upgradedWidgetInfo;
    }
    const userWidgetInfo = widgetCallback(newWidgetInfo, widgetId);
    if (userWidgetInfo !== undefined) {
      return userWidgetInfo;
    }
    return newWidgetInfo;
  };
  return deepCallback;
};
const traverseRenderer$1 = function (rendererOptions, contentCallback, deepWidgetCallback, optionsCallback) {
  let newContent = rendererOptions.content;
  if (rendererOptions.content != null) {
    const modifiedContent = contentCallback(rendererOptions.content);
    if (modifiedContent !== undefined) {
      newContent = modifiedContent;
    }
  }
  const newWidgets = objective_.mapObject(rendererOptions.widgets || {}, function (widgetInfo, widgetId) {
    // Widgets without info or a type are empty widgets, and
    // should always be renderable. It's also annoying to write
    // checks for this everywhere, so we just filter them out once and
    // for all!
    // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
    if (widgetInfo == null || widgetInfo.type == null) {
      return widgetInfo;
    }
    return deepWidgetCallback(widgetInfo, widgetId);
  });
  const newOptions = ___default["default"].extend({}, rendererOptions, {
    content: newContent,
    widgets: newWidgets
  });
  const userOptions = optionsCallback(newOptions);
  if (userOptions !== undefined) {
    return userOptions;
  }
  return newOptions;
};
const traverse = function (rendererOptions, contentCallback, widgetCallback, optionsCallback) {
  contentCallback = contentCallback || noop;
  widgetCallback = widgetCallback || noop;
  optionsCallback = optionsCallback || noop;
  return traverseRenderer$1(rendererOptions, contentCallback, deepCallbackFor(contentCallback, widgetCallback, optionsCallback), optionsCallback);
};

/**
 * Utility functions for constructing and inferring multi-item shapes.
 *
 * A shape is an object that serves as a runtime type declaration: it specifies
 * a tree structure for a particular class of multi-item. See shape-types.js
 * for further discussion.
 *
 * This module allows you to construct arbitrary Shape trees, by combining
 * leaf node shapes like `content` and `hint` into composite shapes like
 * `arrayOf(shape({foo: content, bar: hint}))`.
 */

/**
 * These tools allow you to construct arbirtary shapes, by combining simple
 * leaf shapes like `content` and `hint` into composite shapes like
 * `arrayOf(shape({question: content, hints: arrayOf(hint)}))`.
 */
const contentShape = {
  type: "content"
};
const hintShape = {
  type: "hint"
};
const tagsShape = {
  type: "tags"
};
const buildArrayShape = elementShape => ({
  type: "array",
  elementShape
});
const buildObjectShape = shape => ({
  type: "object",
  shape
});
const hintsShape = buildArrayShape(hintShape);
var shapes = {
  content: contentShape,
  hint: hintShape,
  hints: hintsShape,
  tags: tagsShape,
  arrayOf: buildArrayShape,
  shape: buildObjectShape
};

/**
 * This is a TreeMapper that only has mappers specified for its leaf nodes; its
 * array mapper is the identity function.
 *
 * This is the TreeMapper initially returned by `buildMapper`. It allows you to
 * change the types of your ContentMapper and HintMapper, which is safe because
 * none of the other mappers that depend on those types (aka ArrayMapper) have
 * been specified yet. (Or, more specifically, the ArrayMapper is currently
 * `identity`, which can trivially vary with the ContentMapper and HintMapper's
 * types.)
 *
 * Once you call `setArrayMapper`, however, we move to the other class:
 * TreeMapperForLeavesAndCollections.
 */
class TreeMapperJustForLeaves {
  constructor(content, hint, tags) {
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "hint", void 0);
    _defineProperty(this, "tags", void 0);
    _defineProperty(this, "array", void 0);
    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = identity;
  }
  setContentMapper(newContentMapper) {
    return new TreeMapperJustForLeaves(newContentMapper, this.hint, this.tags);
  }
  setHintMapper(newHintMapper) {
    return new TreeMapperJustForLeaves(this.content, newHintMapper, this.tags);
  }
  setTagsMapper(newTagsMapper) {
    return new TreeMapperJustForLeaves(this.content, this.hint, newTagsMapper);
  }
  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  // @ts-expect-error [FEI-5003] - TS2315 - Type 'Tree' is not generic. | TS2315 - Type 'Tree' is not generic.
  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }
}

/**
 * This is a TreeMapper that already has an ArrayMapper specified, so its
 * ContentMapper and HintMapper are now locked in.
 */
class TreeMapperForLeavesAndCollections {
  constructor(content, hint, tags, array) {
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "hint", void 0);
    _defineProperty(this, "tags", void 0);
    _defineProperty(this, "array", void 0);
    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = array;
  }
  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  // @ts-expect-error [FEI-5003] - TS2315 - Type 'Tree' is not generic. | TS2315 - Type 'Tree' is not generic.
  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }
}
function identity(x) {
  return x;
}

/**
 * Return a new TreeMapper that will perform a no-op transformation on an input
 * tree. To make it useful, chain any combination of `setContentMapper`,
 * `setHintMapper`, `setTagMapper`, and `setArrayMapper` to specify
 * transformations for the individual node types.
 */
// @ts-expect-error [FEI-5003] - TS2300 - Duplicate identifier 'C'. | TS2300 - Duplicate identifier 'H'. | TS2300 - Duplicate identifier 'T'.
function buildMapper() {
  return new TreeMapperJustForLeaves(identity, identity, identity);
}

/**
 * Copy the given tree, apply the corresponding transformation specified in the
 * TreeMapper to each node, and return the resulting tree.
 */
function mapTree(
// @ts-expect-error [FEI-5003] - TS2315 - Type 'Tree' is not generic.
tree, shape, path, mappers
// @ts-expect-error [FEI-5003] - TS2315 - Type 'Tree' is not generic.
) {
  // We trust the shape of the multi-item to match the shape provided at
  // runtime. Therefore, in each shape branch, we cast the node to `any` and
  // reinterpret it as the expected node type.
  if (shape.type === "content") {
    const content = tree;
    return mappers.content(content, shape, path);
  }
  if (shape.type === "hint") {
    const hint = tree;
    return mappers.hint(hint, shape, path);
  }
  if (shape.type === "tags") {
    const tags = tree;
    return mappers.tags(tags, shape, path);
  }
  if (shape.type === "array") {
    // @ts-expect-error [FEI-5003] - TS2315 - Type 'ArrayNode' is not generic.
    const array = tree;
    if (!Array.isArray(array)) {
      throw new PerseusError("Invalid object of type \"".concat(typeof array, "\" found at path ") + // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      "".concat(["<root>"].concat(path).join("."), ". Expected array."), Errors.Internal);
    }
    const elementShape = shape.elementShape;
    // @ts-expect-error [FEI-5003] - TS2315 - Type 'ArrayNode' is not generic.
    const mappedElements = array.map((inner, i) => mapTree(inner, elementShape, path.concat(i), mappers));
    return mappers.array(mappedElements, array, shape, path);
  }
  if (shape.type === "object") {
    const object = tree;
    if (object && typeof object !== "object") {
      throw new PerseusError("Invalid object of type \"".concat(typeof object, "\" found at ") + // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      "path ".concat(["<root>"].concat(path).join("."), ". Expected ") + "\"object\" type.", Errors.InvalidInput);
    }
    const valueShapes = shape.shape;
    if (!valueShapes) {
      throw new PerseusError("Unexpected shape ".concat(JSON.stringify(shape), " at path ") + // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
      "".concat(["<root>"].concat(path).join("."), "."), Errors.InvalidInput);
    }
    const newObject = {};
    Object.keys(valueShapes).forEach(key => {
      if (!(key in object)) {
        throw new PerseusError("Key \"".concat(key, "\" is missing from shape at path ") + // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        "".concat(["<root>"].concat(path).join("."), "."), Errors.InvalidInput);
      }
      newObject[key] = mapTree(object[key], valueShapes[key], path.concat(key), mappers);
    });
    return newObject;
  }
  throw new PerseusError( // @ts-expect-error [FEI-5003] - TS2339 - Property 'type' does not exist on type 'never'.
  "unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}

/**
 * Utility functions for constructing and manipulating multi-items.
 *
 * These functions apply *specifically* to Items and ItemTrees - things that
 * actually semantically *are* multi-items. For more general functions for
 * traversing and manipulating *anything* shaped like a multi-item (like a
 * renderer tree or a score tree or, well, a multi-item), see trees.js.
 */
/**
 * Return a semantically empty ItemTree that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */
function buildEmptyItemTreeForShape(shape) {
  if (shape.type === "content") {
    return {
      __type: "content",
      content: "",
      images: {},
      widgets: {}
    };
  }
  if (shape.type === "hint") {
    return {
      __type: "hint",
      replace: false,
      content: "",
      images: {},
      widgets: {}
    };
  }
  if (shape.type === "tags") {
    return [];
  }
  if (shape.type === "array") {
    return [];
  }
  if (shape.type === "object") {
    const valueShapes = shape.shape;
    const object = {};
    Object.keys(valueShapes).forEach(key => {
      object[key] = buildEmptyItemTreeForShape(valueShapes[key]);
    });
    return object;
  }
  throw new PerseusError( // @ts-expect-error [FEI-5003] - TS2339 - Property 'type' does not exist on type 'never'.
  "unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}

/**
 * Return a semantically empty Item that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */
function buildEmptyItemForShape(shape) {
  return treeToItem(buildEmptyItemTreeForShape(shape));
}

/**
 * Given an Item and its Shape, yield all of its content nodes to the callback.
 */
function findContentNodesInItem$2(item, shape, callback) {
  const itemTree = itemToTree(item);
  buildMapper().setContentMapper(callback).mapTree(itemTree, shape);
}

/**
 * Given an Item and its Shape, yield all of its hint nodes to the callback.
 */
function findHintNodesInItem(item, shape, callback) {
  const itemTree = itemToTree(item);
  buildMapper().setHintMapper(callback).mapTree(itemTree, shape);
}

/**
 * Given an ItemTree, return a Shape that it conforms to.
 *
 * The Shape might not be complete or correct Shape that this Item was designed
 * for. If you have access to the intended Shape, use that instead.
 */
function inferItemShape$2(item) {
  const itemTree = itemToTree(item);
  return inferItemTreeShape(itemTree);
}
function inferItemTreeShape(node) {
  if (Array.isArray(node)) {
    if (node.length) {
      if (typeof node[0] === "string") {
        // There's no ItemTree that can manifest as a string.
        // So, an array of strings must be a TagsNode, not ArrayNode.
        return shapes.tags;
      }
      // Otherwise, assume that this is a valid ArrayNode, and
      // therefore the shape of the first element applies to all
      // elements in the array.
      return shapes.arrayOf(inferItemTreeShape(node[0]));
    }
    // The array is empty, so we arbitrarily guess that it's a content
    // array. As discussed in the docstring, this might be incorrect,
    // and you shouldn't depend on it.
    return shapes.arrayOf(shapes.content);
  }
  if (
  // TODO(mdr): Remove #LegacyContentNode support.
  typeof node === "object" && (node.__type === "content" || node.__type === "item")) {
    return shapes.content;
  }
  if (typeof node === "object" && node.__type === "hint") {
    return shapes.hint;
  }
  if (typeof node === "object") {
    const valueShapes = {};
    Object.keys(node).forEach(key => {
      valueShapes[key] = inferItemTreeShape(node[key]);
    });
    return shapes.shape(valueShapes);
  }
  throw new PerseusError("unexpected multi-item node ".concat(JSON.stringify(node)), Errors.InvalidInput);
}

/**
 * Convert the given Item to an ItemTree, by unwrapping the `_multi` key.
 */
function itemToTree(item) {
  return item._multi;
}

/**
 * Convert the given ItemTree to an Item, by wrapping it in the `_multi` key.
 */
function treeToItem(node) {
  return {
    _multi: node
  };
}

class MultiRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "rendererDataTreeMapper", void 0);
    _defineProperty(this, "getRenderersMapper", void 0);
    _defineProperty(this, "_handleSerializedStateUpdated", (path, newState) => {
      const {
        onSerializedStateUpdated
      } = this.props;
      if (onSerializedStateUpdated) {
        const oldState = this._getSerializedState(this.props.serializedState);
        onSerializedStateUpdated(lens(oldState).set(path, newState).freeze());
      }
    });
    this.rendererDataTreeMapper = buildMapper()
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'unknown' is not assignable to parameter of type 'ContentNode'.
    .setContentMapper((c, _, p) => this._makeContentRendererData(c, p))
    // @ts-expect-error [FEI-5003] - TS2345 - Argument of type 'unknown' is not assignable to parameter of type 'HintNode'.
    .setHintMapper(h => this._makeHintRendererData(h)).setTagsMapper(t => null);

    // @ts-expect-error [FEI-5003] - TS2322 - Type 'TreeMapperForLeavesAndCollections<unknown, any, unknown, any, unknown, unknown>' is not assignable to type 'TreeMapper<ContentRendererData, ContentRendererElement, HintRendererData, HintRendererElement, null, null>'.
    this.getRenderersMapper = buildMapper()
    // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
    .setContentMapper(c => c.makeRenderer())
    // @ts-expect-error [FEI-5003] - TS2571 - Object is of type 'unknown'.
    .setHintMapper(h => h.makeRenderer()).setArrayMapper((renderers, data, shape) => this._annotateRendererArray(renderers, data, shape));

    // Keep state in sync with props.
    this.state = this._tryMakeRendererState(this.props);
  }
  /* eslint-enable react/sort-comp */

  UNSAFE_componentWillReceiveProps(nextProps) {
    // Keep state in sync with props.
    if (nextProps.item !== this.props.item) {
      this.setState(this._tryMakeRendererState(nextProps));
    }
  }

  /**
   * Attempt to build a State that includes a renderer tree corresponding to
   * the item provided in props. On error, return a state with `renderError`
   * set instead.
   */
  _tryMakeRendererState(props) {
    try {
      return {
        rendererDataTree: this._makeRendererDataTree(props.item, props.shape),
        renderError: null
      };
    } catch (e) {
      Log.error("Error building tree state", Errors.Internal, {
        cause: e
      });
      return {
        rendererDataTree: null,
        renderError: e
      };
    }
  }
  /**
   * Props that aren't directly used by the MultiRenderer are delegated to
   * the underlying Renderers.
   */
  _getRendererProps() {
    // `item`, `children`, and others are unused. I'm
    // explicitly pulling them out of `this.props` so I don't pass them to
    // `<Renderer>`. I'm not sure how else to do this.
    const {
      item: _,
      children: __,
      shape: ___,
      serializedState: ____,
      onSerializedStateUpdated: _____,
      ...otherProps
    } = this.props;
    return otherProps;
  }

  /**
   * Construct a Renderer and a ref placeholder for the given ContentNode.
   */
  _makeContentRendererData(content, path) {
    // NOTE(emily): The `findExternalWidgets` function here is computed
    //     inline and thus changes each time we run this function. If it
    //     were to change every render, it would cause the Renderer to
    //     re-render a lot more than is necessary. Don't re-compute this
    //     element unless it is necessary!
    // HACK(mdr): TypeScript can't prove that this is a ContentRendererData,
    //     because of how we awkwardly construct it in order to obtain a
    //     circular reference. But it is, I promise.
    const data = {
      ref: null,
      makeRenderer: null
    };
    const refFunc = e => data.ref = e;
    const findExternalWidgets = criterion => this._findWidgets(data, criterion);
    const handleSerializedState = state => this._handleSerializedStateUpdated(path, state);
    data.makeRenderer = () =>
    /*#__PURE__*/
    /**
     * TODO(somewhatabstract, JIRA-XXXX):
     * `content` contains props that Renderer doesn't have. However,
     * since the type for `content` is not exact, it's hard to know
     * if this spread is including undocumented props so mapping
     * one to one could introduce a bug. Need to work out the exact
     * type for ContentNode and then fix this.
     */
    // @ts-expect-error [FEI-5003] - TS2322 - Type '{ ref: (e: any) => any; findExternalWidgets: (criterion: any) => readonly (Widget | null | undefined)[]; serializedState: any; onSerializedStateUpdated: (state: any) => void; __type: "content" | "item"; ... 9 more ...; reviewMode?: boolean | ... 1 more ... | undefined; }' is not assignable to type 'InexactPartial<Pick<Readonly<Props> & Readonly<{ children?: ReactNode; }>, "content" | "images" | "onRender" | "linterContext" | "widgets" | "alwaysUpdate" | ... 6 more ... | "serializedState">>'.
    React__namespace.createElement(Renderer, _extends({}, this._getRendererProps(), content, {
      ref: refFunc,
      findExternalWidgets: findExternalWidgets,
      serializedState: this.props.serializedState ? lens(this.props.serializedState).get(path) : null,
      onSerializedStateUpdated: handleSerializedState
    }));
    return data;
  }

  /**
   * Construct a Renderer for the given HintNode, and keep track of the hint
   * itself for future use, too.
   */
  _makeHintRendererData(hint) {
    // TODO(mdr): Once HintsRenderer supports inter-widget communication,
    //     give it a ref. Until then, leave the ref null forever, to avoid
    //     confusing the findWidgets functions.
    //
    // NOTE(davidflanagan): As a partial step toward inter-widget
    // communication we're going to pass a findExternalWidgets function
    // (using a dummy data object). This allows passage-ref widgets in
    // hints to use findWidget() to find the passage widgets they reference.
    // Note that this is one-way only, however. It does not allow
    // widgets in the question to find widgets in the hints, for example.
    const findExternalWidgets = criterion => this._findWidgets({}, criterion);
    return {
      hint,
      findExternalWidgets,
      // _annotateRendererArray() needs this
      ref: null,
      makeRenderer: () => /*#__PURE__*/React__namespace.createElement(HintsRenderer, _extends({}, this._getRendererProps(), {
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        findExternalWidgets: findExternalWidgets,
        hints: [hint]
      }))
    };
  }

  /**
   * Construct a tree of interconnected RendererDatas, corresponding to the
   * given item. Called in `_tryMakeRendererState`, in order to store this
   * tree in the component state.
   */
  _makeRendererDataTree(item, shape) {
    const itemTree = itemToTree(item);
    return this.rendererDataTreeMapper.mapTree(itemTree, shape);
  }

  /**
   * Return all widgets that meet the given criterion, from all Renderers
   * except the Renderer that triggered this call.
   *
   * This function is provided to each Renderer's `findExternalWidgets` prop,
   * which enables widgets in different Renderers to discover each other and
   * communicate.
   */
  _findWidgets(callingData, filterCriterion) {
    const results = [];
    this._mapRenderers(data => {
      if (callingData !== data && data.ref) {
        results.push(...data.ref.findInternalWidgets(filterCriterion));
      }
    });
    return results;
  }

  /**
   * Copy the renderer tree, apply the given transformation to the leaf nodes
   * and the optional given transformation to the array nodes, and return the
   * result.
   *
   * Used to provide structured data to the call site (the Renderer tree on
   * `render`, the Score tree on `getScores`, etc.), and to traverse the
   * renderer tree even when we disregard the output (like in
   * `_findWidgets`).
   */
  _mapRenderers(
  // eslint-disable-next-line no-restricted-syntax
  leafMapper
  // @ts-expect-error [FEI-5003] - TS2315 - Type 'Tree' is not generic.
  ) {
    const {
      rendererDataTree
    } = this.state;
    if (!rendererDataTree) {
      return null;
    }
    const mapper = buildMapper().setContentMapper(leafMapper).setHintMapper(leafMapper);
    return mapper.mapTree(rendererDataTree, this.props.shape);
  }
  _scoreFromRef(ref) {
    if (!ref) {
      return null;
    }
    const [guess, score] = ref.guessAndScore();
    let state;
    if (ref.getSerializedState) {
      state = ref.getSerializedState();
    }
    return Util.keScoreFromPerseusScore(score, guess, state);
  }

  /**
   * Return a tree in the shape of the multi-item, with scores at each of
   * the content nodes and `null` at the other leaf nodes.
   */
  getScores() {
    return this._mapRenderers(data => this._scoreFromRef(data.ref));
  }

  /**
   * Return a single composite score for all rendered content nodes.
   * The `guess` is a tree in the shape of the multi-item, with an individual
   * guess at each content node and `null` at the other leaf nodes.
   */
  score() {
    const scores = [];
    const state = [];
    const guess = this._mapRenderers(data => {
      var _data$ref;
      if (!data.ref) {
        return null;
      }
      if (data.ref.getSerializedState) {
        state.push(data.ref.getSerializedState());
      }
      scores.push(data.ref.score());
      return (_data$ref = data.ref) === null || _data$ref === void 0 ? void 0 : _data$ref.getUserInput();
    });
    const combinedScore = scores.reduce(Util.combineScores);
    return Util.keScoreFromPerseusScore(combinedScore, guess, state);
  }

  /**
   * Return a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes and `null` at the other leaf nodes.
   *
   * If the lastSerializedState argument is supplied, this function will fill
   * in the state of not-currently-rendered content and hint nodes with the
   * values from the previous serialized state. If no lastSerializedState is
   * supplied, `null` will be returned for not-currently-rendered content and
   * hint nodes.
   */
  _getSerializedState(lastSerializedState) {
    return this._mapRenderers((data, _, path) => {
      if (data.ref) {
        return data.ref.getSerializedState();
      }
      if (lastSerializedState) {
        return lens(lastSerializedState).get(path);
      }
      return null;
    });
  }

  /**
   * Given a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes, restore each state to the corresponding
   * renderer if currently mounted.
   */
  restoreSerializedState(serializedState, callback) {
    // We want to call our async callback only once all of the childrens'
    // callbacks have run. We add one to this counter before we call out to
    // each renderer and decrement it when it runs our callback.
    let numCallbacks = 0;
    const countCallback = () => {
      numCallbacks--;
      if (callback && numCallbacks === 0) {
        callback();
      }
    };
    this._mapRenderers((data, _, path) => {
      var _data$ref2;
      if (!data.ref) {
        return;
      }
      const state = lens(serializedState).get(path);
      if (!state) {
        return;
      }
      numCallbacks++;
      (_data$ref2 = data.ref) === null || _data$ref2 === void 0 ? void 0 : _data$ref2.restoreSerializedState(state, countCallback);
    });
  }

  /**
   * Given an array of renderers, if it happens to be an array of *hint*
   * renderers, then attach a `firstN` method to the array, which allows the
   * layout to render the hints together in one HintsRenderer.
   */
  _annotateRendererArray(renderers, rendererDatas, shape) {
    if (shape.elementShape.type === "hint") {
      // The shape says that these are HintRendererDatas, even though
      // it's not provable at compile time, so perform a cast.
      const hintRendererDatas = rendererDatas;
      renderers = [...renderers];
      renderers.firstN = n => /*#__PURE__*/React__namespace.createElement(HintsRenderer, _extends({}, this._getRendererProps(), {
        // @ts-expect-error [FEI-5003] - TS2769 - No overload matches this call.
        findExternalWidgets: hintRendererDatas[0] ? hintRendererDatas[0].findExternalWidgets : undefined,
        hints: hintRendererDatas.map(d => d.hint),
        hintsVisible: n
      }));
    }
    return renderers;
  }

  /**
   * Return a tree in the shape of the multi-item, with a Renderer at each
   * content node and a HintRenderer at each hint node.
   *
   * This is generated by running each of the `makeRenderer` functions at the
   * leaf nodes.
   */
  _getRenderers() {
    return this.getRenderersMapper.mapTree(this.state.rendererDataTree, this.props.shape);
  }
  render() {
    if (this.state.renderError) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles.error)
      }, i18n__namespace.$_("Error rendering: %(error)s", {
        error: String(this.state.renderError)
      }));
    }

    // Pass the renderer tree to the `children` function, which will
    // determine the actual content of this component.
    return this.props.children({
      renderers: this._getRenderers()
    });
  }
}
const styles = aphrodite.StyleSheet.create({
  error: {
    color: "red"
  }
});

/**
 * Utility functions to build React PropTypes for multi-items and shapes.
 *
 * If you're writing new components, though, consider using the Item and Shape
 * types instead.
 */

/**
 * Return a PropType that accepts Items of the given shape, and rejects other
 * objects.
 *
 * Usage: `propTypes: {item: buildPropTypeForShape(myShape)}`
 */
function buildPropTypeForShape(shape) {
  return PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
    _multi: buildTreePropTypeForShape(shape)
  }), PropTypes__default["default"].oneOf([null, undefined])]);
}

/**
 * Return a PropType that accepts ItemTrees of the given shape, and rejects
 * other objects.
 */
function buildTreePropTypeForShape(shape) {
  if (shape.type === "content") {
    return PropTypes__default["default"].shape({
      // TODO(mdr): Remove #LegacyContentNode support.
      __type: PropTypes__default["default"].oneOf(["content", "item"]).isRequired,
      content: PropTypes__default["default"].string,
      images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
    });
  }
  if (shape.type === "hint") {
    return PropTypes__default["default"].shape({
      __type: PropTypes__default["default"].oneOf(["hint"]).isRequired,
      content: PropTypes__default["default"].string,
      images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      replace: PropTypes__default["default"].bool
    });
  }
  if (shape.type === "tags") {
    return PropTypes__default["default"].arrayOf(PropTypes__default["default"].string.isRequired);
  }
  if (shape.type === "array") {
    const elementPropType = buildTreePropTypeForShape(shape.elementShape);
    return PropTypes__default["default"].arrayOf(elementPropType.isRequired);
  }
  if (shape.type === "object") {
    const valueShapes = shape.shape;
    const propTypeShape = {};
    Object.keys(valueShapes).forEach(key => {
      propTypeShape[key] = buildTreePropTypeForShape(valueShapes[key]).isRequired;
    });
    return PropTypes__default["default"].shape(propTypeShape);
  }
  throw new PerseusError( // @ts-expect-error [FEI-5003] - TS2339 - Property 'type' does not exist on type 'never'.
  "unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}

/**
 * This library provides support for Perseus multi-items: structured Perseus
 * content that content creators can easily create, and that applications can
 * easily render into different parts of the layout.
 *
 * For more details about application and motivation, see:
 * https://sites.google.com/a/khanacademy.org/forge/for-developers/perseus-items-and-multi-items
 *
 * This file primarily exposes the `MultiRenderer` component, which performs
 * multi-rendering. To multi-render a question, pass in the content of the item
 * to the `MultiRenderer` component as a props. Then, pass in a function which
 * takes an object of renderers (in the same structure as the content), and
 * return a render tree. The `MultiRenderer` component will allow you to
 * combine scores, serialized state, etc. without having to manually call on
 * each of the functions. It also handles inter-widgets requests between the
 * different renderers.
 * For more details, see `multi-items/multi-renderer.jsx`.
 *
 * Example:
 *
 *   item = {_multi: {
 *       left: <content data>,
 *       right: [<content data>, <content data>],
 *   }}
 *   shape = shapes.shape({
 *       left: shapes.content,
 *       right: shapes.arrayOf(shapes.content),
 *   })
 *
 *   <MultiRenderer item={item} shape={shape}>
 *       {({renderers}) =>
 *           <div>
 *               <div id="left">{renderers.left}</div>
 *               <ul id="right">
 *                   {renderers.right.map(r => <li>{r}</li>)}
 *               </ul>
 *           </div>
 *       }
 *   </MultiRenderer>
 *
 * This file also exposes `shapes`, which helps you construct a runtime type
 * declaration for your particular class of multi-item. This can then be used
 * to create a MultirendererEditor for your multi-item shape, and to validate
 * that a multi-item conforms to the shape via `buildPropTypeForShape`.
 * For more details, see `multi-items/shapes.js`.
 *
 * This file also exposes some utility functions for working with generic
 * multi-items, like `findContentNodesInItem`, `findHintNodesInItem`,
 * `inferItemShape`, and `buildEmptyItemForShape`.
 * For more details, see `multi-items/items.js`.
 */
var MultiItems = {
  // Tools for rendering your multi-items
  MultiRenderer,
  // Tools for declaring your multi-item shapes
  shapes,
  buildPropTypeForShape,
  // Tools for generically manipulating multi-items
  buildEmptyItemForShape,
  findContentNodesInItem: findContentNodesInItem$2,
  findHintNodesInItem,
  inferItemShape: inferItemShape$2
};

/**
 * Calculates whether a perseus item is renderable by a specific
 * perseus-item-data version.
 *
 * This is done inside of the perseus repo so that it can traverse
 * widget-specific data that might need to do a sub-traversal.
 * This supports widgets that contain renderers, such as the
 * group or sequence widgets.
 */
const {
  findContentNodesInItem: findContentNodesInItem$1,
  inferItemShape: inferItemShape$1
} = MultiItems;
const isUpgradedWidgetInfoRenderableBy = function (widgetInfo, widgetRendererVersion) {
  if (widgetRendererVersion == null) {
    // If the widget does not exist in this version, this will
    // be null, and that version of perseus cannot render the
    // widget (it doesn't even know the widget exists!)
    return false;
  }
  const widgetVersion = widgetInfo.version || {
    major: 0,
    minor: 0
  };
  if (widgetRendererVersion.major > widgetVersion.major) {
    return true;
  }
  if (widgetRendererVersion.major < widgetVersion.major) {
    return false;
  }
  // If the major versions are the same, the minor version acts
  // like a tie-breaker.
  // For example, input-number 3.2 can render an input-number
  // 2.4, 3.0, or 3.2, but not an input number 3.3 or 4.0.
  return widgetRendererVersion.minor >= widgetVersion.minor;
};
const isRawWidgetInfoRenderableBy = function (widgetInfo, rendererContentVersion) {
  // Empty/non-existant widgets are always safe to render
  if (widgetInfo == null || widgetInfo.type == null) {
    return true;
  }

  // NOTE: This doesn't modify the widget info if the widget info
  // is at a later version than is supported.
  const upgradedWidgetInfo = upgradeWidgetInfoToLatestVersion(widgetInfo);
  return isUpgradedWidgetInfoRenderableBy(upgradedWidgetInfo, rendererContentVersion[upgradedWidgetInfo.type]);
};
const isRendererContentRenderableBy = function (rendererOptions, rendererContentVersion) {
  let isRenderable = true;
  traverse(rendererOptions, null, function (widgetInfo) {
    isRenderable = isRenderable && isRawWidgetInfoRenderableBy(widgetInfo, rendererContentVersion);
  });
  return isRenderable;
};
const isItemRenderableByVersion = function (itemData, rendererContentVersion) {
  if (itemData == null || rendererContentVersion == null) {
    throw new PerseusError("missing parameter to Perseus.isRenderable.item", Errors.InvalidInput);
  }
  if (itemData._multi) {
    const shape = inferItemShape$1(itemData);
    let isRenderable = true;
    findContentNodesInItem$1(itemData, shape, node => {
      const nodeIsRenderable = isRendererContentRenderableBy(node, rendererContentVersion);
      if (!nodeIsRenderable) {
        isRenderable = false;
      }
    });
    return isRenderable;
  }
  return isRendererContentRenderableBy(itemData.question, rendererContentVersion);
};

/**
 * Identifies whether or not a given perseus item requires the use of a mouse
 * or screen, based on the widgets it contains.
 */
const {
  findContentNodesInItem,
  inferItemShape
} = MultiItems;

// Iterate over a single Perseus renderer, mutating `widgets` by appending
// violating widget types discovered in this item.
function traverseRenderer(itemData, widgets) {
  traverse(itemData, null, function (info) {
    if (info.type && !isAccessible(info)) {
      widgets.push(info.type);
    }
  });
}

// Returns a list of widgets that cause a given perseus item to require
// the use of a screen or mouse.
//
// For now we'll just check the `accessible` field on each of the widgets
// in the item data, but in the future we may specify accessibility on
// each widget with higher granularity.
function violatingWidgets(itemData) {
  // TODO(jordan): Hints as well
  const widgets = [];
  if (itemData._multi) {
    const shape = inferItemShape(itemData);
    findContentNodesInItem(itemData, shape, content => traverseRenderer(content, widgets));
  } else {
    traverseRenderer(itemData.question, widgets);
  }

  // Uniquify the list of widgets (by type)
  return ___default["default"].uniq(widgets);
}

/**
 * Some tests require some or all of the widgets and editors to be registered
 * in order for them to work. Requiring this file will register all of the
 * widgets and editors.
 */
const registerAllWidgetsForTesting = () => {
  registerWidgets(allWidgets);
};

const EditorJsonify = {
  serialize: function () {
    // Omit props that get passed to all widgets
    // @ts-expect-error [FEI-5003] - TS2339 - Property 'props' does not exist on type '{ readonly serialize: () => any; }'.
    return ___default["default"].omit(this.props, denylist);
  }
};

/**
 * Main entry point
 */
const apiVersion = version.apiVersion;
const itemDataVersion = version.itemDataVersion;

exports.ApiOptions = ApiOptions;
exports.ArrowPicker = ArrowPicker;
exports.ArticleRenderer = ArticleRenderer;
exports.BaseRadio = BaseRadio;
exports.Categorizer = Categorizer$1;
exports.Changeable = changeable;
exports.ClassNames = ClassNames;
exports.ColorPicker = ColorPicker;
exports.DashPicker = DashPicker;
exports.Dependencies = dependencies;
exports.EditorJsonify = EditorJsonify;
exports.ElementContainer = ElementContainer;
exports.Errors = Errors;
exports.Expression = Expression;
exports.GrapherUtil = util;
exports.GrapherWidget = Grapher$1;
exports.HintRenderer = HintRenderer;
exports.HintsRenderer = HintsRenderer;
exports.InputNumber = InputNumber$1;
exports.InteractiveGraphWidget = InteractiveGraph$1;
exports.ItemRenderer = ItemRenderer;
exports.JiptParagraphs = JiptParagraphs;
exports.KeypadContext = context;
exports.KhanColors = KhanColors;
exports.KhanMath = KhanMath;
exports.LoadingContext = context$1;
exports.Log = Log;
exports.MatrixWidget = Matrix$1;
exports.MultiItems = MultiItems;
exports.NumericInput = NumericInput$1;
exports.PerseusError = PerseusError;
exports.PerseusMarkdown = PerseusMarkdown;
exports.PlotterWidget = Plotter$1;
exports.Radio = Radio;
exports.Renderer = Renderer;
exports.ServerItemRenderer = ref;
exports.SizingUtils = sizingUtils;
exports.TableWidget = Table$1;
exports.TransformerWidget = Transformer$1;
exports.Util = Util;
exports.WIDGET_PROP_DENYLIST = denylist;
exports.WidgetJsonifyDeprecated = WidgetJsonifyDeprecated;
exports.Widgets = widgets$1;
exports.apiVersion = apiVersion;
exports.buildEmptyItemTreeForShape = buildEmptyItemTreeForShape;
exports.buildMapper = buildMapper;
exports.components = components;
exports.constants = constants;
exports.displaySigFigs = displaySigFigs;
exports.globalConstants = globalConstants;
exports.globalStyles = globalStyles;
exports.icons = iconPaths;
exports.init = init;
exports.interactiveSizes = interactiveSizes$1;
exports.isItemRenderableByVersion = isItemRenderableByVersion;
exports.itemDataVersion = itemDataVersion;
exports.itemToTree = itemToTree;
exports.itemVersion = ItemVersion;
exports.mediaQueries = mediaQueries;
exports.preprocessTex = preprocessTex;
exports.registerAllWidgetsForTesting = registerAllWidgetsForTesting;
exports.shapes = shapes;
exports.traverse = traverse;
exports.violatingWidgets = violatingWidgets;
exports.widgets = allWidgets;
//# sourceMappingURL=index.js.map
